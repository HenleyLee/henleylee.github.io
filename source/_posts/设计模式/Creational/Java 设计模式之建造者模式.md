---
title: Java 设计模式之建造者模式
date: 2018-09-13 10:20:45
categories: 设计模式
tags:
  - Java
  - 设计模式
---

## 模式动机 ##
无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。

在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。

复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。

## 模式定义 ##
**`建造者模式(Builder Pattern)`**又可以称为生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。

建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。

> 建造者模式属于**`对象创建型模式`**。

## 模式结构 ##
### 角色组成 ###
建造者模式包含如下角色：
 - **`Builder(抽象建造者)：`**它为创建一个产品 Product 对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是 buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是 getResult()，它们用于返回复杂对象。Builder 既可以是抽象类，也可以是接口。
 - **`ConcreteBuilder(具体建造者)：`**它实现了 Builder 接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。
 - **`Product(产品角色)：`**它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。
 - **`Director(指挥者)：`**指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其 construct() 建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者 Setter 方法将该对象传入指挥者类中。

### 结构图 ###
![建造者模式结构图](https://lyl873825813.github.io/medias/design_pattern/builder_uml.jpg)

### 时序图 ###
![建造者模式时序图](https://lyl873825813.github.io/medias/design_pattern/builder_seq.jpg)

## 模式实现 ##
首先，是产品类。Product 类充当产品类，完整代码如下所示：
```java
/**
 * 产品类
 */
class Product {

    private String number;   // 产品编号
    private String name;     // 产品名称
    private String price;    // 产品价格

    /* getter 和 setter方法. */

    public String getNumber() {
        return number;
    }

    public void setNumber(String number) {
        this.number = number;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getPrice() {
        return price;
    }

    public void setPrice(String price) {
        this.price = price;
    }
}
```

其实，是抽象的建造者和具体的建造者。Builder 接口充当抽象的建造者，ConcreteBuilder 类充当具体的建造者，完整代码如下所示：
```java
/**
 * 抽象的建造者
 */
abstract class Builder {

    /** 需要建造的产品 */
    protected Product product = new Product();

    /**
     * 建造产品编号
     */
    public abstract void buildNumber();

    /**
     * 建造产品名称
     */
    public abstract void buildName();

    /**
     * 建造产品价格
     */
    public abstract void buildPrice();

    /**
     * 返回建造的产品
     */
    public Product createProduct() {
        return product;
    }

}
```

```java
/**
 * 具体的建造者
 */
public class ConcreteBuilder implements Builder {

    /**
     * 建造产品名称
     */
    @Override
    public void buildNumber() {
        product.setNumber("00001");
    }

    /**
     * 产品建造部分B
     */
    @Override
    public void buildName() {
        product.setName("小机器人");
    }

    /**
     * 建造产品价格
     */
    @Override
    public void buildPrice() {
        product.setPrice("18.88");
    }

}
```

然后，是指挥者。Director 类充当具体的指挥者，完整代码如下所示：
```java
/**
 * 指挥者
 */
public class Director {

    /** 当前需要的建造者对象 */
    private Builder builder;

    public Director(Builder builder) {
        this.builder = builder;
    }

    /**
     * 产品构建与组装方法
     */
    public Product construct() {
        builder.buildNumber();
        builder.buildName();
        builder.buildPrice();
        return builder.createProduct();
    }

}
```

最后，是客户端场景类，完整代码如下所示：
```java
/**
 * 建造者模式的客户端场景类
 */
public class BuilderClient {

    public static void main(String[] args) {
        Builder builder = new ConcreteBuilder();
        Director director = new Director(builder);
        Product product = director.construct();
        System.out.println("产品编号：" + product.getNumber());
        System.out.println("产品名称：" + product.getName());
        System.out.println("产品价格：" + product.getPrice());
    }

}
```

## 模式分析 ##
抽象建造者类中定义了产品的创建方法和返回方法;

建造者模式的结构中还引入了一个导演者类 `Director`，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象

在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。

### 优点 ###
建造者模式的主要优点如下：
 - 在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。
 - 每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。
 - 可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。
 - 增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。

### 缺点 ###
建造者模式的主要缺点如下：
 - 建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。
 - 如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。

### 适用环境 ###
在以下情况下可以考虑使用建造者模式：
 - 需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。
 - 需要生成的产品对象的属性相互依赖，需要指定其生成顺序。
 - 对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。
 - 隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。

### 建造者模式与抽象工厂模式的比较 ###
 - 与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。
 - 在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。
 - 如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。

## 模式总结 ##
 - 建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。
 - 建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其`construct()`建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造
 - 在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。
 - 建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。
 - 建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。

## 致谢 ##
[Java Design Pattern](https://www.gitbook.com/book/quanke/design-pattern-java/)
