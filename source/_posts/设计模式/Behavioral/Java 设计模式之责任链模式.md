---
title: Java 设计模式之责任链模式
categories: 设计模式
tags:
  - Java
  - 设计模式
abbrlink: 1bb1b660
date: 2018-10-28 11:45:15
---

## 模式动机 ##
很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的责任链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。

## 模式定义 ##
**`责任链模式(Chain of Responsibility Pattern)`**避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。

**实质**：责任链上的处理者负责处理请求，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。

> 责任链模式是一种**`对象行为型模式`**。

## 模式结构 ##
### 参与角色 ###
责任链模式包含如下角色：
- **`Handler(抽象处理者)：`**它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。
- **`ConcreteHandler(具体处理者)：`**它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。

在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。

### 结构图 ###
![责任链模式结构图](https://henleylee.github.io/medias/design_pattern/chain_responsibility_uml.jpg)

## 模式实现 ##
首先，是抽象处理者。Handler 抽象类充当抽象处理者，完整代码如下所示：
```java
/**
 * 抽象处理者
 */
public abstract class Handler {

    /** 后继处理者角色 */
    protected Handler nextHandler;

    /**
     * 处理请求的抽象方法.
     *
     * @param condition 条件
     */
    public abstract void handle(String condition);

    /**
     * nextHandler的Setter方法
     *
     * @param nextHandler 后继处理器
     */
    public void setNextHandler(Handler nextHandler) {
        this.nextHandler = nextHandler;
    }

}
```
> 责任链模式的核心在于抽象处理者类的设计。

其次，是具体处理者。ConcreteHandler1 和 ConcreteHandler2 类充当具体处理者，完整代码如下所示：

```java
/**
 * 具体处理角色1
 */
public class ConcreteHandler1 extends Handler {

    /**
     * 具体处理角色1的处理方法
     *
     * @param condition 条件
     */
    @Override
    public void handle(String condition) {
        // 如果是自己的责任，就自己处理，负责传给下家处理
        if ("ConcreteHandler1".equals(condition)) {
            System.out.println("具体处理角色1的处理方法handled1...");
        } else {
            System.out.println("具体处理角色1 通过...");
            nextHandler.handle(condition);
        }
    }

}
```

```java
/**
 * 具体处理角色2
 */
public class ConcreteHandler2 extends Handler {

    /**
     * 具体处理角色2的处理方法
     *
     * @param condition 条件
     */
    @Override
    public void handle(String condition) {
        // 如果是自己的责任，就自己处理，负责传给下家处理
        if ("ConcreteHandler2".equals(condition)) {
            System.out.println("具体处理角色2的处理方法handled1...");
        } else {
            System.out.println("具体处理角色2 通过...");
            nextHandler.handle(condition);
        }
    }

}
```

```java
/**
 * 具体处理角色N
 */
public class ConcreteHandlerN extends Handler {

    /**
     * 这里假设n是链的最后一个节点必须处理掉(在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点)
     *
     * @param condition 参数条件
     */
    @Override
    public void handle(String condition) {
        System.out.println( "具体处理角色n的处理方法 结束...");
    }

}
```
> 具体处理者是抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。

最后，是客户端场景类，完整代码如下所示：
```java
public class ChainClient {

    public static void main(String[] args) {
        Handler handler1 = new ConcreteHandler1();
        Handler handler2 = new ConcreteHandler2();
        Handler handlerN = new ConcreteHandlerN();

        handler1.setNextHandler(handler2);
        handler2.setNextHandler(handlerN);

        // 假设这个请求是ConcreteHandler2的责任
        handler1.handle("ConcreteHandler2");
    }

}
```

> 需要注意的是，**责任链模式并不创建责任链，责任链的创建工作必须由系统的其他部分来完成，一般是在使用该责任链的客户端中创建责任链**。责任链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。

## 模式分类 ##
责任链模式可分为两种：
 - 纯的责任链模式
 - 不纯的责任链模式

### 纯的责任链模式 ###
一个纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：**要么承担全部责任，要么将责任推给下家**，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的责任链模式中，**要求一个请求必须被某一个处理者对象所接收**，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的责任链模式。

### 不纯的责任链模式 ###
在一个不纯的责任链模式中**允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收**。每一级具体处理者在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况。

## 模式分析 ##

### 使用场景 ###
责任链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用责任链模式，例如在 Web 应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用责任链模式可以较好地解决此类问题。

### 优点 ###
责任链的主要优点如下：
 - 责任链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。
 - 请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。
 - 在给对象分派职责时，责任链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。
 - 在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。

### 缺点 ###
责任链的的主要缺点如下：
 - 由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因责任链没有被正确配置而得不到处理。
 - 对于比较长的责任链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。
 - 如果建链不当，可能会造成循环调用，将导致系统陷入死循环。

### 适用环境 ###
在以下情况下可以考虑使用责任链模式：
 - 有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。
 - 在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。
 - 可动态指定一组对象处理请求，客户端可以动态创建责任链来处理请求，还可以改变链中处理者之间的先后次序。
        
## 总结 ##
 - 在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。
 - 责任链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的责任链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。

## 致谢 ##
[Java Design Pattern](https://www.gitbook.com/book/quanke/design-pattern-java/)
