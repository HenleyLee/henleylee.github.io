---
title: Java 设计模式之命令模式
date: 2018-10-27 10:26:30
categories: 设计模式
tags:
  - Java
  - 设计模式
---

## 模式动机 ##
在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。

命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。

## 模式定义 ##
**`命令模式(Command Pattern)`**将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式的别名为动作(`Action`)模式或事务(`Transaction`)模式。

> 命令模式是一种**`对象行为型模式`**。

## 模式结构 ##
### 角色组成 ###
命令模式包含如下角色：
- **`Command(抽象命令类)：`**抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的 execute() 等方法，通过这些方法可以调用请求接收者的相关操作。
- **`ConcreteCommand(具体命令类)：`**具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现 execute() 方法时，将调用接收者对象的相关操作(Action)。
- **`Invoker(调用者)：`**调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的 execute() 方法，从而实现间接调用请求接收者的相关操作。
- **`Receiver(接收者)：`**接收者执行与请求相关的操作，它具体实现对请求的业务处理。

### 结构图 ###
![命令模式结构图](http://localhost:4000/medias/design_pattern/command_uml.jpg)

### 时序图 ###
![命令模式时序图](http://localhost:4000/medias/design_pattern/command_seq.jpg)

## 模式实现 ##
首先，是抽象接收者和具体接收者。Receiver 抽象充当抽象接收者，ConcreteReceiver 抽象充当具体接收者，完整代码如下所示：

```java
/**
 * 抽象接收者
 */
public abstract class Receiver {

    /**
     * 定义每个接收者都必须完成的业务
     */
    public abstract void action();

}
```

```java
/**
 * 具体的接收者
 */
public class ConcreteReceiver extends Receiver {

    @Override
    public void action() {
        System.out.println("ConcreteReceiver处理的业务逻辑...");
    }

}
```

其次，是抽象命令类和具体命令类。Command 抽象充当抽象命令类，ConcreteCommand 抽象充当具体命令类，完整代码如下所示：
```java
/**
 * 抽象命令类
 */
public abstract class Command {

    /**
     * 执行命令的方法
     */
    public abstract void execute();

}
```

```java
/**
 * 具体命令类
 */
class ConcreteCommand extends Command {

    /** 维持一个对请求接收者对象的引用 */
    private Receiver receiver;

    public ConcreteCommand(Receiver receiver) {
        this.receiver = receiver;
    }

    public void execute() {
        receiver.action(); // 调用请求接收者的业务处理方法action()
    }

}
```

然后，是调用者。Invoker 抽象充当调用者，完整代码如下所示：
```java
/**
 * 调用者
 */
public class Invoker {

    private Command command;

    public void setCommand(Command command) {
        this.command = command;
    }

    /**
     * 执行命令
     */
    public void action() {
        this.command.execute();
    }
}
```

最后，是客户端场景类，完整代码如下所示：
```java
public class CommandClient {

    public static void main(String[] args) {
        Receiver receiver = new ConcreteReceiver();
        Command command = new ConcreteCommand(receiver);

        Invoker invoker = new Invoker();
        invoker.setCommand(command);          // 把命令交给调用者执行
        invoker.action();                     // 执行命令
    }

}
```

## 模式分析 ##
 - 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。
 - 每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。
 - 命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。
 - 命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。
 - 命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。

### 优点 ###
命令模式的主要优点如下：
 - 降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。
 - 新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。
 - 可以比较容易地设计一个命令队列或宏命令（组合命令）。
 - 为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。

### 缺点 ###
命令模式的主要缺点如下：
 - 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。

### 适用环境 ###
在以下情况下可以考虑使用命令模式：
 - 系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。
 - 系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。
 - 系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。
 - 系统需要将一组操作组合在一起形成宏命令。

## 模式总结 ##
 - 在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。
 - 命令模式包含四个角色：抽象命令类中声明了用于执行请求的 execute() 等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。
 - 命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。
 - 命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。
 - 命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。

## 致谢 ##
[Java Design Pattern](https://www.gitbook.com/book/quanke/design-pattern-java/)

