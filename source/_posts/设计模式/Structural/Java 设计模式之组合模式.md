---
title: Java 设计模式之组合模式
categories: 设计模式
tags:
  - Java
  - 设计模式
abbrlink: 6a4500bc
date: 2018-09-21 12:27:50
---

## 模式动机 ##
对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象）并调用执行，牵一而动百，其中使用了递归调用的机制来对整个结构进行处理。由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下我们希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。组合模式为解决此类问题而诞生，它可以让叶子对象和容器对象的使用具有一致性。这就是组合模式的模式动机。

## 模式定义 ##
**`组合模式(Composite Pattern)`**组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式。

> 组合模式是一种**`对象结构型模式`**。

## 模式结构 ##
### 角色组成 ###
组合模式包含如下角色：
 - **`Component(抽象构件)：`**它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。
 - **`Leaf(叶子构件)：`**它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。
 - **`Composite(容器构件)：`**它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。

### 结构图 ###
![组合模式结构图](https://henleylee.github.io/medias/design_pattern/composite_uml.jpg)

## 模式实现 ##
首先，是抽象构件。Component 抽象类充当抽象构件，完整代码如下所示：
```java
/**
 * 抽象构件
 */
abstract class Component {

    protected String name;

    public Component(String name) {
        this.name = name;
    }

    /**
     * 增加成员
     */
    public abstract void add(Component c);

    /**
     * 删除成员
     */
    public abstract void remove(Component c);

    /**
     * 获取成员
     */
    public abstract Component getChild(int i);

    /**
     * 业务方法
     */
    public abstract void operation();

}
```
> 一般将抽象构件类设计为接口或抽象类，将所有子类共有方法的声明和实现放在抽象构件类中。对于客户端而言，将针对抽象构件编程，而无须关心其具体子类是容器构件还是叶子构件。


其次，是叶子构件。Leaf 类充当叶子构件，完整代码如下所示：
```java
/**
 * 叶子构件
 */
public class Leaf extends Component {

    public Leaf(String name) {
        super(name);
    }

    @Override
    public void add(Component c) {
        // 异常处理或错误提示
    }

    @Override
    public void remove(Component c) {
        // 异常处理或错误提示
    }

    @Override
    public Component getChild(int i) {
        // 异常处理或错误提示
        return null;
    }

    @Override
    public void operation() {
        // 叶子构件具体业务方法的实现
    }

}
```
> 作为抽象构件类的子类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示。当然，这无疑会给叶子构件的实现带来麻烦。

然后，是容器构件。Composite 类充当容器构件，完整代码如下所示：
```java
/**
 * 容器构件
 */
public class Composite extends Component {

    private ArrayList<Component> components = new ArrayList<Component>();

    public Composite(String name) {
        super(name);
    }

    @Override
    public void add(Component c) {
        components.add(c);
    }

    @Override
    public void remove(Component c) {
        components.remove(c);
    }

    @Override
    public Component getChild(int i) {
        return components.get(i);
    }

    @Override
    public void operation() {
        // 容器构件具体业务方法的实现
        // 递归调用成员构件的业务方法
        for (Component component : components) {
            component.operation();
        }
    }

}
```
> 在容器构件中实现了在抽象构件中声明的所有方法，既包括业务方法，也包括用于访问和管理成员子构件的方法，如 add()、remove() 和 getChild() 等方法。需要注意的是在实现具体业务方法时，由于容器构件充当的是容器角色，包含成员构件，因此它将调用其成员构件的业务方法。在组合模式结构中，由于容器构件中仍然可以包含容器构件，因此在对容器构件进行处理时需要使用递归算法，即在容器构件的 operation() 方法中递归调用其成员构件的 operation() 方法。

最后，是客户端场景类，完整代码如下所示：
```java
public class CompositeClient {

    public static void main(String[] args) {
        Composite compositeRoot = new Composite("Root");
        compositeRoot.add(new Leaf("Leaf A"));
        compositeRoot.add(new Leaf("Leaf B"));


        Composite compositeX = new Composite("Composite X");
        compositeX.add(new Leaf("Leaf XA"));
        compositeX.add(new Leaf("Leaf XB"));
        compositeRoot.add(compositeX);


        Composite compositeY = new Composite("Composite Y");
        compositeY.add(new Leaf("Leaf YA"));
        compositeY.add(new Leaf("Leaf YB"));
        compositeX.add(compositeY);

        compositeRoot.operation();

    }

}
```

## 模式分类 ##
在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式：

### 透明组合模式 ###
透明组合模式中，抽象构件 Component 中声明了所有用于管理成员对象的方法，包括 add()、remove() 以及 getChild() 等方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式。

### 安全组合模式 ###
安全组合模式中，在抽象构件 Component 中没有声明任何用于管理成员对象的方法，而是在 Composite 类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。

安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。

## 模式分析 ##
 - 组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。
 - 如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，带来了代码维护复杂、可扩展性差等弊端。组合模式的引入将在一定程度上解决这些问题。
 - 组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。

### 优点 ###
组合模式的主要优点如下：
 - 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
 - 客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。
 - 在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。
 - 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。

### 缺点 ###
组合模式的主要缺点如下：
 - 在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。

### 适用环境 ###
在以下情况下可以考虑使用组合模式：
 - 在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。
 - 在一个使用面向对象语言开发的系统中需要处理一个树形结构。
 - 在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。

## 模式总结 ##
 - 组合模式组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式。
 - 组合模式包含三个角色：抽象构件定义了叶子构件和容器构件对象的接口，可以包含所有子类共有行为的声明和实现；叶子构件定义了叶子节点对象，实现了在抽象构件中定义的行为；容器构件定义了容器节点对象，提供一个集合用于存储子节点，实现了在抽象构件中定义的行为。
 - 组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。
 - 组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。
 - 组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。
 - 组合模式根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。

## 致谢 ##
[Java Design Pattern](https://www.gitbook.com/book/quanke/design-pattern-java/)
