<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title>推荐十大经典排序算法</title>
      <link href="/posts/2019/2ef6609b.html"/>
      <url>/posts/2019/2ef6609b.html</url>
      
        <content type="html"><![CDATA[<p>排序算法是《数据结构与算法》中最基本的算法之一。</p><p>排序算法可以分为内部排序和外部排序，内部排序是数据记录在内存中进行排序，而外部排序是因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。常见的内部排序算法有：<strong>插入排序、希尔排序、选择排序、冒泡排序、归并排序、快速排序、堆排序、基数排序</strong>等。用一张图概括：</p><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_overview.png" alt="十大经典排序算法概览"></p><h2 id="术语说明"><a href="#术语说明" class="headerlink" title="术语说明"></a>术语说明</h2><h3 id="关于时间复杂度"><a href="#关于时间复杂度" class="headerlink" title="关于时间复杂度"></a>关于时间复杂度</h3><ol><li>平方阶 (<code>O(n2)</code>) 排序：各类简单排序：直接插入、直接选择和冒泡排序。</li><li>线性对数阶 (<code>O(nlog2n)</code>) 排序：快速排序、堆排序和归并排序；</li><li><code>O(n1+§)</code> 排序(§ 是介于 0 和 1 之间的常数)：希尔排序</li><li>线性阶 (<code>O(n)</code>) 排序：基数排序，此外还有桶、箱排序。</li></ol><h3 id="关于稳定性"><a href="#关于稳定性" class="headerlink" title="关于稳定性"></a>关于稳定性</h3><ol><li>稳定的排序算法：冒泡排序、插入排序、归并排序和基数排序。</li><li>不稳定的排序算法：选择排序、快速排序、希尔排序、堆排序。</li></ol><h3 id="名词解释"><a href="#名词解释" class="headerlink" title="名词解释"></a>名词解释</h3><p><strong><code>n：</code></strong>数据规模<br><strong><code>k：</code></strong>“桶”的个数<br><strong><code>In-place：</code></strong>占用常数内存，不占用额外内存<br><strong><code>Out-place：</code></strong>占用额外内存<br><strong><code>稳定性：</code></strong>排序后 2 个相等键值的顺序和排序之前它们的顺序相同<br><strong><code>时间复杂度：</code></strong>对排序数据的总的操作次数。反映当 n 变化时，操作次数呈现什么规律。<br><strong><code>空间复杂度：</code></strong>算法在计算机内执行时所需存储空间的度量，它也是数据规模 n 的函数。</p><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>冒泡排序（Bubble Sort）也是一种简单直观的排序算法。它重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢“浮”到数列的顶端。</p><p>作为最简单的排序算法之一，冒泡排序给我的感觉就像 Abandon 在单词书里出现的感觉一样，每次都在第一页第一位，所以最熟悉。冒泡排序还有一种优化算法，就是立一个 flag，当在一趟序列遍历中元素没有发生交换，则证明该序列已经有序。但这种改进对于提升性能来说并没有什么太大作用。</p><h3 id="1-算法步骤"><a href="#1-算法步骤" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>比较相邻的元素。如果第一个比第二个大，就交换他们两个。</li><li>对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。这步做完后，最后的元素会是最大的数。</li><li>针对所有的元素重复以上的步骤，除了最后一个。</li><li>持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。</li></ol><h3 id="2-动图演示"><a href="#2-动图演示" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_bubble.gif" alt="冒泡排序算法"></p><h3 id="3-什么时候最快"><a href="#3-什么时候最快" class="headerlink" title="3. 什么时候最快"></a>3. 什么时候最快</h3><p>当输入的数据已经是正序时(都已经是正序了，我还要你冒泡排序有何用啊)。</p><h3 id="4-什么时候最慢"><a href="#4-什么时候最慢" class="headerlink" title="4. 什么时候最慢"></a>4. 什么时候最慢</h3><p>当输入的数据是反序时(写一个 for 循环反序输出数据不就行了，干嘛要用你冒泡排序呢，我是闲的吗)。</p><h3 id="5-JavaScript-代码实现"><a href="#5-JavaScript-代码实现" class="headerlink" title="5. JavaScript 代码实现"></a>5. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 相邻元素两两对比</span>                <span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 元素交换</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="6-Python-代码实现"><a href="#6-Python-代码实现" class="headerlink" title="6. Python 代码实现"></a>6. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span>i<span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="7-Go-代码实现"><a href="#7-Go-代码实现" class="headerlink" title="7. Go 代码实现"></a>7. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token number">-1</span><span class="token operator">-</span>i<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="8-Java-代码实现"><a href="#8-Java-代码实现" class="headerlink" title="8. Java 代码实现"></a>8. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BubbleSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 设定一个标记，若为true，则表示此次循环没有进行交换，也就是待排序列已经有序，排序已经完成。</span>            <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>                    flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="9-PHP-代码实现"><a href="#9-PHP-代码实现" class="headerlink" title="9. PHP 代码实现"></a>9. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">-</span> <span class="token variable">$i</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$tmp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$tmp</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 O(n²) 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。</p><h3 id="1-算法步骤-1"><a href="#1-算法步骤-1" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li>再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li>重复第二步，直到所有元素均排序完毕。</li></ol><h3 id="2-动图演示-1"><a href="#2-动图演示-1" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_selection.gif" alt="选择排序算法"></p><h3 id="3-JavaScript-代码实现"><a href="#3-JavaScript-代码实现" class="headerlink" title="3. JavaScript 代码实现"></a>3. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">var</span> minIndex<span class="token punctuation">,</span> temp<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 寻找最小的数</span>                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// 将最小数的索引保存</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Python-代码实现"><a href="#4-Python-代码实现" class="headerlink" title="4. Python 代码实现"></a>4. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token comment" spellcheck="true"># 记录最小数的索引</span>        minIndex <span class="token operator">=</span> i        <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">:</span>                minIndex <span class="token operator">=</span> j        <span class="token comment" spellcheck="true"># i 不是最小数时，将 i 和最小数进行交换</span>        <span class="token keyword">if</span> i <span class="token operator">!=</span> minIndex<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="5-Go-代码实现"><a href="#5-Go-代码实现" class="headerlink" title="5. Go 代码实现"></a>5. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token number">-1</span><span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        min <span class="token operator">:=</span> i        <span class="token keyword">for</span> j <span class="token operator">:=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token punctuation">{</span>                min <span class="token operator">=</span> j            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="6-Java-代码实现"><a href="#6-Java-代码实现" class="headerlink" title="6. Java 代码实现"></a>6. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SelectionSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 总共要经过 N-1 轮比较</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> min <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 每轮需要比较的次数 N-i</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 记录目前能找到的最小值元素的下标</span>                    min <span class="token operator">=</span> j<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 将找到的最小值和i位置所在的值进行交换</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">!=</span> min<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>min<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-PHP-代码实现"><a href="#7-PHP-代码实现" class="headerlink" title="7. PHP 代码实现"></a>7. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$minIndex</span> <span class="token operator">=</span> <span class="token variable">$i</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token variable">$i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$minIndex</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$minIndex</span> <span class="token operator">=</span> <span class="token variable">$j</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$minIndex</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$minIndex</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$temp</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h3 id="1-算法步骤-2"><a href="#1-算法步骤-2" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>将第一待排序序列第一个元素看做一个有序序列，把第二个元素到最后一个元素当成是未排序序列。</li><li>从头到尾依次扫描未排序序列，将扫描到的每个元素插入有序序列的适当位置。（如果待插入的元素与有序序列中的某个元素相等，则将待插入元素插入到相等元素的后面。）</li></ol><h3 id="2-动图演示-2"><a href="#2-动图演示-2" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_insertion.gif" alt="插入排序算法"></p><h3 id="3-JavaScript-代码实现-1"><a href="#3-JavaScript-代码实现-1" class="headerlink" title="3. JavaScript 代码实现"></a>3. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">var</span> preIndex<span class="token punctuation">,</span> current<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        preIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            preIndex<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Python-代码实现-1"><a href="#4-Python-代码实现-1" class="headerlink" title="4. Python 代码实现"></a>4. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        preIndex <span class="token operator">=</span> i<span class="token number">-1</span>        current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">while</span> preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current<span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span>            preIndex<span class="token operator">-=</span><span class="token number">1</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current    <span class="token keyword">return</span> arr</code></pre><h3 id="5-Go-代码实现-1"><a href="#5-Go-代码实现-1" class="headerlink" title="5. Go 代码实现"></a>5. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token keyword">range</span> arr <span class="token punctuation">{</span>        preIndex <span class="token operator">:=</span> i <span class="token operator">-</span> <span class="token number">1</span>        current <span class="token operator">:=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>        <span class="token keyword">for</span> preIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">></span> current <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span>            preIndex <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>preIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="6-Java-代码实现-1"><a href="#6-Java-代码实现-1" class="headerlink" title="6. Java 代码实现"></a>6. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InsertSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从下标为1的元素开始选择合适的位置插入，因为下标为0的只有一个元素，默认是有序的</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 记录要插入的数据</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 从已经排序的序列最右边的开始比较，找到比其小的数</span>            <span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> tmp <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                j<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 存在比其小的数，插入</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>j <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-PHP-代码实现-1"><a href="#7-PHP-代码实现-1" class="headerlink" title="7. PHP 代码实现"></a>7. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$preIndex</span> <span class="token operator">=</span> <span class="token variable">$i</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token variable">$current</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$preIndex</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$preIndex</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$current</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$preIndex</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$preIndex</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$preIndex</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$preIndex</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$current</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h2><p>希尔排序，也称递减增量排序算法，是插入排序的一种更高效的改进版本。但希尔排序是非稳定排序算法。</p><p>希尔排序是基于插入排序的以下两点性质而提出改进方法的：</p><ul><li>插入排序在对几乎已经排好序的数据操作时，效率高，即可以达到线性排序的效率；</li><li>但插入排序一般来说是低效的，因为插入排序每次只能将数据移动一位；</li></ul><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对全体记录进行依次直接插入排序。</p><h3 id="1-算法步骤-3"><a href="#1-算法步骤-3" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>选择一个增量序列 t1，t2，……，tk，其中 ti &gt; tj, tk = 1；</li><li>按增量序列个数 k，对序列进行 k 趟排序；</li><li>每趟排序，根据对应的增量 ti，将待排序列分割成若干长度为 m 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ol><h3 id="2-JavaScript-代码实现"><a href="#2-JavaScript-代码实现" class="headerlink" title="2. JavaScript 代码实现"></a>2. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>        temp<span class="token punctuation">,</span>        gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> len<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment" spellcheck="true">//动态定义间隔序列</span>        gap <span class="token operator">=</span>gap<span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>gap<span class="token punctuation">;</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> gap <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>gap<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> i<span class="token operator">-</span>gap<span class="token punctuation">;</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">;</span> j<span class="token operator">-</span><span class="token operator">=</span>gap<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-Python-代码实现"><a href="#3-Python-代码实现" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> math    gap<span class="token operator">=</span><span class="token number">1</span>    <span class="token keyword">while</span><span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        gap <span class="token operator">=</span> gap<span class="token operator">*</span><span class="token number">3</span><span class="token operator">+</span><span class="token number">1</span>    <span class="token keyword">while</span> gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>        <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>gap<span class="token punctuation">,</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">:</span>            temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            j <span class="token operator">=</span> i<span class="token operator">-</span>gap            <span class="token keyword">while</span> j <span class="token operator">>=</span><span class="token number">0</span> <span class="token operator">and</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp<span class="token punctuation">:</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span><span class="token operator">=</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j<span class="token operator">-=</span>gap            arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp        gap <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>gap<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="4-Go-代码实现"><a href="#4-Go-代码实现" class="headerlink" title="4. Go 代码实现"></a>4. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">shellSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    gap <span class="token operator">:=</span> <span class="token number">1</span>    <span class="token keyword">for</span> gap <span class="token operator">&lt;</span> gap<span class="token operator">/</span><span class="token number">3</span> <span class="token punctuation">{</span>        gap <span class="token operator">=</span> gap<span class="token operator">*</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> gap <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> i <span class="token operator">:=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>            temp <span class="token operator">:=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span>            j <span class="token operator">:=</span> i <span class="token operator">-</span> gap            <span class="token keyword">for</span> j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> temp <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span>                j <span class="token operator">-=</span> gap            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>j<span class="token operator">+</span>gap<span class="token punctuation">]</span> <span class="token operator">=</span> temp        <span class="token punctuation">}</span>        gap <span class="token operator">=</span> gap <span class="token operator">/</span> <span class="token number">3</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="5-Java-代码实现"><a href="#5-Java-代码实现" class="headerlink" title="5. Java 代码实现"></a>5. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ShellSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> gap <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            gap <span class="token operator">=</span> gap <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                    j <span class="token operator">-=</span> gap<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            gap <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>gap <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6-PHP-代码实现"><a href="#6-PHP-代码实现" class="headerlink" title="6. PHP 代码实现"></a>6. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token variable">$gap</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token variable">$gap</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$gap</span> <span class="token operator">=</span> <span class="token variable">$gap</span> <span class="token operator">*</span> <span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$gap</span><span class="token punctuation">;</span> <span class="token variable">$gap</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$gap</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$gap</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token variable">$gap</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$len</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token variable">$i</span> <span class="token operator">-</span> <span class="token variable">$gap</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$temp</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">-</span><span class="token operator">=</span> <span class="token variable">$gap</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token variable">$gap</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token operator">+</span><span class="token variable">$gap</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$temp</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>归并排序（Merge sort）是建立在归并操作上的一种有效的排序算法。该算法是采用分治法（Divide and Conquer）的一个非常典型的应用。</p><p>作为一种典型的分而治之思想的算法应用，归并排序的实现由两种方法：</p><ul><li>自上而下的递归（所有递归的方法都可以用迭代重写，所以就有了第 2 种方法）；</li><li>自下而上的迭代；</li></ul><p>在《数据结构与算法 JavaScript 描述》中，作者给出了自下而上的迭代方法。但是对于递归法，作者却认为：</p><blockquote><p>However, it is not possible to do so in JavaScript, as the recursion goes too deep for the language to handle.</p><p>然而，在 JavaScript 中这种方式不太可行，因为这个算法的递归深度对它来讲太深了。</p></blockquote><p>说实话，我不太理解这句话。意思是 JavaScript 编译器内存太小，递归太深容易造成内存溢出吗？还望有大神能够指教。</p><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 O(nlogn) 的时间复杂度。代价是需要额外的内存空间。</p><h3 id="1-算法步骤-4"><a href="#1-算法步骤-4" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>申请空间，使其大小为两个已经排序序列之和，该空间用来存放合并后的序列；</li><li>设定两个指针，最初位置分别为两个已经排序序列的起始位置；</li><li>比较两个指针所指向的元素，选择相对小的元素放入到合并空间，并移动指针到下一位置；</li><li>重复步骤 3 直到某一指针达到序列尾；</li><li>将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h3 id="2-动图演示-3"><a href="#2-动图演示-3" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_merge.gif" alt="归并排序算法"></p><h3 id="3-JavaScript-代码实现-2"><a href="#3-JavaScript-代码实现-2" class="headerlink" title="3. JavaScript 代码实现"></a>3. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment" spellcheck="true">// 采用自上而下的递归方法</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">if</span><span class="token punctuation">(</span>len <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> middle <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        left <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">,</span>        right <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">(</span>middle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>left<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span>length<span class="token punctuation">)</span>        result<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>right<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Python-代码实现-2"><a href="#4-Python-代码实现-2" class="headerlink" title="4. Python 代码实现"></a>4. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> math    <span class="token keyword">if</span><span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">&lt;</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">return</span> arr    middle <span class="token operator">=</span> math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span>    left<span class="token punctuation">,</span> right <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>middle<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>middle<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> merge<span class="token punctuation">(</span>mergeSort<span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> mergeSort<span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">merge</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span>right<span class="token punctuation">)</span><span class="token punctuation">:</span>    result <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>    <span class="token keyword">while</span> left <span class="token operator">and</span> right<span class="token punctuation">:</span>        <span class="token keyword">if</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span><span class="token punctuation">:</span>            result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> left<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>left<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> right<span class="token punctuation">:</span>        result<span class="token punctuation">.</span>append<span class="token punctuation">(</span>right<span class="token punctuation">.</span>pop<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result</code></pre><h3 id="5-Go-代码实现-2"><a href="#5-Go-代码实现-2" class="headerlink" title="5. Go 代码实现"></a>5. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">if</span> length <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr    <span class="token punctuation">}</span>    middle <span class="token operator">:=</span> length <span class="token operator">/</span> <span class="token number">2</span>    left <span class="token operator">:=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">:</span>middle<span class="token punctuation">]</span>    right <span class="token operator">:=</span> arr<span class="token punctuation">[</span>middle<span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">merge</span><span class="token punctuation">(</span>left <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> right <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> result <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span>    <span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            left <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>            right <span class="token operator">=</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        left <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token function">len</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span> <span class="token punctuation">{</span>        result <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>        right <span class="token operator">=</span> right<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">:</span><span class="token punctuation">]</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">}</span></code></pre><h3 id="6-Java-代码实现-2"><a href="#6-Java-代码实现-2" class="headerlink" title="6. Java 代码实现"></a>6. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MergeSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> middle <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> middle<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">sort</span><span class="token punctuation">(</span>left<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">sort</span><span class="token punctuation">(</span>right<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>left<span class="token punctuation">.</span>length <span class="token operator">+</span> right<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> right<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>left<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> left<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            left <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>left<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> left<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>right<span class="token punctuation">.</span>length <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> right<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            right <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>right<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-PHP-代码实现-2"><a href="#7-PHP-代码实现-2" class="headerlink" title="7. PHP 代码实现"></a>7. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$len</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$middle</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$len</span> <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$left</span> <span class="token operator">=</span> <span class="token function">array_slice</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$middle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$right</span> <span class="token operator">=</span> <span class="token function">array_slice</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$middle</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">,</span> <span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$result</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">&lt;=</span> <span class="token variable">$right</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$left</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token variable">$result</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$right</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token variable">$result</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h2><p>快速排序是由东尼·霍尔所发展的一种排序算法。在平均状况下，排序 n 个项目要 Ο(nlogn) 次比较。在最坏状况下则需要 Ο(n2) 次比较，但这种状况并不常见。事实上，快速排序通常明显比其他 Ο(nlogn) 算法更快，因为它的内部循环（inner loop）可以在大部分的架构上很有效率地被实现出来。</p><p>快速排序使用分治法（Divide and conquer）策略来把一个串行（list）分为两个子串行（sub-lists）。</p><p>快速排序又是一种分而治之思想在排序算法上的典型应用。本质上来看，快速排序应该算是在冒泡排序基础上的递归分治法。</p><p>快速排序的名字起的是简单粗暴，因为一听到这个名字你就知道它存在的意义，就是快，而且效率高！它是处理大数据最快的排序算法之一了。虽然 Worst Case 的时间复杂度达到了 O(n²)，但是人家就是优秀，在大多数情况下都比平均时间复杂度为 O(n logn) 的排序算法表现要更好，可是这是为什么呢，我也不知道。好在我的强迫症又犯了，查了 N 多资料终于在《算法艺术与信息学竞赛》上找到了满意的答案：</p><blockquote><p>快速排序的最坏运行情况是 O(n²)，比如说顺序数列的快排。但它的平摊期望时间是 O(nlogn)，且 O(nlogn) 记号中隐含的常数因子很小，比复杂度稳定等于 O(nlogn) 的归并排序要小很多。所以，对绝大多数顺序性较弱的随机数列而言，快速排序总是优于归并排序。</p></blockquote><h3 id="1-算法步骤-5"><a href="#1-算法步骤-5" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>从数列中挑出一个元素，称为 “基准”（pivot）;</li><li>重新排序数列，所有元素比基准值小的摆放在基准前面，所有元素比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个分区退出之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li>递归地（recursive）把小于基准值元素的子数列和大于基准值元素的子数列排序；</li></ol><p>递归的最底部情形，是数列的大小是零或一，也就是永远都已经被排序好了。虽然一直递归下去，但是这个算法总会退出，因为在每次的迭代（iteration）中，它至少会把一个元素摆到它最后的位置去。</p><h3 id="2-动图演示-4"><a href="#2-动图演示-4" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_quick.gif" alt="快速排序算法"></p><h3 id="3-JavaScript-代码实现-3"><a href="#3-JavaScript-代码实现-3" class="headerlink" title="3. JavaScript 代码实现"></a>3. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>        partitionIndex<span class="token punctuation">,</span>        left <span class="token operator">=</span> <span class="token keyword">typeof</span> left <span class="token operator">!=</span> <span class="token string">'number'</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token punctuation">:</span> left<span class="token punctuation">,</span>        right <span class="token operator">=</span> <span class="token keyword">typeof</span> right <span class="token operator">!=</span> <span class="token string">'number'</span> <span class="token operator">?</span> len <span class="token operator">-</span> <span class="token number">1</span> <span class="token punctuation">:</span> right<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        partitionIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex<span class="token number">-1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left <span class="token punctuation">,</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 分区操作</span>    <span class="token keyword">var</span> pivot <span class="token operator">=</span> left<span class="token punctuation">,</span>                      <span class="token comment" spellcheck="true">// 设定基准值（pivot）</span>        index <span class="token operator">=</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>            index<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> index<span class="token number">-1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">partition2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">let</span> pivot <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">></span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token operator">--</span>high<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token operator">++</span>low<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    arr<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  arr<span class="token punctuation">[</span>low<span class="token punctuation">]</span> <span class="token operator">=</span> pivot<span class="token punctuation">;</span>  <span class="token keyword">return</span> low<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">quickSort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">let</span> pivot <span class="token operator">=</span> <span class="token function">partition2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quickSort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> low<span class="token punctuation">,</span> pivot <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">quickSort2</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Python-代码实现-3"><a href="#4-Python-代码实现-3" class="headerlink" title="4. Python 代码实现"></a>4. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token operator">=</span>None<span class="token punctuation">,</span> right<span class="token operator">=</span>None<span class="token punctuation">)</span><span class="token punctuation">:</span>    left <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">if</span> <span class="token operator">not</span> isinstance<span class="token punctuation">(</span>left<span class="token punctuation">,</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">else</span> left    right <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span> <span class="token keyword">if</span> <span class="token operator">not</span> isinstance<span class="token punctuation">(</span>right<span class="token punctuation">,</span><span class="token punctuation">(</span>int<span class="token punctuation">,</span> float<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">else</span> right    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right<span class="token punctuation">:</span>        partitionIndex <span class="token operator">=</span> partition<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>        quickSort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex<span class="token number">-1</span><span class="token punctuation">)</span>        quickSort<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token keyword">return</span> arr<span class="token keyword">def</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">:</span>    pivot <span class="token operator">=</span> left    index <span class="token operator">=</span> pivot<span class="token operator">+</span><span class="token number">1</span>    i <span class="token operator">=</span> index    <span class="token keyword">while</span>  i <span class="token operator">&lt;=</span> right<span class="token punctuation">:</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">:</span>            swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> index<span class="token punctuation">)</span>            index<span class="token operator">+=</span><span class="token number">1</span>        i<span class="token operator">+=</span><span class="token number">1</span>    swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>pivot<span class="token punctuation">,</span>index<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> index<span class="token number">-1</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span></code></pre><h3 id="5-Go-代码实现-3"><a href="#5-Go-代码实现-3" class="headerlink" title="5. Go 代码实现"></a>5. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> right <span class="token punctuation">{</span>        partitionIndex <span class="token operator">:=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span>        <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex<span class="token number">-1</span><span class="token punctuation">)</span>        <span class="token function">_quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> left<span class="token punctuation">,</span> right <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">{</span>    pivot <span class="token operator">:=</span> left    index <span class="token operator">:=</span> pivot <span class="token operator">+</span> <span class="token number">1</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> index<span class="token punctuation">)</span>            index <span class="token operator">+=</span> <span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> index<span class="token number">-1</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="6-C-版"><a href="#6-C-版" class="headerlink" title="6. C++版"></a>6. C++版</h3><pre class=" language-C++"><code class="language-C++"> //严蔚敏《数据结构》标准分割函数 Paritition1(int A[], int low, int high) {   int pivot = A[low];   while (low < high) {     while (low < high && A[high] >= pivot) {       --high;     }     A[low] = A[high];     while (low < high && A[low] <= pivot) {       ++low;     }     A[high] = A[low];   }   A[low] = pivot;   return low; } void QuickSort(int A[], int low, int high) //快排母函数 {   if (low < high) {     int pivot = Paritition1(A, low, high);     QuickSort(A, low, pivot - 1);     QuickSort(A, pivot + 1, high);   } }</code></pre><h3 id="7-Java-代码实现"><a href="#7-Java-代码实现" class="headerlink" title="7. Java 代码实现"></a>7. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">QuickSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> partitionIndex <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> left<span class="token punctuation">,</span> partitionIndex <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">quickSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> partitionIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> right<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设定基准值（pivot）</span>        <span class="token keyword">int</span> pivot <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">int</span> index <span class="token operator">=</span> pivot <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> index<span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> right<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>pivot<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>                index<span class="token operator">++</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> pivot<span class="token punctuation">,</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="8-PHP-代码实现"><a href="#8-PHP-代码实现" class="headerlink" title="8. PHP 代码实现"></a>8. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>    <span class="token variable">$middle</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$leftArray</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$rightArray</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$middle</span><span class="token punctuation">)</span>            <span class="token variable">$rightArray</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token variable">$leftArray</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$leftArray</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token variable">$leftArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token variable">$leftArray</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$middle</span><span class="token punctuation">;</span>    <span class="token variable">$rightArray</span> <span class="token operator">=</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token variable">$rightArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">array_merge</span><span class="token punctuation">(</span><span class="token variable">$leftArray</span><span class="token punctuation">,</span> <span class="token variable">$rightArray</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h2><p>堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。堆排序可以说是一种利用堆的概念来排序的选择排序。分为两种方法：</p><ol><li>大顶堆：每个节点的值都大于或等于其子节点的值，在堆排序算法中用于升序排列；</li><li>小顶堆：每个节点的值都小于或等于其子节点的值，在堆排序算法中用于降序排列；</li></ol><p>堆排序的平均时间复杂度为 Ο(nlogn)。</p><h3 id="1-算法步骤-6"><a href="#1-算法步骤-6" class="headerlink" title="1. 算法步骤"></a>1. 算法步骤</h3><ol><li>创建一个堆 H[0……n-1]；</li><li>把堆首（最大值）和堆尾互换；</li><li>把堆的尺寸缩小 1，并调用 shift_down(0)，目的是把新的数组顶端数据调整到相应位置；</li><li>重复步骤 2，直到堆的尺寸为 1。</li></ol><h3 id="2-动图演示-5"><a href="#2-动图演示-5" class="headerlink" title="2. 动图演示"></a>2. 动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_heap.gif" alt="堆排序算法"></p><h3 id="3-JavaScript-代码实现-4"><a href="#3-JavaScript-代码实现-4" class="headerlink" title="3. JavaScript 代码实现"></a>3. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">var</span> len<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 因为声明的多个函数都需要数据长度，所以把len设置成为全局变量</span><span class="token keyword">function</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// 建立大顶堆</span>    len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len<span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 堆调整</span>    <span class="token keyword">var</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>        right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">,</span>        largest <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token number">-1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        len<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Python-代码实现-4"><a href="#4-Python-代码实现-4" class="headerlink" title="4. Python 代码实现"></a>4. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">import</span> math    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>math<span class="token punctuation">.</span>floor<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span>i<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">:</span>    left <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">1</span>    right <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span>i<span class="token operator">+</span><span class="token number">2</span>    largest <span class="token operator">=</span> i    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> left    <span class="token keyword">if</span> right <span class="token operator">&lt;</span> arrLen <span class="token operator">and</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">:</span>        largest <span class="token operator">=</span> right    <span class="token keyword">if</span> largest <span class="token operator">!=</span> i<span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token keyword">def</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">:</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token keyword">def</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">:</span>    <span class="token keyword">global</span> arrLen    arrLen <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    buildMaxHeap<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">:</span>        swap<span class="token punctuation">(</span>arr<span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span>i<span class="token punctuation">)</span>        arrLen <span class="token operator">-=</span><span class="token number">1</span>        heapify<span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="5-Go-代码实现-4"><a href="#5-Go-代码实现-4" class="headerlink" title="5. Go 代码实现"></a>5. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">heapSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    arrLen <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> arrLen <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span>        arrLen <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> arrLen <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> arrLen <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span> <span class="token punctuation">{</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">heapify</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> arrLen <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    left <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">1</span>    right <span class="token operator">:=</span> <span class="token number">2</span><span class="token operator">*</span>i <span class="token operator">+</span> <span class="token number">2</span>    largest <span class="token operator">:=</span> i    <span class="token keyword">if</span> left <span class="token operator">&lt;</span> arrLen <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> left    <span class="token punctuation">}</span>    <span class="token keyword">if</span> right <span class="token operator">&lt;</span> arrLen <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> right    <span class="token punctuation">}</span>    <span class="token keyword">if</span> largest <span class="token operator">!=</span> i <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> arrLen<span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">func</span> <span class="token function">swap</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> i<span class="token punctuation">,</span> j <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">}</span></code></pre><h3 id="6-Java-代码实现-3"><a href="#6-Java-代码实现-3" class="headerlink" title="6. Java 代码实现"></a>6. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HeapSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>            len<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span>len <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            largest <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">></span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            largest <span class="token operator">=</span> right<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="7-PHP-代码实现-3"><a href="#7-PHP-代码实现-3" class="headerlink" title="7. PHP 代码实现"></a>7. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">global</span> <span class="token variable">$len</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token variable">$len</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">global</span> <span class="token variable">$len</span><span class="token punctuation">;</span>    <span class="token variable">$left</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token variable">$i</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token variable">$right</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token variable">$i</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token variable">$largest</span> <span class="token operator">=</span> <span class="token variable">$i</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$left</span> <span class="token markup">&lt; $len &amp;&amp; $arr[$left] ></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$largest</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$largest</span> <span class="token operator">=</span> <span class="token variable">$left</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$right</span> <span class="token markup">&lt; $len &amp;&amp; $arr[$right] ></span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$largest</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$largest</span> <span class="token operator">=</span> <span class="token variable">$right</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$largest</span> <span class="token operator">!=</span> <span class="token variable">$i</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token variable">$largest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$largest</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">,</span> <span class="token variable">$j</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token variable">$temp</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$temp</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">function</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">global</span> <span class="token variable">$len</span><span class="token punctuation">;</span>    <span class="token variable">$len</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token variable">$i</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token variable">$len</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="计数排序"><a href="#计数排序" class="headerlink" title="计数排序"></a>计数排序</h2><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。作为一种线性时间复杂度的排序，计数排序要求输入的数据必须是有确定范围的整数。</p><h3 id="1-动图演示"><a href="#1-动图演示" class="headerlink" title="1. 动图演示"></a>1. 动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_counting.gif" alt="计数排序算法"></p><h3 id="2-JavaScript-代码实现-1"><a href="#2-JavaScript-代码实现-1" class="headerlink" title="2. JavaScript 代码实现"></a>2. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>maxValue<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        sortedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        arrLen <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">,</span>        bucketLen <span class="token operator">=</span> maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arrLen<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span><span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>sortedIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>            bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="3-Python-代码实现-1"><a href="#3-Python-代码实现-1" class="headerlink" title="3. Python 代码实现"></a>3. Python 代码实现</h3><pre class=" language-python"><code class="language-python"><span class="token keyword">def</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">:</span>    bucketLen <span class="token operator">=</span> maxValue<span class="token operator">+</span><span class="token number">1</span>    bucket <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token operator">*</span>bucketLen    sortedIndex <span class="token operator">=</span><span class="token number">0</span>    arrLen <span class="token operator">=</span> len<span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token keyword">in</span> range<span class="token punctuation">(</span>arrLen<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">if</span> <span class="token operator">not</span> bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">:</span>            bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token number">0</span>        bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">+=</span><span class="token number">1</span>    <span class="token keyword">for</span> j <span class="token keyword">in</span> range<span class="token punctuation">(</span>bucketLen<span class="token punctuation">)</span><span class="token punctuation">:</span>        <span class="token keyword">while</span> bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">></span><span class="token number">0</span><span class="token punctuation">:</span>            arr<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span> <span class="token operator">=</span> j            sortedIndex<span class="token operator">+=</span><span class="token number">1</span>            bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">-=</span><span class="token number">1</span>    <span class="token keyword">return</span> arr</code></pre><h3 id="4-Go-代码实现-1"><a href="#4-Go-代码实现-1" class="headerlink" title="4. Go 代码实现"></a>4. Go 代码实现</h3><pre class=" language-go"><code class="language-go"><span class="token keyword">func</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>arr <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> maxValue <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span> <span class="token punctuation">{</span>    bucketLen <span class="token operator">:=</span> maxValue <span class="token operator">+</span> <span class="token number">1</span>    bucket <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">,</span> bucketLen<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 初始为0的数组</span>    sortedIndex <span class="token operator">:=</span> <span class="token number">0</span>    length <span class="token operator">:=</span> <span class="token function">len</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span>    <span class="token keyword">for</span> i <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> i<span class="token operator">++</span> <span class="token punctuation">{</span>        bucket<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> j <span class="token operator">:=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketLen<span class="token punctuation">;</span> j<span class="token operator">++</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>sortedIndex<span class="token punctuation">]</span> <span class="token operator">=</span> j            sortedIndex <span class="token operator">+=</span> <span class="token number">1</span>            bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">}</span></code></pre><h3 id="5-Java-代码实现-1"><a href="#5-Java-代码实现-1" class="headerlink" title="5. Java 代码实现"></a>5. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CountingSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">countingSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> bucketLen <span class="token operator">=</span> maxValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>bucketLen<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            bucket<span class="token punctuation">[</span>value<span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> sortedIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> bucketLen<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>sortedIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> j<span class="token punctuation">;</span>                bucket<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxValue <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="6-PHP-代码实现-1"><a href="#6-PHP-代码实现-1" class="headerlink" title="6. PHP 代码实现"></a>6. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$maxValue</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$maxValue</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$maxValue</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$m</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$m</span> <span class="token operator">&lt;</span> <span class="token variable">$maxValue</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$m</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$bucket</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$arrLen</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$arrLen</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">array_key_exists</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$bucket</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$bucket</span><span class="token punctuation">[</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$bucket</span><span class="token punctuation">[</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$sortedIndex</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">foreach</span> <span class="token punctuation">(</span><span class="token variable">$bucket</span> <span class="token keyword">as</span> <span class="token variable">$key</span> <span class="token operator">=</span><span class="token operator">></span> <span class="token variable">$len</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$len</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$sortedIndex</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$key</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="桶排序"><a href="#桶排序" class="headerlink" title="桶排序"></a>桶排序</h2><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li>在额外空间充足的情况下，尽量增大桶的数量</li><li>使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>同时，对于桶中元素的排序，选择何种比较排序算法对于性能的影响至关重要。</p><h3 id="1-什么时候最快"><a href="#1-什么时候最快" class="headerlink" title="1. 什么时候最快"></a>1. 什么时候最快</h3><p>当输入的数据可以均匀的分配到每一个桶中。</p><h3 id="2-什么时候最慢"><a href="#2-什么时候最慢" class="headerlink" title="2. 什么时候最慢"></a>2. 什么时候最慢</h3><p>当输入的数据被分配到了同一个桶中。</p><h3 id="3-JavaScript-代码实现-5"><a href="#3-JavaScript-代码实现-5" class="headerlink" title="3. JavaScript 代码实现"></a>3. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token keyword">function</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> bucketSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">var</span> i<span class="token punctuation">;</span>    <span class="token keyword">var</span> minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>          minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 输入数据的最小值</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">></span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>          maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 输入数据的最大值</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//桶的初始化</span>    <span class="token keyword">var</span> DEFAULT_BUCKET_SIZE <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 设置桶的默认数量为5</span>    bucketSize <span class="token operator">=</span> bucketSize <span class="token operator">||</span> DEFAULT_BUCKET_SIZE<span class="token punctuation">;</span>    <span class="token keyword">var</span> bucketCount <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Array</span><span class="token punctuation">(</span>bucketCount<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">//利用映射函数将数据分配到各个桶中</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        buckets<span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    arr<span class="token punctuation">.</span>length <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">insertionSort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token comment" spellcheck="true">// 对每个桶进行排序，这里使用了插入排序</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Java-代码实现"><a href="#4-Java-代码实现" class="headerlink" title="4. Java 代码实现"></a>4. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BucketSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> InsertSort insertSort <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InsertSort</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketSize<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> arr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                minValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>value <span class="token operator">></span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> bucketCount <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>maxValue <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>bucketCount<span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 利用映射函数将数据分配到各个桶中</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucketSize<span class="token punctuation">)</span><span class="token punctuation">;</span>            buckets<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">arrAppend</span><span class="token punctuation">(</span>buckets<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> arrIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">:</span> buckets<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>bucket<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 对每个桶进行排序，这里使用了插入排序</span>            bucket <span class="token operator">=</span> insertSort<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span>bucket<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>arrIndex<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自动扩容，并保存数据     *     * @param arr     * @param value     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">arrAppend</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-PHP-代码实现"><a href="#5-PHP-代码实现" class="headerlink" title="5. PHP 代码实现"></a>5. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$bucketSize</span> <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$minValue</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token variable">$maxValue</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">&lt;</span> <span class="token variable">$minValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token variable">$minValue</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">></span> <span class="token variable">$maxValue</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token variable">$maxValue</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token variable">$bucketCount</span> <span class="token operator">=</span> <span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$maxValue</span> <span class="token operator">-</span> <span class="token variable">$minValue</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token variable">$bucketSize</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token variable">$buckets</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$buckets</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$buckets</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$buckets</span><span class="token punctuation">[</span><span class="token function">floor</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token variable">$minValue</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token variable">$bucketSize</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$arr</span> <span class="token operator">=</span> <span class="token keyword">array</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$buckets</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$bucketTmp</span> <span class="token operator">=</span> <span class="token variable">$buckets</span><span class="token punctuation">[</span><span class="token variable">$i</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token function">sort</span><span class="token punctuation">(</span><span class="token variable">$bucketTmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$bucketTmp</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$bucketTmp</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h2><p>基数排序是一种非比较型整数排序算法，其原理是将整数按位数切割成不同的数字，然后按每个位数分别比较。由于整数也可以表达字符串（比如名字或日期）和特定格式的浮点数，所以基数排序也不是只能使用于整数。</p><h3 id="1-基数排序-vs-计数排序-vs-桶排序"><a href="#1-基数排序-vs-计数排序-vs-桶排序" class="headerlink" title="1. 基数排序 vs 计数排序 vs 桶排序"></a>1. 基数排序 vs 计数排序 vs 桶排序</h3><p>基数排序有两种方法：</p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>基数排序：根据键值的每位数字来分配桶；</li><li>计数排序：每个桶只存储单一键值；</li><li>桶排序：每个桶存储一定范围的数值；</li></ul><h3 id="2-LSD-基数排序动图演示"><a href="#2-LSD-基数排序动图演示" class="headerlink" title="2. LSD 基数排序动图演示"></a>2. LSD 基数排序动图演示</h3><p><img src="https://henleylee.github.io/medias/study/algorithm_sort_radix.gif" alt="基数排序算法"></p><h3 id="3-JavaScript-代码实现-6"><a href="#3-JavaScript-代码实现-6" class="headerlink" title="3. JavaScript 代码实现"></a>3. JavaScript 代码实现</h3><pre class=" language-js"><code class="language-js"><span class="token comment" spellcheck="true">//LSD Radix Sort</span><span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxDigit<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">var</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">var</span> dev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> dev <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">,</span> mod <span class="token operator">*</span><span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> bucket <span class="token operator">=</span> <span class="token function">parseInt</span><span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> dev<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">var</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> counter<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">var</span> value <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">if</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">!=</span><span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>value <span class="token operator">=</span> counter<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                      arr<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="4-Java-代码实现-1"><a href="#4-Java-代码实现-1" class="headerlink" title="4. Java 代码实现"></a>4. Java 代码实现</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 基数排序 * 考虑负数的情况还可以参考： https://code.i-harness.com/zh-CN/q/e98fa9 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RadixSort</span> <span class="token keyword">implements</span> <span class="token class-name">IArraySort</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sourceArray<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 对 arr 进行拷贝，不改变参数内容</span>        <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>sourceArray<span class="token punctuation">,</span> sourceArray<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> maxDigit <span class="token operator">=</span> <span class="token function">getMaxDigit</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">radixSort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> maxDigit<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 获取最高位数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getMaxDigit</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">getNumLenght</span><span class="token punctuation">(</span>maxValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">getMaxValue</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>maxValue <span class="token operator">&lt;</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>                maxValue <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> maxValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">protected</span> <span class="token keyword">int</span> <span class="token function">getNumLenght</span><span class="token punctuation">(</span><span class="token keyword">long</span> num<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>num <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> lenght <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">long</span> temp <span class="token operator">=</span> num<span class="token punctuation">;</span> temp <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span> temp <span class="token operator">/=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            lenght<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> lenght<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> maxDigit<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mod <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> dev <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> maxDigit<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">,</span> dev <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">,</span> mod <span class="token operator">*=</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 考虑负数的情况，这里扩展一倍队列数，其中 [0-9]对应负数，[10-19]对应正数 (bucket + 10)</span>            <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> counter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span>mod <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> bucket <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">%</span> mod<span class="token punctuation">)</span> <span class="token operator">/</span> dev<span class="token punctuation">)</span> <span class="token operator">+</span> mod<span class="token punctuation">;</span>                counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">arrayAppend</span><span class="token punctuation">(</span>counter<span class="token punctuation">[</span>bucket<span class="token punctuation">]</span><span class="token punctuation">,</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">int</span> pos <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bucket <span class="token operator">:</span> counter<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> value <span class="token operator">:</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    arr<span class="token punctuation">[</span>pos<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自动扩容，并保存数据     *     * @param arr     * @param value     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">arrayAppend</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        arr <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        arr<span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="5-PHP-代码实现-1"><a href="#5-PHP-代码实现-1" class="headerlink" title="5. PHP 代码实现"></a>5. PHP 代码实现</h3><pre class=" language-php"><code class="language-php"><span class="token keyword">function</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">,</span> <span class="token variable">$maxDigit</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$maxDigit</span> <span class="token operator">===</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token variable">$maxDigit</span> <span class="token operator">=</span> <span class="token function">max</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token variable">$counter</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$i</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$i</span> <span class="token operator">&lt;</span> <span class="token variable">$maxDigit</span><span class="token punctuation">;</span> <span class="token variable">$i</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">preg_match_all</span><span class="token punctuation">(</span><span class="token string">'/\d/'</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>string<span class="token punctuation">)</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token variable">$matches</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$numArr</span> <span class="token operator">=</span> <span class="token variable">$matches</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token variable">$lenTmp</span> <span class="token operator">=</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$numArr</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token variable">$bucket</span> <span class="token operator">=</span> <span class="token function">array_key_exists</span><span class="token punctuation">(</span><span class="token variable">$lenTmp</span> <span class="token operator">-</span> <span class="token variable">$i</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token variable">$numArr</span><span class="token punctuation">)</span>                <span class="token operator">?</span> <span class="token function">intval</span><span class="token punctuation">(</span><span class="token variable">$numArr</span><span class="token punctuation">[</span><span class="token variable">$lenTmp</span> <span class="token operator">-</span> <span class="token variable">$i</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                <span class="token punctuation">:</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">array_key_exists</span><span class="token punctuation">(</span><span class="token variable">$bucket</span><span class="token punctuation">,</span> <span class="token variable">$counter</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token variable">$counter</span><span class="token punctuation">[</span><span class="token variable">$bucket</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token variable">$counter</span><span class="token punctuation">[</span><span class="token variable">$bucket</span><span class="token punctuation">]</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token variable">$pos</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token variable">$j</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token variable">$j</span> <span class="token operator">&lt;</span> <span class="token function">count</span><span class="token punctuation">(</span><span class="token variable">$counter</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token variable">$j</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token variable">$value</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token variable">$counter</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token variable">$value</span> <span class="token operator">=</span> <span class="token function">array_shift</span><span class="token punctuation">(</span><span class="token variable">$counter</span><span class="token punctuation">[</span><span class="token variable">$j</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token variable">$pos</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token variable">$value</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>          <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token variable">$arr</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://github.com/hustcc/JS-Sorting-Algorithm" target="_blank" rel="noopener">十大经典排序算法</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Atomic 类之 AtomicInteger</title>
      <link href="/posts/2019/54a06e13.html"/>
      <url>/posts/2019/54a06e13.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>java.util.concurrent.atomic</code> 包下，有 <code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code> 等原子类，它们的基本特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>java.util.concurrent.atomic.AtomicInteger</code> 类提供了可以原子读取和写入的底层 <code>int</code> 值的操作，并且还包含高级原子操作。<code>AtomicInteger</code> 支持基础 <code>int</code> 变量上的原子操作，它还提供了原子自增方法、原子自减方法以及原子赋值方法等。其底层是通过 <code>volatile</code> 和 <code>CAS</code> 实现的，其中 <code>volatile</code> 保证了内存可见性，<code>CAS</code> 算法保证了原子性。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code> 是一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程。当把变量声明为 <code>volatile</code> 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。<code>volatile</code> 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 <code>volatile</code> 类型的变量时总返回最新写入的值。在访问 <code>volatile</code> 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 <code>volatile</code> 变量是一种比 <code>sychronized</code> 关键字更轻量级的同步机制。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><code>CAS(Compare And Swap)</code> 即比较并交换，<code>CAS</code> 是乐观锁技术，当多个线程尝试使用 <code>CAS</code> 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。它包含三个参数：内存值 V、预期值 A、要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。原理如下图所示：<br><img src="https://henleylee.github.io/medias/java/atomic_cas_process.png" alt="CAS乐观锁原理"></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>AtomicInteger</code> 类中常用的重要方法如下：</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>public boolean get()</code></td><td>返回当前值</td></tr><tr><td><code>public void set(boolean newValue)</code></td><td>无条件地设置为给定值</td></tr><tr><td><code>public void lazySet(boolean newValue)</code></td><td>最终设置为给定值</td></tr><tr><td><code>public boolean getAndSet(boolean newValue)</code></td><td>以原子方式设置为给定值并返回之前的值</td></tr><tr><td><code>public boolean compareAndSet(boolean expect, boolean update)</code></td><td>如果当前值<code>==</code>期望值，则以原子方式将值设置为给定的更新值</td></tr><tr><td><code>public boolean weakCompareAndSet(boolean expect, boolean update)</code></td><td>如果当前值<code>==</code>期望值，则以原子方式将值设置为给定的更新值</td></tr><tr><td><code>public int getAndIncrement()</code></td><td>以原子方式将当前值增加<code>1</code>并返回之前的值</td></tr><tr><td><code>public int getAndDecrement()</code></td><td>以原子方式将当前值减去<code>1</code>并返回之前的值</td></tr><tr><td><code>public int getAndAdd(int delta)</code></td><td>以原子方式将当前值增加<code>delta</code>并返回之前的值</td></tr><tr><td><code>public int incrementAndGet()</code></td><td>以原子方式将当前值增加<code>1</code>并返回更新的值</td></tr><tr><td><code>public int decrementAndGet()</code></td><td>以原子方式将当前值减去<code>1</code>并返回更新的值</td></tr><tr><td><code>public int addAndGet(int delta)</code></td><td>以原子方式将当前值增加<code>delta</code>并返回更新的值</td></tr><tr><td><code>public int getAndUpdate(IntUnaryOperator function)</code></td><td>使用给定函数的结果以原子方式更新当前值并返回之前的值</td></tr><tr><td><code>public int updateAndGet(IntUnaryOperator function)</code></td><td>使用给定函数的结果以原子方式更新当前值并返回更新的值</td></tr><tr><td><code>public int getAndAccumulate(int x, IntBinaryOperator function)</code></td><td>使用给定函数得到当前值和给定值的结果以原子方式更新当前值并返回之前的值</td></tr><tr><td><code>public int accumulateAndGet(int x, IntBinaryOperator function)</code></td><td>使用给定函数得到当前值和给定值的结果以原子方式更新当前值并返回更新的值</td></tr><tr><td><code>public int intValue()</code></td><td>返回当前值的 <code>int</code> 表示形式</td></tr><tr><td><code>public int longValue()</code></td><td>返回当前值的 <code>long</code> 表示形式</td></tr><tr><td><code>public int floatValue()</code></td><td>返回当前值的 <code>float</code> 表示形式</td></tr><tr><td><code>public int doubleValue()</code></td><td>返回当前值的 <code>double</code> 表示形式</td></tr><tr><td><code>public String toString()</code></td><td>返回当前值的 <code>String</code> 表示形式</td></tr></tbody></table><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>AtomicInteger</code> 类保证了一系列的操作都是原子操作，不会受到多线程环境下的并发不安全问题，原理则是依赖神奇的 <code>sun.misc.Unsafe</code> 支持。下面简单分析一下 <code>AtomicInteger</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicInteger</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span> <span class="token keyword">implements</span> <span class="token class-name">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span>Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6214790243416807050L<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用指针类Unsafe</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 变量value的内存偏移量</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// volatile修饰的变量value</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>AtomicInteger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ReflectiveOperationException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造方法(使用初始值0创建一个新的AtomicInteger)     */</span>    <span class="token keyword">public</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造方法(使用给定的初始值创建新的AtomicInteger)     *     * @param initialValue 初始值     */</span>    <span class="token keyword">public</span> <span class="token function">AtomicInteger</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> initialValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回当前值     *     * @return 当前值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 无条件地设置为给定值     *     * @param newValue 新值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 最终设置为给定值     *     * @param newValue 新值     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unsafe<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式设置为给定值并返回之前的值     *     * @param newValue 新值     * @return 之前的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndSetInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果当前值==期望值，则以原子方式将值设置为给定的更新值     *     * @param expect 期望值     * @param update 新值     * @return 如果成功，则返回true；实际值不等于预期值则返回 false     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果当前值==期望值，则以原子方式将值设置为给定的更新值     *     * &lt;p>     * 可能意外失败并且不提供排序保证，因此几乎只是compareAndSet()方法的适当替代方法。     *     * @param expect 期望值     * @param update 新值     * @return 如果成功，则返回true     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">weakCompareAndSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> expect<span class="token punctuation">,</span> <span class="token keyword">int</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> expect<span class="token punctuation">,</span> update<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式将当前值增加1并返回之前的值     *     * @return 之前的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndIncrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式将当前值减去1并返回之前的值     *     * @return 之前的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndDecrement</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式将当前值增加给定值并返回之前的值     *     * @param delta 增加的值     * @return 之前的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式将当前值增加1并返回更新的值     *     * @return 更新的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式将当前值减去1并返回更新的值     *     * @return 更新的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">decrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式将当前值增加给定值并返回更新的值     *     * @param delta 增加的值     * @return 更新的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">addAndGet</span><span class="token punctuation">(</span><span class="token keyword">int</span> delta<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">getAndAddInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> delta<span class="token punctuation">)</span> <span class="token operator">+</span> delta<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用给定函数的结果以原子方式更新当前值并返回之前的值     *     * @param updateFunction 给定函数     * @return 之前的值     * @since 1.8     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndUpdate</span><span class="token punctuation">(</span>IntUnaryOperator updateFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            next <span class="token operator">=</span> updateFunction<span class="token punctuation">.</span><span class="token function">applyAsInt</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用给定函数的结果以原子方式更新当前值并返回更新的值     *     * @param updateFunction 给定函数     * @return 更新的值     * @since 1.8     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">updateAndGet</span><span class="token punctuation">(</span>IntUnaryOperator updateFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            next <span class="token operator">=</span> updateFunction<span class="token punctuation">.</span><span class="token function">applyAsInt</span><span class="token punctuation">(</span>prev<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用给定函数得到当前值和给定值的结果以原子方式更新当前值并返回之前的值     *     * @param x                   更新的值     * @param accumulatorFunction 给定函数     * @return 之前的值     * @since 1.8     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">getAndAccumulate</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> IntBinaryOperator accumulatorFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            next <span class="token operator">=</span> accumulatorFunction<span class="token punctuation">.</span><span class="token function">applyAsInt</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 使用给定函数得到当前值和给定值的结果以原子方式更新当前值并返回更新的值     *     * @param x                   更新的值     * @param accumulatorFunction 给定函数     * @return 更新的值     * @since 1.8     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">accumulateAndGet</span><span class="token punctuation">(</span><span class="token keyword">int</span> x<span class="token punctuation">,</span> IntBinaryOperator accumulatorFunction<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> prev<span class="token punctuation">,</span> next<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            next <span class="token operator">=</span> accumulatorFunction<span class="token punctuation">.</span><span class="token function">applyAsInt</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns the value of this {@code AtomicInteger} as an {@code int}.     * Equivalent to {@link #get()}.     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">intValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回当前值的long表示形式     *     * @return 当前值的long表示形式     */</span>    <span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">longValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回当前值的float表示形式     *     * @return 当前值的float表示形式     */</span>    <span class="token keyword">public</span> <span class="token keyword">float</span> <span class="token function">floatValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回当前值的double表示形式     *     * @return 当前值的double表示形式     */</span>    <span class="token keyword">public</span> <span class="token keyword">double</span> <span class="token function">doubleValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">double</span><span class="token punctuation">)</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回当前值的String表示形式     *     * @return 当前值的String表示形式     */</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Integer<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 <code>java.util.concurrent.atomic</code> 包下的原子类，最大的好处就是可以避免多线程的优先级倒置和死锁情况的发生，提升在高并发处理下的性能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java Atomic 类之 AtomicBoolean</title>
      <link href="/posts/2019/842a4d70.html"/>
      <url>/posts/2019/842a4d70.html</url>
      
        <content type="html"><![CDATA[<p>在 <code>java.util.concurrent.atomic</code> 包下，有 <code>AtomicBoolean</code>、<code>AtomicInteger</code>、<code>AtomicLong</code>、<code>AtomicReference</code> 等原子类，它们的基本特性就是在多线程环境下，当有多个线程同时执行这些类的实例包含的方法时，具有排他性，即当某个线程进入方法，执行其中的指令时，不会被其他线程打断，而别的线程就像自旋锁一样，一直等到该方法执行完成，才由 JVM 从等待队列中选择一个另一个线程进入，这只是一种逻辑上的理解。实际上是借助硬件的相关指令来实现的，不会阻塞线程(或者说只是在硬件级别上阻塞了)。</p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p><code>java.util.concurrent.atomic.AtomicBoolean</code> 类提供了可以原子读取和写入的底层 <code>boolean</code> 的操作，并且还包含高级原子操作。<code>AtomicBoolean</code> 支持基础 <code>boolean</code> 变量上的原子操作。其底层是通过 <code>volatile</code> 和 <code>CAS</code> 实现的，其中 <code>volatile</code> 保证了内存可见性，<code>CAS</code> 算法保证了原子性。</p><h3 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h3><p><code>volatile</code> 是一种稍弱的同步机制，用来确保将变量的更新操作通知到其他线程。当把变量声明为 <code>volatile</code> 类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。<code>volatile</code> 变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取 <code>volatile</code> 类型的变量时总返回最新写入的值。在访问 <code>volatile</code> 变量时不会执行加锁操作，因此也就不会使执行线程阻塞，因此 <code>volatile</code> 变量是一种比 <code>sychronized</code> 关键字更轻量级的同步机制。</p><h3 id="CAS"><a href="#CAS" class="headerlink" title="CAS"></a>CAS</h3><p><code>CAS(Compare And Swap)</code> 即比较并交换，<code>CAS</code> 是乐观锁技术，当多个线程尝试使用 <code>CAS</code> 同时更新同一个变量时，只有其中一个线程能更新变量的值，而其它线程都失败，失败的线程并不会被挂起，而是被告知这次竞争中失败，并可以再次尝试。它包含三个参数：内存值 V、预期值 A、要修改的新值 B。当且仅当预期值 A 和内存值 V 相同时，将内存值 V 修改为 B，否则什么都不做。原理如下图所示：<br><img src="https://henleylee.github.io/medias/java/atomic_cas_process.png" alt="CAS乐观锁原理"></p><h2 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h2><p><code>AtomicBoolean</code> 类中常用的重要方法如下：</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>public boolean get()</code></td><td>返回当前值</td></tr><tr><td><code>public void set(boolean newValue)</code></td><td>无条件地设置为给定值</td></tr><tr><td><code>public void lazySet(boolean newValue)</code></td><td>最终设置为给定值</td></tr><tr><td><code>public boolean getAndSet(boolean newValue)</code></td><td>以原子方式设置为给定值并返回之前的值</td></tr><tr><td><code>public boolean compareAndSet(boolean expect, boolean update)</code></td><td>如果当前值<code>==</code>期望值，则以原子方式将值设置为给定的更新值</td></tr><tr><td><code>public boolean weakCompareAndSet(boolean expect, boolean update)</code></td><td>如果当前值<code>==</code>期望值，则以原子方式将值设置为给定的更新值</td></tr><tr><td><code>public String toString()</code></td><td>返回当前值的 <code>String</code> 表示形式</td></tr></tbody></table><h2 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h2><p><code>AtomicBoolean</code> 类保证了一系列的操作都是原子操作，不会受到多线程环境下的并发不安全问题，原理则是依赖神奇的 <code>sun.misc.Unsafe</code> 支持。下面简单分析一下 <code>AtomicBoolean</code> 的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AtomicBoolean</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 4654671469794556979L<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Unsafe unsafe <span class="token operator">=</span> Unsafe<span class="token punctuation">.</span><span class="token function">getUnsafe</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用指针类Unsafe</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> valueOffset<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 变量value的内存偏移量</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// volatile修饰的变量value</span>    <span class="token keyword">static</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            valueOffset <span class="token operator">=</span> unsafe<span class="token punctuation">.</span><span class="token function">objectFieldOffset</span><span class="token punctuation">(</span>AtomicBoolean<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"value"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造方法(使用初始值false创建一个新的AtomicBoolean)     */</span>    <span class="token keyword">public</span> <span class="token function">AtomicBoolean</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 构造方法(使用给定的初始值创建新的AtomicBoolean)     *     * @param initialValue 初始值     */</span>    <span class="token keyword">public</span> <span class="token function">AtomicBoolean</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> initialValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> initialValue <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回当前值     *     * @return 当前值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 无条件地设置为给定值     *     * @param newValue 新值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> newValue <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 最终设置为给定值     *     * @param newValue 新值     * @since 1.6     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">lazySet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        unsafe<span class="token punctuation">.</span><span class="token function">putOrderedInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span> <span class="token punctuation">(</span>newValue <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 以原子方式设置为给定值并返回之前的值     *     * @param newValue 新值     * @return 之前的值     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">getAndSet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> prev<span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">compareAndSet</span><span class="token punctuation">(</span>prev<span class="token punctuation">,</span> newValue<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> prev<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果当前值==期望值，则以原子方式将值设置为给定的更新值     *     * @param expect 期望值     * @param update 新值     * @return 如果成功，则返回true；实际值不等于预期值则返回 false     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">compareAndSet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> expect<span class="token punctuation">,</span> <span class="token keyword">boolean</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span>                <span class="token punctuation">(</span>expect <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>update <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 如果当前值==期望值，则以原子方式将值设置为给定的更新值     *     * &lt;p>     * 可能意外失败并且不提供排序保证，因此几乎只是compareAndSet()方法的适当替代方法。     *     * @param expect 期望值     * @param update 新值     * @return 如果成功，则返回true     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">weakCompareAndSet</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> expect<span class="token punctuation">,</span> <span class="token keyword">boolean</span> update<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> unsafe<span class="token punctuation">.</span><span class="token function">compareAndSwapInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> valueOffset<span class="token punctuation">,</span>                <span class="token punctuation">(</span>expect <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token punctuation">(</span>update <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 返回当前值的String表示形式     *     * @return 当前值的String表示形式     */</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Boolean<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>使用 <code>java.util.concurrent.atomic</code> 包下的原子类，最大的好处就是可以避免多线程的优先级倒置和死锁情况的发生，提升在高并发处理下的性能。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 刘海屏适配指南</title>
      <link href="/posts/2019/430c6e50.html"/>
      <url>/posts/2019/430c6e50.html</url>
      
        <content type="html"><![CDATA[<p>Apple 一直在引领设计的潮流，自从 iPhone X 发布之后，“刘海屏”就一直存在争议，本以为是一个美丽的错误，却造就了一时间“刘海屏”的模仿潮。目前，国内已经推出的刘海屏”手机有 OPPO R15 和 华为 P20，并且 Google 也在 I/O 大会上提高了相应的适配方案。</p><p>刘海屏指的是手机屏幕正上方由于追求极致边框而采用的一种手机解决方案，因形似刘海儿而得名。也有一些其他叫法：挖孔屏、凹口屏等，这里统一按刘海屏命名。就现在市场上的情况来说，“刘海屏”主要分成两类，一类是标准的 Android P API，另外一类就是厂商在 Android P 以下的系统，做的特殊适配。</p><h2 id="适配方案"><a href="#适配方案" class="headerlink" title="适配方案"></a>适配方案</h2><p>对于增加了刘海屏的手机屏幕，大部分都是“切割”的区域都位于状态栏，所以就面临了三种情况。</p><ol><li>对于有状态栏的页面，不会受到刘海屏特性的影响，因为刘海屏包含在状态栏中了；</li><li>全屏显示的页面，系统刘海屏方案会对应用界面做下移处理，避开刘海区显示，这时会看到刘海区域变成一条黑边，完全看不到刘海了；</li><li>已经适配 Android P 应用的全屏页面可以通过谷歌提供的适配方案使用刘海区，真正做到全屏显示。</li></ol><h2 id="标准-API"><a href="#标准-API" class="headerlink" title="标准 API"></a>标准 API</h2><p>Android P 支持最新的全面屏以及为摄像头和扬声器预留空间的凹口屏幕。 通过全新的 DisplayCutout 类，可以确定非功能区域的位置和形状，这些区域不应显示内容。 要确定这些凹口屏幕区域是否存在及其位置，请使用 getDisplayCutout() 函数。</p><h3 id="DisplayCutout-类"><a href="#DisplayCutout-类" class="headerlink" title="DisplayCutout 类"></a>DisplayCutout 类</h3><p><code>android.view.DisplayCutout</code> 类主要用于获取凹口位置和安全区域的位置等。主要方法如下所示：</p><table><thead><tr><th>方法</th><th>功能描述</th></tr></thead><tbody><tr><td><code>getBoundingRects()</code></td><td>返回 Rects 的列表，每个 Rects 都是显示屏上非功能区域的边界矩形</td></tr><tr><td><code>getSafeInsetLeft()</code></td><td>返回安全区域距离屏幕左边的距离(单位：px)</td></tr><tr><td><code>getSafeInsetRight()</code></td><td>返回安全区域距离屏幕右边的距离(单位：px)</td></tr><tr><td><code>getSafeInsetTop()</code></td><td>返回安全区域距离屏幕顶部的距离(单位：px)</td></tr><tr><td><code>getSafeInsetBottom()</code></td><td>返回安全区域距离屏幕底部的距离(单位：px)</td></tr></tbody></table><h3 id="凹口屏幕显示模式"><a href="#凹口屏幕显示模式" class="headerlink" title="凹口屏幕显示模式"></a>凹口屏幕显示模式</h3><p>Android P 中新增了一个布局参数属性 layoutInDisplayCutoutMode，包含了三种不同的模式，如下所示：</p><table><thead><tr><th>模式</th><th>模式说明</th></tr></thead><tbody><tr><td><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_DEFAULT</code></td><td>只有当 DisplayCutout 完全包含在系统栏中时，才允许窗口延伸到 DisplayCutout 区域。否则，窗口布局不与 DisplayCutout 区域重叠。</td></tr><tr><td><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER</code></td><td>该窗口决不允许与 DisplayCutout 区域重叠。</td></tr><tr><td><code>LAYOUT_IN_DISPLAY_CUTOUT_MODE_SHORT_EDGES</code></td><td>该窗口始终允许延伸到屏幕短边上的 DisplayCutout 区域。</td></tr></tbody></table><p>可以通过以下代码设置凹口屏幕显示模式：</p><pre class=" language-java"><code class="language-java">WindowManager<span class="token punctuation">.</span>LayoutParams layoutParams <span class="token operator">=</span> <span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getAttributes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>layoutParams<span class="token punctuation">.</span>layoutInDisplayCutoutMode <span class="token operator">=</span> WindowManager<span class="token punctuation">.</span>LayoutParams<span class="token punctuation">.</span>LAYOUT_IN_DISPLAY_CUTOUT_MODE_NEVER<span class="token punctuation">;</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setAttributes</span><span class="token punctuation">(</span>layoutParams<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="非标准-API"><a href="#非标准-API" class="headerlink" title="非标准 API"></a>非标准 API</h2><p>在 Android P 之前，没有标准 API。然而国产各大厂商在 Android P 之前(基本都是Android O)就用上了高档大气上档次的刘海屏，所以，这也造就了各大厂商在 Android P 之前的解决方案百花齐放。下面，我们来看下主流厂商：华为、vivo、OPPO、小米等所提供的方案。</p><h3 id="华为"><a href="#华为" class="headerlink" title="华为"></a>华为</h3><h4 id="使用刘海区显示"><a href="#使用刘海区显示" class="headerlink" title="使用刘海区显示"></a>使用刘海区显示</h4><p>使用新增的 <code>meta-data</code> 属性 <code>android.notch_support</code>，在应用的 <code>AndroidManifest.xml</code> 中增加 <code>meta-data</code> 属性，此属性不仅可以针对 <code>Application</code> 生效，也可以对 <code>Activity</code> 配置生效。具体方式如下所示：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.notch_support<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p><code>android.notch_support</code> 属性不仅可以针对 <code>Application</code> 生效，也可以对 <code>Activity</code> 配置生效：</p><ul><li><strong><code>对 Application 生效</code></strong>意味着该应用的所有页面，系统都不会做竖屏场景的特殊下移或者是横屏场景的右移特殊处理。</li><li><strong><code>对 Activity 生效</code></strong>意味着可以针对单个页面进行刘海屏适配，设置了该属性的 <code>Activity</code> 系统将不会做特殊处理。</li></ul><h4 id="判断是否刘海屏"><a href="#判断是否刘海屏" class="headerlink" title="判断是否刘海屏"></a>判断是否刘海屏</h4><p>通过以下代码即可知道华为手机是否是刘海屏手机，返回 true 表示是刘海屏，返回 false 表示非刘海屏：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNotchInScreenForEMUI</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> ret <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ClassLoader cl <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">HwNotchSizeUtil</span> <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.huawei.android.util.HwNotchSizeUtil"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method get <span class="token operator">=</span> HwNotchSizeUtil<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"hasNotchInScreen"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span> get<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>HwNotchSizeUtil<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchInScreen ClassNotFoundException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchInScreen NoSuchMethodException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchInScreen Exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="获取刘海尺寸"><a href="#获取刘海尺寸" class="headerlink" title="获取刘海尺寸"></a>获取刘海尺寸</h4><p>通过以下代码即可获取华为手机的刘海尺寸：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getNotchSizeForEMUI</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> ret <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ClassLoader cl <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">HwNotchSizeUtil</span> <span class="token operator">=</span> cl<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"com.huawei.android.util.HwNotchSizeUtil"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method get <span class="token operator">=</span> HwNotchSizeUtil<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getNotchSize"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> get<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>HwNotchSizeUtil<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"getNotchSize ClassNotFoundException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"getNotchSize NoSuchMethodException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"getNotchSize Exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="小米"><a href="#小米" class="headerlink" title="小米"></a>小米</h3><h4 id="使用刘海区显示-1"><a href="#使用刘海区显示-1" class="headerlink" title="使用刘海区显示"></a>使用刘海区显示</h4><p>使用新增的 <code>meta-data</code> 属性 <code>notch.config</code>，在应用的 <code>AndroidManifest.xml</code> 中增加 <code>meta-data</code> 属性，此属性可以针对 <code>Application</code> 生效。具体方式如下所示：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>notch.config<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>portrait|landscape<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>value 的取值可以是以下4种：</p><ul><li><code>none：</code>横竖屏都不绘制耳朵区</li><li><code>portrait：</code>竖屏绘制到耳朵区</li><li><code>landscape：</code>横屏绘制到耳朵区</li><li><code>portrait|landscape：</code>横竖屏都绘制到耳朵区</li></ul><p>注：一旦开发者声明了 <code>meta-data</code>，系统就会优先遵从开发者的声明。</p><h4 id="判断是否刘海屏-1"><a href="#判断是否刘海屏-1" class="headerlink" title="判断是否刘海屏"></a>判断是否刘海屏</h4><p>小米手机系统增加了 property <code>ro.miui.notch</code>，值为 <code>1</code> 时则是 Notch 屏手机。</p><pre class=" language-java"><code class="language-java">SystemProperties<span class="token punctuation">.</span><span class="token function">getInt</span><span class="token punctuation">(</span><span class="token string">"ro.miui.notch"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span></code></pre><p><code>SystemProperties</code> 是系统隐藏 API，所以可以通过以下代码即可知道小米手机是否是刘海屏手机，返回 true 表示是刘海屏，返回 false 表示非刘海屏：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNotchInScreenForMIUI</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> notch <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@SuppressLint</span><span class="token punctuation">(</span><span class="token string">"PrivateApi"</span><span class="token punctuation">)</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clz <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"android.os.SystemProperties"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method get <span class="token operator">=</span> clz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"getInt"</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        notch <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> get<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>clz<span class="token punctuation">,</span> <span class="token string">"ro.miui.notch"</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchInScreen ClassNotFoundException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchInScreen NoSuchMethodException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IllegalAccessException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchInScreen IllegalAccessException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InvocationTargetException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchInScreen InvocationTargetException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> notch <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="获取刘海尺寸-1"><a href="#获取刘海尺寸-1" class="headerlink" title="获取刘海尺寸"></a>获取刘海尺寸</h4><p>MIUI 10 新增了获取刘海宽和高的方法，需升级至 8.6.26 开发版及以上版本。</p><p>以下是获取当前设备刘海高度的方法:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getNotchHeightForMIUI</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> resourceId <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getIdentifier</span><span class="token punctuation">(</span><span class="token string">"notch_height"</span><span class="token punctuation">,</span> <span class="token string">"dimen"</span><span class="token punctuation">,</span> <span class="token string">"android"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resourceId <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDimensionPixelSize</span><span class="token punctuation">(</span>resourceId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>以下是获取当前设备刘海宽度的方法:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getNotchWidthForMIUI</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> resourceId <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getIdentifier</span><span class="token punctuation">(</span><span class="token string">"notch_width"</span><span class="token punctuation">,</span> <span class="token string">"dimen"</span><span class="token punctuation">,</span> <span class="token string">"android"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>resourceId <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getDimensionPixelSize</span><span class="token punctuation">(</span>resourceId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="OPPO"><a href="#OPPO" class="headerlink" title="OPPO"></a>OPPO</h3><h4 id="判断是否刘海屏-2"><a href="#判断是否刘海屏-2" class="headerlink" title="判断是否刘海屏"></a>判断是否刘海屏</h4><p>通过以下代码即可知道 OPPO 手机是否是刘海屏手机，返回 true 表示是刘海屏，返回 false 表示非刘海屏：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNotchInScreenForOPPO</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasSystemFeature</span><span class="token punctuation">(</span><span class="token string">"com.oppo.feature.screen.heteromorphism"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="获取刘海尺寸-2"><a href="#获取刘海尺寸-2" class="headerlink" title="获取刘海尺寸"></a>获取刘海尺寸</h4><p>OPPO 手机目前不提供接口获取刘海尺寸，目前其有刘海屏的机型尺寸规格都是统一的。不排除以后机型会有变化。其显示屏宽度为 1080px，高度为 2280px。刘海区域则都是宽度为 324px, 高度为 80px。</p><h3 id="VIVO"><a href="#VIVO" class="headerlink" title="VIVO"></a>VIVO</h3><h4 id="判断是否刘海屏-3"><a href="#判断是否刘海屏-3" class="headerlink" title="判断是否刘海屏"></a>判断是否刘海屏</h4><p>通过以下代码即可知道华为手机是否是刘海屏手机，返回 true 表示是刘海屏，返回 false 表示非刘海屏：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> VIVO_NOTCH  <span class="token operator">=</span> <span class="token number">0x00000020</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 是否有刘海</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> VIVO_FILLET <span class="token operator">=</span> <span class="token number">0x00000008</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 是否有圆角</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNotchForVOIO</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> ret <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        ClassLoader classLoader <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">FtFeature</span> <span class="token operator">=</span> classLoader<span class="token punctuation">.</span><span class="token function">loadClass</span><span class="token punctuation">(</span><span class="token string">"android.util.FtFeature"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method method <span class="token operator">=</span> FtFeature<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"isFeatureSupport"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ret <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">boolean</span><span class="token punctuation">)</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>FtFeature<span class="token punctuation">,</span> VIVO_NOTCH<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ClassNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"Notch"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchAtVoio ClassNotFoundException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchMethodException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"Notch"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchAtVoio NoSuchMethodException"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Log<span class="token punctuation">.</span><span class="token function">e</span><span class="token punctuation">(</span><span class="token string">"Notch"</span><span class="token punctuation">,</span> <span class="token string">"hasNotchAtVoio Exception"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> ret<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="获取刘海尺寸-3"><a href="#获取刘海尺寸-3" class="headerlink" title="获取刘海尺寸"></a>获取刘海尺寸</h4><p>VIVO 手机目前不提供接口获取刘海尺寸，目前其有刘海屏的机型尺寸规格都是统一的。不排除以后机型会有变化。刘海区域则都是宽度为 100dp, 高度为 27dp。</p><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.android.com/guide/topics/display-cutout/" target="_blank" rel="noopener">Google 官方文档</a><br><a href="https://devcenter.huawei.com/consumer/cn/devservice/doc/50114" target="_blank" rel="noopener">华为刘海屏手机安卓O版本适配指导</a><br><a href="https://dev.mi.com/console/doc/detail?pId=1293" target="_blank" rel="noopener">小米刘海屏水滴屏 Android O 适配</a><br><a href="https://open.oppomobile.com/wiki/doc#id=10159" target="_blank" rel="noopener">OPPO 凹形屏适配说明</a><br><a href="https://dev.vivo.com.cn/documentCenter/doc/103" target="_blank" rel="noopener">VIVO 异形屏应用适配指南</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 全面屏适配指南</title>
      <link href="/posts/2019/62291f67.html"/>
      <url>/posts/2019/62291f67.html</url>
      
        <content type="html"><![CDATA[<p>全面屏是手机业界对于超高屏占比手机设计的一个宽泛的定义。从字面上解释就是，手机的正面全部都是屏幕，四个边框位置都是采用无边框设计，追求接近 100% 的屏占比。但受限于目前的技术，还不能做到手机正面屏占比 100% 的手机。现在业内所说的全面屏手机是指真实屏占比可以达到 80% 以上，拥有超窄边框设计的手机。</p><p>全面屏手机屏幕的宽高比例比较特殊，不再是以前的 <code>16:9</code> 了。比如三星的 Galaxy S8 屏幕分辨率是：2960×1440，对应的屏幕比例为 18.5:9。VIVO X20 手机屏幕分辨率是 2160x1080，对应的屏幕比例为 18:9。对于这种奇葩的屏幕比例，Android 开发者该如何去优化自己的应用，才能在这些手机上显示的更加完美呢？下面，从以下方面来探究 APP 完美适配全面屏手机的方法。</p><h2 id="声明最大屏幕高宽比"><a href="#声明最大屏幕高宽比" class="headerlink" title="声明最大屏幕高宽比"></a>声明最大屏幕高宽比</h2><p>由于全面屏手机的高宽比比之前大，如果不适配的话，Android 默认为最大的宽高比是 1.86，小于全面屏手机的宽高比，因此，在全面屏手机上打开部分 APP 时，上下就会留有空间，显示为黑条。这样非常影响视觉体验，另外全面屏提供的额外空间也没有得以利用，因此，这样的应用需要做相关适配。</p><p>在 <code>Android 7.0(API level 24)</code>及更高版本中 Google 默认支持了多窗口模式，即 <code>Manifest</code> 文件中配置 <code>Activity</code> 的 <code>android:resizeableActivity</code> 默认属性为 <code>true</code>，在这种情况下并不需要配置 android:MaxAspectRatio 即可自动适配全面屏，还可以为整个应用或特定 Activity 明确设置 <code>android:resizeableActivity=&quot;true&quot;</code> 属性。</p><p>如果不希望自己的应用或 <code>Activity</code> 在多窗口模式下运行，请设置 <code>android:resizeableActivity=&quot;false&quot;</code>。在这种情况下，应用会始终全屏显示。系统会根据 Android 操作系统级别控制完成此操作的方式：</p><ul><li>如果您的应用定位到 Android 8.0(API level 26)及更高版本，它会根据其布局填充整个屏幕。</li><li>如果您的应用定位到 Android 7.1(API level 25)及更低版本，则系统会将应用界面的大小限制为长宽比为 16:9(约为 1.86)的窗口。 如果应用在具有较大屏幕长宽比的设备上运行，则该应用会在带黑边的 16:9 窗口中显示，从而使部分屏幕处于未占用状态。</li></ul><p>对于这种情况就需要考虑适配了，目前有以下两种解决方案：</p><ul><li><p>设置最大长宽比：</p><ul><li>Android 8.0(API level 26)及更高版本设置最大长宽比，可以在 <code>&lt;activity&gt;</code> 标签中使用 <code>android:maxAspectRatio</code> 声明最大比例。声明 <code>2.4</code> 的最大长宽比的示例代码如下所示：<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --></span><span class="token comment" spellcheck="true">&lt;!-- Use a letterbox on screens larger than 2.4 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>maxAspectRatio</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.4<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">></span></span></code></pre></li><li>Android 7.1(API level 25)及更低版本设置最大长宽比，可以在 请在 <code>&lt;application&gt;</code> 标签中添加一个名为 <code>android.max_aspect</code> 的 <code>&lt;meta-data&gt;</code> 元素，如下所示：<pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!-- Render on full screen up to screen aspect ratio of 2.4 --></span><span class="token comment" spellcheck="true">&lt;!-- Use a letterbox on screens larger than 2.4 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta-data</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.max_aspect<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>value</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>2.4<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre></li></ul><blockquote><p>如果设置了最大长宽比，请勿忘记同时设置 <code>android:resizeableActivity=&quot;false&quot;</code>。否则，最大长宽比没有任何作用。</p></blockquote></li><li><p>设置支持多窗口模式：<br>在 <code>Android 7.0(API level 24)</code>及更高版本中 Google 默认支持了多窗口模式，即 <code>Manifest</code> 文件中配置 <code>Activity</code> 的 <code>android:resizeableActivity</code> 默认属性为 <code>true</code>。</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>application</span> <span class="token attr-name"><span class="token namespace">android:</span>allowBackup</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>icon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@mipmap/ic_launcher<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>label</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/app_name<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>roundIcon</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@mipmap/ic_launcher_round<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>supportsRtl</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@style/AppTheme<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>resizeableActivity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>.MainActivity<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.category.LAUNCHER<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>application</span><span class="token punctuation">></span></span></code></pre></li></ul><h2 id="UI-适配"><a href="#UI-适配" class="headerlink" title="UI 适配"></a>UI 适配</h2><p>通过增加上面适配方案提到的配置，应用在全面屏手机上就能够默认全屏显示了，但是为了避免出现 UI 异常的问题，还是需要应用自己做一些额外的 UI 适配工作：</p><ol><li>对于列表形式的应用，如：微信、网易新闻等，只是显示的内容变多，基本无影响。</li><li>对于整屏的应用，应用为了保证多种屏幕的适配，需遵循 Google 的适配建议，可以参考 <a href="https://developer.android.com/guide/practices/screens_support.html" target="_blank" rel="noopener">Google 官网</a>中的最佳做法章节进行适配。</li><li>对于使用整幅图片作为背景时需注意图片的填充方式，否则可能会无法填充整个屏幕。如：使用背景是用 ImageView 建议将其 scaleType 设置为 CENTER_CROP 或者使用 .9.png 图片。</li></ol><h2 id="虚拟导航键优化"><a href="#虚拟导航键优化" class="headerlink" title="虚拟导航键优化"></a>虚拟导航键优化</h2><p>为了实现更高的屏占比，屏幕内的虚拟导航键就成了标准功能，如何让其应用界面在视觉上统一，同样需要开发者的积极适配。Android 已经有相关接口允许开发者自定义虚拟键的样式。关于使用哪种样式，有以下建议:</p><ol><li>如果页面含有复杂背景/纹理，建议设置为透明。</li><li>含底部 Tab 栏的页面，建议将虚拟键设置为底部 Tab 栏的颜色。</li><li>不含底部 Tab 栏的页面，建议使用背景颜色。</li></ol><blockquote><p>由于一个应用内含有多种不同的页面，希望开发者能当前页面的情况，来选择合适的虚拟键样式，以保证视觉的统一美观。</p></blockquote><p>Android 有标准的实现方式，调用 <a href="https://developer.android.com/reference/android/view/Window.html#setNavigationBarColor(int)" target="_blank" rel="noopener">window.setNavigationBarColor(int color)</a> 方法即可。在调用该接口时，还需要设置一些 <code>flag</code>，详见该接口的注释说明：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Sets the color of the navigation bar to {@param color}. * * For this to take effect, * the window must be drawing the system bar backgrounds with * {@link android.view.WindowManager.LayoutParams#FLAG_DRAWS_SYSTEM_BAR_BACKGROUNDS} and * {@link android.view.WindowManager.LayoutParams#FLAG_TRANSLUCENT_NAVIGATION} must not be set. * * If {@param color} is not opaque, consider setting * {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_STABLE} and * {@link android.view.View#SYSTEM_UI_FLAG_LAYOUT_HIDE_NAVIGATION}. * &lt;p> * The transitionName for the view background will be "android:navigation:background". * &lt;/p> * @attr ref android.R.styleable#Window_navigationBarColor */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">setNavigationBarColor</span><span class="token punctuation">(</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">int</span> color<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>除了调用上述方法外，还可以通过在主题中添加 <a href="https://developer.android.com/reference/android/view/Window.html#attr_android:navigationBarColor" target="_blank" rel="noopener">android:navigationBarColor</a> 属性来实现：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AppTheme<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Theme.AppCompat.Light.NoActionBar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    &lt;item name=<span class="token string">"colorPrimary"</span>>@color/colorPrimary&lt;/item>    &lt;item name=<span class="token string">"colorPrimaryDark"</span>>@color/colorPrimaryDark&lt;/item>    &lt;item name=<span class="token string">"colorAccent"</span>>@color/colorAccent&lt;/item>    &lt;item name=<span class="token string">"android:navigationBarColor"</span>>@color/navigationBarColor&lt;/item></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><h2 id="参考文档"><a href="#参考文档" class="headerlink" title="参考文档"></a>参考文档</h2><p><a href="https://developer.android.com/guide/practices/screens-distribution" target="_blank" rel="noopener">Google 官方文档</a><br><a href="https://dev.mi.com/console/doc/detail?pId=1160" target="_blank" rel="noopener">小米全面屏适配说明</a><br><a href="https://developer.huawei.com/consumer/cn/devservice/doc/50111" target="_blank" rel="noopener">华为全面屏适配技术指导</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 线程池详解</title>
      <link href="/posts/2019/cf2a801.html"/>
      <url>/posts/2019/cf2a801.html</url>
      
        <content type="html"><![CDATA[<p>Java 中，使用线程来异步执行任务。Java 线程的创建与销毁需要一定的开销，如果为每一个任务创建一个新线程来执行，这些线程的创建和销毁将消耗大量的计算资源。针对这种情况，通常需要使用线程池来管理线程，使用线程池有以下几个好处：</p><ul><li>降低资源消耗。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>提高响应速度。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>提高线程的可管理性。线程是稀缺资源，不能无限制创建，否则不但会消耗资源，还会降低系统的稳定性，而使用线程池可以进行统一分配、调优和监控。</li></ul><h2 id="线程池的创建"><a href="#线程池的创建" class="headerlink" title="线程池的创建"></a>线程池的创建</h2><p>Java 中创建线程池很简单，只需要通过线程池工厂类 <code>Executors</code> 的提供的静态方法即可。<code>Executors</code> 提供四种线程池，分别为：</p><ul><li><strong><code>newFixedThreadPool()：</code></strong>创建一个定长线程池，可控制线程最大并发数，超出的线程会在队列中等待。</li><li><strong><code>newCachedThreadPool()：</code></strong>创建一个可缓存线程池，如果线程池长度超过处理需要，可灵活回收空闲线程，若无可回收，则新建线程。</li><li><strong><code>newScheduledThreadPool()：</code></strong>创建一个定长线程池，支持定时和周期性任务执行。</li><li><strong><code>newSingleThreadExecutor()：</code></strong>创建一个单线程化的线程池，它只会用唯一的工作线程来执行任务，保证所有任务按照指定顺序(FIFO, LIFO, 优先级)执行。</li><li><strong><code>newSingleThreadScheduledExecutor()：</code></strong>创建一个单线程化的线程池，支持定时和周期性任务执行。</li><li><strong><code>newWorkStealingPool()：</code></strong>JDK 1.8 新增，创建一个维护足够线程的线程池来支持给定的并行级别，并通过使用多个队列，减少竞争，它需要穿一个并行级别的参数，如果不传，则被设定为默认的 CPU 数量。</li></ul><p>根据 <code>Executors</code> 提供的方法可知：线程池分为 <code>ThreadPoolExecutor</code>、<code>ScheduledThreadPoolExecutor</code> 和 <code>ForkJoinPool</code> 3 种。</p><h2 id="ThreadPoolExecutor"><a href="#ThreadPoolExecutor" class="headerlink" title="ThreadPoolExecutor"></a>ThreadPoolExecutor</h2><p><code>java.util.concurrent.ThreadPoolExecutor</code> 类是线程池中最核心的一个类，因此如果要透彻地了解 Java 中的线程池，必须先了解这个类。</p><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>ThreadPoolExecutor</code> 类提供了四个构造方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExecutorService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             threadFactory<span class="token punctuation">,</span> defaultHandler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> maximumPoolSize<span class="token punctuation">,</span> keepAliveTime<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> workQueue<span class="token punctuation">,</span>             Executors<span class="token punctuation">.</span><span class="token function">defaultThreadFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span> <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span>                              TimeUnit unit<span class="token punctuation">,</span> BlockingQueue<span class="token operator">&lt;</span>Runnable<span class="token operator">></span> workQueue<span class="token punctuation">,</span>                              ThreadFactory threadFactory<span class="token punctuation">,</span> RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>corePoolSize <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;=</span> <span class="token number">0</span> <span class="token operator">||</span>            maximumPoolSize <span class="token operator">&lt;</span> corePoolSize <span class="token operator">||</span>            keepAliveTime <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>workQueue <span class="token operator">==</span> null <span class="token operator">||</span> threadFactory <span class="token operator">==</span> null <span class="token operator">||</span> handler <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>corePoolSize <span class="token operator">=</span> corePoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>maximumPoolSize <span class="token operator">=</span> maximumPoolSize<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>workQueue <span class="token operator">=</span> workQueue<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>keepAliveTime <span class="token operator">=</span> unit<span class="token punctuation">.</span><span class="token function">toNanos</span><span class="token punctuation">(</span>keepAliveTime<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>threadFactory <span class="token operator">=</span> threadFactory<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>handler <span class="token operator">=</span> handler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从上面的代码可以得知，<code>ThreadPoolExecutor</code> 继承了 <code>AbstractExecutorService</code> 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p><p>下面解释下一下构造器中各个参数的含义：</p><ul><li><strong><code>corePoolSize：</code></strong>核心线程的数量。默认情况下，在创建了线程池后，线程池中的线程数为0。当提交一个任务到线程池时，线程池会创建一个核心线程来执行任务，线程池中的线程数目达到线程池核心线程的数量时就不再创建，就会把后续到达的任务放到缓存队列当中。</li><li><strong><code>maximumPoolSize：</code></strong>线程池允许创建的最大线程数。如果队列满了，并且已创建的线程数小于最大线程数，则线程池会再创建新的线程执行任务。所以只有队列满了的时候，这个参数才有意义。因此当你使用了无界任务队列的时候，这个参数就没有效果了。</li><li><strong><code>keepAliveTime：</code></strong>线程活动保持时间，即当线程池的工作线程空闲后，保持存活的时间。默认情况下，只有当线程池中的线程数大于核心线程数量时，keepAliveTime 才会起作用，直到线程池中的线程数不大于核心线程数量，即当线程池中的线程数大于核心线程数量时，如果一个线程空闲的时间达到 keepAliveTime，则会终止，直到线程池中的线程数不超过核心线程数量。但是如果调用了 allowCoreThreadTimeOut(boolean) 方法，在线程池中的线程数不大于核心线程数量时，keepAliveTime 参数也会起作用，直到线程池中的线程数为 0。</li><li><strong><code>unit：</code></strong>线程活动保持时间的单位：可选的单位有7种，分别为：天(DAYS)、小时(HOURS)、分钟(MINUTES)、毫秒(MILLISECONDS)、微秒(MICROSECONDS，千分之一毫秒)和纳秒(NANOSECONDS，千分之一微秒)</li><li><strong><code>workQueue：</code></strong>用来保存等待执行任务的阻塞队列。workQueue 的类型为 BlockingQueue<runnable>，通常可以取下面三种类型：<ul><li><code>ArrayBlockingQueue：</code>基于数组的先进先出队列，此队列创建时必须指定大小。</li><li><code>LinkedBlockingQueue：</code>基于链表的先进先出队列，如果创建时没有指定此队列大小，则默认为 Integer.MAX_VALUE。</li><li><code>SynchronousQueue：</code>这个队列比较特殊，它不会保存提交的任务，而是将直接新建一个线程来执行新来的任务。</li></ul></runnable></li><li><strong><code>threadFactory：</code></strong>线程工厂，主要用来创建线程。可以通过线程工厂给每个创建出来的线程设置更加有意义的名字。</li><li><strong><code>handler：</code></strong>拒绝处理任务时策略，可以理解为饱和策略。当队列和线程池都满了，说明线程池处于饱和状态，那么必须采取一种策略处理提交的新任务。默认提供了以下四种策略：<ul><li><code>AbortPolicy：</code>丢弃任务并抛出 RejectedExecutionException 异常。</li><li><code>DiscardPolicy：</code>丢弃任务，但是不抛出异常。</li><li><code>DiscardOldestPolicy：</code>丢弃队列最前面的任务，并执行当前任务。</li><li><code>CallerRunsPolicy：</code>由调用线程处理该任务。</li></ul></li></ul><h3 id="线程池状态"><a href="#线程池状态" class="headerlink" title="线程池状态"></a>线程池状态</h3><p>在 <code>ThreadPoolExecutor</code> 中定义几个常量用来表示线程池的各个状态：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RUNNING    <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SHUTDOWN   <span class="token operator">=</span>  <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> STOP       <span class="token operator">=</span>  <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TIDYING    <span class="token operator">=</span>  <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TERMINATED <span class="token operator">=</span>  <span class="token number">3</span> <span class="token operator">&lt;&lt;</span> COUNT_BITS<span class="token punctuation">;</span></code></pre><blockquote><p>当线程池处于 <code>SHUTDOWN</code> 或 <code>STOP</code> 状态，并且所有工作线程已经销毁，任务缓存队列已经清空或执行结束后，线程池被设置为 <code>TERMINATED</code> 状态。</p></blockquote><h3 id="execute"><a href="#execute" class="headerlink" title="execute()"></a>execute()</h3><p><code>execute()</code> 方法用于向线程池提交任务，该方法是 <code>java.util.concurrent.Executor</code> 接口中声明的方法，在 <code>ThreadPoolExecutor</code> 进行了具体的实现，这个方法是 <code>ThreadPoolExecutor</code> 的核心方法，通过这个方法可以向线程池提交一个任务，交由线程池去执行。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断需要提交的任务是否为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>command <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 如果需要提交的任务为null，则抛出空指针异常</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断线程池的当前线程数量是否小于核心线程数量</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&lt;</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 直接将任务加入worker启动运行</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        c <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 运行线程数量大于核心线程数量时，当前状态为RUNNING并且将任务加入缓冲队列成功</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isRunning</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> workQueue<span class="token punctuation">.</span><span class="token function">offer</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> recheck <span class="token operator">=</span> ctl<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果线程池没有处于RUNNING状态，则从缓冲队列中删除任务，执行reject()方法处理任务</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">isRunning</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">remove</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果线程池处于RUNNING状态，但是没有线程，则将任务加入worker</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">workerCountOf</span><span class="token punctuation">(</span>recheck<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token function">addWorker</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 往线程池中创建新的线程失败，则执行reject()方法处理任务</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">addWorker</span><span class="token punctuation">(</span>command<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token function">reject</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="submit"><a href="#submit" class="headerlink" title="submit()"></a>submit()</h3><p><code>submit()</code> 方法用于向线程池提交任务，该方法是 <code>java.util.concurrent.ExecutorService</code> 接口中声明的方法，在 <code>AbstractExecutorService</code> 就已经有了具体的实现，在 <code>ThreadPoolExecutor</code> 中并没有对其进行重写，这个方法也是用来向线程池提交任务的，但是它和 <code>execute()</code> 方法不同，它能够返回任务执行的结果，去看 <code>submit()</code> 方法的实现，会发现它实际上还是调用的 <code>execute()</code> 方法，只不过它利用了 <code>java.util.concurrent.Future</code> 来获取任务执行结果。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> Future<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将提交的任务会封装成一个FutureTask对象</span>    RunnableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> ftask <span class="token operator">=</span> <span class="token function">newTaskFor</span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 执行execute()方法提交任务</span>    <span class="token function">execute</span><span class="token punctuation">(</span>ftask<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 返回FutureTask对象</span>    <span class="token keyword">return</span> ftask<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>不管 <code>submit(callable)</code> 还是 <code>submit(runnable)</code> 都是提交一个任务是指是创建了一个 <code>FutureTask</code>，被 <code>FutureTask</code> 构造函数统一适配为自己的成员 <code>callable</code>，最终都会执行 <code>execute(futureTask)</code> 方法。</p></blockquote><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown()"></a>shutdown()</h3><p><code>shutdown()</code> 方法将线程池里的线程状态设置成 <code>SHUTDOWN</code> 状态，此时线程池不能够接受新的任务，但是会等待所有任务执行完毕后才终止。</p><h3 id="shutdownNow"><a href="#shutdownNow" class="headerlink" title="shutdownNow()"></a>shutdownNow()</h3><p><code>shutdownNow()</code> 方法将线程池里的线程状态设置成 <code>STOP</code> 状态，此时线程池不能接受新的任务，并且会去尝试终止正在执行的任务，同时清空任务缓存队列，返回尚未执行的任务。</p><h2 id="ScheduledThreadPoolExecutor"><a href="#ScheduledThreadPoolExecutor" class="headerlink" title="ScheduledThreadPoolExecutor"></a>ScheduledThreadPoolExecutor</h2><p><code>java.util.concurrent.ScheduledThreadPoolExecutor</code> 类也是线程池中最核心的一个类，它继承 <code>ThreadPoolExecutor</code> 来重用线程池的功能，并且还支持周期性任务的调度。</p><h3 id="构造方法-1"><a href="#构造方法-1" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>ScheduledThreadPoolExecutor</code> 类提供了四个构造方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ScheduledThreadPoolExecutor</span> <span class="token keyword">extends</span> <span class="token class-name">ThreadPoolExecutor</span> <span class="token keyword">implements</span> <span class="token class-name">ScheduledExecutorService</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> DEFAULT_KEEPALIVE_MILLIS<span class="token punctuation">,</span> MILLISECONDS<span class="token punctuation">,</span>              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> DEFAULT_KEEPALIVE_MILLIS<span class="token punctuation">,</span> MILLISECONDS<span class="token punctuation">,</span>              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> DEFAULT_KEEPALIVE_MILLIS<span class="token punctuation">,</span> MILLISECONDS<span class="token punctuation">,</span>              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">ScheduledThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span> ThreadFactory threadFactory<span class="token punctuation">,</span>                                       RejectedExecutionHandler handler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>corePoolSize<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">,</span> DEFAULT_KEEPALIVE_MILLIS<span class="token punctuation">,</span> MILLISECONDS<span class="token punctuation">,</span>              <span class="token keyword">new</span> <span class="token class-name">DelayedWorkQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> threadFactory<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>因为 <code>ScheduledThreadPoolExecutor</code> 继承自 <code>ThreadPoolExecutor</code>，所以这里都是调用的 <code>ThreadPoolExecutor</code> 类的构造方法。</p></blockquote><h3 id="常用方法"><a href="#常用方法" class="headerlink" title="常用方法"></a>常用方法</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 创建一个Runnable定时任务，并在delay时间后执行</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">schedule</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个Callable定时任务，并在delay时间后执行</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>V<span class="token operator">></span> ScheduledFuture<span class="token operator">&lt;</span>V<span class="token operator">></span> <span class="token function">schedule</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>V<span class="token operator">></span> callable<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个Runnable周期任务，在initialDelay时间开始执行，每隔period时间再执行一次</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleAtFixedRate</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span> <span class="token keyword">long</span> initialDela<span class="token punctuation">,</span>y <span class="token keyword">long</span> period<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 创建一个Runnable周期任务，在initialDelay时间开始执行，以一次任务结束的时间为起点，每隔delay时间再执行一次</span><span class="token keyword">public</span> ScheduledFuture<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">scheduleWithFixedDelay</span><span class="token punctuation">(</span>Runnable command<span class="token punctuation">,</span> <span class="token keyword">long</span> initialDelay<span class="token punctuation">,</span> <span class="token keyword">long</span> delay<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="ForkJoinPool"><a href="#ForkJoinPool" class="headerlink" title="ForkJoinPool"></a>ForkJoinPool</h2><p><code>java.util.concurrent.ForkJoinPool</code> 类和 <code>ThreadPoolExecutor</code> 一样它也是 <code>ExecutorService</code> 接口的实现类，是 Java 7 提供的一个用于并行执行任务的特殊线程池，将一个大任务拆分成多个小任务后，使用 fork 可以将小任务分发给其他线程同时处理，使用 join 可以将多个线程处理的结果进行汇总；这实际上就是分治思想的并行版本。</p><h3 id="构造方法-2"><a href="#构造方法-2" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>ForkJoinPool</code> 类提供了四个构造方法：<br>public class ForkJoinPool extends AbstractExecutorService {</p><pre><code>public ForkJoinPool() {    this(Math.min(MAX_CAP, Runtime.getRuntime().availableProcessors()),         defaultForkJoinWorkerThreadFactory, null, false);}public ForkJoinPool(int parallelism) {    this(parallelism, defaultForkJoinWorkerThreadFactory, null, false);}public ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory,                    UncaughtExceptionHandler handler, boolean asyncMode) {    this(checkParallelism(parallelism), checkFactory(factory), handler,         asyncMode ? FIFO_QUEUE : LIFO_QUEUE, &quot;ForkJoinPool-&quot; + nextPoolId() + &quot;-worker-&quot;);    checkPermission();}private ForkJoinPool(int parallelism, ForkJoinWorkerThreadFactory factory,                     UncaughtExceptionHandler handler, int mode,                     String workerNamePrefix) {    this.workerNamePrefix = workerNamePrefix;    this.factory = factory;    this.ueh = handler;    this.config = (parallelism &amp; SMASK) | mode;    long np = (long)(-parallelism); // offset ctl counts    this.ctl = ((np &lt;&lt; AC_SHIFT) &amp; AC_MASK) | ((np &lt;&lt; TC_SHIFT) &amp; TC_MASK);}</code></pre><p>}</p><p>从上面的代码可以得知，<code>ForkJoinPool</code> 继承了 <code>AbstractExecutorService</code> 类，并提供了四个构造器，事实上，通过观察每个构造器的源码具体实现，发现前面三个构造器都是调用的第四个构造器进行的初始化工作。</p><p>下面解释下一下构造器中各个参数的含义：</p><ul><li><strong><code>parallelism：</code></strong>并行级别。通常默认为 JVM 可用的处理器个数 Runtime.getRuntime().availableProcessors()。</li><li><strong><code>factory：</code></strong>线程工程，主要用来创建 ForkJoinPool 中使用的线程。</li><li><strong><code>handler：</code></strong>用于处理工作线程未处理的异常，默认为 null。</li><li><strong><code>mode：</code></strong>用于控制 WorkQueue 的工作模式，有 FIFO_QUEUE 和 LIFO_QUEUE 两个值。</li><li><strong><code>workerNamePrefix：</code></strong>创建的线程的名称前缀。</li></ul><h3 id="execute-1"><a href="#execute-1" class="headerlink" title="execute()"></a>execute()</h3><p><code>execute()</code> 方法用于提交任务到 ForkJoinPool，最终是调用的 <code>externalSubmit()</code> 方法。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">externalSubmit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> job<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token keyword">instanceof</span> <span class="token class-name">ForkJoinTask</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// avoid re-wrap</span>        <span class="token comment" spellcheck="true">// 避免二次包装</span>        job <span class="token operator">=</span> <span class="token punctuation">(</span>ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> task<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 将要提交的任务包装成ForkJoinTask</span>        job <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinTask<span class="token punctuation">.</span>RunnableExecuteAction</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">externalSubmit</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="submit-1"><a href="#submit-1" class="headerlink" title="submit()"></a>submit()</h3><p><code>submit()</code> 方法也是用于提交任务到 ForkJoinPool 的，但是它和 <code>execute()</code> 方法不同，它能够返回任务执行的结果，去看 <code>submit()</code> 方法的实现，会发现它实际上也是调用的 <code>externalSubmit()</code> 方法，只不过它利用了 <code>java.util.concurrent.ForkJoinTask</code> 来获取任务执行结果。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ForkJoinTask<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>ForkJoinTask<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">externalSubmit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ForkJoinTask<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Callable<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">externalSubmit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ForkJoinTask<span class="token punctuation">.</span>AdaptedCallable</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> ForkJoinTask<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">,</span> T result<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">externalSubmit</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ForkJoinTask<span class="token punctuation">.</span>AdaptedRunnable</span><span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>task<span class="token punctuation">,</span> result<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> <span class="token function">submit</span><span class="token punctuation">(</span>Runnable task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> job<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token keyword">instanceof</span> <span class="token class-name">ForkJoinTask</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// avoid re-wrap</span>        <span class="token comment" spellcheck="true">// 避免二次包装</span>        job <span class="token operator">=</span> <span class="token punctuation">(</span>ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> task<span class="token punctuation">;</span>    <span class="token keyword">else</span>        <span class="token comment" spellcheck="true">// 将要提交的任务包装成ForkJoinTask</span>        job <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ForkJoinTask<span class="token punctuation">.</span>AdaptedRunnableAction</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">externalSubmit</span><span class="token punctuation">(</span>job<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="invoke"><a href="#invoke" class="headerlink" title="invoke()"></a>invoke()</h3><p><code>invoke()</code> 方法也是用于提交任务到 ForkJoinPool 的，只不过该方法是同步提交的，等待完成后返回结果。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">invoke</span><span class="token punctuation">(</span>ForkJoinTask<span class="token operator">&lt;</span>T<span class="token operator">></span> task<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>task <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">NullPointerException</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">externalSubmit</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> task<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="ForkJoinTask"><a href="#ForkJoinTask" class="headerlink" title="ForkJoinTask"></a>ForkJoinTask</h3><h4 id="核心方法"><a href="#核心方法" class="headerlink" title="核心方法"></a>核心方法</h4><p>大多数情况下，都是直接提交 <code>ForkJoinTask</code> 对象到 <code>ForkJoinPool</code> 中，因为 <code>ForkJoinTask</code> 有以下三个核心方法：</p><ul><li><strong><code>fork()：</code></strong>在任务执行过程中将大任务划分为多个小的子任务，调用子任务的 <code>fork()</code> 方法可以将任务放到线程池中异步调度。</li><li><strong><code>join()：</code></strong>调用子任务的 <code>join()</code> 方法等待任务返回的结果。这个方法类似于 <code>Thread.join()</code>，区别在于前者不受线程中断机制的影响。如果子任务中有运行时异常，<code>join()</code> 方法会抛出异常，<code>quietlyJoin()</code> 方法不会抛出异常也不会返回结果，需要开发者调用 <code>getException()</code> 或 <code>getRawResult()</code> 自己去处理异常和结果。</li><li><strong><code>invoke()：</code></strong>在当前线程同步执行该任务。该方法也不受中断机制影响。如果子任务中有运行时异常，<code>invoke()</code> 方法会抛出异常，<code>quietlyInvoke()</code> 方法不会抛出异常也不会返回结果，需要开发者调用 <code>getException()</code> 或 <code>getRawResult()</code> 自己去处理异常和结果。</li></ul><blockquote><p><code>ForkJoinTask</code> 中 <code>join()</code> 和 <code>invoke()</code> 方法都不受中断机制影响，内部调用 <code>externalAwaitDone()</code> 方法实现。<br>如果是在 <code>ForkJoinTask</code> 内部调用 <code>get()</code> 方法，本质上和 <code>join()</code> 方法一样都是调用 <code>externalAwaitDone()</code>。<br>但如果是在 <code>ForkJoinTask</code> 外部调用 <code>get()</code> 方法，这时会受线程中断机制影响，因为内部是通过调用 <code>externalInterruptibleAwaitDone()</code> 方法实现的。</p></blockquote><h4 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h4><p><code>ForkJoinTask</code> 由上面三个方法衍生出了几个静态方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> t1<span class="token punctuation">,</span> ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> t2<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>ForkJoinTask<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> tasks<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">ForkJoinTask</span><span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">invokeAll</span><span class="token punctuation">(</span>Collection<span class="token operator">&lt;</span>T<span class="token operator">></span> tasks<span class="token punctuation">)</span></code></pre><blockquote><p>上面几个方法都是让第一个任务同步执行，其他任务异步执行(注意：其他任务先 fork，第一个任务再 invoke)。</p></blockquote><h4 id="任务状态"><a href="#任务状态" class="headerlink" title="任务状态"></a>任务状态</h4><p><code>ForkJoinTask</code> 内部维护了四个状态：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** The run status of this task */</span><span class="token comment" spellcheck="true">// 默认等于0，小于0表示任务已经执行过，大于0说明任务没执行完</span><span class="token keyword">volatile</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// accessed directly by pool and workers</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DONE_MASK   <span class="token operator">=</span> <span class="token number">0xf0000000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// mask out non-completion bits</span><span class="token comment" spellcheck="true">// NORMAL,CANCELLED,EXCEPTIONAL均小于0</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NORMAL      <span class="token operator">=</span> <span class="token number">0xf0000000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// must be negative</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CANCELLED   <span class="token operator">=</span> <span class="token number">0xc0000000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// must be &lt; NORMAL</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXCEPTIONAL <span class="token operator">=</span> <span class="token number">0x80000000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// must be &lt; CANCELLED</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SIGNAL      <span class="token operator">=</span> <span class="token number">0x00010000</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// must be >= 1 &lt;&lt; 16</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> SMASK       <span class="token operator">=</span> <span class="token number">0x0000ffff</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// short bits for tags</span></code></pre><h4 id="抽象子类"><a href="#抽象子类" class="headerlink" title="抽象子类"></a>抽象子类</h4><p>通常不会直接使用 <code>ForkJoinTask</code>，而是使用它的两个抽象子类：</p><ul><li><strong><code>RecursiveAction：</code></strong>没有返回值的任务；</li><li><strong><code>RecursiveTask：</code></strong>有返回值的任务。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>MVC、MVP 和 MVVM 之间的区别</title>
      <link href="/posts/2019/de9d67a4.html"/>
      <url>/posts/2019/de9d67a4.html</url>
      
        <content type="html"><![CDATA[<p><code>MVC</code>、<code>MVP</code> 和 <code>MVVM</code> 都是常见的软件架构设计模式(Architectural Pattern)，它通过分离关注点来改进代码的组织方式。不同于设计模式(Design Pattern)，只是为了解决一类问题而总结出的抽象方法，一种架构模式往往使用了多种设计模式。</p><p>要了解 <code>MVC</code>、<code>MVP</code> 和 <code>MVVM</code>，就要知道它们的相同点和不同点。不同部分是 <code>C(Controller)</code>、<code>P(Presenter)</code>、<code>VM(View-Model)</code>，而相同的部分则是 <code>MV(Model-View)</code>。</p><h2 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h2><p><strong><code>MVC</code></strong>(Model-View-Controller 的缩写)模式是一种软件设计典范，用一种业务逻辑、数据、界面显示分离的方法组织代码，在改进和个性化定制界面及用户交互的同时，不需要重新编写业务逻辑。</p><p><img src="https://henleylee.github.io/medias/study/architectural_pattern_mvc.png" alt="MVC模式"></p><ul><li><strong><code>Model(模型)：</code></strong>负责处理数据、状态和业务逻辑；</li><li><strong><code>View(视图)：</code></strong>负责界面的布局和显示以及与用户的交互；</li><li><strong><code>Controller(控制器)：</code></strong>作为 View 与 Model 交互的桥梁，用于控制应用程序的流程和页面的业务逻辑，以此来达到分离视图显示和业务逻辑层。</li></ul><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><code>MVC</code> 模式的特点在于实现关注点分离，即应用程序中的数据模型与业务和展示逻辑解耦。在客户端 Web 开发中，就是将模型(M-数据、操作数据)、视图(V-显示数据的 HTML 元素)之间实现代码分离，松散耦合，使之成为一个更容易开发、维护和测试的客户端应用程序。</p><ol><li>View 传送指令到 Controller；</li><li>Controller 完成业务逻辑后，要求 Model 改变状态；</li><li>Model 将新的数据发送到 View，用户得到反馈。</li></ol><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><p><code>MVC</code> 模式的流程一共有两种，在日常开发中都会使用到：</p><ul><li>一种是通过 View 接受指令，传递给 Controller，然后对模型进行修改或者查找底层数据，最后把改动渲染在视图上。 </li><li>另一种是通过 Controller 接受指令，然后对模型进行修改或者查找底层数据，最后把改动渲染在视图上。 </li></ul><blockquote><p>不管哪种模式，MVC 的通信都是单向的。View 层会从 Model 层拿数据，因此 MVC 中的 View 层和 Model 层还是存在耦合的。</p></blockquote><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><code>MVC</code> 模式具有以下优点：</p><ul><li>重用性高，生命周期成本低，部署快；</li><li>使开发和维护用户接口的技术含量降低；</li><li>耦合性低，视图层和业务层分离，允许更改视图层代码而不用重新编译模型和控制器代码；</li><li>可维护性高，分离视图层和业务逻辑层也使得 Web 应用更易于维护和修改。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><code>MVC</code> 模式具有以下缺点：</p><ul><li>不适合小型，中等规模的应用程序，花费大量时间将 MVC 应用到规模并不是很大的应用程序通常会得不偿失；</li><li>视图与控制器间过于紧密连接，视图与控制器是相互分离，但却是联系紧密的部件，视图没有控制器的存在，其应用是很有限的，反之亦然，这样就妨碍了他们的独立重用；</li><li>视图对模型数据的低效率访问，依据模型操作接口的不同，视图可能需要多次调用才能获得足够的显示数据。对未变化数据的不必要的频繁访问，也将损害操作性能；</li></ul><h2 id="MVP"><a href="#MVP" class="headerlink" title="MVP"></a>MVP</h2><p><strong><code>MVP</code></strong>(Model-View-Presenter 的缩写)模式是 MVC 的改良模式，由 IBM 的子公司 Taligent 提出。和 MVC 的相同之处在于：Controller/Presenter 负责业务逻辑，Model 管理数据，View 负责显示，只不过是将 Controller 改为了 Presenter，View 通过接口与 Presenter 进行交互，降低耦合，方便进行单元测试，同时改变了通信方向。</p><p><img src="https://henleylee.github.io/medias/study/architectural_pattern_mvp.png" alt="MVP模式"></p><ul><li><strong><code>View(视图)：</code></strong>负责绘制 UI 元素、与用户进行交互(在 Android 中 Activity、Fragment、View都可以做为 View 层)</li><li><strong><code>Model(模型)：</code></strong>负责处理数据、状态和业务逻辑(主要职责是存储、检索、操纵数据，也可以实现一个 Model interface 用来降低耦合)；</li><li><strong><code>Presenter(控制器)：</code></strong>作为 View 与 Model 交互的中间纽带，负责完成 View 与 Model 间的交互。可以把 Presenter 理解为一个中间层的角色，它接受 Model 层的数据，并且处理之后传递给 View 层，还需要处理 View 层的用户交互等操作。</li></ul><blockquote><p>开发中往往把 Android 中界面部分的实现也理解为采用了 MVC 框架，常常把 Activity 理解为 MVC 模式中的 Controller。</p></blockquote><h3 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h3><p><code>MVP</code> 模式的特点在于 Presenter 完全把 Model 和 View 进行了分离，并且 Model、View 和 Presenter 之间双向通信。</p><ul><li>View 与 Model 不通信，都通过 Presenter 传递。Presenter 完全把 Model 和 View 进行了分离，主要的程序逻辑在 Presenter 里实现。</li><li>View 非常薄，不部署任何业务逻辑，称为“被动视图(Passive View)”，即没有任何主动性，而 Presenter 非常厚，所有逻辑都部署在那里。</li><li>Presenter 与具体的 View 是没有直接关联的，而是通过定义好的接口进行交互，从而使得在变更 View 时候可以保持 Presenter 的不变，这样就可以重用。</li><li>还可以编写测试用的 View，模拟用户的各种操作，从而实现对 Presenter 的测试而不需要使用自动化的测试工具。 </li></ul><blockquote><p>在 MVP 中，View 并不直接使用 Model，它们之间的通信是通过 Presenter 来进行的，所有的交互都发生在 Presenter 内部。在 MVC 中，View 会直接从 Model 中读取数据而不是通过 Controller。</p></blockquote><h3 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h3><p><code>MVP</code> 模式具有以下优点：</p><ul><li>模型与视图完全分离，可以修改视图而不影响模型；</li><li>可以更高效地使用模型，因为所有的交互都发生在一个地方 —— Presenter 内部；</li><li>可以将一个 Presenter 用于多个视图，而不需要改变 Presenter 的逻辑。这个特性非常的有用，因为视图的变化总是比模型的变化频繁；</li><li>如果把逻辑放在 Presenter 中，那么就可以脱离用户接口来测试这些逻辑(单元测试)。</li></ul><h3 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h3><p><code>MVP</code> 模式具有以下缺点：</p><ul><li>View 和 Presenter 的交互会过于频繁，使得他们的联系过于紧密。也就是说，一旦视图变更了，Presenter 也要变更。</li></ul><h2 id="MVVM"><a href="#MVVM" class="headerlink" title="MVVM"></a>MVVM</h2><p><strong><code>MVVM</code></strong>(Model-View-ViewModel 的缩写)模式和 MVP 模式相比，MVVM 模式用 ViewModel 替换了 Presenter ，其他层基本上与 MVP 模式一致，ViewModel 可以理解成是 View 的数据模型和 Presenter 的合体。</p><p><img src="https://henleylee.github.io/medias/study/architectural_pattern_mvvm.png" alt="MVVM模式"></p><ul><li><strong><code>View(视图)：</code></strong>负责绘制 UI 元素、与用户进行交互(在 Android 中 Activity、Fragment、View都可以做为 View 层)</li><li><strong><code>Model(模型)：</code></strong>负责处理数据、状态和业务逻辑(主要职责是存储、检索、操纵数据)；</li><li><strong><code>ViewModel(视图模型)：</code></strong>主要包括界面逻辑和模型数据封装，Behavior/Command 事件响应，绑定的属性定义等。</li></ul><h3 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h3><p><code>MVVM</code> 模式采用双向绑定(data-binding)：View 的变动，自动反映在 ViewModel，反之亦然。这种模式实际上是框架替应用开发者做了一些工作(相当于 ViewModel 类是由库帮开发者生成的)，开发者只需要较少的代码就能实现比较复杂的交互。</p><h3 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h3><p><code>MVVM</code> 模式具有以下优点：</p><ul><li>双向绑定技术，当 Model 变化时，ViewModel 会自动更新，View 也会自动变化，很好的做到数据的一致性；</li><li>低耦合，视图(View)可以独立于 Model 变化和修改，一个 ViewModel 可以绑定到不同的 View 上，当 View 变化的时候 Model 可以不变，当 Model 变化的时候 View 也可以不变；</li><li>独立开发，开发人员可以专注于业务逻辑和数据的开发(ViewModel)，设计人员可以专注于页面设计，使用 Expression Blend 可以很容易设计界面并生成 xml 代码；</li><li>可测试，界面向来是比较难于测试的，而现在测试可以针对 ViewModel 来写。</li></ul><h3 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h3><p><code>MVVM</code> 模式具有以下缺点：</p><ul><li>数据绑定也使得 Bug 很难被调试，数据绑定使得一个位置的 Bug 被快速传递到别的位置，要定位原始出问题的地方就变得不那么容易了；</li><li>数据双向绑定不利于代码重用。客户端开发最常用的是 View，但是数据双向绑定技术，让每一个 View 都绑定了一个 Model，不同的模块 Model 都不同；</li><li>一个大的模块中 Model 也会很大，虽然使用方便了也很容易保证数据的一致性，但是长期持有，不释放内存就造成话费更多的内存。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL 之高级操作</title>
      <link href="/posts/2019/c55cd1a6.html"/>
      <url>/posts/2019/c55cd1a6.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>SQL</code></strong> 是用于访问和处理数据库的标准的计算机语言。</p><h2 id="SQL-约束"><a href="#SQL-约束" class="headerlink" title="SQL 约束"></a>SQL 约束</h2><p>SQL 约束用于规定表中的数据规则。如果存在违反约束的数据行为，行为会被约束终止。</p><p>约束可以在创建表时规定(通过 CREATE TABLE 语句)，或者在表创建之后规定(通过 ALTER TABLE 语句)。</p><p>SQL CREATE TABLE + CONSTRAINT 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">(</span>column_name1 data_type<span class="token punctuation">(</span>size<span class="token punctuation">)</span> constraint_name<span class="token punctuation">,</span>column_name2 data_type<span class="token punctuation">(</span>size<span class="token punctuation">)</span> constraint_name<span class="token punctuation">,</span>column_name3 data_type<span class="token punctuation">(</span>size<span class="token punctuation">)</span> constraint_name<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在 SQL 中，我们有如下约束：</p><ul><li><code>NOT NULL</code> - 强制某列不能接受 NULL 值(默认情况下，表的列接受 NULL 值)。NOT NULL 约束强制字段始终包含值。这意味着，如果不向字段添加值，就无法插入新记录或者更新记录。</li><li><code>UNIQUE</code> - 唯一标识数据库表中的每条记录，保证某列的每行必须有唯一的值。</li><li><code>PRIMARY KEY</code> - 唯一标识数据库表中的每条记录，确保某列或多列组合有唯一标识，相当于 NOT NULL 和 UNIQUE 的结合。每个表都应该有一个主键，并且每个表只能有一个主键。</li><li><code>FOREIGN KEY</code> - 一个表中的 FOREIGN KEY 指向另一个表中的 UNIQUE KEY(唯一约束的键)，保证一个表中的数据匹配另一个表中的值的参照完整性。</li><li><code>CHECK</code> - 用于限制列中的值的范围，保证列中的值符合指定的条件。如果对单个列定义 CHECK 约束，那么该列只允许特定的值。如果对一个表定义 CHECK 约束，那么此约束会基于行中其他列的值在特定的列中对值进行限制。</li><li><code>DEFAULT</code> - 用于向列中插入默认值，规定没有给列赋值时的默认值。如果没有规定其他的值，那么会将默认值添加到所有的新记录。</li></ul><blockquote><p>请注意，每个表可以有多个 UNIQUE 约束，但是每个表只能有一个 PRIMARY KEY 约束。</p></blockquote><h2 id="SQL-AUTO-INCREMENT"><a href="#SQL-AUTO-INCREMENT" class="headerlink" title="SQL AUTO INCREMENT"></a>SQL AUTO INCREMENT</h2><p><code>AUTO INCREMENT</code> 关键字会在新记录插入表中时生成一个唯一的数字，用于表中的字段值自动递增。</p><p>默认地，AUTO_INCREMENT 的开始值是 1，每条新记录递增 1。</p><h2 id="SQL-LIMIT"><a href="#SQL-LIMIT" class="headerlink" title="SQL LIMIT"></a>SQL LIMIT</h2><p><code>LIMIT</code> 子句用于限制由 SELECT 语句返回的数据数量。对于拥有数千条记录的大型表来说，LIMIT 子句是非常有用的。</p><ul><li><p>用于 SQL Server / MS Access 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">TOP</span> number<span class="token operator">|</span><span class="token keyword">percent</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></code></pre></li><li><p>用于 MySQL 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">LIMIT</span> number<span class="token punctuation">;</span></code></pre></li><li><p>用于 Oracle 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> ROWNUM <span class="token operator">&lt;=</span> number<span class="token punctuation">;</span></code></pre></li></ul><blockquote><p>注意：并非所有的数据库系统都支持 SELECT LIMIT 语句。</p></blockquote><h2 id="SQL-LIKE"><a href="#SQL-LIKE" class="headerlink" title="SQL LIKE"></a>SQL LIKE</h2><p><code>LIKE</code> 操作符用于在 WHERE 子句中搜索列中的指定模式。SQL LIKE 操作符语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">LIKE</span> pattern<span class="token punctuation">;</span></code></pre><h2 id="SQL-通配符"><a href="#SQL-通配符" class="headerlink" title="SQL 通配符"></a>SQL 通配符</h2><p>在搜索数据库中的数据时，SQL 通配符可以替代一个或多个字符。SQL 通配符必须与 <code>LIKE</code> 运算符一起使用。</p><p>在 SQL 中，可使用以下通配符：</p><table><thead><tr><th style="text-align:center">通配符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>%</code></td><td>替代一个或多个字符</td></tr><tr><td style="text-align:center"><code>_</code></td><td>仅替代一个字符</td></tr><tr><td style="text-align:center"><code>[charlist]</code></td><td>字符列中的任何单一字符</td></tr><tr><td style="text-align:center"><code>[^charlist]</code>或<code>[!charlist]</code></td><td>不在字符列中的任何单一字</td></tr></tbody></table><p>搭配以上通配符可以让 LIKE 命令实现多种技巧：</p><ul><li><code>LIKE &#39;Mc%&#39;</code>：将搜索以字母 Mc 开头的所有字符串(如 McBadden)。</li><li><code>LIKE &#39;%inger&#39;</code>：将搜索以字母 inger 结尾的所有字符串(如 Ringer、Stringer)。</li><li><code>LIKE &#39;%en%&#39;</code>：将搜索在任何位置包含字母 en 的所有字符串(如 Bennet、Green、McBadden)。</li><li><code>LIKE &#39;_heryl&#39;</code>：将搜索以字母 heryl 结尾的所有六个字母的名称(如 Cheryl、Sheryl)。</li><li><code>LIKE &#39;[CK]ars[eo]n&#39;</code>：将搜索下列字符串：Carsen、Karsen、Carson 和 Karson(如 Carson)。</li><li><code>LIKE &#39;[M-Z]inger&#39;</code>：将搜索以字符串 inger 结尾、以从 M 到 Z 的任何单个字母开头的所有名称(如 Ringer)。</li><li><code>LIKE &#39;M[^c]%&#39;</code>：将搜索以字母 M 开头，并且第二个字母不是 c 的所有名称(如 MacFeather)。</li></ul><h2 id="SQL-IN"><a href="#SQL-IN" class="headerlink" title="SQL IN"></a>SQL IN</h2><p><code>IN</code> 操作符允许在 WHERE 子句中规定多个值。SQL IN 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">IN</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果需要选取不在规定的多个值内的记录，可以使用 <code>NOT IN</code>：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">NOT</span> <span class="token operator">IN</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p><code>IN</code> 与 <code>=</code> 的异同：</p><ul><li>相同点：均在 <code>WHERE</code> 中作为筛选条件之一使用，均是等于的含义。</li><li>不同点：<code>IN</code> 可以规定多个值，<code>=</code> 只能规定一个值。</li></ul><p>下面两种语法等价：</p><ul><li><p><strong>IN</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">IN</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p><strong>=</strong></p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name<span class="token operator">=</span>value1 <span class="token operator">or</span> column_name<span class="token operator">=</span>value2<span class="token punctuation">;</span></code></pre></li></ul><h2 id="SQL-BETWEEN"><a href="#SQL-BETWEEN" class="headerlink" title="SQL BETWEEN"></a>SQL BETWEEN</h2><p><code>BETWEEN</code> 操作符选取介于两个值之间的数据范围内的记录。这些值可以是数值、文本或者日期。SQL BETWEEN 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">BETWEEN</span> value1 <span class="token operator">AND</span> value2<span class="token punctuation">;</span></code></pre><p>如果需要选取不介于两个值之间的数据范围内的记录，可以使用 <code>NOT BETWEEN</code>：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name <span class="token operator">NOT</span> <span class="token operator">BETWEEN</span> value1 <span class="token operator">AND</span> value2<span class="token punctuation">;</span></code></pre><p>请注意，在不同的数据库中，BETWEEN 操作符会产生不同的结果！</p><ul><li>在某些数据库中，BETWEEN 选取介于两个值之间但不包括两个测试值的字段。</li><li>在某些数据库中，BETWEEN 选取介于两个值之间且包括两个测试值的字段。</li><li>在某些数据库中，BETWEEN 选取介于两个值之间且包括第一个测试值但不包括最后一个测试值的字段。</li></ul><p>因此，请检查您的数据库是如何处理 BETWEEN 操作符！</p><h2 id="SQL-别名"><a href="#SQL-别名" class="headerlink" title="SQL 别名"></a>SQL 别名</h2><p>通过使用 SQL，可以为表名称或列名称指定别名。基本上，创建别名是为了让表名称或列名称的可读性更强。</p><ul><li><p>表的别名语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name <span class="token keyword">AS</span> alias_name<span class="token punctuation">;</span></code></pre></li><li><p>列的别名语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name <span class="token keyword">AS</span> alias_name<span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></code></pre></li></ul><p>在下面的情况下，使用别名很有用：</p><ul><li>在查询中涉及超过一个表</li><li>在查询中使用了函数</li><li>列名称很长或者可读性差</li><li>需要把两个列或者多个列结合在一起</li></ul><h2 id="SQL-JOIN"><a href="#SQL-JOIN" class="headerlink" title="SQL JOIN"></a>SQL JOIN</h2><p><code>JOIN</code> 子句用于把来自两个或多个表的行结合起来，基于这些表之间的共同字段。</p><p>可以使用的不同的 SQL JOIN 类型：</p><ul><li><code>INNER JOIN</code>：如果表中存在至少一个匹配，则返回行。</li><li><code>LEFT JOIN</code>：即使右表中没有匹配，也从左表返回所有的行。如果右表中没有匹配，则结果为 NULL。</li><li><code>RIGHT JOIN</code>：即使左表中没有匹配，也从右表返回所有的行。如果左表中没有匹配，则结果为 NULL。</li><li><code>FULL JOIN</code>：只要左表和右表其中一个表中存在匹配，则返回行。结合了 LEFT JOIN 和 RIGHT JOIN 的结果。</li></ul><h2 id="SQL-UNION"><a href="#SQL-UNION" class="headerlink" title="SQL UNION"></a>SQL UNION</h2><p><code>UNION</code> 操作符用于合并两个或多个 SELECT 语句的结果集。UNION 内部的每个 SELECT 语句必须拥有相同数量的列。列也必须拥有相似的数据类型。同时，每个 SELECT 语句中的列的顺序必须相同。</p><p>SQL UNION 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><p>默认地，UNION 操作符选取不同的值。如果允许重复的值，请使用 <code>UNION ALL</code>。SQL UNION ALL 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table1<span class="token keyword">UNION</span> <span class="token keyword">ALL</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span> <span class="token keyword">FROM</span> table2<span class="token punctuation">;</span></code></pre><blockquote><p>注意：UNION 结果集中的列名总是等于 UNION 中第一个 SELECT 语句中的列名。</p></blockquote><h2 id="SQL-SELECT-INTO"><a href="#SQL-SELECT-INTO" class="headerlink" title="SQL SELECT INTO"></a>SQL SELECT INTO</h2><p><code>SELECT INTO</code> 语句从一个表复制数据，然后把数据插入到另一个新表中(要求目标表不存在)。SQL SELECT INTO 语法如下：</p><ul><li><p>可以复制所有的列插入到新表中：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span><span class="token keyword">INTO</span> newtable <span class="token punctuation">[</span><span class="token operator">IN</span> externaldb<span class="token punctuation">]</span><span class="token keyword">FROM</span> table1<span class="token punctuation">;</span></code></pre></li><li><p>只复制希望的列插入到新表中：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">INTO</span> newtable <span class="token punctuation">[</span><span class="token operator">IN</span> externaldb<span class="token punctuation">]</span><span class="token keyword">FROM</span> table1<span class="token punctuation">;</span></code></pre></li></ul><blockquote><p>注意：新表将会使用 <code>SELECT</code> 语句中定义的列名称和类型进行创建。您可以使用 <code>AS</code> 子句来应用新名称。</p></blockquote><h2 id="SQL-INSERT-INTO-SELECT"><a href="#SQL-INSERT-INTO-SELECT" class="headerlink" title="SQL INSERT INTO SELECT"></a>SQL INSERT INTO SELECT</h2><p><code>INSERT INTO SELECT</code> 语句从一个表复制数据，然后把数据插入到一个已存在的表中(要求目标表存在)。目标表中任何已存在的行都不会受影响。SQL INSERT INTO SELECT 语法如下：</p><ul><li><p>可以从一个表中复制所有的列插入到另一个已存在的表中：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> table2<span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table1<span class="token punctuation">;</span></code></pre></li><li><p>可以只复制希望的列插入到另一个已存在的表中：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> table2<span class="token punctuation">(</span>column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token keyword">SELECT</span> column_name<span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token keyword">FROM</span> table1<span class="token punctuation">;</span></code></pre></li></ul><h2 id="SQL-GROUP-BY"><a href="#SQL-GROUP-BY" class="headerlink" title="SQL GROUP BY"></a>SQL GROUP BY</h2><p><code>GROUP BY</code> 语句用于结合聚合函数，根据一个或多个列对结果集进行分组。SQL GROUP BY 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">,</span> aggregate_function<span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> column_name<span class="token punctuation">;</span></code></pre><h2 id="SQL-函数"><a href="#SQL-函数" class="headerlink" title="SQL 函数"></a>SQL 函数</h2><p>SQL 拥有很多可用于计数和计算的内建函数。</p><h3 id="SQL-Aggregate-函数"><a href="#SQL-Aggregate-函数" class="headerlink" title="SQL Aggregate 函数"></a>SQL Aggregate 函数</h3><p>SQL Aggregate 函数计算从列中取得的值，返回一个单一的值。有用的 Aggregate 函数：</p><ul><li><code>AVG()</code> - 返回数值列的平均值。</li><li><code>COUNT()</code> - 返回匹配指定条件的行数。</li><li><code>FIRST()</code> - 返回指定的列中第一个记录的值。</li><li><code>LAST()</code> - 返回指定的列中最后一个记录的值。</li><li><code>MAX()</code> - 返回指定列的最大值。</li><li><code>MIN()</code> - 返回指定列的最小值。</li><li><code>SUM()</code> - 返回数值列的总数。</li></ul><h3 id="SQL-Scalar-函数"><a href="#SQL-Scalar-函数" class="headerlink" title="SQL Scalar 函数"></a>SQL Scalar 函数</h3><p>SQL Scalar 函数基于输入值，返回一个单一的值。有用的 Scalar 函数：</p><ul><li><code>UCASE()</code> - 把某个字段的值转换为大写。</li><li><code>LCASE()</code> - 把某个字段的值转换为小写。</li><li><code>MID()</code> - 从某个文本字段中提取字符。</li><li><code>LEN()</code> - 返回某个文本字段中值的长度。</li><li><code>ROUND()</code> - 对某个数值字段进行指定小数位数的四舍五入。</li><li><code>NOW()</code> - 返回当前的系统的日期和时间。</li><li><code>FORMAT()</code> - 用于对字段的显示方式进行格式化。</li></ul><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">W3Cschool SQL 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>SQL 之基础操作</title>
      <link href="/posts/2019/38865d3b.html"/>
      <url>/posts/2019/38865d3b.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>SQL</code></strong> 是用于访问和处理数据库的标准的计算机语言。</p><h2 id="SQL-简介"><a href="#SQL-简介" class="headerlink" title="SQL 简介"></a>SQL 简介</h2><h3 id="SQL-是什么？"><a href="#SQL-是什么？" class="headerlink" title="SQL 是什么？"></a>SQL 是什么？</h3><ul><li>SQL 是指结构化查询语言，全称是 Structured Query Language。</li><li>SQL 是一种 ANSI(American National Standards Institute 美国国家标准化组织)标准的计算机语言。</li></ul><h3 id="SQL-能做什么？"><a href="#SQL-能做什么？" class="headerlink" title="SQL 能做什么？"></a>SQL 能做什么？</h3><ul><li>SQL 面向数据库执行查询</li><li>SQL 可从数据库取回数据</li><li>SQL 可在数据库中插入新的记录</li><li>SQL 可更新数据库中的数据</li><li>SQL 可从数据库删除记录</li><li>SQL 可创建新数据库</li><li>SQL 可在数据库中创建新表</li><li>SQL 可在数据库中创建存储过程</li><li>SQL 可在数据库中创建视图</li><li>SQL 可以设置表、存储过程和视图的权限</li></ul><p>虽然 SQL 是一门 ANSI 标准的计算机语言，但是仍然存在着多种不同版本的 SQL 语言。然而，为了与 ANSI 标准相兼容，它们必须以相似的方式共同地来支持一些主要的命令(比如 <code>SELECT</code>、<code>UPDATE</code>、<code>DELETE</code>、<code>INSERT</code>、<code>WHERE</code> 等等)。</p><blockquote><p>注释：除了 SQL 标准之外，大部分 SQL 数据库程序都拥有它们自己的专有扩展！</p></blockquote><h3 id="在网站上如何使用-SQL？"><a href="#在网站上如何使用-SQL？" class="headerlink" title="在网站上如何使用 SQL？"></a>在网站上如何使用 SQL？</h3><p>要创建一个显示数据库中数据的网站，需要：</p><ul><li>RDBMS 数据库程序(比如 MS Access、SQL Server、MySQL)</li><li>使用服务器端脚本语言，比如 PHP 或 ASP</li><li>使用 SQL 来获取您想要的数据</li><li>使用 HTML / CSS</li></ul><h3 id="RDBMS"><a href="#RDBMS" class="headerlink" title="RDBMS"></a>RDBMS</h3><ul><li>RDBMS(Relational Database Management System) 指关系型数据库管理系统。</li><li>RDBMS 是 SQL 的基础，同样也是所有现代数据库系统的基础，比如 MS SQL Server、IBM DB2、Oracle、MySQL 以及 Microsoft Access。</li><li>RDBMS 中的数据存储在被称为表的数据库对象中。表是相关的数据项的集合，它由列和行组成。</li></ul><h2 id="SQL-语法"><a href="#SQL-语法" class="headerlink" title="SQL 语法"></a>SQL 语法</h2><h3 id="数据库表"><a href="#数据库表" class="headerlink" title="数据库表"></a>数据库表</h3><p>一个数据库通常包含一个或多个表。每个表有一个名字标识(例如 Customer、order)，表包含带有数据的记录(行)。</p><h3 id="SQL-语句"><a href="#SQL-语句" class="headerlink" title="SQL 语句"></a>SQL 语句</h3><p>在数据库上执行的大部分工作都由 SQL 语句完成。</p><ul><li><p>SQL 语句的大小写问题：<br><strong>SQL 对大小写不敏感</strong>：<code>SELECT</code> 与 <code>select</code> 是相同的。</p></li><li><p>SQL 语句后面的分号问题：<br>某些数据库系统要求在每条 SQL 语句的末端使用分号。分号是在数据库系统中分隔每条 SQL 语句的标准方法，这样就可以在对服务器的相同请求中执行一条以上的 SQL 语句。</p></li></ul><h3 id="SQL-命令"><a href="#SQL-命令" class="headerlink" title="SQL 命令"></a>SQL 命令</h3><p>SQL 是指结构化查询语言，是用于执行查询的语法。但是 SQL 语言也包含用于更新、插入和删除记录的语法。</p><p>可以把 SQL 分为两个部分：<code>数据定义语言(DDL)</code>和<code>数据操作语言(DML)</code>。</p><h4 id="数据定义语言-DDL"><a href="#数据定义语言-DDL" class="headerlink" title="数据定义语言(DDL)"></a>数据定义语言(DDL)</h4><p>数据定义语言(Data Definition Language，简称 DDL)用于改变数据库结构，包括创建/更改/删除数据库对象或表、定义索引(键)、规定表之间的链接以及施加表间的约束。SQL 中最重要的 DDL 语句:</p><ul><li><strong>CREATE DATABASE</strong> - 创建新数据库</li><li><strong>ALTER DATABASE</strong> - 修改数据库</li><li><strong>DROP DATABASE</strong> - 删除数据库</li><li><strong>CREATE TABLE</strong> - 创建新表</li><li><strong>ALTER TABLE</strong> - 修改表</li><li><strong>TRUNCATE TABLE</strong> - 删除表中数据</li><li><strong>DROP TABLE</strong> - 删除表</li><li><strong>CREATE INDEX</strong> - 创建索引(搜索键)</li><li><strong>DROP INDEX</strong> - 删除索引</li></ul><h4 id="数据操作语言-DML"><a href="#数据操作语言-DML" class="headerlink" title="数据操作语言(DML)"></a>数据操作语言(DML)</h4><p>数据操作语言(Data Manipulation Language，简称 DML)用于检索、插入、修改和删除数据。SQL 中最重要的 DML 语句:</p><ul><li><strong>SELECT</strong> - 从数据库表中查询数据</li><li><strong>INSERT</strong> - 向数据库表中插入数据</li><li><strong>UPDATE</strong> - 更新数据库表中的数据</li><li><strong>DELETE</strong> - 从数据库表中删除数据</li></ul><h2 id="SQL-CREATE-DATABASE"><a href="#SQL-CREATE-DATABASE" class="headerlink" title="SQL CREATE DATABASE"></a>SQL CREATE DATABASE</h2><p><code>CREATE DATABASE</code> 用于创建数据库。SQL CREATE DATABASE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">DATABASE</span> database_name<span class="token punctuation">;</span></code></pre><h2 id="SQL-DROP-DATABASE"><a href="#SQL-DROP-DATABASE" class="headerlink" title="SQL DROP DATABASE"></a>SQL DROP DATABASE</h2><p><code>DROP DATABASE</code> 语句用于删除数据库。SQL DROP DATABASE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">DATABASE</span> database_name<span class="token punctuation">;</span></code></pre><h2 id="SQL-CREATE-TABLE"><a href="#SQL-CREATE-TABLE" class="headerlink" title="SQL CREATE TABLE"></a>SQL CREATE TABLE</h2><p><code>CREATE TABLE</code> 语句用于创建数据库中的表。表由行和列组成，每个表都必须有个表名。SQL CREATE TABLE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">(</span>column_name1 data_type<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span>column_name2 data_type<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span>column_name3 data_type<span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><ul><li>column_name：规定表中列的名称。</li><li>data_type：规定列的数据类型(例如 varchar、integer、decimal、date 等等)。</li><li>size：规定表中列的最大长度。</li></ul><h2 id="SQL-ALTER-TABLE"><a href="#SQL-ALTER-TABLE" class="headerlink" title="SQL ALTER TABLE"></a>SQL ALTER TABLE</h2><p><code>ALTER TABLE</code> 语句用于在已有的表中添加、修改或删除列。</p><p>如需在表中添加列，请使用下列语法:</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name<span class="token keyword">ADD</span> column_name data_type</code></pre><p>要删除表中的列，请使用下列语法(请注意，某些数据库系统不允许这种在数据库表中删除列的方式)：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name<span class="token keyword">DROP</span> <span class="token keyword">COLUMN</span> column_name</code></pre><p>要改变表中列的数据类型，请使用下列语法：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name<span class="token keyword">ALTER</span> <span class="token keyword">COLUMN</span> column_name data_type</code></pre><h2 id="SQL-TRUNCATE-TABLE"><a href="#SQL-TRUNCATE-TABLE" class="headerlink" title="SQL TRUNCATE TABLE"></a>SQL TRUNCATE TABLE</h2><p><code>TRUNCATE TABLE</code> 语句用于删除表中的所有行，但表结构及其列、约束、索引等保持不变。SQL TRUNCATE TABLE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">TRUNCATE</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">;</span></code></pre><h2 id="SQL-DROP-TABLE"><a href="#SQL-DROP-TABLE" class="headerlink" title="SQL DROP TABLE"></a>SQL DROP TABLE</h2><p><code>DROP TABLE</code> 语句用于删除表。SQL DROP TABLE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> table_name<span class="token punctuation">;</span></code></pre><h2 id="SQL-CREATE-INDEX"><a href="#SQL-CREATE-INDEX" class="headerlink" title="SQL CREATE INDEX"></a>SQL CREATE INDEX</h2><p><code>CREATE INDEX</code> 语句用于在表中创建索引。在不读取整个表的情况下，索引使数据库应用程序可以更快地查找数据。。SQL CREATE INDEX 语法如下：</p><ul><li><p>在表上创建一个简单的索引，允许使用重复的值：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">INDEX</span> index_name<span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>在表上创建一个唯一的索引，不允许使用重复的值(唯一的索引意味着两个行不能拥有相同的索引值)：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">CREATE</span> <span class="token keyword">UNIQUE</span> <span class="token keyword">INDEX</span> index_name<span class="token keyword">ON</span> table_name <span class="token punctuation">(</span>column_name<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><p>用户无法看到索引，它们只能被用来加速搜索/查询。如果希望索引不止一个列，可以在括号中列出这些列的名称，用逗号隔开。</p><p>虽然索引的目的在于提高数据库的性能，但这里有几个情况需要避免使用索引。使用索引时，应重新考虑下列准则：</p><ul><li>索引不应该使用在较小的表上。</li><li>索引不应该使用在有频繁的大批量的更新或插入操作的表上。</li><li>索引不应该使用在含有大量的 NULL 值的列上。</li><li>索引不应该使用在频繁操作的列上。</li></ul><blockquote><p>注意：更新一个包含索引的表需要比更新一个没有索引的表更多的时间，这是由于索引本身也需要更新。因此，理想的做法是仅仅在常常被搜索的列(以及表)上面创建索引。</p></blockquote><h2 id="SQL-DROP-INDEX"><a href="#SQL-DROP-INDEX" class="headerlink" title="SQL DROP INDEX"></a>SQL DROP INDEX</h2><p><code>DROP INDEX</code> 语句用于删除表中的索引。</p><ul><li><p>用于 MS Access 的语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name <span class="token keyword">ON</span> table_name<span class="token punctuation">;</span></code></pre></li><li><p>用于 MS SQL Server 的语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> table_name<span class="token punctuation">.</span>index_name<span class="token punctuation">;</span></code></pre></li><li><p>用于 DB2/Oracle 的语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span></code></pre></li><li><p>用于 MySQL 的语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">ALTER</span> <span class="token keyword">TABLE</span> table_name <span class="token keyword">DROP</span> <span class="token keyword">INDEX</span> index_name<span class="token punctuation">;</span></code></pre></li></ul><blockquote><p>当删除索引时应特别注意，因为性能可能会下降或提高。</p></blockquote><h2 id="SQL-SELECT"><a href="#SQL-SELECT" class="headerlink" title="SQL SELECT"></a>SQL SELECT</h2><p><code>SELECT</code> 语句用于从数据库中查询数据，结果被存储在一个结果表中，称为结果集。SQL SELECT 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">,</span>column_name<span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></code></pre><p>与</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></code></pre><p>在表中，一个列可能会包含多个重复值，有时也许希望仅仅列出不同(distinct)的值。<code>DISTINCT</code> 关键词用于返回唯一不同的值。SQL SELECT DISTINCT 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token keyword">DISTINCT</span> column_name<span class="token punctuation">,</span>column_name<span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></code></pre><h2 id="SQL-WHERE"><a href="#SQL-WHERE" class="headerlink" title="SQL WHERE"></a>SQL WHERE</h2><p><code>WHERE</code> 子句用于提取那些满足指定标准的记录。SQL WHERE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">,</span>column_name<span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span><span class="token punctuation">;</span></code></pre><p>下面的运算符可以在 <code>WHERE</code> 子句中使用：</p><table><thead><tr><th style="text-align:center">运算符</th><th>描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>=</code></td><td>等于</td></tr><tr><td style="text-align:center"><code>&lt;&gt;</code></td><td>不等于(注释：在 SQL 的一些版本中，该操作符可被写成 !=)</td></tr><tr><td style="text-align:center"><code>&gt;</code></td><td>大于</td></tr><tr><td style="text-align:center"><code>&lt;</code></td><td>小于</td></tr><tr><td style="text-align:center"><code>&gt;=</code></td><td>大于等于</td></tr><tr><td style="text-align:center"><code>&lt;=</code></td><td>小于等于</td></tr><tr><td style="text-align:center"><code>BETWEEN</code></td><td>在某个范围内</td></tr><tr><td style="text-align:center"><code>LIKE</code></td><td>搜索某种模式</td></tr><tr><td style="text-align:center"><code>IN</code></td><td>指定针对某个列的多个可能值</td></tr></tbody></table><h2 id="SQL-AND-amp-OR"><a href="#SQL-AND-amp-OR" class="headerlink" title="SQL AND &amp; OR"></a>SQL AND &amp; OR</h2><p><code>AND</code> 和 <code>OR</code> 运算符用于基于一个以上的条件对记录进行过滤。<br>SQL AND 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span><span class="token operator">AND</span> column_name operator <span class="token keyword">value</span><span class="token punctuation">;</span></code></pre><blockquote><p>如果第一个条件和第二个条件都成立，则 <code>AND</code> 运算符显示该条记录。</p></blockquote><p>SQL OR 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span><span class="token operator">OR</span> column_name operator <span class="token keyword">value</span><span class="token punctuation">;</span></code></pre><blockquote><p>如果第一个条件和第二个条件中只要有一个成立，则 <code>OR</code> 运算符显示该条记录。</p></blockquote><p>SQL AND 和 OR 结合语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> column_name operator <span class="token keyword">value</span><span class="token operator">AND</span> <span class="token punctuation">(</span>column_name operator <span class="token keyword">value</span> <span class="token operator">OR</span> column_name operator <span class="token keyword">value</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="SQL-ORDER-BY"><a href="#SQL-ORDER-BY" class="headerlink" title="SQL ORDER BY"></a>SQL ORDER BY</h2><p><code>ORDER BY</code> 关键字用于对结果集按照一个列或者多个列进行排序。ORDER BY 关键字默认按照升序对记录进行排序。如果需要按照降序对记录进行排序，可以使用 <code>DESC</code> 关键字。SQL ORDER BY 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">SELECT</span> column_name<span class="token punctuation">,</span>column_name<span class="token keyword">FROM</span> table_name<span class="token keyword">ORDER</span> <span class="token keyword">BY</span> column_name <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">,</span>column_name <span class="token punctuation">[</span><span class="token keyword">ASC</span><span class="token operator">|</span><span class="token keyword">DESC</span><span class="token punctuation">]</span><span class="token punctuation">;</span></code></pre><ul><li><code>ORDER BY</code> 多列的时候，先按照第一个列名排序，在按照第二个列名排序；</li><li><code>ORDER BY</code> 排列时，不写明 <code>ASC|DESC</code> 的时候，默认是 <code>ASC</code>，<code>DESC</code> 需要写明；</li><li><code>ASC</code> 或 <code>DESC</code>只对它紧跟着的第一个列名有效，其他列名不受影响，仍然是默认的升序。</li></ul><blockquote><p><code>ASC</code> 是指定列按<code>升序</code>排列，<code>DESC</code> 则是指定列按<code>降序</code>排列。</p></blockquote><h2 id="SQL-INSERT"><a href="#SQL-INSERT" class="headerlink" title="SQL INSERT"></a>SQL INSERT</h2><p><code>INSERT INTO</code> 语句用于向表中插入新记录。INSERT INTO 语句可以有两种编写形式：</p><ul><li><p>第一种形式无需指定要插入数据的列名，只需提供被插入的值即可：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> table_name<span class="token keyword">VALUES</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">,</span>value3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>该种形式需要列出插入行的每一列数据。</p></blockquote></li><li><p>第二种形式需要指定列名及被插入的值：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> table_name <span class="token punctuation">(</span>column1<span class="token punctuation">,</span>column2<span class="token punctuation">,</span>column3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token keyword">VALUES</span> <span class="token punctuation">(</span>value1<span class="token punctuation">,</span>value2<span class="token punctuation">,</span>value3<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p>该种形式没有指定的列将被自动填充为 null。</p></blockquote></li></ul><h2 id="SQL-UPDATE"><a href="#SQL-UPDATE" class="headerlink" title="SQL UPDATE"></a>SQL UPDATE</h2><p><code>UPDATE</code> 语句用于更新表中已存在的记录。SQL UPDATE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">UPDATE</span> table_name<span class="token keyword">SET</span> column1<span class="token operator">=</span>value1<span class="token punctuation">,</span>column2<span class="token operator">=</span>value2<span class="token punctuation">,</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">WHERE</span> some_column<span class="token operator">=</span>some_value<span class="token punctuation">;</span></code></pre><blockquote><p><strong><code>请注意 SQL UPDATE 语句中的 WHERE 子句！</code></strong> WHERE 子句规定哪条记录或者哪些记录需要更新。如果省略了 WHERE 子句，所有的记录都将被更新！执行没有 WHERE 子句的 UPDATE 要慎重，再慎重。</p></blockquote><h2 id="SQL-DELETE"><a href="#SQL-DELETE" class="headerlink" title="SQL DELETE"></a>SQL DELETE</h2><p><code>DELETE</code> 语句用于删除表中的行。SQL DELETE 语法如下：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> table_name<span class="token keyword">WHERE</span> some_column<span class="token operator">=</span>some_value<span class="token punctuation">;</span></code></pre><blockquote><p><strong><code>请注意 SQL DELETE 语句中的 WHERE 子句！</code></strong> WHERE 子句规定哪条记录或者哪些记录需要删除。如果您省略了 WHERE 子句，所有的记录都将被删除！</p></blockquote><p>可以在不删除表的情况下，删除表中所有的行。这意味着表结构、属性、索引将保持不变：</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></code></pre><p>或</p><pre class=" language-sql"><code class="language-sql"><span class="token keyword">DELETE</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> table_name<span class="token punctuation">;</span></code></pre><blockquote><p><strong>注意：</strong>在删除记录时要格外小心！因为不能重来！</p></blockquote><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://www.w3school.com.cn/sql/index.asp" target="_blank" rel="noopener">W3Cschool SQL 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-散列表</title>
      <link href="/posts/2019/8a8eeb6c.html"/>
      <url>/posts/2019/8a8eeb6c.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>散列表(Hash table)</code></strong>是实现字典操作的一种有效的数据结构。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><code>散列表</code></strong>也叫哈希表，是根据键和值(key 和 value)直接进行访问的数据结构。也就是说，它通过把 <code>key</code> 和 <code>value</code> 映射到表中的一个位置来访问记录，以加快查找的速度。这个映射函数叫做<code>散列函数</code>，存放记录的表叫做<code>散列表</code>。</p><p>给定表 <code>M</code>，存在函数 <code>f(key)</code>，对任意给定的关键字值 <code>key</code>，代入函数后若能得到包含该关键字的记录在表中的地址，则称表 <code>M</code> 为哈希表，函数 <code>f(key)</code> 为 <code>哈希函数</code>。</p><p>散列表的数据结构如下图所示：<br><img src="https://henleylee.github.io/medias/study/data_structure_hash_table.png" alt="散列表的数据结构"></p><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><code>散列函数和散列表：</code>若关键字为 key，则其值存放在 f(key) 的存储位置上。由此，不需比较便可直接取得所查记录。称这个对应关系 f 为 散列函数，按这个思想建立的表为散列表。</li><li><code>哈希冲突：</code>对不同的关键字可能得到同一散列地址，即 key1≠key2，而f(key1)=f(key2)，这种现象称为哈希冲突。具有相同函数值的关键字对该散列函数来说称做同义词。</li><li><code>散列和散列地址：</code>根据散列函数 f(k) 和处理冲突的方法将一组关键字映射到一个有限的连续的地址集上，并以关键字在地址集中的“像”作为记录在表中的存储位置，这种表便称为散列表，这一映射过程称为散列造表或散列，所得的存储位置称散列地址。</li><li><code>均匀散列函数：</code>若对于关键字集合中的任一个关键字，经散列函数映象到地址集合中任何一个地址的概率是相等的，则称此类散列函数为均匀散列函数(Uniform Hash function)，这就是使关键字经过散列函数得到一个“随机的地址”，从而减少冲突。</li></ul><h2 id="散列表的特点"><a href="#散列表的特点" class="headerlink" title="散列表的特点"></a>散列表的特点</h2><p>散列表有两种用法：一种是 key 的值与 value 的值一样，一般称这种情况的结构为 Set(集合)；而如果 key 和 value 所对应的内容不一样时，那么我们称这种情况为 Map(图)。</p><p>根据散列表的存储结构，可以得出散列表的以下特点。</p><ul><li><code>访问速度很快：</code>由于散列表有散列函数，可以将指定的 key 都映射到一个地址上，所以在访问一个 key 对应的 value 时，根本不需要一个一个地进行查找，可以直接跳到那个地址。所以在对散列表进行添加、删除、修改、查找等任何操作时，速度都很快。</li><li><code>需要额外的空间：</code>首先，散列表实际上是存不满的，如果一个散列表刚好能够存满，那么肯定是个巧合。而且当散列表中元素的使用率越来越高时，性能会下降，所以一般会选择扩容来解决这个问题。另外，如果有冲突的话，则也是需要额外的空间去存储的，比如链地址法，不但需要额外的空间，甚至需要使用其他数据结构。这个特点有个很常用的词可以表达，叫作“空间换时间”，在大多数时候，对于算法的实现，为了能够有更好的性能，往往会考虑牺牲些空间，让算法能够更快些。</li><li><code>无序：</code>散列表还有一个非常明显的特点，那就是无序。为了能够更快地访问元素，散列表是根据散列函数直接找到存储地址的，这样我们的访问速度就能够更快，但是对于有序访问却没有办法应对。</li><li><code>可能会产生碰撞：</code>没有完美的散列函数，无论如何总会产生冲突，这时就需要采用冲突解决方案，这也使散列表更加复杂。通常在不同的高级语言的实现中，对于冲突的解决方案不一定一样。</li></ul><h2 id="常用的哈希函数"><a href="#常用的哈希函数" class="headerlink" title="常用的哈希函数"></a>常用的哈希函数</h2><p>哈希函数能使对一个数据序列的访问过程更加迅速有效，通过哈希函数，数据元素将被更快地定位。</p><h3 id="直接寻址表"><a href="#直接寻址表" class="headerlink" title="直接寻址表"></a>直接寻址表</h3><p><code>直接寻址法</code>是指取关键字或关键字的某个线性函数值为散列地址，即 H(key)=key 或 H(key) = a*key + b，其中 a 和 b 为常数，这种散列函数叫做自身函数。</p><ul><li>优点：简单、均匀，也不会产生冲突。</li><li>缺点：需要事先知道关键字的分布情况，适合查找表较小且连续的情况。</li></ul><p>由于这样的限制，在现实应用中，此方法虽然简单，但却并不常用。</p><h3 id="数字分析法"><a href="#数字分析法" class="headerlink" title="数字分析法"></a>数字分析法</h3><p><code>数字分析法</code>是指分析一组数据，比如一组员工的出生年月日，这时我们发现出生年月日的前几位数字大体相同，这样的话，出现冲突的几率就会很大，但是我们发现年月日的后几位表示月份和具体日期的数字差别很大，如果用后面的数字来构成散列地址，则冲突的几率会明显降低。因此数字分析法就是找出数字的规律，尽可能利用这些数据来构造冲突几率较低的散列地址。</p><p>如果现在要存储某家公司的登记表，若用手机号作为关键字，极有可能前7位都是相同的，选择后四位成为散列地址就是不错的选择。若容易出现冲突，对抽取出来 的数字再进行反转、右环位移等。总的目的就是为了提供一个散列函数，能够合理地将关键字分配到散列表的各个位置。</p><p>数字分析法通过适合处理关键字位数比较大的情况，如果事先知道关键字的分布且关键字的若干位分布比较均匀，就可以考虑用这个方法。</p><h3 id="平方取中法"><a href="#平方取中法" class="headerlink" title="平方取中法"></a>平方取中法</h3><p><code>平方取中法</code>是指当无法确定关键字中哪几位分布较均匀时，可以先求出关键字的平方值，然后按需要取平方值的中间几位作为哈希地址。这是因为：平方后中间几位和关键字中每一位都相关，故不同关键字会以较高的概率产生不同的哈希地址。</p><p>这个方法计算很简单，假设关键字是1234，那么它的平方就是1522756，再抽取中间的3位就是227，用做散列地址。</p><p>平方取中法比较适合不知道关键字的分布，而位数又不是很大的情况。</p><h3 id="折叠法"><a href="#折叠法" class="headerlink" title="折叠法"></a>折叠法</h3><p><code>折叠法</code>是指将关键字从左到右分割成位数相同的几部分，最后一部分位数可以不同，然后将这几部分叠加求和，并按散列表表长，取后几位作为散列地址。数位叠加可以有移位叠加和间界叠加两种方法。移位叠加是将分割后的每一部分的最低位对齐，然后相加；间界叠加是从一端向另一端沿分割界来回折叠，然后对齐相加。</p><p>比如关键字是9876543210，散列表表长为三位，将它分为四组，987|654|321|0，然后将它们叠加求和987 + 654 + 321 + 0 = 1962，再求后3位得到散列地址962。</p><p>折叠法事先不需要知道关键字的分布，适合关键字位数较多的情况。</p><h3 id="随机数法"><a href="#随机数法" class="headerlink" title="随机数法"></a>随机数法</h3><p><code>随机数法</code>是指选择一随机函数，取关键字的随机值作为散列地址，即 f(key)=random(key)。这里 random() 是随机函数，通常用于关键字长度不同的场合。</p><h3 id="除留余数法"><a href="#除留余数法" class="headerlink" title="除留余数法"></a>除留余数法</h3><p><code>除留余数法</code>是指取关键字被某个不大于散列表表长 m 的数 p 除后所得的余数为散列地址，即 H(key)=key mod p,p&lt;=m，mod 是取模(求余数)。不仅可以对关键字直接取模，也可在折叠、平方取中等运算之后取模。对 p 的选择很重要，一般取素数或 m，若 p 选的不好，容易产生同义词。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>总之，实际工作中需视不同的情况采用不同的哈希函数，通常考虑的因素有：</p><ul><li>计算哈希函数所需时间</li><li>关键字的长度</li><li>哈希表的大小</li><li>关键字的分布情况</li><li>记录的查找频率</li></ul><p>综合以上等因素，才能决策选择哪种散列函数更合适。</p><h2 id="哈希冲突的解决方法"><a href="#哈希冲突的解决方法" class="headerlink" title="哈希冲突的解决方法"></a>哈希冲突的解决方法</h2><p>有时不同的 key 通过哈希函数可能会得到相同的地址，这在操作时可能会对数据造成覆盖、丢失。之所以产生冲突是由于哈希函数有时对不同的 key 计算之后获得了相同的地址。</p><p>冲突的处理方式也有很多，下面介绍几种。</p><h3 id="开放寻址法"><a href="#开放寻址法" class="headerlink" title="开放寻址法"></a>开放寻址法</h3><p><code>开放寻址法</code>是指一旦发生了冲突，就去寻找下一个空的散列地址，只要散列表足够大，空的散列地址总能找到，并将记录存入。</p><p>它的公式为：f<sub>i</sub>(key)=(f(key)+d<sub>i</sub>) MOD m (i=1,2，…，m-1)，其中 f(key) 为散列函数，m 为散列表长，d<sub>i</sub> 为增量序列，可有下列三种取法：</p><ul><li>d<sub>i</sub>=1,2,3，…，m-1，称线性探测再散列；</li><li>d<sub>i</sub>=1<sup>2</sup>,-1<sup>2</sup>,2<sup>2</sup>,-2<sup>2</sup>，…，±k<sup>2</sup>,(k&lt;=m/2）称二次探测再散列；</li><li>d<sub>i</sub>=伪随机数序列，称伪随机探测再散列。</li></ul><h3 id="再哈希法"><a href="#再哈希法" class="headerlink" title="再哈希法"></a>再哈希法</h3><p><code>再哈希法</code>是指在产生冲突之后，使用关键字的其他部分继续计算地址，如果还是有冲突，则继续使用其他部分再计算地址。</p><p>它的公式为：f<sub>i</sub>(key)=RH<sub>i</sub>(key) (i=1,2，…，k)，其中 RH<sub>i</sub>(key) 就是不同的散列函数，可以把前面说的除留余数、折叠、平方取中全部用上。每当发生散列地址冲突时，就换一个散列函数计算。</p><p>这种方法能够使得关键字不产生聚集，但相应地也增加了计算的时间。</p><h3 id="链地址法"><a href="#链地址法" class="headerlink" title="链地址法"></a>链地址法</h3><p><code>链地址法</code>也叫拉链法，其实就是对 key 通过哈希之后落在同一个地址上的值，做一个链表。在很多高级语言的实现当中，也是使用这种方式处理冲突的。</p><p>将所有关键字为同义词的记录存储在一个单链表中，称这种表为同义词子表，在散列表中只存储所有同义词子表前面的指针。此时，已经不存在什么冲突换地址的问题，无论有多少个冲突，都只是在当前位置给单链表增加结点的问题。</p><p>链地址法对于可能会造成很多冲突的散列函数来说，提供了绝不会出现找不到地址的保证。当然，这也就带来了查找时需要遍历单链表的性能损耗。</p><h3 id="公共溢出区法"><a href="#公共溢出区法" class="headerlink" title="公共溢出区法"></a>公共溢出区法</h3><p><code>公共溢出区法</code>是指是建立一个公共溢出区，当地址存在冲突时，把新的地址放在公共溢出区里。</p><p>在查找时，对给定值通过散列函数计算出散列地址后，先与基本表的相应位置进行比对，如果相等，则查找成功；如果不相等，则到溢出表中进行顺序查找。如果相对于基本表而言，有冲突的数据很少的情况下，公共溢出区的结构对查找性能来说还是非常高的。</p><h2 id="哈希表的性能分析"><a href="#哈希表的性能分析" class="headerlink" title="哈希表的性能分析"></a>哈希表的性能分析</h2><p>在没有哈希冲突的情况下，哈希表是在查找中效率最高的，因为它的时间复杂度为 <code>O(1)</code>。然而在实际应用中，冲突是不可避免的，那么散列表的平均查找长度取决于那些因素呢？</p><ul><li><code>处理冲突的方法：</code>相同的关键字，相同的散列函数，处理冲突的方法不同，会使得平均查找长度不同。</li><li><code>哈希表的装填因子 α：</code> α 为填入表中的记录个数/哈希表长度。α 标志着哈希表的装满程度。当填入表中的记录越多，α 越大，产生冲突的可能性就越大。也就是说哈希表的平均查找长度取决于装填因子，而不是取决于集合中的记录个数。可以通过将哈希表的空间设置的比查找集合大，通过牺牲空间，在换取查找效率。这样哈希查找的时间复杂度就是真的是 O(1) 了。</li></ul><h2 id="散列表的适用场景"><a href="#散列表的适用场景" class="headerlink" title="散列表的适用场景"></a>散列表的适用场景</h2><p>根据散列表的特点可以想到，散列表比较适合查找性能要求高，数据元素之间无逻辑关系要求的情况。</p><h3 id="缓存"><a href="#缓存" class="headerlink" title="缓存"></a>缓存</h3><p>通常开发程序时，对一些常用的信息会做缓存，用的就是散列表，比如要缓存用户的信息，一般用户的信息都会有唯一标识的字段，比如 ID。这时做缓存，可以把 ID 作为 key，而 value 用来存储用户的详细信息，这里的 value 通常是一个对象，包含用户的一些关键字段，比如名字、年龄等。</p><p>在每次需要获取一个用户的信息时，就不用与数据库这类的本地磁盘存储交互了(其实在大多数时候，数据库可能与服务不在一台机器上，还会有相应的网络性能损耗)，可以直接从内存中得到结果。这样不仅能够快速获取数据，也能够减轻数据库的压力。</p><p>有时要查询一些数据，这些数据与其他数据是有关联的，如果进行数据库的关联查询，那么效率会非常低，这时可以分为两部分进行查询：将被关联的部分放入散列表中，只需要遍历一遍；对于另一部分数据，则通过程序手动关联，速度会很快，并且由于是通过散列表的 key 和 value 的对应关系对应数据的，所以性能也会比较好。</p><h3 id="快速查找"><a href="#快速查找" class="headerlink" title="快速查找"></a>快速查找</h3><p>这里说的查找，不是排序，而是在集合中找出是否存在指定的元素。</p><p>这样的场景很多，比如要在指定的用户列表中查找是否存在指定的用户，这时就可以使用散列表了。在这个场景下使用的散列表其实是在上面提到的 Set 类型，实际上不需要 value 这个值。</p><p>还有一个场景，一般对网站的操作会有个 IP 地址黑名单，如果某些 IP 有大量的非法操作，于是就封锁了这些 IP 对我们网站的访问。这个 IP 是如何存储的呢？就是用的散列表。当一个访问行为发送过来时，通常会获取其 IP，判断其是否存在于黑名单中，如果存在，则禁止其访问。这种情况也是使用的 Set。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-树</title>
      <link href="/posts/2019/f30c2ae3.html"/>
      <url>/posts/2019/f30c2ae3.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>树(Tree)</code></strong>是算法中常用的一种数据结构，为了存储和查找的方便，用各种树结构来存储文件。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><code>树</code></strong>是由 n(n&gt;=0) 个有限节点组成一个具有层次关系的集合，它是一种<code>非线性</code>的数据结构。把它叫做<code>树</code>是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。</p><p>树的数据结构如下图所示：<br><img src="https://henleylee.github.io/medias/study/data_structure_tree.png" alt="树的数据结构"></p><blockquote><p>单个节点是一棵树，树根就是该节点本身。空集合也是树，称为空树。空树中没有节点。</p></blockquote><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><code>树</code>具有以下的特点：</p><ul><li>有且仅有一个特定的称为根(root)节点；</li><li>每棵树有且只有一个根节点；</li><li>每个节点都只有有限个子节点或无子节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>树里面没有环路；</li><li>除了根节点外，其余节点可分为多个互不相交的有限集，其中每一个集合本身又是一棵树，称为原树的子树(SubTree)。</li></ul><h3 id="术语"><a href="#术语" class="headerlink" title="术语"></a>术语</h3><ul><li><code>树的度：</code>树内各节点的度的最大值。</li><li><code>节点的度：</code>一个节点含有的子树的个数称为该节点的度。</li><li><code>叶节点或终端节点：</code>度为 0 的节点。</li><li><code>非终端节点或分支节点：</code>度不为 0 的节点，分支节点也称为内部节点。</li><li><code>孩子和双亲：</code>节点的子树的根，该节点称为孩子的双亲。</li><li><code>父亲节点或父节点：</code>若一个节点含有子节点，则这个节点称为其子节点的父节点。</li><li><code>孩子节点或子节点：</code>一个节点含有的子树的根节点称为该节点的子节点。</li><li><code>兄弟节点：</code>具有相同父节点的节点互称为兄弟节点。</li><li><code>节点的层次：</code>从根开始定义起，根为第 1 层，根的子节点为第 2 层，以此类推。</li><li><code>树的深度或高度：</code>树中节点的最大层次。</li><li><code>节点的深度：</code>从根到该节点的唯一路径长，根的深度为 0。</li><li><code>节点的高度：</code>为从该节点到一片树叶的最长路径长，所有树叶的高度为 0。</li><li><code>堂兄弟节点：</code>父节点在同一层的节点互为堂兄弟。</li><li><code>节点的祖先：</code>从根到该节点所经分支上的所有节点。</li><li><code>子孙：</code>以某节点为根的子树中任一节点都称为该节点的子孙。</li><li><code>森林：</code>由 m(m&gt;=0) 棵互不相交的树的集合称为森林。</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>对于存储结构，可能会联想到顺序存储结构和链式存储结构。但是对于数这种可能会有很多孩子的特殊数据结构，只用顺序存储结构或者链式存储结构很难实现，那么可以将这两者结合，产生主要的三种存储结构表示法：<code>双亲表示法</code>、<code>孩子表示法</code>、<code>孩子兄弟表示法</code>。</p><h3 id="双亲表示法"><a href="#双亲表示法" class="headerlink" title="双亲表示法"></a>双亲表示法</h3><p><code>双亲表示法</code>是假设以一组连续空间存储树的节点，同时在每个节点中，附设一个指示器指示其双亲节点到链表中的位置。</p><blockquote><p>除了根节点外，其余每个节点，它不一定有孩子，但是有且仅有一个双亲。</p></blockquote><h4 id="节点结构"><a href="#节点结构" class="headerlink" title="节点结构"></a>节点结构</h4><p>双亲表示的节点结构：</p><table><thead><tr><th style="text-align:center">data(数据域)</th><th>parent(指针域)</th></tr></thead><tbody><tr><td style="text-align:center">存储节点的数据信息</td><td>存储该节点的双亲所在数组中的下标</td></tr></tbody></table><h4 id="代码定义"><a href="#代码定义" class="headerlink" title="代码定义"></a>代码定义</h4><pre><code>/* 树的双亲表法节点结构定义*/#define MAX_TREE_SIZE 100typedef int  ElemeType;typedef struct PTNode{           // 节点结构    ElemeType data;              // 节点数据    int parent;                  // 双亲位置}PTNode;typedef struct {                 // 树结构    PTNode nodes[MAX_TREE_SIZE]; // 节点数组    int r;                       // 根的位置    int n;                       // 节点数}PTree;</code></pre><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><p>由于根节点是没有双亲的，约定根节点的位置域为 -1。<br>优点：根据节点的 <code>parent</code> 指针很容易找到它的双亲节点。所用时间复杂度为 <code>O(1)</code>，直到 <code>parent</code> 为 <code>-1</code> 时，表示找到了树节点的根。<br>缺点：查找孩子节点难，想要找到孩子节点，需要遍历整个结构才行。</p><h3 id="孩子表示法"><a href="#孩子表示法" class="headerlink" title="孩子表示法"></a>孩子表示法</h3><p><code>孩子表示法</code>是指把每个节点的孩子节点排列起来，以单链表作存储结构，则 n 个节点有 n 个孩子链表，如果是叶子节点则此单链表为空，然后 n 个头指针又组成一个线性表，采用顺序存储结构，存放进一个一维数组中。</p><blockquote><p>由于树中每个节点可能有多棵子树，因此可以使用多重链表，即每个节点包含多个指针域，其中每个指针指向一棵子树的根节点，我们把这种方法叫做多重链表表示法。不过，树的每个节点的度(节点的孩子个数)是不同的。</p></blockquote><h4 id="节点结构-1"><a href="#节点结构-1" class="headerlink" title="节点结构"></a>节点结构</h4><p>孩子表示法有以下两种节点结构：</p><ul><li>孩子链表的孩子节点：</li></ul><table><thead><tr><th style="text-align:center">child(数据域)</th><th>next(指针域)</th></tr></thead><tbody><tr><td style="text-align:center">存储某个节点在表头数组中的下标</td><td>存储指向某节点的下一个孩子节点的指针</td></tr></tbody></table><ul><li>表头数组的表头节点：</li></ul><table><thead><tr><th style="text-align:center">data(数据域)</th><th>firstchild(头指针域)</th></tr></thead><tbody><tr><td style="text-align:center">存储某个节点的数据信息</td><td>存储该节点的孩子链表的头指针</td></tr></tbody></table><h4 id="代码定义-1"><a href="#代码定义-1" class="headerlink" title="代码定义"></a>代码定义</h4><pre><code>/* 树的孩子表示法结构定义*/#define MAX_TREE_SIZE 100typedef int  ElemeType;typedef struct CTNode{           // 孩子节点    int child;                   // 孩子节点的下标    struct CTNode * next;        // 指向下一节点的指针}*ChildPtr;typedef struct {                 // 表头结构    ElemeType data;              // 节点数据    ChildPtr firstchild;         // 指向第一个孩子的指针}CTBox;typedef struct {                // 树结构    CTBox nodes[MAX_TREE_SIZE]; // 节点数组    int r;                      // 根的位置    int n;                      // 节点树}CTree;</code></pre><h4 id="特点-2"><a href="#特点-2" class="headerlink" title="特点"></a>特点</h4><p>优点：查找某个节点的孩子或者兄弟，只需要查找这个节点的孩子单链表即可。<br>缺点：查找双亲难，可以在上面的表头结构中加入节点对应的双亲所在的数组下标。</p><h3 id="孩子兄弟表示法"><a href="#孩子兄弟表示法" class="headerlink" title="孩子兄弟表示法"></a>孩子兄弟表示法</h3><p><code>孩子兄弟表示法</code>是指任意一棵树，它的节点的第一个孩子如果存在就是唯一的，它的右兄弟如果存在也是唯一的。因此，设置两个指针，分别指向该节点的第一个孩子和此节点的右兄弟。</p><h4 id="节点结构-2"><a href="#节点结构-2" class="headerlink" title="节点结构"></a>节点结构</h4><p>孩子兄弟表示法的节点结构：</p><table><thead><tr><th style="text-align:center">data(数据域)</th><th>firstchild(指针域)</th><th>rightsib(指针域)</th></tr></thead><tbody><tr><td style="text-align:center">存储节点的数据信息</td><td>存储该节点的第一个孩子的存储地址</td><td>存储该节点的右兄弟节点的存储地址</td></tr></tbody></table><h4 id="代码定义-2"><a href="#代码定义-2" class="headerlink" title="代码定义"></a>代码定义</h4><pre><code>/* 树的孩子兄弟表示法结构定义*/#define MAX_TREE_SIZE 100typedef int  ElemeType;typedef struct CSNode{    ElemeType data;              // 节点数据    struct CSNode * firstchild;  // 指向第一个孩子的指针    struct CSNode * rightsib;    // 指向第一个孩子的右兄弟的指针}CSNode, *CSTree;</code></pre><h2 id="树的分类"><a href="#树的分类" class="headerlink" title="树的分类"></a>树的分类</h2><p>数据结构中有很多树的结构，其中包括二叉树、二叉搜索树、平衡二叉树、2-3 树、红黑树等等。</p><h3 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h3><p>二叉树是数据结构中一种重要的数据结构，也是树表家族最为基础的结构。</p><h4 id="定义-1"><a href="#定义-1" class="headerlink" title="定义"></a>定义</h4><p><strong><code>二叉树(Binary Tree)</code></strong>是一个有根树，并且每个节点最多只有2科子树(即二叉树中不存在度大于2的结点)，并且二叉树的子树有左右之分，其次序不能任意颠倒。</p><p>二叉树的数据结构如下图所示：<br><img src="https://henleylee.github.io/medias/study/data_structure_binary_tree.png" alt="二叉树的数据结构"></p><p>二叉树的第 n 层至多有 2<sup>n-1</sup> 个结点；深度为 k 的二叉树至多有 2<sup>k-1</sup> 个结点；对任何一棵非空二叉树 T，如果其树叶总数为 n<sub>0</sub>，度为2的结点数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1。</p><h4 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h4><p>二叉树的性质：</p><ul><li>在非空二叉树中，第 i 层的结点总数不超过 2<sup>i-1</sup>(i&gt;=1);</li><li>深度为 k 的二叉树最多有 2<sup>k</sup>-1 个结点(k&gt;=1)，最少有 k 个结点;</li><li>对于任意一棵二叉树，如果其终端结点数为 n<sub>0</sub>，而度数为2的结点总数为 n<sub>2</sub>，则 n<sub>0</sub>=n<sub>2</sub>+1;</li><li>具有 n 个结点的完全二叉树的深度为 log<sub>2</sub>(n+1);</li><li>具有 n 个结点的完全二叉树各结点如果用顺序方式存储，则对任一结点 i(1≤i≤n) 之间有如下关系：<ul><li>如果 i=1，则节点 i 是二叉树的根，无双亲；如果 i&gt;1，则其双亲是节点 i/2；</li><li>如果 2i&gt;n，则节点 i 无左孩子，节点 i 是叶子节点；否则其左孩子(即左子树的根结点)是节点 2i；</li><li>如果 2i+1&gt;n，则节点 i 无右孩子；否则其其右孩子(即右子树的根结点)是节点 2i+1。</li></ul></li><li>给定n个节点，能构成 h(n) 种不同的二叉树，其中 h(n) 为卡特兰数的第 n 项，h(n)=C(2*n, n)/(n+1)。</li><li>设有 i 个枝点，I 为所有枝点的道路长度总和，J 为叶的道路长度总和 J=I+2<sup>i</sup>。</li></ul><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p><strong><code>满二叉树(Full Binary Tree)：</code></strong>除最后一层无任何子节点外，每一层上的所有结点都有两个子结点。也可以这样理解，除叶子结点外的所有结点均有两个子结点。节点数达到最大值，所有叶子结点必须在同一层上。</p><p>满二叉树的数据结构如下图所示：<br><img src="https://henleylee.github.io/medias/study/data_structure_full_binary_tree.png" alt="满二叉树的数据结构"></p><p>满二叉树的性质：</p><ul><li>一颗树深度为 h，最大层数为 k，深度与最大层数相同，k=h;</li><li>叶子数为2<sup>n</sup>;</li><li>第 k 层的结点数是：2<sup>k-1</sup>;</li><li>总结点数是：2<sup>k-1</sup>，且总节点数一定是奇数。</li></ul><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p><strong><code>完全二叉树(Complete Binary Tree)</code></strong>是指从根结点到倒数第二层满足完美二叉树，最后一层可以不完全填充，其叶子结点都靠左对齐。</p><p>完全二叉树的数据结构如下图所示：<br><img src="https://henleylee.github.io/medias/study/data_structure_complete_binary_tree.png" alt="完全二叉树的数据结构"></p><blockquote><p>注：完全二叉树是效率很高的数据结构，堆是一种完全二叉树或者近似完全二叉树，所以效率极高，像十分常用的排序算法、Dijkstra算法、Prim算法等都要用堆才能优化，二叉排序树的效率也要借助平衡性来提高，而平衡性基于完全二叉树。</p></blockquote><h3 id="二叉排序树"><a href="#二叉排序树" class="headerlink" title="二叉排序树"></a>二叉排序树</h3><p><strong><code>二叉排序树(Binary Sort Tree)</code></strong>又称为二叉搜索树或二叉查找树(Binary Search Tree)。二叉排序树或者是一棵空树，或者是具有下列性质的二叉树：</p><ul><li>若左子树不空，则左子树上所有结点的值均小于它的根结点的值；</li><li>若右子树不空，则右子树上所有结点的值均大于或等于它的根结点的值；</li><li>左、右子树也分别为二叉排序树；</li><li>没有键值相等的节点。</li></ul><h4 id="性质-1"><a href="#性质-1" class="headerlink" title="性质"></a>性质</h4><p>二叉查找树的性质：对二叉查找树进行中序遍历，即可得到有序的数列。</p><h4 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h4><p>二叉查找树的时间复杂度：它和二分查找一样，插入和查找的时间复杂度均为 <code>O(logn)</code>，但是在最坏的情况下仍然会有 <code>O(n)</code> 的时间复杂度。原因在于插入和删除元素的时候，树没有保持平衡。我们追求的是在最坏的情况下仍然有较好的时间复杂度，这就是平衡查找树设计的初衷。</p><h4 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h4><p>在二叉排序树中查找给定值的过程如下：</p><ol><li>如果二叉查找树为空，查找失败，返回 null；</li><li>如果二叉查找树的根节点的关键字与给定值相等，则查找出；</li><li>否则，继续在相应的子树中查找。如果要查找的关键字小于根节点的关键字，在左子树中查找；如果要查找的关键字大于根节点的关键字，在右子树中查找。</li><li>重复前面的三个步骤，直至查找成功或查找失败。</li></ol><blockquote><p>二叉查找树的高度决定了二叉查找树的查找效率。</p></blockquote><h4 id="插入过程"><a href="#插入过程" class="headerlink" title="插入过程"></a>插入过程</h4><p>在二叉排序树中插入给定值的过程如下：</p><ol><li>若当前二叉查找树为空，则插入的元素为根节点；</li><li>若插入的元素值小于根节点值，则递归从根节点的左子树中找到可插入位置；</li><li>若插入的元素值大于根节点值，则递归从根节点的右子树中找到可插入位置。</li></ol><blockquote><p>新插入的结点一定是一个新添加的叶子结点，并且是查找不成功时查找路径上访问的最后一个节点的左孩子或右孩子节点。</p></blockquote><h4 id="删除过程"><a href="#删除过程" class="headerlink" title="删除过程"></a>删除过程</h4><p>在二叉排序树删去一个结点，分三种情况讨论：</p><ol><li>如果删除的结点为叶子结点(即左子树和右子树均为空树)，由于删去叶子结点不破坏整棵树的结构，则可以直接删除此子结点；</li><li>如果删除的结点有一个子节点(只有左子树或右子树)，可以将子节点直接移到被删除元素的位置即可，作此修改也不破坏二叉排序树的特性；</li><li>如果删除的结点有两个子节点(左子树和右子树均不为空)，这时候就采用中序遍历，找到待删除的节点的后继节点，将其与待删除的节点互换，此时待删除节点的位置已经是叶子节点，可以直接删除。</li></ol><h4 id="最小值"><a href="#最小值" class="headerlink" title="最小值"></a>最小值</h4><p>在二叉排序树中获取最小值的过程如下：</p><ol><li>如果根节点无左子树，则返回根节点。</li><li>依次查询跟节点的左子树节点，返回左子树的最后一个左节点。</li></ol><h4 id="最大值"><a href="#最大值" class="headerlink" title="最大值"></a>最大值</h4><p>在二叉排序树中获取最大值的过程如下：</p><ol><li>如果根节点无右子树，则返回根节点。</li><li>依次查询根节点的右子树节点，返回右子树的最后一个右节点。</li></ol><h3 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h3><p><strong><code>平衡二叉树(Balanced Binary Tree)</code></strong>又被称为 AVL 树(有别于 AVL 算法)，平衡二叉树或者是一棵空树，或者是具有下列性质的二叉树：</p><ul><li>它的左子树和右子树都是平衡二叉树；</li><li>它的左子树和右子树的深度之差的绝对值不超过1。</li></ul><p>若将二叉树节点的平衡因子BF定义为该节点的左子树的深度减去它的右子树的深度，则平衡二叉树上所有节点的平衡因子只可能为-1、0和1。只要二叉树上有一个节点的平衡因子的绝对值大于1，那么该二叉树就是不平衡的。</p><p>平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。在平衡二叉搜索树中，其高度一般都良好地维持在 O(log<sub>2</sub>n)，大大降低了操作的时间复杂度。</p><p>最小二叉平衡树的节点的公式如下：</p><pre><code>F(n)=F(n-1)+F(n-2)+1</code></pre><p>这个类似于一个递归的数列，可以参考 Fibonacci 数列，公式中 1 是根节点，F(n-1) 是左子树的节点数量，F(n-2) 是右子树的节点数量。</p><h4 id="AVL-树"><a href="#AVL-树" class="headerlink" title="AVL 树"></a>AVL 树</h4><p><strong><code>AVL 树</code></strong>是最先发明的自平衡二叉查找树算法。在 AVL 中任何节点的左右子树的高度最大差别为一，所以它也被称为高度平衡树，n 个结点的 AVL 树最大深度约 1.44log<sub>2</sub>n。查找、插入和删除在平均和最坏情况下都是 O(logn)。增加和删除可能需要通过一次或多次树旋转来重新平衡这个树。这个方案很好的解决了二叉查找树退化成链表的问题，把插入，查找，删除的时间复杂度最好情况和最坏情况都维持在O(logN)。但是频繁旋转会使插入和删除牺牲掉O(logN)左右的时间，不过相对二叉查找树来说，时间上稳定了很多。</p><blockquote><p>AVL 树最关键的也是最难的一步操作就是旋转。旋转主要是为了实现 AVL 树在实施了插入和删除操作以后，树重新回到平衡的方法。</p></blockquote><h4 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h4><p><strong><code>红黑树</code></strong>是一种自平衡二叉查找树，是在计算机科学中用到的一种数据结构，典型的用途是实现关联数组。它是在1972年由 Rudolf Bayer 发明的，他称之为<code>对称二叉B树</code>，它现代的名字是在 Leo J. Guibas 和 Robert Sedgewick 于1978年写的一篇论文中获得的。它是复杂的，但它的操作有着良好的最坏情况运行时间，并且在实践中是高效的: 它可以在 O(logn) 时间内做查找，插入和删除，这里的 n 是树中元素的数目。</p><p>红黑树和 AVL 树一样都对插入时间、删除时间和查找时间提供了最好可能的最坏情况担保。这不只是使它们在时间敏感的应用如实时应用（real time application）中有价值，而且使它们有在提供最坏情况担保的其他数据结构中作为建造板块的价值；例如，在计算几何中使用的很多数据结构都可以基于红黑树。此外，红黑树还是2-3-4树的一种等同，它们的思想是一样的，只不过红黑树是2-3-4树用二叉树的形式表示的。</p><p>红黑树是每个节点都带有颜色属性的二叉查找树，颜色为红色或黑色。在二叉查找树强制的一般要求以外，对于任何有效的红黑树增加了如下的额外要求：</p><ol><li>节点是红色或黑色。</li><li>根是黑色。</li><li>所有叶子都是黑色(叶子是 NIL 节点)。</li><li>每个红色节点必须有两个黑色的子节点(从每个叶子到根的所有路径上不能有两个连续的红色节点)。</li><li>从任一节点到其每个叶子的所有简单路径都包含相同数目的黑色节点。</li></ol><h4 id="Treap"><a href="#Treap" class="headerlink" title="Treap"></a>Treap</h4><p><strong><code>Treap</code></strong>是一棵二叉排序树，它的左子树和右子树分别是一个 Treap，和一般的二叉排序树不同的是，Treap 纪录一个额外的数据，就是优先级。Treap 在以关键码构成二叉排序树的同时，还满足堆的性质(在这里假设节点的优先级大于该节点的孩子的优先级)。但是这里要注意的是 Treap 和二叉堆有一点不同，就是二叉堆必须是完全二叉树，而 Treap 并不一定是。</p><h4 id="伸展树"><a href="#伸展树" class="headerlink" title="伸展树"></a>伸展树</h4><p><strong><code>伸展树(Splay Tree)</code></strong>是一种二叉排序树，它能在 O(logn) 内完成插入、查找和删除操作。它由 Daniel Sleator 和 Robert Tarjan 创造。它的优势在于不需要记录用于平衡树的冗余信息。在伸展树上的一般操作都基于伸展操作。</p><h3 id="B-树"><a href="#B-树" class="headerlink" title="B 树"></a>B 树</h3><p><strong><code>B 树(B-tree)</code></strong>是一种树状数据结构，能够用来存储排序后的数据。这种数据结构能够让查找数据、循序存取、插入数据及删除的动作，都在对数时间内完成。B 树，概括来说是一个一般化的二叉查找树，可以拥有多于2个子节点。与自平衡二叉查找树不同，B 树为系统最优化大块数据的读和写操作。B 树算法减少定位记录时所经历的中间过程，从而加快存取速度。这种数据结构常被应用在数据库和文件系统的实作上。</p><p>在 B 树中查找给定关键字的方法是，首先把根结点取来，在根结点所包含的关键字 K1,…,Kn 查找给定的关键字(可用顺序查找或二分查找法)，若找到等于给定值的关键字，则查找成功；否则，一定可以确定要查找的关键字在 Ki 与 Ki+1 之间，Pi 为指向子树根节点的指针，此时取指针 Pi 所指的结点继续查找，直至找到，或指针 Pi 为空时查找失败。</p><p>B树也是一种用于查找的平衡树，但是它不是二叉树。B 树作为一种多路搜索树，它或者是空树，或者是满足下列性质的树：</p><ul><li>定义任意非叶子结点最多只有 m 个儿子；且 m&gt;2；</li><li>根结点的儿子数为[2, m]；</li><li>除根结点以外的非叶子结点的儿子数为[M/2, M]；</li><li>每个结点存放至少m/2-1（取上整）和至多m-1个关键字；（至少2个关键字）</li><li>非叶子结点的关键字个数等于指向儿子的指针个数-1；</li><li>非叶子结点的关键字：K[1], K[2], …, K[M-1]；且K[i] &lt; K[i+1]；</li><li>非叶子结点的指针：P[1], P[2], …, P[M]；其中P[1]指向关键字小于K[1]的子树，P[m]指向关键字大于K[m-1]的子树，其它P[i]指向关键字属于(K[i-1], K[i])的子树；</li><li>所有叶子结点位于同一层。</li></ul><h3 id="B-树-1"><a href="#B-树-1" class="headerlink" title="B+ 树"></a>B+ 树</h3><p><strong><code>B+ 树</code></strong>是 B 树的变体，也是一种多路搜索树：</p><ul><li>其定义基本与 B 树相同；</li><li>非叶子结点的子树指针与关键字个数相同；</li><li>非叶子结点的子树指针 P[i]，指向关键字值属于 [K[i], K[i+1]) 的子树(B 树是开区间)；</li><li>为所有叶子结点增加一个链指针；</li><li>所有关键字都在叶子结点出现。</li></ul><p>B+ 树的搜索与 B 树也基本相同，区别是 B+ 树只有达到叶子结点才命中(B 树可以在非叶子结点命中)，其性能也等价于在关键字全集做一次二分查找；</p><p>B+ 树的性质：</p><ul><li>所有关键字都出现在叶子结点的链表中(稠密索引)，且链表中的关键字恰好是有序的；</li><li>不可能在非叶子结点命中；</li><li>非叶子结点相当于是叶子结点的索引(稀疏索引)，叶子结点相当于是存储(关键字)数据的数据层；</li><li>更适合文件索引系统。</li></ul><h3 id="B-树-2"><a href="#B-树-2" class="headerlink" title="B* 树"></a>B* 树</h3><p><strong><code>B* 树</code></strong>是 B+ 树的变体，在 B+ 树的非根和非叶子结点再增加指向兄弟的指针，将结点的最低利用率从1/2提高到2/3。</p><p>B<em> 树定义了非叶子结点关键字个数至少为(2/3)</em>m，即块的最低使用率为2/3(代替 B+ 树的1/2)；</p><ul><li>B+ 树的分裂：当一个结点满时，分配一个新的结点，并将原结点中1/2的数据复制到新结点，最后在父结点中增加新结点的指针；B+ 树的分裂只影响原结点和父结点，而不会影响兄弟结点，所以它不需要指向兄弟的指针；</li><li>B* 树的分裂：当一个结点满时，如果它的下一个兄弟结点未满，那么将一部分数据移到兄弟结点中，再在原结点插入关键字，最后修改父结点中兄弟结点的关键字(因为兄弟结点的关键字范围改变了)；如果兄弟也满了，则在原结点与兄弟结点之间增加新结点，并各复制1/3的数据到新结点，最后在父结点增加新结点的指针。</li></ul><p>所以，B* 树分配新结点的概率比 B+ 树要低，空间使用率更高。</p><h3 id="Trie-树"><a href="#Trie-树" class="headerlink" title="Trie 树"></a>Trie 树</h3><p><strong><code>Tire 树</code></strong>称为字典树，又称单词查找树。Trie 树，是一种树形结构，是一种哈希树的变种。典型应用是用于统计，排序和保存大量的字符串(但不仅限于字符串)，所以经常被搜索引擎系统用于文本词频统计。它的优点是：利用字符串的公共前缀来减少查询时间，最大限度地减少无谓的字符串比较，查询效率比哈希树高。　</p><p>Trie 树的性质：</p><ul><li>根节点不包含字符，除根节点外每一个节点都只包含一个字符；</li><li>从根节点到某一节点，路径上经过的字符连接起来，为该节点对应的字符串；</li><li>每个节点的所有子节点包含的字符都不相同。</li></ul><p>Tire 树的应用：</p><ul><li>串的快速检索：给出 N 个单词组成的熟词表，以及一篇全用小写英文书写的文章，请按最早出现的顺序写出所有不在熟词表中的生词。在这道题中，可以用数组枚举，用哈希，用字典树，先把熟词建一棵树，然后读入文章进行比较，这种方法效率是比较高的。</li><li>“串”排序：给定 N 个互不相同的仅由一个单词构成的英文名，将他们按字典序从小到大输出。用字典树进行排序，采用数组的方式创建字典树，这棵树的每个结点的所有儿子很显然地按照其字母大小排序。对这棵树进行先序遍历即可。</li><li>最长公共前缀：对所有串建立字典树，对于两个串的最长公共前缀的长度即他们所在的结点的公共祖先个数，于是，问题就转化为求公共祖先的问题。</li></ul><h2 id="树的遍历"><a href="#树的遍历" class="headerlink" title="树的遍历"></a>树的遍历</h2><p>树的遍历是树的一种重要的运算。所谓遍历是指对树中所有结点的信息的访问，即依次对树中每个结点访问一次且仅访问一次。</p><p>二叉树的遍历方式分为3种：</p><ul><li><strong><code>前序遍历：</code></strong>先根节点，后左孩子节点，再右孩子结点。即：若树为空，则空操作返回。否则，先访问根节点，然后前序遍历左子树，再前序遍历右子树。</li><li><strong><code>中序遍历：</code></strong>先左孩子结点，后根节点，再右孩子结点。即：若树为空，则空操作返回。否则，从根节点开始(注意并不是先访问根节点)，中序遍历根节点的左子树，然后是访问根节点，最后中序遍历根节点的右子树。</li><li><strong><code>后序遍历：</code></strong>先左孩子节点，后右孩子结点，再根节点。即：若树为空，则空操作返回。否则，从左到右先叶子后节点的方式遍历访问左右子树，最后访问根节点。</li></ul><blockquote><p>注意：这里的<strong><code>序</code></strong>为<strong>根节点的遍历顺序</strong>。</p></blockquote><p>二叉树的3中遍历方式的结果如下图所示：<br><img src="https://henleylee.github.io/medias/study/binary_tree_traversal.png" alt="二叉树的遍历方式"></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-链表</title>
      <link href="/posts/2019/155edf9a.html"/>
      <url>/posts/2019/155edf9a.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>链表(Linked list)</code></strong>是算法中常用的一种基础数据结构，是一种链式存储结构的线性表。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><code>链表</code></strong>是一种物理存储单元上非连续、非顺序的存储结构，数据元素的逻辑顺序是通过链表中的指针链接次序实现的。</p><p>链表由一系列节点(链表中每一个元素称为节点)组成，节点可以在运行时动态生成。每个节点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个节点地址的指针域。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p><code>链表</code>是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以是连续的，也可以是不连续的。因此，为了表示每个数据元素与其直接后继数据元素之间的逻辑关系，对数据元素来说，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p><code>链表</code>的优点就是插入和删除操作会非常快，时间复杂度为 <code>O(1)</code>。</p><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p><code>链表</code>的缺点就是要找一个元素，必须要从头开始找起，时间复杂度为 <code>O(n)</code>。</p><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><p>链表有很多种不同的类型：<code>单向链表</code>、<code>双向链表</code>以及<code>循环链表</code>。</p><h3 id="单向链表"><a href="#单向链表" class="headerlink" title="单向链表"></a>单向链表</h3><p><strong><code>单向链表</code></strong>指的是链表中的节点的指针域只能指向链表中的下一个节点或者指向 NULL，节点之间不能相互指向，单向链表是链表中结构最简单的。</p><blockquote><p><code>单向链表</code>只能从一个方向进行遍历。</p></blockquote><h4 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h4><p><code>单向链表</code>有一个头节点和一个尾节点，头节点没有值域，只有链域，专门存放第一个节点的地址；尾节点，有值域，也有链域，链域值始终为NULL。</p><p>对于单向链表，如果想在尾部添加一个节点，那么必须从头部一直遍历到尾部，找到尾节点，然后在尾节点后面插入一个节点。</p><h4 id="效率分析"><a href="#效率分析" class="headerlink" title="效率分析"></a>效率分析</h4><p>单向链表的效率分析如下：</p><ul><li>链表插入和删除操作的时间复杂度均为 <code>O(n)</code>；</li><li>链表读取操作的时间复杂度为 <code>O(n)</code>。</li></ul><h4 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h4><p>单向链表的优缺点如下：</p><ul><li>优点：插入和删除操作不需要移动数据元素。</li><li>缺点：只能从头到尾遍历，只能找到后继，无法找到前驱，不支持随机读取。</li></ul><h3 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h3><p><strong><code>双向链表</code></strong>其实是单向链表的改进，在双向链表中，节点除含有数据域外，还有两个链域，一个存储直接后继节点地址，一般称之为右链域；一个存储直接前驱节点地址，一般称之为左链域。</p><blockquote><p><code>双向链表</code>是可以从两个方向进行遍历的。</p></blockquote><h4 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h4><p>双向链表的优缺点如下：</p><ul><li>优点：可以从两个方向进行遍历，可以找到前驱和后继。</li><li>缺点：增加删除节点复杂，多需要分配一个指针存储空间。</li></ul><h3 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h3><p><strong><code>循环链表</code></strong>指的是在单向链表和双向链表的基础上，将两种链表的最后一个节点指向第一个节点从而实现循环。</p><p>循环链表与单向链表和循环链表有以下不同：</p><ul><li>在建立一个循环链表时，必须使其最后一个节点的指针指向表头节点，而不是象单链表那样置为 NULL。此种情况还使用于在最后一个节点后插入一个新的节点。</li><li>在判断是否到表尾时，是判断该节点链域的值是否是表头节点，当链域值等于表头指针时，说明已到表尾。而非象单链表那样判断链域值是否为 NULL。</li></ul><blockquote><p><code>循环链表</code>是一个链表环。</p></blockquote><h4 id="优缺点-2"><a href="#优缺点-2" class="headerlink" title="优缺点"></a>优缺点</h4><p>循环链表的优缺点如下：</p><ul><li>优点：没有 NULL 指针，可以从任一节点遍历整个链表，可以找到前驱和后继。</li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构-线性表</title>
      <link href="/posts/2019/5b12b8a1.html"/>
      <url>/posts/2019/5b12b8a1.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>线性表</code></strong>是最基本、最简单、也是最常用的一种数据结构。</p><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong><code>线性表</code></strong>是数据结构的一种，一个线性表是 n(n&gt;=0) 个具有相同特性的数据元素的有限序列。数据元素是一个抽象的符号，其具体含义在不同的情况下一般不同。</p><p>在稍复杂的线性表中，一个数据元素可由多个数据项(item)组成，此种情况下常把数据元素称为记录(record)，含有大量记录的线性表又称文件(file)。</p><p>线性表中的个数 n 定义为线性表的长度，n=0 时称为空表。在非空表中每个数据元素都有一个确定的位置。</p><p>线性表的相邻元素之间存在着序偶关系，除第一个元素外，每个元素有且仅有一个直接前驱，除最后一个元素外，每个元素有且仅有一个直接后继。</p><blockquote><p>线性表中数据元素之间的关系是一对一的关系，即除了第一个和最后一个数据元素之外，其它数据元素都是首尾相接的。注意，这句话只适用大部分线性表，而不是全部。比如，循环链表逻辑层次上也是一种线性表(存储层次上属于链式存储)，但是把最后一个数据元素的尾指针指向了首位结点。</p></blockquote><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><p>在数据结构逻辑层次上细分，线性表可分为一般<code>线性表</code>和<code>受限线性表</code>。一般线性表也就是我们通常所说的线性表，可以自由的删除或添加结点。受限线性表主要包括栈和队列，受限表示对结点的操作受限制。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>线性表的逻辑结构简单，便于实现和操作。因此，线性表这种数据结构在实际应用中是广泛采用的一种数据结构。</p><h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3><p>线性表具有以下特点：</p><ul><li>集合中元素个数有限且数据类型相同。    </li><li>集合中必存在唯一的一个第一元素和最后元素。</li><li>除最后一个元素之外，均有唯一的后继(后件)。</li><li>除第一个元素之外，均有唯一的前驱(前件)。</li></ul><h2 id="存储结构"><a href="#存储结构" class="headerlink" title="存储结构"></a>存储结构</h2><p>线性表是线性结构的一种数据结构，线性表有两种，分别是顺序存储结构的线性表(叫做<code>顺序表</code>)和链式存储结构的线性表(叫做<code>链表</code>)。</p><h3 id="顺序存储结构"><a href="#顺序存储结构" class="headerlink" title="顺序存储结构"></a>顺序存储结构</h3><p><strong><code>顺序存储结构</code></strong>指的是用一段地址连续的存储单元依次存储线性表的数据元素。它以<code>物理位置相邻</code>来表示线性表中数据元素间的逻辑关系，可随机存取表中任一元素。</p><p>顺序表是指顺序存储结构的线性表，使用数组实现，一组地址连续的存储单元，数组大小有两种方式指定，一是静态分配，二是动态扩展。顺序表表现在物理内存中，也就是物理上的存储方式，事实上就是在内存中找个初始地址，然后通过占位的形式，把一定的内存空间给占了，然后把相同数据类型的数据元素依次放在这块空地中。注意，这块物理内存的地址空间是连续的。</p><p>线性表的顺序存储结构，在存、取数据时，时间复杂度是 <code>O(1)</code>；而在插入或者删除时，时间复杂度是 <code>O(n)</code>。也就是说线性表的顺序存储结构比较适合存取数据，不适合经常插入和删除数据的应用。</p><p>优点：</p><ul><li>无需为了表示表中元素之间的逻辑关系而增加额外的存储空间(相对于链式存储而言)；</li><li>可以快速的存取表中任意位置的元素；</li><li>存储密度大(等于1)，存储空间利用率高。</li></ul><p>缺点：</p><ul><li>插入和删除操作需要移动大量的元素；</li><li>当线性表长度变化较大时，难以确定存储空间的容量；</li><li>容易造成存储空间的“碎片”(因为线性表的顺序存储结构申请的内存空间都以连续的，如果因为某些操作导致某个部分出现了一小块的不连续内存空间，因为这一小块内存空间太小不能够再次被利用/分配，那么就造成了内存浪费，也就是“碎片”)。</li></ul><h3 id="链式存储结构"><a href="#链式存储结构" class="headerlink" title="链式存储结构"></a>链式存储结构</h3><p><strong><code>链式存储结构</code></strong>指的是用一组任意的存储单元存储线性表中的数据元素。它的存储单元可以是连续的，也可以是不连续的。</p><p>在表示数据元素之间的逻辑关系时，除了存储其本身的信息之外，还需存储一个指示其直接后继的信息(即直接后继的存储位置)，这两部分信息组成数据元素的存储映像，称为结点。它包括两个域：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域(指针域中存储的信息称为指针或链)。</p><p>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素，这组存储单元可以存在内存中未被占用的任意位置。与顺序存储相比，允许存储空间不连续，插入删除时不需要移动大量的元素，只需修改指针即可，但查找某个元素，只能从头遍历整个链表。</p><p>线性表的链式存储结构，在存、取数据时，时间复杂度是 <code>O(n)</code>；而在插入或者删除时，时间复杂度是 <code>O(1)</code>。也就是说线性表的链式存储结构比较适合插入或者删除数据，不适合经常查找数据的应用。</p><p>优点：</p><ul><li>无需分配存储空间，只要有就可以分配，元素个数不受限制；</li><li>可以快速插入或者删除元素。</li></ul><p>缺点：</p><ul><li>查找操作需要从表头开始查找；</li><li>存储密度小(小于1)，存储空间利用率低。</li></ul><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><table><thead><tr><th style="text-align:center">存储方式</th><th>顺序存储结构</th><th>链式存储结构</th></tr></thead><tbody><tr><td style="text-align:center">内存分配</td><td>用一段连续的存储单元依次存储线性表的数据元素</td><td>用一组任意的存储单元存放线性表的元素</td></tr><tr><td style="text-align:center">空间性能</td><td>需要预分配存储空间，分大了浪费，小了容易发生上溢</td><td>不需要分配存储空间，只要有就可以分配，元素个数不受限制</td></tr><tr><td style="text-align:center">时间性能</td><td>查找 O(1)、插入和删除 O(n)</td><td>查找 O(n)、插入和删除 O(1)</td></tr><tr><td style="text-align:center">存储密度</td><td>大</td><td>小</td></tr><tr><td style="text-align:center">应用</td><td>顺序表</td><td>链表</td></tr></tbody></table><h2 id="结构特点"><a href="#结构特点" class="headerlink" title="结构特点"></a>结构特点</h2><p>线性结构具有以下特点：</p><ol><li>均匀性：虽然不同数据表的数据元素可以是各种各样的，但对于同一线性表的各数据元素必定具有相同的数据类型和长度。</li><li>有序性：各数据元素在线性表中的位置只取决于它们的序号，数据元素之前的相对位置是线性的，即存在唯一的“第一个“和“最后一个”的数据元素，除了第一个和最后一个外，其它元素前面均只有一个数据元素(直接前驱)和后面均只有一个数据元素（直接后继）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>数据结构简介</title>
      <link href="/posts/2019/b8928e0e.html"/>
      <url>/posts/2019/b8928e0e.html</url>
      
        <content type="html"><![CDATA[<p><strong><code>数据结构(Data Structure)</code></strong>是<code>计算机存储、组织数据的方式</code>。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p><h2 id="数据结构定义"><a href="#数据结构定义" class="headerlink" title="数据结构定义"></a>数据结构定义</h2><p><strong><code>数据结构</code></strong>是指<strong>相互之间存在着一种或多种关系的数据元素的集合和该集合中数据元素之间的关系组成</strong>。记为：</p><pre><code>Data_Structure=(D,R)</code></pre><p>其中 <code>D</code> 是数据元素的集合，<code>R</code> 是该集合中所有元素之间的关系的有限集合。</p><p>数据结构具体指同一类数据元素中各元素之间的相互关系，包括三个组成成分，数据的<code>逻辑结构</code>、<code>存储结构</code>和<code>数据运算结构</code>。</p><h2 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h2><p><strong><code>数据的逻辑结构</code></strong>是指反映数据元素之间的逻辑关系的数据结构，其中的逻辑关系是指数据元素之间的前后件关系，而与他们在计算机中的存储位置无关。逻辑结构分为以下几种：</p><ul><li><strong><code>集合结构：</code></strong>数据元素<code>同属一个集合</code>，单个数据元素之间<code>没有任何关系</code>。</li><li><strong><code>线性结构：</code></strong>数据结构中的元素存在<code>一对一</code>的相互关系。</li><li><strong><code>树形结构：</code></strong>数据结构中的元素存在<code>一对多</code>的相互关系。</li><li><strong><code>图形结构：</code></strong>数据结构中的元素存在<code>多对多</code>的相互关系。</li></ul><h2 id="数据的物理结构"><a href="#数据的物理结构" class="headerlink" title="数据的物理结构"></a>数据的物理结构</h2><p><strong><code>数据的物理结构</code></strong>是指数据的逻辑结构在计算机存储空间的存放形式，它包括数据元素的机内表示和关系的机内表示。物理结构又叫存储结构，分为以下几种：</p><ul><li><strong><code>顺序存储结构：</code></strong>一段连续的内存空间。优点：随机访问；缺点：插入删除效率低，大小固定。</li><li><strong><code>链式存储结构：</code></strong>不连续的内存空间。优点：大小动态扩展，插入删除效率高；缺点：不能随机访问。</li><li><strong><code>索引存储结构：</code></strong>为了方便查找，整体无序，但索引块之间有序，需要额外空间，存储索引表。优点：对顺序查找的一种改进，查找效率高；缺点：需额外空间存储索引。</li><li><strong><code>散列存储结构：</code></strong>选取某个函数，数据元素根据函数计算存储位置可能存在多个数据元素存储在同一位置，引起地址冲。优点：查找基于数据本身即可找到，查找效率高，存取效率高；缺点：存取随机，不便于顺序查找。</li></ul><blockquote><p>由于具体实现的方法有顺序、链接、索引、散列等多种，所以，一种数据结构可表示成一种或多种存储结构。</p></blockquote><h2 id="数据结构算法"><a href="#数据结构算法" class="headerlink" title="数据结构算法"></a>数据结构算法</h2><p><strong><code>数据结构算法</code></strong>的设计取决于数据的逻辑结构，而算法的实现依赖于采用的存储结构。数据的存储结构实质上是它的逻辑结构在计算机存储器中的实现，为了全面的反映一个数据的逻辑结构，它在存储器中的映象包括两方面内容，即数据元素之间的信息和数据元素之间的关系。不同数据结构有其相应的若干运算。数据的运算是在数据的逻辑结构上定义的操作算法，如检索、插入、删除、更新和排序等。</p><p>数据的运算是数据结构的一个重要方面，讨论任一种数据结构时都离不开对该结构上的数据运算及其实现算法的讨论。</p><p>数据结构不同于数据类型，也不同于数据对象，它不仅要描述数据类型的数据对象，而且要描述数据对象各元素之间的相互关系。</p><p>数据类型是一个值的集合和定义在这个值集上的一组操作的总称。数据类型可分为两类：原子类型、结构类型。一方面，在程序设计语言中，每一个数据都属于某种数据类型。类型明显或隐含地规定了数据的取值范围、存储方式以及允许进行的运算。可以认为，数据类型是在程序设计中已经实现了的数据结构。另一方面，在程序设计过程中，当需要引入某种新的数据结构时，总是借助编程语言所提供的数据类型来描述数据的存储结构。</p><p>对每一个数据结构而言，必定存在与它密切相关的一组操作。若操作的种类和数目不同，即使逻辑结构相同，数据结构能起的作用也不同。不同的数据结构其操作集不同，但下列操作必不可缺：</p><ol><li>结构的生成；</li><li>结构的销毁；</li><li>在结构中查找满足规定条件的数据元素；</li><li>在结构中插入新的数据元素；</li><li>删除结构中已经存在的数据元素；</li><li>遍历。</li></ol><h2 id="数据结构分类"><a href="#数据结构分类" class="headerlink" title="数据结构分类"></a>数据结构分类</h2><p>每一种数据结构都有着独特的数据存储方式，常用的数据结构有：数组、栈、链表、队列、树、图、堆、散列表等，如图所示：<br><img src="https://henleylee.github.io/medias/study/data_structure_category.png" alt="数据结构分类"></p><h3 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h3><p><strong><code>数组</code></strong>是可以再内存中连续存储多个元素的结构，在内存中的分配也是连续的，数组中的元素通过数组下标进行访问，数组下标从0开始。</p><ul><li><p>优点：</p><ul><li>按照索引查询元素速度快</li><li>按照索引遍历数组方便</li></ul></li><li><p>缺点：</p><ul><li>数组的大小固定后就无法扩容了</li><li>数组只能存储一种类型的数据</li><li>添加，删除的操作慢，因为要移动其他的元素。</li></ul></li></ul><p>适用场景：查询频繁，对存储空间要求不大，很少增加和删除的情况。</p><h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p><strong><code>栈</code></strong>是一种特殊的线性表，仅能在线性表的一端操作，栈顶允许操作，栈底不允许操作。栈的特点是<code>先进后出</code>，或者说是<code>后进先出</code>，从栈顶放入元素的操作叫入栈，取出元素叫出栈。 </p><p>栈的结构就像一个集装箱，越先放进去的东西越晚才能拿出来，所以，栈常应用于实现递归功能方面的场景，例如斐波那契数列。</p><h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p><strong><code>队列</code></strong>与栈一样也是一种特殊的线性表，它只允许在表的前端(front)进行删除操作，而在表的后端(rear)进行插入操作。队列的特点是<code>先进先出</code>，或者说是<code>后进后出</code>，进行插入操作的端称为队尾，进行删除操作的端称为队头，从一端放入元素的操作称为入队，取出元素为出队。队列中没有元素时，称为空队列。</p><p>使用场景：因为队列先进先出的特点，在多线程阻塞队列管理中非常适用。</p><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><p><strong><code>链表</code></strong>是物理存储单元上非连续、非顺序的存储结构，它既可以表示线性结构，也可以用于表示非线性结构，数据元素的逻辑顺序是通过链表的指针地址实现。链表由一系列结点(链表中每一个元素称为结点)组成，结点可以在运行时动态生成。每个结点包括两个部分：一个是存储数据元素的数据域，另一个是存储下一个结点地址的指针域。根据指针的指向，链表能形成不同的结构，例如单链表，双向链表，循环链表等。 </p><ul><li><p>链表的优点：</p><ul><li>链表是很常用的一种数据结构，不需要初始化容量，可以任意加减元素；</li><li>添加或者删除元素时只需要改变前后两个元素结点的指针域指向地址即可，所以添加，删除很快；</li></ul></li><li><p>缺点：</p><ul><li>因为含有大量的指针域，占用空间较大；</li><li>查找元素需要遍历链表来查找，非常耗时。</li></ul></li></ul><p>适用场景：数据量较小，需要频繁增加，删除操作的场景。</p><h3 id="树"><a href="#树" class="headerlink" title="树"></a>树</h3><p><strong><code>树</code></strong>是由n(n&gt;0)个有限节点组成一个具有层次关系的集合。把它叫做<code>树</code>是因为它看起来像一棵倒挂的树，也就是说它是根朝上，而叶朝下的。它具有以下的特点：</p><ul><li>有且仅有一个根结点(没有父节点的节点称为根节点)；</li><li>每个节点有零个或多个子节点；</li><li>每一个非根节点有且只有一个父节点；</li><li>除了根节点外，每个子节点可以分为多个不相交的子树；</li></ul><p>在日常的应用中，我们讨论和用的更多的是树的其中一种结构，就是二叉树。二叉树是树的特殊一种，具有如下特点：</p><ul><li>每个结点最多有两颗子树，结点的度最大为2。</li><li>左子树和右子树是有顺序的，次序不能颠倒。</li><li>即使某结点只有一个子树，也要区分左右子树。</li></ul><p>二叉树是一种比较有用的折中方案，它添加，删除元素都很快，并且在查找方面也有很多的算法优化，所以，二叉树既有链表的好处，也有数组的好处，是两者的优化方案，在处理大批量的动态数据方面非常有用。</p><h3 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h3><p><strong><code>堆</code></strong>是一种特殊的树形数据结构，每个结点都有一个值。堆的特点是根结点的值最小或最大，且根结点的两个子树也是一个堆。它具有以下的特点：</p><ul><li>堆中某个节点的值总是不大于或不小于其父节点的值；</li><li>堆总是一棵完全二叉树。</li></ul><p>将根节点最大的堆叫做最大堆或大根堆，根节点最小的堆叫做最小堆或小根堆。常见的堆有二叉堆、斐波那契堆等。因为堆有序的特点，一般用来做数组中的排序，称为堆排序。</p><h3 id="图"><a href="#图" class="headerlink" title="图"></a>图</h3><p><strong><code>图</code></strong>是由结点的有穷集合 V 和边的集合 E 组成。其中，为了与树形结构加以区别，在图结构中常常将结点称为顶点，边是顶点的有序偶对，若两个顶点之间存在一条边，就表示这两个顶点具有相邻关系。 </p><p>按照顶点指向的方向可分为无向图和有向图。图是一种比较复杂的数据结构，在存储数据上有着比较复杂和高效的算法，分别有邻接矩阵 、邻接表、十字链表、邻接多重表、边集数组等存储结构。</p><h3 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h3><p><strong><code>散列表</code></strong>也叫哈希表，是根据键和值(key 和 value)直接进行访问的数据结构，通过 <code>key</code> 和 <code>value</code> 来映射到集合中的一个位置，这样就可以很快找到集合中的对应元素。</p><p><code>f(key)</code> 称为散列函数或哈希函数，用来记录数据的存储位置，若结构中存在键和 <code>key</code> 相等的记录，则必定在 <code>f(K)</code> 的存储位置上。而散列表就是把 <code>key</code> 通过一个固定的算法函数(哈希函数)转换成一个整型数字，然后就将该数字对数组长度进行取余，取余结果就当作数组的下标，将 <code>value</code> 存储在以该数字为下标的数组空间里，这种存储空间可以充分利用数组的查找优势来查找元素，所以查找的速度很快。</p><p>哈希表在应用中也是比较常见的，就如 Java 中有些集合类就是借鉴了哈希原理构造的，例如 <code>HashMap</code>、<code>Hashtable</code> 等，利用哈希表的优势，对于集合的查找元素时非常方便的，然而，因为哈希表是基于数组衍生的数据结构，在添加删除元素方面是比较慢的，所以很多时候需要用到一种数组链表来做，也就是拉链法。拉链法是数组结合链表的一种结构，较早前的 <code>HashMap</code> 底层的存储就是采用这种结构，直到 JDK 1.8 之后才换成了数组加红黑树的结构。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP 协议中的三次握手和四次挥手</title>
      <link href="/posts/2019/3375718e.html"/>
      <url>/posts/2019/3375718e.html</url>
      
        <content type="html"><![CDATA[<p>TCP 在传输之前会进行三次沟通，一般称为<strong><code>三次握手</code></strong>；传完数据断开的时候要进行四次沟通，一般称为<strong><code>四次挥手</code></strong>。</p><h2 id="什是-TCP-协议"><a href="#什是-TCP-协议" class="headerlink" title="什是 TCP 协议"></a>什是 TCP 协议</h2><p><strong><code>TCP</code></strong>是 Transmission Control Protocol 的简称，中文名是<code>传输控制协议</code>，是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，完成第四层传输层所指定的功能。</p><blockquote><p><code>TCP</code> 是面向连接的、可靠的、缓慢的、可靠交付以及保证消息顺序的。<code>TCP</code> 用于实现可靠传输的情况，文件非常重要，对网络拥堵有较高的要求的情况。</p></blockquote><h2 id="TCP-报文格式"><a href="#TCP-报文格式" class="headerlink" title="TCP 报文格式"></a>TCP 报文格式</h2><p><code>TCP</code> 报文是 TCP 层传输的数据单元，也叫报文段，分为<code>报头</code>和<code>数据</code>两部分。<code>TCP</code> 报文的格式如下图所示：<br><img src="https://henleylee.github.io/medias/study/tcp_message_header.png" alt="TCP报文格式"></p><p><code>报头</code>包含以下信息：</p><ul><li><code>源端口(16位)：</code>源端口用来标识报文的返回地址。</li><li><code>目的端口(16位)：</code>目的端口指明接收方计算机上的应用程序接口。</li><li><code>序列号(32位)：</code>也称为顺序号(Sequence Number)，简写为 seq。TCP 是面向字节流的，TCP 连接中传送的字节流中的每个字节都按顺序编号。整个要传送的字节流的起始序号必须要在连接建立时设置。</li><li><code>确认号(32位)：</code>也称为应答号(Acknowledgment Number)，简写为 ack。在握手阶段，确认序号将发送方的序号加1作为回答。</li><li><code>数据偏移(4位)：</code>也成为首部长度，TCP 的头长度最长可为60字节(二进制1111换算为十进制为15，15*4字节=60字节)。</li><li><code>保留(6位)：</code>为将来定义新的用途保留，现在一般置0。</li><li><code>标志位(6位)：</code>TCP 报头信息中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控 TCP 的状态机的，依次为 <code>URG</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>SYN</code>、<code>FIN</code>。</li><li><code>窗口(16位)：</code>滑动窗口大小，用来告知发送端接受端的缓存大小，以此控制发送端发送数据的速率，从而达到流量控制。窗口大小是一个16bit字段，因而窗口大小最大为65535。</li><li><code>检验和(16位)：</code>检验和覆盖了整个的 TCP 报文段： TCP 首部和 TCP 数据。这是一个强制性的字段，一定是由发端计算和存储，并由收端进行验证。</li><li><code>紧急指针(16位)：</code>一般不使用，只有当 URG 标志置1时紧急指针才有效。紧急指针是一个正的偏移量，和序号字段中的值相加表示紧急数据最后一个字节的序号。</li><li><code>选项(长度可变)：</code>长度可变，最长可达40字节。通常为空，可根据首部长度推算。用于发送方与接收方协商最大报文段长度(Maximum Segment Size，简称 MSS)或在高速网络环境下作窗口调节因子时使用。首部字段还定义了一个时间戳选项。</li></ul><h3 id="序号"><a href="#序号" class="headerlink" title="序号"></a>序号</h3><p><code>TCP</code> 是一个面向连接的、可靠的传输协议。而这个可靠传输的功能则是靠<code>32位序列号</code>和<code>32位确认号</code>实现。</p><ul><li><code>序列号(Sequence Number)：</code>seq 序号，占32位，用来标识从 TCP 源端向目的端发送的字节流，发起方发送数据时对此进行标记。在 TCP 传送的流中，每一个字节一个序号，序号是本报文段发送的数据组的第一个字节的序号，所以序号确保了 TCP 传输的有序性。</li><li><code>确认号(Acknowledgment Number)：</code>ack 序号，占32位，指明下一个期待收到的字节序号，表明该序号之前的所有数据已经正确无误的收到。确认号只有当 ACK 标志为1时才有效，ack=seq+1。</li></ul><blockquote><p>序列号和确认号是 TCP 可靠传输的关键部分。</p></blockquote><h3 id="标志位"><a href="#标志位" class="headerlink" title="标志位"></a>标志位</h3><p>TCP 报头信息中有6个标志比特，它们中的多个可同时被设置为1，主要是用于操控 TCP 的状态机的，依次为 <code>URG</code>、<code>ACK</code>、<code>PSH</code>、<code>RST</code>、<code>SYN</code>、<code>FIN</code>。每个标志位的含义如下：</p><table><thead><tr><th style="text-align:center">标志位</th><th>含义</th></tr></thead><tbody><tr><td style="text-align:center">URG</td><td>表示 TCP 包的紧急指针域有效，用来保证 TCP 连接不被中断，并且督促中间层设备要尽快处理这些数据。</td></tr><tr><td style="text-align:center">ACK</td><td>表示应答域有效，就是说前面所说的 TCP 应答号将会包含在 TCP 数据包中；有两个取值：0和1，为1的时候表示应答域有效，反之为0。</td></tr><tr><td style="text-align:center">PSH</td><td>表示 Push 操作。所谓 Push 操作就是指在数据包到达接收端以后，立即传送给应用程序，而不是在缓冲区中排队。</td></tr><tr><td style="text-align:center">RST</td><td>表示连接复位请求。用来复位那些产生错误的连接，也被用来拒绝错误和非法的数据包。</td></tr><tr><td style="text-align:center">SYN</td><td>表示同步序号，用来建立连接。SYN 标志位和 ACK 标志位搭配使用，当连接请求的时候，SYN=1，ACK=0；连接被响应的时候，SYN=1，ACK=1(这个标志的数据包经常被用来进行端口扫描)。</td></tr><tr><td style="text-align:center">FIN</td><td>表示发送端已经达到数据末尾，也就是说双方的数据传送完成，没有数据可以传送了，发送 FIN 标志位的 TCP 数据包后，连接将被断开(这个标志的数据包也经常被用于进行端口扫描)。</td></tr></tbody></table><blockquote><p>需要注意的是：不要将<code>确认号 ack</code> 与<code>标志位 ACK</code> 搞混了；<code>确认方ack=发起方req+1</code>，两端配对。</p></blockquote><h2 id="TCP-连接的建立-三次握手"><a href="#TCP-连接的建立-三次握手" class="headerlink" title="TCP 连接的建立(三次握手)"></a>TCP 连接的建立(三次握手)</h2><p><code>TCP</code> 是面向连接的<code>传输层协议</code>，无论哪一方向另一方发送数据之前，都必须先在双方之间建立一条连接。当主动方发出 <code>SYN</code> 连接请求后，等待对方回答 <code>SYN+ACK</code>，并最终对对方的 <code>SYN</code> 执行 <code>ACK</code> 确认。</p><p><img src="https://henleylee.github.io/medias/study/tcp_connection_establish.png" alt="TCP连接的建立(三次握手)"><br>TCP 三次握手的过程如下：</p><ul><li>第一次握手：建立连接时，客户端发送 <code>SYN</code> 报文段，设置 <code>seq=x</code>；然后，客户端进入 <code>SYN_SEND</code> 状态，等待服务器的确认；</li><li>第二次握手：服务器收到客户端的 <code>SYN</code> 报文段，需要确认客户端的 <code>SYN</code> 报文段，设置 <code>ack=x+1(seq+1)</code>，同时自己也发送一个 <code>SYN</code> 报文段，设置 <code>seq=y</code>(即 <code>SYN+ACK</code> 包)，此时服务器进入 <code>SYN_RECV</code> 状态；</li><li>第三次握手：客户端收到服务器的 <code>SYN+ACK</code> 报文段。然后设置 <code>ack=y+1(seq+1)</code>，向服务器发送 <code>ACK</code> 报文段，发送完成后，客户端和服务器端都进入 <code>ESTABLISHED</code> 状态，完成 TCP 三次握手。</li></ul><p>完成三次握手后，客户端和服务器端就可以开始传送数据。</p><blockquote><p>在 <code>TCP/IP</code> 协议中，<code>TCP</code> 协议提供可靠的连接服务，连接是通过<code>三次握手</code>进行初始化的。<code>三次握手</code>的目的是同步连接双方的序列号和确认号并交换 <code>TCP</code> 窗口大小信息。</p></blockquote><h2 id="TCP-连接的释放-四次挥手"><a href="#TCP-连接的释放-四次挥手" class="headerlink" title="TCP 连接的释放(四次挥手)"></a>TCP 连接的释放(四次挥手)</h2><p><code>TCP</code> 连接是双向传输的对等的模式，就是说双方都可以同时向对方发送或接收数据。因此，每个方向都必须要单独进行关闭，这一原则是当一方完成数据发送任务后，发送一个 <code>FIN</code> 来终止这一方向的连接，收到一个 <code>FIN</code> 只是意味着这一方向上没有数据流动了，即不会再收到数据了，但是在这个 <code>TCP</code> 连接上仍然能够发送数据，直到这一方向也发送了 <code>FIN</code>。</p><p><img src="https://henleylee.github.io/medias/study/tcp_connection_release.png" alt="TCP连接的释放(四次挥手)"><br>TCP 四次挥手的过程如下：</p><ul><li>第一次挥手：主机A(可以是客户端，也可以是服务端)发送一个 <code>FIN</code> 报文段，设置 <code>seq=x</code>，用来关闭主机A到主机B的数据传送，此时，主机A进入 <code>FIN_WAIT_1</code> 状态；</li><li>第二次挥手：主机B收到主机A发送的 <code>FIN</code> 报文段，向主机A发回一个 <code>ACK</code>，设置 <code>seq=x+1</code>，主机A进入 <code>FIN_WAIT_2</code> 状态；</li><li>第三次挥手：主机B向主机A发送 <code>FIN</code> 报文段，设置 <code>seq=y</code>，请求关闭连接，同时主机B进入 <code>CLOSE_WAIT</code> 状态；</li><li>第四次挥手：主机A收到主机B发送的 <code>FIN</code> 报文段，设置 <code>seq=y+1</code>，向主机B发送 <code>ACK</code> 报文段，然后主机A进入 <code>TIME_WAIT</code> 状态；主机B收到主机A的 <code>ACK</code>报文段以后，就关闭连接。</li></ul><p>完成四次挥手后，客户端和服务器端建立的连接被释放。</p><blockquote><p>无论是客户还是服务器，任何一端都可以执行主动关闭。通常情况是，客户执行主动关闭，但是某些协议，例如，HTTP/1.0 却由服务器执行主动关闭。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>TCP</code> 连接从建立到释放的过程如下图所示：<br><img src="https://henleylee.github.io/medias/study/tcp_data_exchange.png" alt=" TCP的状态机"></p><ul><li><p>为什么建立连接是三次握手，关闭连接确是四次挥手呢？<br>建立连接的时候， 服务器在 <code>LISTEN</code> 状态下，收到建立连接请求的 <code>SYN</code> 报文后，把 <code>ACK</code> 和 <code>SYN</code> 放在一个报文里发送给客户端。而关闭连接时，服务器收到对方的 <code>FIN</code> 报文时，仅仅表示对方不再发送数据了但是还能接收数据，而自己也未必全部数据都发送给对方了，所以己方可以立即关闭，也可以发送一些数据给对方后，再发送 <code>FIN</code> 报文给对方来表示同意现在关闭连接，因此，己方 <code>ACK</code> 和 <code>FIN</code> 一般都会分开发送，从而导致多了一次。</p></li><li><p>如果已经建立了连接，但是客户端突然出现故障了怎么办？<br><code>TCP</code> 还设有一个保活计时器，显然，客户端如果出现故障，服务器不能一直等下去，白白浪费资源。服务器每收到一次客户端的请求后都会重新复位这个计时器，时间通常是设置为2小时，若两小时还没有收到客户端的任何数据，服务器就会发送一个探测报文段，以后每隔75分钟发送一次。若一连发送10个探测报文仍然没反应，服务器就认为客户端出了故障，接着就关闭连接。 </p></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>TCP 和 UDP 协议的区别</title>
      <link href="/posts/2019/771dd6d2.html"/>
      <url>/posts/2019/771dd6d2.html</url>
      
        <content type="html"><![CDATA[<p><code>TCP/IP</code> 是个协议组，可分为三个层次：<code>网络层</code>、<code>传输层</code>和<code>应用层</code>。</p><ul><li>在网络层有 <code>IP</code>、<code>ICMP</code>、<code>ARP</code>、<code>RARP</code> 和 <code>BOOTP</code> 协议。</li><li>在传输层有 <code>TCP</code> 和 <code>UDP</code> 协议。</li><li>在应用层有 <code>FTP</code>、<code>HTTP</code>、<code>TELNET</code>、<code>SMTP</code>、<code>DNS</code>、<code>TFTP</code> 等协议。</li></ul><h2 id="什是-TCP-协议"><a href="#什是-TCP-协议" class="headerlink" title="什是 TCP 协议"></a>什是 TCP 协议</h2><p><strong><code>TCP</code></strong>是 Transmission Control Protocol 的简称，中文名是<code>传输控制协议</code>，是一种面向连接的、可靠的、基于字节流的传输层通信协议，由 IETF 的 RFC 793 定义。在简化的计算机网络 OSI 模型中，完成第四层传输层所指定的功能。</p><blockquote><p><code>TCP</code> 是面向连接的、可靠的、缓慢的、可靠交付以及保证消息顺序的。<code>TCP</code> 用于实现可靠传输的情况，文件非常重要，对网络拥堵有较高的要求的情况。</p></blockquote><h2 id="什是-UDP-协议"><a href="#什是-UDP-协议" class="headerlink" title="什是 UDP 协议"></a>什是 UDP 协议</h2><p><strong><code>UDP</code></strong>是 User Datagram Protocol 的简称，中文名是<code>用户数据报协议</code>，是一种无连接的、提供面向事务的简单且不可靠的传输层通信协议，由 IETF 的 RFC 768 定义。在简化的计算机网络 OSI 模型中，同样完成第四层传输层所指定的功能。UDP 在 IP 报文的协议号是 17。</p><blockquote><p><code>UDP</code> 是无连接的、不可靠的、没有序列保证，但是一个快速传输的协议。<code>UDP</code> 用于高速传输和实时性较高的场合(即时通信)，<code>UDP</code> 常被用于广播和细节控制交给应用的通信传输。</p></blockquote><h2 id="TCP-和-UDP-的相同点"><a href="#TCP-和-UDP-的相同点" class="headerlink" title="TCP 和 UDP 的相同点"></a>TCP 和 UDP 的相同点</h2><ol><li>TCP 和 UDP 在简化的计算机网络 OSI 模型中，都是<code>传输层协议</code>。</li><li>TCP 和 UDP 都是<code>位于 IP 层之上</code>。</li><li>TCP 和 UDP 都是<code>保护网络层的传输</code>，双方的通信都<code>需要开放端口</code>。</li></ol><h2 id="TCP-和-UDP-的不同点"><a href="#TCP-和-UDP-的不同点" class="headerlink" title="TCP 和 UDP 的不同点"></a>TCP 和 UDP 的不同点</h2><ol><li><code>TCP 是面向连接的协议，而 UDP 是无连接的协议</code>。使用 TCP 协议在发送数据之前需要建立连接，而使用 UDP 协议在发送数据之前不需要建立连接。</li><li><code>TCP 提供可靠的服务，而 UDP 提供不可靠的服务</code>。使用 TCP 协议发送的消息是保证交付给客户端的，如果消息在传输过程中丢失，那么它将重发，这是由 TCP 协议本身控制的。</li><li><code>TCP 保证数据的有序性，而 UDP 不保证数据的有序性</code>。</li><li><code>TCP 不保存数据的边界，而 UDP 保证</code>。TCP 中数据以字节流的形式发送，并没有明显的标志表明传输信号消息(段)的边界。在 UDP 中，数据包单独发送的，只有当它们到达时，才会再次集成。</li><li><code>TCP 传输速度比较慢，而 UDP 传输速度较快</code>。TCP 在传输数据之前必须先建立连接，以保证消息的可靠交付和有序性，需要做的事情比 UDP 多。</li><li><code>TCP 是重量级的协议，而 UDP 是一个轻量级的协议</code>。UDP 传输的信息中不承担任何间接创造连接，保证交货或秩序的的信息。</li><li><code>TCP 数据包报头大，而 UDP 数据包报头小</code>。TCP 数据包报头的大小是20字节，包含序列号、数据偏移量、控制标志、窗口、紧急指针、可选项、填充项、校验和、源端口和目的端口；UDP 数据报报头是8个字节，只包含长度、源端口号、目的端口、校验和。</li><li><code>TCP 有流量控制，而 UDP 没有流量控制</code>。TCP 在任何用户数据可以被发送之前，需要三数据包来设置一个套接字连接。</li><li><code>TCP 对系统资源要求较多，而 UDP 对系统资源要求较少</code>。</li><li><code>TCP 是点到点的，而 UDP 支持一对一、一对多、多对一和多对多的交互通信</code>。</li><li><code>TCP 最适合需要高可靠且对传输时间要求不高的应用，而 UDP 适合需要快速且高效传输的应用</code>。</li><li><code>TCP 被应用于 FTP、HTTP、HTTPS、TELNET、SMTP 等协议，而 UDP 被应用于 DNS、TFTP、DHCP、SNMP、TFTP 等协议</code>。</li></ol><p>TCP 和 UDP 主要区别如下表所示：</p><table><thead><tr><th style="text-align:center"></th><th style="text-align:center">TCP</th><th style="text-align:center">UDP</th></tr></thead><tbody><tr><td style="text-align:center">是否连接</td><td style="text-align:center">面向连接</td><td style="text-align:center">面向非连接</td></tr><tr><td style="text-align:center">程序结构</td><td style="text-align:center">复杂</td><td style="text-align:center">简单</td></tr><tr><td style="text-align:center">传输速度</td><td style="text-align:center">较慢</td><td style="text-align:center">较快</td></tr><tr><td style="text-align:center">传输可靠性</td><td style="text-align:center">可靠</td><td style="text-align:center">不可靠</td></tr><tr><td style="text-align:center">数据正确性</td><td style="text-align:center">保证</td><td style="text-align:center">不保证</td></tr><tr><td style="text-align:center">数据有序性</td><td style="text-align:center">保证</td><td style="text-align:center">不保证</td></tr><tr><td style="text-align:center">数据实时性</td><td style="text-align:center">较低</td><td style="text-align:center">较高</td></tr><tr><td style="text-align:center">系统资源要求</td><td style="text-align:center">较多</td><td style="text-align:center">较少</td></tr><tr><td style="text-align:center">应用场合</td><td style="text-align:center">传输大量的数据，对可靠性要求较高的场合</td><td style="text-align:center">传送少量数据、对可靠性要求不高的场景</td></tr></tbody></table><h2 id="TCP-和-UDP-的编程步骤"><a href="#TCP-和-UDP-的编程步骤" class="headerlink" title="TCP 和 UDP 的编程步骤"></a>TCP 和 UDP 的编程步骤</h2><p><code>TCP</code> 和 <code>UDP</code> 的编程都是基于 <code>Socket</code> 实现的。</p><h3 id="Socket-简介"><a href="#Socket-简介" class="headerlink" title="Socket 简介"></a>Socket 简介</h3><p><strong><code>Socket</code></strong>是应用层与 <code>TCP/IP</code> 协议族通信的中间软件抽象层，它是一组编程接口。在设计模式中，<code>Socket</code> 其实就是一个门面模式，它把复杂的 <code>TCP/IP</code> 协议族隐藏在 <code>Socket</code> 接口后面，对用户来说，一组简单的接口就是全部，让 <code>Socket</code> 去组织数据，以符合指定的协议。</p><p><code>Socket</code> 又称<code>套接字</code>，应用程序通常通过 <code>Socket</code> 向网络发出请求或者应答网络请求。</p><h3 id="TCP-的编程步骤"><a href="#TCP-的编程步骤" class="headerlink" title="TCP 的编程步骤"></a>TCP 的编程步骤</h3><ul><li><p>TCP 编程的<code>服务端</code>一般步骤是：<br>1、创建一个 socket，用函数 socket()；<br>2、设置 socket 属性，用函数 setsockopt()； <em>可选</em><br>3、绑定 IP 地址、端口等信息到 socket 上，用函数 bind();<br>4、开启监听，用函数 listen()；<br>5、接收客户端上来的连接，用函数 accept()；<br>6、收发数据，用函数 send()和 recv()，或者 read() 和 write();<br>7、关闭网络连接；<br>8、关闭监听；</p></li><li><p>TCP 编程的<code>客户端</code>一般步骤是：</p><ol><li>创建一个 socket，用函数 socket()；</li><li>设置 socket 属性，用函数 setsockopt()； <em>可选</em></li><li>绑定 IP 地址、端口等信息到 socket 上，用函数 bind()； <em>可选</em></li><li>设置要连接的对方的 IP 地址和端口等属性；</li><li>连接服务器，用函数 connect()；</li><li>收发数据，用函数 send() 和 recv()，或者 read() 和 write()；</li><li>关闭网络连接；</li></ol></li></ul><h3 id="UDP-的编程步骤"><a href="#UDP-的编程步骤" class="headerlink" title="UDP 的编程步骤"></a>UDP 的编程步骤</h3><ul><li><p>UDP 编程的<code>服务端</code>一般步骤是：</p><ol><li>创建一个 socket，用函数 socket()；</li><li>设置 socket 属性，用函数 setsockopt()； <em>可选</em></li><li>绑定 IP 地址、 端口等信息到 socket 上，用函数 bind()；</li><li>循环接收数据，用函数 recvfrom()；</li><li>关闭网络连接；</li></ol></li><li><p>UDP 编程的<code>客户端</code>一般步骤是：</p><ol><li>创建一个 socket，用函数 socket()；</li><li>设置 socket 属性，用函数 setsockopt()； <em>可选</em></li><li>绑定 IP 地址、端口等信息到 socket 上，用函数bind()； <em>可选</em></li><li>设置对方的 IP 地址和端口等属性；</li><li>发送数据，用函数 sendto()；</li><li>关闭网络连接；socket() 的参数不同</li></ol></li></ul><h3 id="编程步骤的区别"><a href="#编程步骤的区别" class="headerlink" title="编程步骤的区别"></a>编程步骤的区别</h3><p>TCP 和 UDP 的编程步骤区别如下：</p><ol><li>TCP 服务端需要调用 listen() 和 accept()，而 UDP 服务端不需要调用这两个方法；</li><li>TCP 收发数据用 send()/recv() 方法；而 UDP 收发数据用 sendto()/recvfrom() 方法；</li><li>TCP 地址信息在 connect()/accept() 时确定；而 UDP 在 sendto()/recvfrom() 中每次均需指定地址信息；</li><li>UDP 的 shutdown() 方法有效；而 UDP 的 shutdown() 方法无效。</li></ol><h2 id="为什么-UDP-有时比-TCP-更有优势"><a href="#为什么-UDP-有时比-TCP-更有优势" class="headerlink" title="为什么 UDP 有时比 TCP 更有优势"></a>为什么 UDP 有时比 TCP 更有优势</h2><p>UDP 以其简单、传输快的优势，在越来越多场景下取代了 TCP，如实时游戏。TCP 的传输虽然是可靠的，但是需要付出的代价更大，对数据内容正确性的检验必然占用计算机的处理时间和网络的带宽，因此 TCP 传输的效率不如 UDP 高。</p><ul><li>网速的提升给 UDP 的稳定性提供可靠网络保障，丢包率很低，如果使用应用层重传，能够确保传输的可靠性。</li><li>TCP 为了实现网络通信的可靠性，使用了复杂的拥塞控制算法，建立了繁琐的握手过程，由于 TCP 内置的系统协议栈中，极难对其进行改进。</li></ul><p>采用 TCP，一旦发生丢包，TCP 会将后续的包缓存起来，等前面的包重传并接收到后再继续发送，延时会越来越大；基于 UDP 对实时性要求较为严格的情况下，采用自定义重传机制，能够把丢包产生的延迟降到最低，尽量减少网络问题对游戏性造成影响。</p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中的 Handler 消息机制详解</title>
      <link href="/posts/2019/9669634f.html"/>
      <url>/posts/2019/9669634f.html</url>
      
        <content type="html"><![CDATA[<p>Android 应用程序是通过消息来驱动的，Android 某种意义上也可以说成是一个以消息驱动的系统，UI、事件、生命周期都和消息处理机制息息相关，并且消息处理机制在整个 Android 知识体系中也是尤其重要。</p><h2 id="消息处理机制"><a href="#消息处理机制" class="headerlink" title="消息处理机制"></a>消息处理机制</h2><p><strong><code>消息处理机制</code></strong>本质是一个线程开启循环模式持续监听并依次处理其他线程给它发的消息。</p><p>简单的说：一个线程开启一个无限循环模式，不断遍历自己的消息列表，如果有消息就挨个拿出来做处理，如果列表没消息，自己就堵塞(相当于 wait，让出 CPU 资源给其他线程)，其他线程如果想让该线程做什么事，就往该线程的消息队列插入消息，该线程会不断从队列里拿出消息做处理。</p><h2 id="Handler-简介"><a href="#Handler-简介" class="headerlink" title="Handler 简介"></a>Handler 简介</h2><p><strong><code>android.os.Handler</code></strong>是 Android 中相当经典的异步消息机制，在 Android 发展的历史长河中扮演着很重要的角色，无论是我们直接面对的应用层还是 FrameWork 层，使用的场景还是相当的多。</p><h3 id="Handler-的引入"><a href="#Handler-的引入" class="headerlink" title="Handler 的引入"></a>Handler 的引入</h3><p>在 Android 开发中，UI 操作是线程不安全的，为了保证 UI 操作是线程安全的，规定了只允许在 UI 线程更新 UI 组件，如果在子线程中尝试进行 UI 操作，程序就有可能会崩溃。</p><p>在多线程的应用场景中，将工作线程中需更新 UI 的操作信息传递到 UI 线程，从而实现多个线程并发更新 UI 的同时并保证线程安全，最终实现异步消息的处理，因此引入了 <strong><code>Handler 消息传递机制</code></strong>。</p><h3 id="Handler-的作用"><a href="#Handler-的作用" class="headerlink" title="Handler 的作用"></a>Handler 的作用</h3><p><code>Handler</code> 能够发送和处理 <code>Message</code> 和 <code>Runnable</code>，每个 <code>Handler</code> 对象对应一个 <code>Thread</code> 和 <code>Thread 的消息队列</code>。每当创建一个 <code>Handler</code>时，它就和所在线程的消息队列绑定在一起，然后就可以传递 <code>Message</code> 和 <code>Runnable</code> 到消息队列中，执行消息后就从消息队列中退出。</p><p><code>Handler</code> 有以下两个主要用途：</p><ul><li>执行定时任务：将未来某个时间点将要执行的 <code>Message</code> 或 <code>Runnable</code> 加入到消息队列；</li><li>线程间的通信：在子线程把需要在另一个线程执行的操作加入到消息队列中去。</li></ul><h2 id="Handler-消息机制"><a href="#Handler-消息机制" class="headerlink" title="Handler 消息机制"></a>Handler 消息机制</h2><p><strong><code>android.os.Handler</code></strong>是 Android 类库提供的用于接受、传递和处理 <code>Message</code>或 <code>Runnable</code>对象的处理类，它结合 <code>Looper</code>、<code>Message</code> 和 <code>MessageQueue</code> 以及当前线程实现了一个消息循环机制，用于实现任务的异步加载和处理。</p><p><code>Handler</code> 消息处理机制的流程图如下图所示：<br><img src="https://henleylee.github.io/medias/android/handler_process.png" alt="Handler消息处理机制流程图"></p><blockquote><p><code>Handler</code> 消息机制是 Android 的两大消息机制之一，另一个是 <code>Binder IPC</code> 机制。</p></blockquote><h3 id="消息机制架构"><a href="#消息机制架构" class="headerlink" title="消息机制架构"></a>消息机制架构</h3><p><code>Handler</code> 消息机制的架构图如下图所示：<br><img src="https://henleylee.github.io/medias/android/handler_architecture.png" alt="Handler消息机制架构图"></p><p>从 <code>Handler</code> 消息机制的架构图中可以看到：</p><ul><li><code>Looper</code> 有一个 <code>MessageQueue</code> 消息队列；</li><li><code>MessageQueue</code> 有一组待处理的 <code>Message</code>；</li><li><code>Message</code> 中有一个用于处理消息的 <code>Handler</code>；</li><li><code>Handler</code> 中有 <code>Looper</code> 和 <code>MessageQueue</code>。</li></ul><h3 id="消息机制核心类"><a href="#消息机制核心类" class="headerlink" title="消息机制核心类"></a>消息机制核心类</h3><p><code>Handler</code> 消息机制中有3个核心类：</p><ul><li><strong><code>Handler：</code></strong>处理程序</li><li><strong><code>MessageQueue：</code></strong>消息队列</li><li><strong><code>Looper：</code></strong>循环器</li></ul><p>它们之间的关系如下图所示：<br><img src="https://henleylee.github.io/medias/android/handler_core_classes.png" alt="Handler消息机制核心类关系"></p><h3 id="消息机制典型实例"><a href="#消息机制典型实例" class="headerlink" title="消息机制典型实例"></a>消息机制典型实例</h3><p>下面展示一个典型的关于 <code>Handler/Looper</code> 的线程：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LooperThread</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Handler mHandler<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Looper<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// process incoming messages here</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="Looper"><a href="#Looper" class="headerlink" title="Looper"></a>Looper</h2><p><strong><code>android.os.Looper</code></strong>用于为一个线程开启一个消息循环，按分发机制将消息分发给目标处理者。</p><blockquote><p>默认情况下，线程没有与之关联的消息循环；当一个线程运行到某处，准备创建一个消息循环，必须在将要运行循环的线程中先调用 <code>Looper.prepare()</code> 做一些准备工作(即：创建一个 Looper 对象，并把它设置进线程的本地存储区里)，然后继续调用 <code>Looper.loop()</code> 建立起消息处理循环，开始让它处理消息，直到循环停止。</p></blockquote><h3 id="prepare"><a href="#prepare" class="headerlink" title="prepare()"></a>prepare()</h3><p><strong><code>prepare()</code></strong>方法用于线程创建消息循环前做一些准备工作，创建一个 <code>Looper</code> 对象，并把它设置进线程的本地存储区里。对于无参的情况，默认调用 <code>prepare(true)</code>，表示的是当前 <code>Looper</code> 允许退出，而对于 <code>false</code> 的情况则表示当前 <code>Looper</code> 不允许退出。<code>prepare()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 每个线程只允许执行一次该方法，第二次执行时线程的TLS已有数据，则会抛出异常</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"Only one Looper may be created per thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建Looper对象，并保存到当前线程的TLS区域</span>    sThreadLocal<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Looper</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这里的 <code>sThreadLocal</code> 是 <code>ThreadLocal</code> 类型，<code>ThreadLocal</code> 表示<code>线程本地存储区</code>(Thread Local Storage，简称为 TLS)，每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域。</p><p><code>Looper.prepare()</code> 在每个线程只允许执行一次，该方法会创建 <code>Looper</code> 对象，<code>Looper</code> 的构造方法中会创建一个 <code>MessageQueue</code> 对象，再将 <code>Looper</code> 对象保存到当前线程本地存储区。<code>Looper</code> 的构造方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token function">Looper</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 创建MessageQueue对象</span>    mQueue <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MessageQueue</span><span class="token punctuation">(</span>quitAllowed<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 记录当前线程</span>    mThread <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>另外，与 <code>prepare()</code> 方法功能相近的，还有一个 <code>prepareMainLooper()</code> 方法，该方法主要在 <code>android.app.ActivityThread</code> 类中使用，它是为主线程创建一个 <code>Looper</code>，在主线程创建 <code>Looper</code> 对象中，就设置了不允许退出消息循环。<code>prepareMainLooper()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">prepareMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 设置不允许退出的Looper</span>    <span class="token function">prepare</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将当前的Looper保存为主Looper，每个线程只允许执行一次</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sMainLooper <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"The main Looper has already been prepared."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        sMainLooper <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="myLooper"><a href="#myLooper" class="headerlink" title="myLooper()"></a>myLooper()</h3><p><strong><code>myLooper()</code></strong>方法用于获取 <code>TLS</code> 存储的 <code>Looper</code> 对象。如果调用线程未与 <code>Looper</code> 关联(没有调用过 <code>prepare()</code> 方法)则返回 <code>null</code>。<code>myLooper()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token annotation punctuation">@Nullable</span> Looper <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> sThreadLocal<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>另外，与 <code>myLooper()</code> 方法功能相近的，还有一个 <code>getMainLooper()</code> 方法，该方法用于获取主线程的 <code>Looper</code> 对象。<code>getMainLooper()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Looper <span class="token function">getMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> sMainLooper<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="loop"><a href="#loop" class="headerlink" title="loop()"></a>loop()</h3><p><strong><code>loop()</code></strong>方法用于开启消息循环，让 <code>Looper</code> 开始工作，从消息队列里取出消息并处理。<code>loop()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取TLS存储的Looper对象</span>    <span class="token keyword">final</span> Looper me <span class="token operator">=</span> <span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>me <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span><span class="token string">"No Looper; Looper.prepare() wasn't called on this thread."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取Looper对象中的消息队列</span>    <span class="token keyword">final</span> MessageQueue queue <span class="token operator">=</span> me<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Make sure the identity of this thread is that of the local process,</span>    <span class="token comment" spellcheck="true">// and keep track of what that identity token actually is.</span>    Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 确保在权限检查时基于本地进程，而不是调用进程</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> ident <span class="token operator">=</span> Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 进入loop的主循环方法</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 取出消息队列中的下一条消息(可能会阻塞)</span>        Message msg <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// might block</span>        <span class="token comment" spellcheck="true">// 没有消息，则退出循环</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// No message indicates that the message queue is quitting.</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 默认为null，可通过setMessageLogging()方法来指定输出，用于debug功能</span>        <span class="token keyword">final</span> Printer logging <span class="token operator">=</span> me<span class="token punctuation">.</span>mLogging<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logging <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logging<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">">>>>> Dispatching to "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span>                    msg<span class="token punctuation">.</span>callback <span class="token operator">+</span> <span class="token string">": "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>what<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 用于分发Message</span>        msg<span class="token punctuation">.</span>target<span class="token punctuation">.</span><span class="token function">dispatchMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>        dispatchEnd <span class="token operator">=</span> needEndTime <span class="token operator">?</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>logging <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            logging<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"&lt;&lt;&lt;&lt;&lt; Finished to "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> msg<span class="token punctuation">.</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 恢复调用者信息</span>        <span class="token keyword">final</span> <span class="token keyword">long</span> newIdent <span class="token operator">=</span> Binder<span class="token punctuation">.</span><span class="token function">clearCallingIdentity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>loop()</code> 方法进入循环模式，不断重复下面的操作，直到没有消息时退出循环：</p><ul><li>读取 <code>MessageQueue</code> 的下一条 <code>Message</code>；</li><li>把 <code>Message</code> 分发给相应的 <code>target</code>；</li><li>再把分发后的 <code>Message</code> 回收到消息池，以便重复利用。</li></ul><p>这是这个消息处理的核心部分。另外，上面代码中可以看到有 <code>logging</code> 方法，这是用于 <code>debug</code> 的，默认情况下 <code>logging == null</code>，通过设置 <code>setMessageLogging()</code> 用来开启 <code>debug</code> 工作。</p><blockquote><p>注意：写在 <code>Looper.loop()</code> 之后的代码不会被执行，这个函数内部是一个循环，当调用 <code>mHandler.getLooper().quit()</code> 后，loop 才会中止，其后的代码才能得以运行。</p></blockquote><h3 id="quit"><a href="#quit" class="headerlink" title="quit()"></a>quit()</h3><p><strong><code>quit()</code></strong>方法用于退出消息循环，让 <code>Looper</code> 停止工作。<code>quit()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 移除消息队列中的消息</span>    mQueue<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">quitSafely</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 安全地移除消息队列中的消息</span>    mQueue<span class="token punctuation">.</span><span class="token function">quit</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>quit()</code> 方法的实现最终调用的是 <code>MessageQueue.quit()</code> 方法，传入 <code>true</code> 表示只移除尚未触发的所有消息，对于正在触发的消息并不移除；传入 <code>flase</code> 表示移除所有的消息。</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><code>Looper</code> 是 <code>MessageQueue</code> 和 <code>Handler</code> 的通信媒介，一个线程中只能有一个 <code>Looper</code>，但是一个 <code>Looper</code> 可以绑定多个线程的 <code>Handler</code>，即多个线程可以向一个 <code>Looper</code> 所持有的 <code>MessageQueue</code> 中发送消息，提供了线程间通信的方式。</p><p><code>Looper</code> 循环取出消息队列中的消息，并将取出的消息分发给创建该消息的处理者(Handler)，在消息循环过程中，若消息队列为空，则线程阻塞。</p><h2 id="Message"><a href="#Message" class="headerlink" title="Message"></a>Message</h2><p><strong><code>android.os.Message</code></strong>用于表示消息体，装载需要发送的信息。<code>Message</code> 主要包含以下内容：</p><table><thead><tr><th>数据类型</th><th>成员变量</th><th>解释</th></tr></thead><tbody><tr><td>int</td><td>what</td><td>消息类别</td></tr><tr><td>long</td><td>when</td><td>消息触发时间</td></tr><tr><td>int</td><td>arg1</td><td>参数1</td></tr><tr><td>int</td><td>arg2</td><td>参数2</td></tr><tr><td>Object</td><td>obj</td><td>消息内容</td></tr><tr><td>Handler</td><td>target</td><td>消息响应方</td></tr><tr><td>Runnable</td><td>callback</td><td>回调方法</td></tr></tbody></table><p>创建消息的过程，就是填充消息的上述内容的一项或多项。</p><h3 id="消息池"><a href="#消息池" class="headerlink" title="消息池"></a>消息池</h3><p>在代码中，可能经常看到 <code>recycle()</code> 方法，看似可能是在做虚拟机的 <code>gc()</code> 相关的工作，其实不然，这是用于把消息加入到消息池的作用。这样的好处是，当消息池不为空时，可以直接从消息池中获取 <code>Message</code> 对象，而不是直接创建，提高效率。</p><p><code>Message</code> 类中的静态变量 <code>sPool</code> 的数据类型为 <code>Message</code>，通过 <code>next</code> 成员变量，维护一个消息池；静态变量 <code>MAX_POOL_SIZE</code> 代表消息池的可用大小；消息池的默认大小为 <code>50</code>。</p><p>消息池常用的操作方法是 <code>obtain()</code> 和 <code>recycle()</code>。</p><h3 id="obtain"><a href="#obtain" class="headerlink" title="obtain()"></a>obtain()</h3><p><strong><code>obtain()</code></strong>方法用于从消息池中取出 <code>Message</code>，该方法可以避免在许多情况下分配新对象，比创建和分配新实例效率更高。<code>obtain()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sPoolSync<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断消息池是否为空</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sPool <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 从sPool中取出一个Message对象</span>            Message m <span class="token operator">=</span> sPool<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将sPool指向next</span>            sPool <span class="token operator">=</span> m<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将消息链表断开</span>            m<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 清除in-use flag</span>            m<span class="token punctuation">.</span>flags <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 消息池的可用大小进行减1操作</span>            sPoolSize<span class="token operator">--</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> m<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 当消息池为空时，直接创建Message对象</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Message</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>obtain()</code> 方法有以下几种重载方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span>Message<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span>Handler<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span>Handler<span class="token punctuation">,</span> Runnable<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span>Handler<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span>Handler<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> Object<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span>Handler<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">static</span> Message <span class="token function">obtain</span><span class="token punctuation">(</span>Handler<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">,</span> Object<span class="token punctuation">)</span></code></pre><p><code>obtain()</code> 方法都是把消息池表头的 <code>Message</code> 取走，再把表头指向 <code>next</code>。</p><h3 id="recycle"><a href="#recycle" class="headerlink" title="recycle()"></a>recycle()</h3><p><strong><code>recycle()</code></strong>方法用于把不再使用的 <code>Message</code> 加入消息池。<code>recycle()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断消息是否正在使用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">isInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// Android 5.0 之前的版本默认为false，之后的版本默认为true</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gCheckRecycle<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"This message cannot be recycled because it "</span>                    <span class="token operator">+</span> <span class="token string">"is still in use."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 对于不再使用的消息，加入到消息池</span>    <span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将消息标示位置为IN_USE，并清空消息所有的参数</span>    flags <span class="token operator">=</span> FLAG_IN_USE<span class="token punctuation">;</span>    what <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    arg1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    arg2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    obj <span class="token operator">=</span> null<span class="token punctuation">;</span>    replyTo <span class="token operator">=</span> null<span class="token punctuation">;</span>    sendingUid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    when <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    target <span class="token operator">=</span> null<span class="token punctuation">;</span>    callback <span class="token operator">=</span> null<span class="token punctuation">;</span>    data <span class="token operator">=</span> null<span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>sPoolSync<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当消息池没有满时，将Message对象加入消息</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sPoolSize <span class="token operator">&lt;</span> MAX_POOL_SIZE<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将消息加到链表的表头</span>            next <span class="token operator">=</span> sPool<span class="token punctuation">;</span>            sPool <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 消息池的可用大小进行加1操作</span>            sPoolSize<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>recycle()</code> 方法将 <code>Message</code> 加入到消息池的过程，都是把 <code>Message</code> 加到链表的表头。</p><h3 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h3><p><code>Message</code> 是线程间通信的数据元，即 <code>Handler</code> 接受和处理的消息对象，被用来存储需操作的通信信息。</p><h2 id="MessageQueue"><a href="#MessageQueue" class="headerlink" title="MessageQueue"></a>MessageQueue</h2><p><strong><code>android.os.MessageQueue</code></strong>用于表示消息队列，它由对应的 <code>Looper</code> 创建并进行管理，每个线程中都只会有一个 <code>MessageQueue</code> 对象。</p><h3 id="创建消息队列"><a href="#创建消息队列" class="headerlink" title="创建消息队列"></a>创建消息队列</h3><p><code>MessageQueue</code> 会在 <code>Looper.prepare()</code> 方法被调用创建 <code>Looper</code> 对象时，在 <code>Looper</code> 的构造方法中被创建。<code>MessageQueue</code> 的构造方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token function">MessageQueue</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> quitAllowed<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mQuitAllowed <span class="token operator">=</span> quitAllowed<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 通过native方法初始化消息队列，其中mPtr是供native代码使用</span>    mPtr <span class="token operator">=</span> <span class="token function">nativeInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><p><strong><code>next()</code></strong>方法用于提取消息队列中的下一条消息，该方法在 <code>Looper.loop()</code> 方法的循环体中被调用。<code>next()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java">Message <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">long</span> ptr <span class="token operator">=</span> mPtr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当消息循环已经退出并被丢弃，则直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ptr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 循环迭代的首次为-1</span>    <span class="token keyword">int</span> pendingIdleHandlerCount <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> nextPollTimeoutMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>nextPollTimeoutMillis <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Binder<span class="token punctuation">.</span><span class="token function">flushPendingCommands</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回</span>        <span class="token function">nativePollOnce</span><span class="token punctuation">(</span>ptr<span class="token punctuation">,</span> nextPollTimeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 尝试检索下一条消息，如果找到则返回</span>            <span class="token keyword">final</span> <span class="token keyword">long</span> now <span class="token operator">=</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Message prevMsg <span class="token operator">=</span> null<span class="token punctuation">;</span>            Message msg <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span>target <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 当消息Handler为空时，查询MessageQueue中的下一条异步消息msg，则退出循环</span>                <span class="token keyword">do</span> <span class="token punctuation">{</span>                    prevMsg <span class="token operator">=</span> msg<span class="token punctuation">;</span>                    msg <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>msg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>now <span class="token operator">&lt;</span> msg<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 当异步消息触发时间大于当前时间，则设置下一次轮询的超时时长</span>                    nextPollTimeoutMillis <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>when <span class="token operator">-</span> now<span class="token punctuation">,</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 获取一条消息，并返回</span>                    mBlocked <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>prevMsg <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        prevMsg<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        mMessages <span class="token operator">=</span> msg<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    msg<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 设置消息的使用状态，即flags |= FLAG_IN_USE</span>                    msg<span class="token punctuation">.</span><span class="token function">markInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> msg<span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 没有消息</span>                nextPollTimeoutMillis <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 已处理所有待处理消息，处理退出消息，返回null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">dispose</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 当消息队列为空，或者是消息队列的第一个消息时</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingIdleHandlerCount <span class="token operator">&lt;</span> <span class="token number">0</span>                    <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mMessages <span class="token operator">==</span> null <span class="token operator">||</span> now <span class="token operator">&lt;</span> mMessages<span class="token punctuation">.</span>when<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                pendingIdleHandlerCount <span class="token operator">=</span> mIdleHandlers<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>pendingIdleHandlerCount <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 没有idle handlers 需要运行，则循环并等待</span>                mBlocked <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token keyword">continue</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mPendingIdleHandlers <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mPendingIdleHandlers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IdleHandler</span><span class="token punctuation">[</span>Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span>pendingIdleHandlerCount<span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            mPendingIdleHandlers <span class="token operator">=</span> mIdleHandlers<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span>mPendingIdleHandlers<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">//只有第一次循环时，会运行idle handlers，执行完成后，重置pendingIdleHandlerCount为0</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> pendingIdleHandlerCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> IdleHandler idler <span class="token operator">=</span> mPendingIdleHandlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 释放handler的引用</span>            mPendingIdleHandlers<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>            <span class="token keyword">boolean</span> keep <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// idler时执行的方法</span>                keep <span class="token operator">=</span> idler<span class="token punctuation">.</span><span class="token function">queueIdle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> t<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Log<span class="token punctuation">.</span><span class="token function">wtf</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"IdleHandler threw exception"</span><span class="token punctuation">,</span> t<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>keep<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    mIdleHandlers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>idler<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 重置idle handler个数为0，以保证不会再次重复运行</span>        pendingIdleHandlerCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 当调用一个空闲handler时，一个新message能够被分发，因此无需等待可以直接查询pending message</span>        nextPollTimeoutMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>nativePollOnce</code> 是阻塞操作，其中 <code>nextPollTimeoutMillis</code> 代表下一个消息到来前，还需要等待的时长；当 <code>nextPollTimeoutMillis = -1</code> 时，表示消息队列中无消息，会一直等待下去。</p><p>当处于空闲时，往往会执行 <code>IdleHandler</code> 中的方法。当 <code>nativePollOnce()</code> 返回后，<code>next()</code> 从 <code>mMessages</code> 中提取一个消息。<code>nativePollOnce()</code> 方法用于提取消息队列中的消息，提取消息的调用链。</p><h3 id="enqueueMessage"><a href="#enqueueMessage" class="headerlink" title="enqueueMessage()"></a>enqueueMessage()</h3><p><strong><code>enqueueMessage()</code></strong>方法用于向消息队列中添加一条消息，该方法在 <code>Handler.enqueueMessage()</code> 方法中被调用。<code>enqueueMessage()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">boolean</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> when<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断Message的target是否为null(每一个普通的Message必须有一个target)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>target <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Message must have a target."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 判断Message是否正在使用</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span><span class="token function">isInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>msg <span class="token operator">+</span> <span class="token string">" This message is already in use."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断是否正在退出时</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{</span>            IllegalStateException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span>                    msg<span class="token punctuation">.</span>target <span class="token operator">+</span> <span class="token string">" sending message to a Handler on a dead thread"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 回收Message，加入到消息池</span>            msg<span class="token punctuation">.</span><span class="token function">recycle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 设置消息的使用状态，即flags |= FLAG_IN_USE</span>        msg<span class="token punctuation">.</span><span class="token function">markInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>when <span class="token operator">=</span> when<span class="token punctuation">;</span>        Message p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> needWake<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// p为null(代表MessageQueue没有消息)或者msg的触发时间是队列中最早的，则进入该该分支</span>            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            mMessages <span class="token operator">=</span> msg<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当阻塞时需要唤醒</span>            needWake <span class="token operator">=</span> mBlocked<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将消息按时间顺序插入到MessageQueue。一般地，不需要唤醒事件队列，除非消息队头存在barrier，并且同时Message是队列中最早的异步消息。</span>            needWake <span class="token operator">=</span> mBlocked <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>target <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span> msg<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Message prev<span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                prev <span class="token operator">=</span> p<span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null <span class="token operator">||</span> when <span class="token operator">&lt;</span> p<span class="token punctuation">.</span>when<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span><span class="token function">isAsynchronous</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    needWake <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// invariant: p == prev.next</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 消息没有退出，我们认为此时mPtr != 0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>MessageQueue</code> 是按照 <code>Message</code> 触发时间的先后顺序排列的，队头的消息是将要最早触发的消息。当有消息需要加入消息队列时，会从队列头开始遍历，直到找到消息应该插入的合适位置，以保证所有消息的时间顺序。</p><h3 id="removeMessages"><a href="#removeMessages" class="headerlink" title="removeMessages()"></a>removeMessages()</h3><p><strong><code>removeMessages()</code></strong>方法用于移除消息队列中所有符合条件的消息，该方法在 <code>Handler.removeMessages()</code> 方法中被调用。<code>removeMessages()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">removeMessages</span><span class="token punctuation">(</span>Handler h<span class="token punctuation">,</span> <span class="token keyword">int</span> what<span class="token punctuation">,</span> Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断Handler是否为null，若为null则直接返回</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>h <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从消息队列的头部开始，移除所有符合条件的消息</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>target <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>what <span class="token operator">==</span> what                <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null <span class="token operator">||</span> p<span class="token punctuation">.</span>obj <span class="token operator">==</span> object<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message n <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            mMessages <span class="token operator">=</span> n<span class="token punctuation">;</span>            p<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            p <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 移除剩余的符合要求的消息</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Message n <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>n <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>n<span class="token punctuation">.</span>target <span class="token operator">==</span> h <span class="token operator">&amp;&amp;</span> n<span class="token punctuation">.</span>what <span class="token operator">==</span> what                        <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>object <span class="token operator">==</span> null <span class="token operator">||</span> n<span class="token punctuation">.</span>obj <span class="token operator">==</span> object<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    Message nn <span class="token operator">=</span> n<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                    n<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> nn<span class="token punctuation">;</span>                    <span class="token keyword">continue</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>            p <span class="token operator">=</span> n<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>removeMessages()</code> 方法采用了两个 <code>while</code> 循环，第一个循环是从队头开始，移除所有符合条件的消息，第二个循环是从头部移除完连续的满足条件的消息之后，再从队列后面继续查询是否有满足条件的消息需要被移除。</p><p>另外，与 <code>removeMessages()</code> 方法功能相近的，还有一个重载方法方法，也是用于移除消息队列中所有符合条件的消息。此外，还有一个 <code>removeCallbacksAndMessages()</code> 方法，用于移除所有待处理的 <code>Message.obj</code> 为指定 <code>object</code> 或 <code>null</code> 的 <code>Message</code> 和 <code>Runnable</code>。</p><h3 id="postSyncBarrier"><a href="#postSyncBarrier" class="headerlink" title="postSyncBarrier()"></a>postSyncBarrier()</h3><p><strong><code>postSyncBarrier()</code></strong>方法用于向 <code>Looper</code> 的消息队列发布同步障碍(创建了一个没有 <code>target</code> 的 <code>Message</code> 对象并加入到消息队列中)，该方法在 <code>ViewRootImpl.scheduleTraversals()</code> 方法中被调用。<code>postSyncBarrier()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">postSyncBarrier</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">postSyncBarrier</span><span class="token punctuation">(</span>SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">postSyncBarrier</span><span class="token punctuation">(</span><span class="token keyword">long</span> when<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将新的同步屏障令牌加入队列(不需要唤醒队列，因为障碍的目的是阻止它)</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> token <span class="token operator">=</span> mNextBarrierToken<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> Message msg <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span><span class="token function">markInUse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>when <span class="token operator">=</span> when<span class="token punctuation">;</span>        msg<span class="token punctuation">.</span>arg1 <span class="token operator">=</span> token<span class="token punctuation">;</span>        Message prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        Message p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>when <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> p<span class="token punctuation">.</span>when <span class="token operator">&lt;=</span> when<span class="token punctuation">)</span> <span class="token punctuation">{</span>                prev <span class="token operator">=</span> p<span class="token punctuation">;</span>                p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// invariant: p == prev.next</span>            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> msg<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            msg<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">;</span>            mMessages <span class="token operator">=</span> msg<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> token<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通常都是通过 <code>Handler</code> 发送消息的，<code>Handler</code> 在 <code>Message</code> 加入到消息队列时，都会为 <code>Message</code> 设置 <code>target</code>，所以每一个普通的 <code>Message</code> 都必定有一个 <code>target</code>。但是对于特殊的 <code>message</code> 是没有 <code>target</code>，即 <code>sync barrier token</code>，这个特殊消息的作用就是用于拦截同步消息，所以并不会唤醒 <code>Looper</code>。</p><p>同步消息被添加到消息队列后，消息处理照常进行，直到消息队列遇到已发布的同步屏障。遇到屏障时，队列中的后续同步消息将被挂起(暂停执行)，直到通过调用 <code>removeSyncBarrier()</code> 方法并指定标识同步屏障的令牌来移除同步屏障，该方法在 <code>ViewRootImpl.doTraversal()</code> 方法中被调用。<code>removeSyncBarrier()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">removeSyncBarrier</span><span class="token punctuation">(</span><span class="token keyword">int</span> token<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 从队列中移除同步障碍标记(如果队列不再被障碍物阻挡，则将其唤醒)</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Message prev <span class="token operator">=</span> null<span class="token punctuation">;</span>        Message p <span class="token operator">=</span> mMessages<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 从消息队列找到target为null并且token相等的Message</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>target <span class="token operator">!=</span> null <span class="token operator">||</span> p<span class="token punctuation">.</span>arg1 <span class="token operator">!=</span> token<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            prev <span class="token operator">=</span> p<span class="token punctuation">;</span>            p <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"The specified message queue synchronization "</span>                    <span class="token operator">+</span> <span class="token string">" barrier token has not been posted or has already been removed."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">final</span> <span class="token keyword">boolean</span> needWake<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>prev <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            prev<span class="token punctuation">.</span>next <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            needWake <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            mMessages <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            needWake <span class="token operator">=</span> mMessages <span class="token operator">==</span> null <span class="token operator">||</span> mMessages<span class="token punctuation">.</span>target <span class="token operator">!=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        p<span class="token punctuation">.</span><span class="token function">recycleUnchecked</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果循环正在退出，那么它已经处于唤醒状态；如果消息没有退出，我们认为此时mPtr != 0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>needWake <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mQuitting<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">nativeWake</span><span class="token punctuation">(</span>mPtr<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>postSyncBarrier()</code> 方法只对同步消息产生影响，对于异步消息没有任何差别。这个机制的作用在于可以马上暂停执行“同步”消息，直到条件允许后通过移除同步屏障来恢复“同步”消息的处理。例如在 <code>View.invalidate()</code> 需要执行时，将会设置同步栏挂起所有“同步”消息，直到下一帧准备好显示后移除同步栏。</p></blockquote><h3 id="native-方法"><a href="#native-方法" class="headerlink" title="native 方法"></a>native 方法</h3><p><code>MessageQueue</code> 是消息机制的 Java 层和 C++ 层的连接纽带，大部分核心方法都交给 <code>native</code> 层来处理，其中 <code>MessageQueue</code> 类中涉及的 <code>native</code> 方法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">static</span> <span class="token keyword">long</span> <span class="token function">nativeInit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">nativeDestroy</span><span class="token punctuation">(</span><span class="token keyword">long</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">nativePollOnce</span><span class="token punctuation">(</span><span class="token keyword">long</span> ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> timeoutMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">nativeWake</span><span class="token punctuation">(</span><span class="token keyword">long</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">nativeIsPolling</span><span class="token punctuation">(</span><span class="token keyword">long</span> ptr<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">native</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">nativeSetFileDescriptorEvents</span><span class="token punctuation">(</span><span class="token keyword">long</span> ptr<span class="token punctuation">,</span> <span class="token keyword">int</span> fd<span class="token punctuation">,</span> <span class="token keyword">int</span> events<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p><code>MessageQueue</code> 是一种先进先出的数据结构，被用来存储 <code>Handler</code> 发送过来的消息。</p><h2 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h2><p><strong><code>android.os.Handler</code></strong>用于作为发送和处理 <code>Message</code> 和 <code>Runnable</code> 的处理程序，每个 <code>Handler</code> 中都会有一个 <code>Looper</code> 和 <code>MessageQueue</code> 对象。</p><h3 id="创建-Handler"><a href="#创建-Handler" class="headerlink" title="创建 Handler"></a>创建 Handler</h3><p><code>Handler</code> 的构造方法有以下几种：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> async<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span></code></pre><p><code>Handler</code> 的构造方法有两种情况：不指定 <code>Looper</code> 和指定 <code>Looper</code>。<code>Handler</code> 类在构造方法中，可指定 <code>Looper</code>、<code>Callback 回调方法</code>以及<code>消息的处理方式(同步或异步)</code>，对于无参的 <code>Handler</code>，默认是当前线程的 <code>Looper</code>。</p><h4 id="不指定-Looper"><a href="#不指定-Looper" class="headerlink" title="不指定 Looper"></a>不指定 Looper</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> async<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>null<span class="token punctuation">,</span> async<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>FIND_POTENTIAL_LEAKS<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span><span class="token operator">></span> klass <span class="token operator">=</span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 匿名类、内部类或本地类都必须申明为static，否则会警告可能出现内存泄露</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>klass<span class="token punctuation">.</span><span class="token function">isAnonymousClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> klass<span class="token punctuation">.</span><span class="token function">isMemberClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">||</span> klass<span class="token punctuation">.</span><span class="token function">isLocalClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span>klass<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> Modifier<span class="token punctuation">.</span>STATIC<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span> <span class="token string">"The following Handler class should be static or leaks might occur: "</span> <span class="token operator">+</span>                    klass<span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 从当前线程的TLS中获取Looper对象</span>    <span class="token comment" spellcheck="true">// 若在工作线程，必须先执行Looper.prepare()，才能获取Looper对象，否则为null</span>    mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mLooper <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>                <span class="token string">"Can't create handler inside thread "</span> <span class="token operator">+</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                        <span class="token operator">+</span> <span class="token string">" that has not called Looper.prepare()"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 获取消息队列(来自Looper对象)</span>    mQueue <span class="token operator">=</span> mLooper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 回调方法</span>    mCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 设置消息是否为异步处理方式</span>    mAsynchronous <span class="token operator">=</span> async<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>对于 <code>Handler</code> 的不指定 <code>Looper</code> 的构造方法，默认采用当前线程 <code>TLS</code> 中的 <code>Looper</code> 对象，只要执行的 <code>Looper.prepare()</code> 方法，那么便可以获取有效的 <code>Looper</code> 对象。</p><h4 id="指定-Looper"><a href="#指定-Looper" class="headerlink" title="指定 Looper"></a>指定 Looper</h4><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>looper<span class="token punctuation">,</span> null<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">(</span>looper<span class="token punctuation">,</span> callback<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mLooper <span class="token operator">=</span> looper<span class="token punctuation">;</span>    mQueue <span class="token operator">=</span> looper<span class="token punctuation">.</span>mQueue<span class="token punctuation">;</span>    mCallback <span class="token operator">=</span> callback<span class="token punctuation">;</span>    mAsynchronous <span class="token operator">=</span> async<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="消息分发"><a href="#消息分发" class="headerlink" title="消息分发"></a>消息分发</h3><p>在 <code>Looper.loop()</code> 方法中循环处理消息时，若消息队列中有消息时，就会通过 <code>Message</code> 的 <code>target</code>(即 Handler)，调用 <code>dispatchMessage()</code> 方法来分发消息。<code>dispatchMessage()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">dispatchMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断Message的回调方法是否为null</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>msg<span class="token punctuation">.</span>callback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当Message存在回调方法时，则执行message.callback.run()</span>        <span class="token function">handleCallback</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断Handler是否被指定了Callback回调</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mCallback <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当Handler被指定了Callback回调时，回调handleMessage()方法</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mCallback<span class="token punctuation">.</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 若Callback的消息处理方法返回true，则直接返回</span>                <span class="token keyword">return</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// Handler自身的消息处理方法</span>        <span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>消息分发流程如下：</p><ol><li>当 <code>Message</code> 的回调方法不为空时，则回调方法 <code>msg.callback.run()</code>，其中 <code>callback</code> 数据类型为 <code>Runnable</code>，否则进入步骤2；</li><li>当 <code>Handler</code> 的 <code>mCallback</code> 成员变量不为空时，则回调方法 <code>mCallback.handleMessage(msg)</code>，否则进入步骤3；</li><li>调用 <code>Handler</code> 自身的消息处理方法 <code>handleMessage()</code>，该方法默认为空，<code>Handler</code> 子类通过重写该方法来完成具体的逻辑。</li></ol><blockquote><p>对于很多情况下，消息分发后的处理方法是第3种情况，即 <code>Handler.handleMessage()</code>，一般地往往通过重写该方法从而实现自己的业务逻辑。</p></blockquote><h3 id="消息生成"><a href="#消息生成" class="headerlink" title="消息生成"></a>消息生成</h3><p><strong><code>obtainMessage()</code></strong>方法用于从消息池中取出 <code>Message</code>，比创建和分配新实例效率更高。<code>obtainMessage()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">int</span> arg1<span class="token punctuation">,</span> <span class="token keyword">int</span> arg2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> Message <span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">int</span> arg1<span class="token punctuation">,</span> <span class="token keyword">int</span> arg2<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> arg1<span class="token punctuation">,</span> arg2<span class="token punctuation">,</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上面的源码可以看到 <code>Handler.obtainMessage()</code> 方法最终调用的都是 <code>Message.obtain()</code> 方法，都是从消息池中取出 <code>Message</code>，其中 <code>this</code> 为当前的 <code>Handler</code> 对象。</p><h3 id="消息发送"><a href="#消息发送" class="headerlink" title="消息发送"></a>消息发送</h3><p><code>Handler</code> 用于接受、传递和处理的消息分为 <code>Message</code> 和 <code>Runnable</code> 两种。</p><h4 id="发送-Message"><a href="#发送-Message" class="headerlink" title="发送 Message"></a>发送 Message</h4><p>发送 <code>Message</code> 的方式有以下几种：</p><ul><li><p>sendMessage()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>sendEmptyMessage()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendEmptyMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendEmptyMessageDelayed</span><span class="token punctuation">(</span>what<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>sendEmptyMessageDelayed()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendEmptyMessageDelayed</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> Message msg <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> msg<span class="token punctuation">.</span>what <span class="token operator">=</span> what<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>sendEmptyMessageAtTime()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendEmptyMessageAtTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> Message msg <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> msg<span class="token punctuation">.</span>what <span class="token operator">=</span> what<span class="token punctuation">;</span> <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>sendMessageDelayed()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>delayMillis <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     delayMillis <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>msg<span class="token punctuation">,</span> SystemClock<span class="token punctuation">.</span><span class="token function">uptimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>sendMessageAtTime()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>     RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>             <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>sendMessageAtFrontOfQueue()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtFrontOfQueue</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span> MessageQueue queue <span class="token operator">=</span> mQueue<span class="token punctuation">;</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>queue <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>     RuntimeException e <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RuntimeException</span><span class="token punctuation">(</span>             <span class="token keyword">this</span> <span class="token operator">+</span> <span class="token string">" sendMessageAtTime() called with no mQueue"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     Log<span class="token punctuation">.</span><span class="token function">w</span><span class="token punctuation">(</span><span class="token string">"Looper"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token keyword">return</span> <span class="token function">enqueueMessage</span><span class="token punctuation">(</span>queue<span class="token punctuation">,</span> msg<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>该方法通过设置消息的触发时间为 <code>0</code>，从而使 <code>Message</code> 加入到消息队列的队头。</p></blockquote></li></ul><h4 id="发送-Runnable"><a href="#发送-Runnable" class="headerlink" title="发送 Runnable"></a>发送 Runnable</h4><p>发送 <code>Runnable</code> 的方式有以下几种：</p><ul><li><p>post()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>postAtTime()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postAtTime</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>postAtTime()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postAtTime</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Object token<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">,</span> uptimeMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>postDelayed()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postDelayed</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">,</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>postDelayed()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postDelayed</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Object token<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">,</span> delayMillis<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li><li><p>postAtFrontOfQueue()</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postAtFrontOfQueue</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token function">sendMessageAtFrontOfQueue</span><span class="token punctuation">(</span><span class="token function">getPostMessage</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre></li></ul><p>从上面的源码可以看到 <code>Handler</code> 发送 <code>Runnable</code> 的方法最终调用的都是发送 <code>Message</code> 的方法，把 <code>Runnable</code> 封装成 <code>Message</code> 对象的过程是在 <code>getPostMessage()</code> 方法中完成的。<code>getPostMessage()</code> 方法的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> Message <span class="token function">getPostMessage</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Message m <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span>callback <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">return</span> m<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> Message <span class="token function">getPostMessage</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Object token<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Message m <span class="token operator">=</span> Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    m<span class="token punctuation">.</span>obj <span class="token operator">=</span> token<span class="token punctuation">;</span>    m<span class="token punctuation">.</span>callback <span class="token operator">=</span> r<span class="token punctuation">;</span>    <span class="token keyword">return</span> m<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><p><code>Handler</code> 发送消息的一系列方法最终调用 <code>MessageQueue.enqueueMessage(msg, uptimeMillis)</code> 方法将消息添加到消息队列中，其中 <code>uptimeMillis</code> 为系统当前的运行时间，不包括休眠时间。</p><p>无论 <code>Handler</code> 将 <code>Message</code> 还是 <code>Runnable</code> 加入 <code>MessageQueue</code>，最终都只是将 <code>Message</code> 加入到 <code>MessageQueue</code>。分析源码可以看到 <code>Handler</code> 将 <code>Runnable</code> 加入到消息队列的方法内部都是调用 <code>getPostMessage()</code> 方法把 <code>Runnable</code> 封装成 <code>Message</code> 对象的 <code>callback</code> 属性，然后再将得到的 <code>Message</code> 加入到消息队列的。</p><h3 id="消息移除"><a href="#消息移除" class="headerlink" title="消息移除"></a>消息移除</h3><p><code>Handler</code> 移除消息的方法有以下几种：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">removeMessages</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mQueue<span class="token punctuation">.</span><span class="token function">removeMessages</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">removeMessages</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> Object object<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mQueue<span class="token punctuation">.</span><span class="token function">removeMessages</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> what<span class="token punctuation">,</span> object<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">removeCallbacksAndMessages</span><span class="token punctuation">(</span>Object token<span class="token punctuation">)</span> <span class="token punctuation">{</span>    mQueue<span class="token punctuation">.</span><span class="token function">removeCallbacksAndMessages</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> token<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上面的源码可以看到 <code>Handler</code> 移除消息的方法最终调用的都是 <code>MessageQueue</code> 的方法。</p><h3 id="总结-4"><a href="#总结-4" class="headerlink" title="总结"></a>总结</h3><p><code>Handler</code> 是消息机制中非常重要的辅助类，更多的实现都是 <code>Message</code> 和 <code>MessageQueue</code> 中的方法，<code>Handler</code> 的目的是为了更加方便的使用消息机制。</p><h2 id="消息机制总结"><a href="#消息机制总结" class="headerlink" title="消息机制总结"></a>消息机制总结</h2><p><code>Looper</code> 和 <code>MessageQueue</code> 消息循环和消息队列都是属于 <code>Thread</code>，而 <code>Handler</code> 本身并不具有 <code>Looper</code> 和 <code>MessageQueue</code>；但是消息系统的建立和交互，是 <code>Thread</code> 将 <code>Looper</code> 和 <code>MessageQueue</code> 交给某个 <code>Handler</code> 维护建立消息系统模型。所以消息系统模型的核心就是 <code>Looper</code>。消息循环和消息队列都是由 <code>Looper</code> 建立的，而建立 <code>Handler</code> 的关键就是这个 <code>Looper</code>。</p><h3 id="消息机制图解"><a href="#消息机制图解" class="headerlink" title="消息机制图解"></a>消息机制图解</h3><p>最后用一张图，来表示整个消息机制：<br><img src="https://henleylee.github.io/medias/android/handler_summary.png" alt="Handler消息处理机制"><br>从上图中可以看出：</p><ul><li><code>Handler</code> 通过 <code>sendMessage()</code> 方法发送 <code>Message</code> 到 <code>MessageQueue</code> 队列；</li><li><code>Looper</code> 通过 <code>loop()</code> 方法不断提取出达到触发条件的 <code>Message</code>，并将 <code>Message</code> 交给它的 <code>target</code> 来处理；</li><li>经过 <code>dispatchMessage()</code> 后，交回给 <code>Handler</code> 的 <code>handleMessage()</code> 来进行相应地处理。</li><li>将 <code>Message</code> 加入 <code>MessageQueue</code> 时，处往管道写入字符，可以会唤醒 <code>loop</code> 线程；如果 <code>MessageQueue</code> 中没有 <code>Message</code>，并处于 <code>Idle</code> 状态，则会执行 <code>IdelHandler</code> 接口中的方法，往往用于做一些清理性地工作。</li></ul><h3 id="消息分发优先级"><a href="#消息分发优先级" class="headerlink" title="消息分发优先级"></a>消息分发优先级</h3><p><code>Handler</code> 通过 <code>dispatchMessage()</code> 方法分发消息：</p><ol><li><code>Message</code> 的回调方法：<code>message.callback.run()</code> 优先级最高；</li><li><code>Handler</code> 的回调方法：<code>Handler.mCallback.handleMessage(msg)</code> 优先级仅次于1；</li><li><code>Handler</code> 的默认方法：<code>Handler.handleMessage(msg)</code> 优先级最低。</li></ol><h3 id="消息缓存机制"><a href="#消息缓存机制" class="headerlink" title="消息缓存机制"></a>消息缓存机制</h3><p>为了提高效率，<code>Message</code> 提供了一个大小为 <code>50</code> 的缓存池以链表的形式缓存 <code>Message</code> 对象，减少对象不断创建与销毁的过程。通过 <code>Message.obtain()</code> 方法或 <code>Handler.obtainMessage()</code> 方法可以直接从消息池中取出缓存的 <code>Message</code> 对象，从而提高效率。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中的多进程通信机制</title>
      <link href="/posts/2019/20c92935.html"/>
      <url>/posts/2019/20c92935.html</url>
      
        <content type="html"><![CDATA[<h2 id="Android-IPC-简介"><a href="#Android-IPC-简介" class="headerlink" title="Android IPC 简介"></a>Android IPC 简介</h2><p><strong><code>IPC</code></strong>是 <code>Inter-Process Communication</code> 的缩写，含义就是<strong><code>进程间通信</code></strong>或者<strong><code>跨进程通信</code></strong>，是指两个进程之间进行数据交换的过程。</p><p>那么什么是进程，什么是线程，在操作系统中，进程和线程是两个截然不同的概念。线程是 CPU 调度的最小单元，同时线程是一种有限的系统资源。而进程指的一个执行单元，在 PC 和移动设备上指的是一个程序或者一个应用。一个进程可以包含多个线程，因此进程和线程是包含被包含的关系，最简单情况下，一个进程可以只有一个线程，即主线程，在 Android 里面也叫 UI 线程，在 UI 线程里才能操作界面元素。</p><blockquote><p>IPC 不是 Android 中所独有的，任何一个操作系统都需要相应的 IPC 机制，比如 Windows 上可以通过剪贴板等来进行进程间通信。Android 是一种基于 Linux 内核的移动操作系统，它的进程间通信方式并不能完全继承自 Linux，它有自己的进程间通信方式。</p></blockquote><p>在 Android 中，一个应用程序就是一个独立的进程(应用运行在一个独立的环境中，可以避免其他应用程序/进程的干扰)。一般来说，当我们启动一个应用程序时，系统会创建一个进程(在 Android 系统中，所有的应用程序进程以及系统服务进程 SystemServer 都是由 Zygote 进程孕育 fork 出来的，并且每个进程都会有独立的 ID)，并为这个进程创建一个主线程(UI 线程)，然后就可以运行应用程序了，应用程序的组件默认都是运行在它的进程中。</p><h2 id="Android-多进程的优缺点"><a href="#Android-多进程的优缺点" class="headerlink" title="Android 多进程的优缺点"></a>Android 多进程的优缺点</h2><h3 id="多进程的优点"><a href="#多进程的优点" class="headerlink" title="多进程的优点"></a>多进程的优点</h3><ul><li>减少主进程所占用的内存，降低应用被系统杀死的概率；</li><li>不会影响到主业务的代码的稳定运行，降低应用程序的崩溃率；</li><li>有独立的生命周期，可以完全不依赖用户对应用的使用，可以独立启动、退出。</li></ul><h3 id="多进程的缺点"><a href="#多进程的缺点" class="headerlink" title="多进程的缺点"></a>多进程的缺点</h3><ul><li>Application 会多次创建，多进程模式中，不同进程的组件拥有相互独立的虚拟机、内存空间、Application；</li><li>单例模式、静态变量完全失效，不同进程的内存空间相互独立，故不同的进程中，会有不同的实例，在一个进程中修改静态变量，在另外一个进程中失效；</li><li>线程同步机制完全失效，因为空间独立，不管是锁对象还是锁全局类都无法保证线程同步，因为进程不同，锁住的对象不是同一个；</li><li>SharePreference 的可靠性下降，SharePreference 底层是对 XML 文件操作，不支持两个进程同时去执行写操作，因为它没有实现并发修改的机制，不能保证数据的安全性、准确性。</li></ul><h2 id="Android-多进程的实现"><a href="#Android-多进程的实现" class="headerlink" title="Android 多进程的实现"></a>Android 多进程的实现</h2><p>正常情况下，一个应用程序启动后只会运行在一个进程中，其进程名为应用程序的包名，所有的基本组件都会在这个进程中运行。但是如果需要将某些组件(如 Service、Activity 等)运行在单独的进程中，可以通过在 <code>AndroidManifest.xml</code> 中声明组件时，用 <code>android:process</code> 属性来指定其所运行的进程。</p><p>Android 中 <code>android:process</code> 的使用分为以下两种情况：</p><ul><li><code>android:process</code> 的值以 <code>:</code> 开头(如 android:process=”:remote”)，将运行在<code>默认包名:remote</code> 进程中，属于<code>私有进程</code>，不允许其他APP的组件来访问。</li><li><code>android:process</code> 的值以<code>小写字母</code>开头(如 android:process=”package:remote”)，将运行在 <code>package:remote</code> 进程中，属于<code>全局进程</code>，其他具有相同 shareUID 与签名的 APP 可以跑在这个进程中。</li></ul><blockquote><p><code>AndroidMantifest.xml</code> 中的 <code>activity</code>、<code>service</code>、<code>receiver</code> 和 <code>provider</code> 元素均支持 <code>android:process</code> 属性；<code>application</code> 元素也支持 <code>android:process</code> 属性，可以修改应用程序的默认进程名(默认值为包名)。</p></blockquote><h2 id="Android-IPC-基础概念"><a href="#Android-IPC-基础概念" class="headerlink" title="Android IPC 基础概念"></a>Android IPC 基础概念</h2><h3 id="Serializable-接口"><a href="#Serializable-接口" class="headerlink" title="Serializable 接口"></a>Serializable 接口</h3><p><strong><code>Serializable</code></strong>是 Java 提供的一个序列化接口，它是一个空接口，为对象标准的序列化和反序列化操作。使用 <code>Serializable</code> 来实现序列化相当简单，一句话即可。用法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Serializable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> 6429127138009130173L<span class="token punctuation">;</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="Parcelable-接口"><a href="#Parcelable-接口" class="headerlink" title="Parcelable 接口"></a>Parcelable 接口</h3><p><strong><code>Parcelable</code></strong>是 Android 提供的序列化方式，<code>Parcel</code> 内部包装了可序列化的数据，可以在 <code>Binder</code> 中自由传输，在序列化过程中需要实现的功能有序列化、反序列化和内容描述序列化功能有 <code>writeToParcel()</code> 方法来完成，最终是通过 <code>Parcel</code> 中的一系列 <code>writeXXX()</code> 方法来完成的。用法如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token keyword">implements</span> <span class="token class-name">Parcelable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">describeContents</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeToParcel</span><span class="token punctuation">(</span>Parcel dest<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">)</span> <span class="token punctuation">{</span>        dest<span class="token punctuation">.</span><span class="token function">writeString</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>        dest<span class="token punctuation">.</span><span class="token function">writeInt</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token function">User</span><span class="token punctuation">(</span>Parcel in<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">readInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Parcelable<span class="token punctuation">.</span>Creator<span class="token operator">&lt;</span>User<span class="token operator">></span> CREATOR <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Parcelable<span class="token punctuation">.</span>Creator</span><span class="token operator">&lt;</span>User<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> User <span class="token function">createFromParcel</span><span class="token punctuation">(</span>Parcel source<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> User<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">newArray</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">[</span>size<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>Serializable</code> 是 Java 中的序列化接口，其使用起来简单但是开销很大，在序列化和反序列化过程中需要大量的 I/O 操作。而 <code>Parcelable</code> 是 Android 中的序列化方式，因此更适合用在 Android 平台上，它的缺点就是使用起来稍微麻烦点，但是它的效率很高。</p></blockquote><h3 id="Binder"><a href="#Binder" class="headerlink" title="Binder"></a>Binder</h3><p>直观来说，<code>android.os.Binder</code> 是 Android 中的一个类，它实现了 <code>android.os.IBinder</code> 接口。从 IPC 角度来说，<code>Binder</code> 是 Android 中的一种跨进程通信方式，<code>Binder</code> 还可以理解为一种虚拟的物理设备，它的设备驱动是 <code>/dev/binder</code>，该通信方式在 <code>Linux</code> 中没有。从 Android Framework 角度来说，<code>Binder</code> 是 <code>ServiceManager</code> 连接各种 <code>Manager</code>(ActivityManager、WindowManager等等)和相应 <code>ManagerService</code> 的桥梁。从 Android 应用层来说，<code>Binder</code> 是客户端和服务端进行通信的媒介，当 <code>bindService</code> 的时候，服务端会返回一个包含了服务端业务调用的 <code>Binder</code> 对象，通过 <code>Binder</code> 对象，客户端就可以获取服务端提供的服务或者数据，这里的服务包括普通服务和基于 <code>AIDL</code> 的服务。</p><h2 id="Android-中的-IPC-方式"><a href="#Android-中的-IPC-方式" class="headerlink" title="Android 中的 IPC 方式"></a>Android 中的 IPC 方式</h2><p>Android 实现跨进程通信的方式有很多，比如通过 <code>Intent</code> 来传递 <code>Bundle</code> 数据、<code>共享文件</code>、基于 <code>Binder</code> 的 <code>Messenger</code> 和 <code>AIDL</code> 以及 <code>Socket</code> 等。</p><h3 id="通过-Bundle-传递数据"><a href="#通过-Bundle-传递数据" class="headerlink" title="通过 Bundle 传递数据"></a>通过 Bundle 传递数据</h3><p><strong><code>通过 Bundle 传递数据</code></strong>是最常用的一种进程间通信方式，Android 四大组件中三大组件(Activity、Service、Receiver)都是支持在 <code>Intent</code> 中传递 <code>Bundle</code> 数据的，由于 <code>Bundle</code> 实现了 <code>Parcelable</code> 接口，所以它可以方便地在不同的进程间传输。</p><p><code>Bundle</code> 支持传递的数据类型包括<code>基本数据类型</code>、<code>String</code>、<code>CharSequence</code> 以及实现了 <code>Serializable</code> 或 <code>Parcellable</code> 接口的数据结构。</p><blockquote><p>Serializable 是 Java 的序列化方法，代码量少(仅一句)，但I/O开销较大，一般用于输出到磁盘或网卡；Parcellable 是 Android 的序列化方法，实现代码多，效率高，一般用户内存间序列化和反序列化传输。</p></blockquote><h3 id="文件共享"><a href="#文件共享" class="headerlink" title="文件共享"></a>文件共享</h3><p><strong><code>共享文件</code></strong>也是一种常用的的进程间通信方式，两个进程间通过读/写同一个文件来交换数据，比如一个进程把数据写入文件，另一个进程通过读取这个文件来获取数据。</p><blockquote><p>Linux 机制下，可以对文件并发写，所以要注意同步；Windows 下不支持并发读或写。</p></blockquote><h3 id="Messenger"><a href="#Messenger" class="headerlink" title="Messenger"></a>Messenger</h3><p><strong><code>Messenger</code></strong>可以翻译为信使，顾名思义，通过它可以在不同进程中传递 <code>Message</code> 对象，在 <code>Message</code> 中放入我们需要传递的数据，就可以轻松地实现数据的进程间传递。<code>Messenger</code> 是一种轻量级的 IPC 方案，它是基于 <code>AIDL</code> 实现的。</p><p>实现 <code>Messenger</code> 有以下两个步骤，分为服务端进程和客户端进程。服务端(被动方)提供一个 Service 来处理客户端(主动方)连接，维护一个 <code>Handler</code> 来创建 <code>Messenger</code>，在 <code>onBind</code> 时返回 <code>Messenger</code> 的 <code>Binder</code>。双方用 <code>Messenger</code> 来发送数据，用 <code>Handler</code> 来处理数据。<code>Messenger</code> 处理数据依靠 <code>Handler</code>，所以是串行的，也就是说，<code>Handler</code> 接到多个 <code>Message</code> 时，就要排队依次处理。</p><h3 id="AIDL"><a href="#AIDL" class="headerlink" title="AIDL"></a>AIDL</h3><p><strong><code>AIDL</code></strong>是远程服务跨进程通信的一种方式，它通过定义服务端暴露的接口，以提供给客户端来调用，<code>AIDL</code> 使服务器可以并行处理，而 <code>Messenger</code> 封装了 <code>AIDL</code> 之后只能串行运行，所以 <code>Messenger</code> 一般用作消息传递。</p><p>通过编写 <code>aidl</code> 文件来设计想要暴露的接口，编译后会自动生成响应的 Java 文件，服务器将接口的具体实现写在 <code>Stub</code> 中，用 <code>IBinder</code> 对象传递给客户端，客户端 <code>bindService</code> 的时候，用 <code>asInterface</code> 的形式将 <code>IBinder</code> 还原成接口，再调用其中的方法。</p><h3 id="ContentProvider"><a href="#ContentProvider" class="headerlink" title="ContentProvider"></a>ContentProvider</h3><p><strong><code>ContentProvider</code></strong>是 Android 中提供的专门用于不同应用间进行数据共享的方式，它的底层实现同样也是 <code>Binder</code>，主要用来为其他应用提供数据，可以说天生就是为进程通信而生的。</p><blockquote><p>实现一个 <code>ContentProvider</code> 需要实现6个方法，其中 <code>onCreate()</code> 方法是主线程中回调的，其他方法是运行在 <code>Binder</code> 之中的。自定义的 <code>ContentProvider</code> 注册时要提供 <code>authorities</code> 属性，应用需要访问的时候将属性包装成 <code>Uri.parse(&quot;content://authorities&quot;)</code>。还可以设置 <code>permission</code>、<code>readPermission</code>、<code>writePermission</code> 来设置权限。 <code>ContentProvider</code> 有 <code>query()</code>、<code>delete()</code>、<code>insert()</code>、<code>update()</code> 等方法，看起来像是是一个数据库管理类，但其实可以用文件、内存数据等等一切来充当数据源，<code>query()</code> 方法返回的是一个 <code>Cursor</code> 对象，可以自定义继承 <code>AbstractCursor</code> 的类来实现。</p></blockquote><h3 id="Socket"><a href="#Socket" class="headerlink" title="Socket"></a>Socket</h3><p><strong><code>Socket</code></strong>也称为<code>套接字</code>，是网络通信中的概念，它分为流式套接字和用户数据套接字两种，分别应于网络的传输控制层中的 <code>TCP</code> 和 <code>UDP</code> 协议。</p><blockquote><p>需要注意的是：<code>Android 不允许在主线程中请求网络</code>，而且请求网络必须要注意声明相应的 <code>permission</code>。然后，在服务器中定义 <code>ServerSocket</code> 来监听端口，客户端使用 <code>Socket</code> 来请求端口，连通后就可以进行通信。</p></blockquote><h2 id="IPC-方式的优缺点和适用场景"><a href="#IPC-方式的优缺点和适用场景" class="headerlink" title="IPC 方式的优缺点和适用场景"></a>IPC 方式的优缺点和适用场景</h2><table><thead><tr><th>名称</th><th>优点</th><th>缺点</th><th>适用场景</th></tr></thead><tbody><tr><td>Bundle</td><td>简单易用</td><td>只能传输 Bundle 支持的数据类型</td><td>四大组件间的进程通信</td></tr><tr><td>文件共享</td><td>简单易用</td><td>不适合高并发的情况，并且无法做到进程间的即时通讯</td><td>无并发访问情况下，交换简单的数据实时性不高的情况</td></tr><tr><td>AIDL</td><td>功能强大，支持一对多并发通信，支持实时通讯</td><td>需要处理好线程同步</td><td>一对多通信且有 RPC 需求</td></tr><tr><td>Messager</td><td>支持一对多串行通信，支持实时通讯</td><td>不能很好处理高并发情况，不支持 RPC，数据通过 Message 进行传输，因此只能传输 Bundle 支持的数据类型</td><td>低并发的一对多即时通信，无 RPC 需求，或者无需返回结果的 RPC 需求</td></tr><tr><td>ContentProvider</td><td>在数据源访问方面功能强大，支持一对多并发数据共享，可通过call方法扩展其他操作</td><td>主要提供数据源的 Crud</td><td>一对多的进程间数据共享</td></tr><tr><td>Socket</td><td>功能强大，可以通过网络传输字节流，支持一对多并发实时通讯</td><td>实现细节有点繁琐，不支持直接的 RPC</td><td>网络数据交换</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中的多线程通信机制</title>
      <link href="/posts/2019/e116562b.html"/>
      <url>/posts/2019/e116562b.html</url>
      
        <content type="html"><![CDATA[<h2 id="线程简介"><a href="#线程简介" class="headerlink" title="线程简介"></a>线程简介</h2><p>在 <code>Java</code> 中，线程会有那么几种状态：创建，就绪，运行，阻塞，死亡。当应用程序有组件在运行时，<code>UI 线程</code>是处于运行状态的。默认情况下，应用的所有组件的操作都是在 <code>UI线程</code>里完成的，包括响应用户的操作(触摸、点击等)、组件生命周期方法的调用、UI 的更新等。因此如果 <code>UI线程</code>处理阻塞状态时(在线程里做一些耗时的操作，如网络连接等)，就会不能响应各种操作，如果阻塞时间达到5秒，就会让程序处于 <code>ANR(application not response)</code> 状态，这时用户就可能退出甚至卸载你的应用，这是我们不能接受的。这时，有人就会说，我们在其他线程中更新 UI 不就可以了吗，就不会导致 UI 线程处于阻塞状态了。但答案是否定的。</p><p>因为 Android 的 <code>UI线程</code>是非线程安全的，应用更新 UI，是调用 <code>invalidate()</code> 方法来实现界面的重绘，而 <code>invalidate()</code> 方法是非线程安全的，也就是说当我们在非 UI 线程来更新 UI 时，可能会有其他的线程或 UI 线程也在更新 UI，这就会导致界面更新的不同步。因此我们不能在非 UI 主线程中做更新 UI 的操作。也就是说在使用 Android 中的线程时，要保证：</p><ul><li>不能阻塞 UI 主线程，也就是不能在 UI 主线程中做耗时的操作(如网络连接、文件的 I/O 操作)；</li><li>只能在 UI 主线程中做更新 UI 的操作。</li></ul><p>在 Android 中，把除主线程外的，其他所有的线程都叫做工作线程，也就是说 Android 只会存在两种线程：<strong><code>主线程(UI thread)</code></strong>和<strong><code>工作线程(work thread)</code></strong>。</p><blockquote><p>主线程主要负责处理和界面有关的事情，而工作线程则往往用于执行耗时操作。</p></blockquote><h2 id="Android-中的线程"><a href="#Android-中的线程" class="headerlink" title="Android 中的线程"></a>Android 中的线程</h2><p>在 Android 中除了 <code>Thread</code> 本身以外，可以扮演线程的角色还有很多，比如：<code>AnsyncTask</code> 和 <code>IntentService</code>，同时 <code>HandlerThread</code> 也是一种的特殊的线程，<code>AnsyncTask</code> 底层用到了线程池，对于 <code>IntentService</code> 和 <code>HandlerThread</code> 来说，他们的底层则直接使用了线程。</p><h3 id="AsyncTask"><a href="#AsyncTask" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p><strong><code>AsyncTask</code></strong>是 Android 提供的一种轻量级的异步任务类，它可以在线程池中执行后台任务，然后把执行进度和最终结果传递给主线程并在主线程中更新 UI，其内部封装了 <code>Thread</code> 和 <code>Handler</code>，通过 <code>AsyncTask</code> 可以更加方便地执行后台任务，以及在主线程中访问 UI，但是不能执行可别耗时的后台任务，对于特别耗时的后台任务，建议使用线程池。</p><p><code>AsyncTask</code> 是一个抽象的泛型类，它提供了 <code>Params</code>、<code>Progress</code>、<code>Result</code> 三个参数，<code>Params</code> 表示参数类型，<code>Progerss</code> 表示后台任务的执行进度的类型，而 <code>Result</code> 则表示后台任务的返回结果的类型，如果不需要传递具体的参数，那么这三个参数可以用 <code>Void</code> 来代替。</p><p><code>AsyncTask</code> 还提供了四个核心方法：</p><ul><li><code>onPreExecute()：</code>在主线程中执行，在异步任务执行之前，此方法被调用，一般可以用于做一些初始化工作。</li><li><code>doInBackground(Params... params)：</code>在线程池中执行，此方法用于执行异步任务，params 参数表示异步任务的输入参数，在此方法中可以通过 <code>publishProgress()</code> 方法来更新任务进度，<code>publishProgress()</code> 方法会调用 <code>onProgressUpdate()</code> 方法，另外此方法需要返回执行结果给 <code>onPostExecute()</code> 方法。</li><li><code>onProgressUpdate(Progress... values)：</code>在主线程中执行，当后台任务的执行进度发生改变时此方法会被调用。</li><li><code>onPostExecute(Result result)：</code>在主线程执行，在异步任务执行后此方法会被调用，其中 result 参数是后台任务的返回值，即 <code>doInBackground()</code> 方法的返回值。</li></ul><p>除了上述四个方法之外，<code>AsyncTask</code> 还提供了 <code>onCancelled()</code> 方法，它同样在主线程中执行，当异步任务被取消时，<code>onCancelled()</code> 方法会被调用，这个时候 <code>onPostExecute()</code> 方法则不会被调用。</p><p>使用 <code>AsyncTask</code> 需要注意以下几点：</p><ul><li><code>AsyncTask</code> 类必须在主线程中加载，这就意味着第一次访问 <code>AsyncTask</code> 必须发生在主线程；</li><li><code>AsyncTask</code> 的对象必须在 UI 线程中创建；</li><li><code>execute()</code> 方法必须在 UI 线程调用；</li><li>不要在程序中直接调用 <code>onPreExecute()</code>、<code>onPostExecute()</code>、<code>doInBackground()</code> 和 <code>onProgressUpdate()</code> 方法；</li><li>一个 <code>AsyncTask</code> 对象只能执行一次，即只能调用一次 <code>execute()</code> 方法，否则会报运行时异常。</li></ul><blockquote><p><code>AsyncTask</code> 为主线程与工作线程之间进行快速的切换提供一种简单便捷的机制。适用于当下立即需要启动，但是异步执行的生命周期短暂的使用场景。</p></blockquote><h3 id="HandlerThread"><a href="#HandlerThread" class="headerlink" title="HandlerThread"></a>HandlerThread</h3><p><strong><code>HandlerThread</code></strong>继承了 <code>Thread</code>，它是一种可以使用 <code>Handler</code> 的 <code>Thread</code>，它的实现很简单，就是在 <code>run()</code> 方法中通过 <code>Looper.prepare()</code> 来创建消息队列，并通过 <code>Looper.loop()</code> 来开启消息循环，这样在实际的使用中就允许在 <code>HandlerThread</code> 中创建 <code>Handler</code> 了。</p><p><code>HandlerThread</code> 的 <code>run()</code> 方法实现如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    mTid <span class="token operator">=</span> Process<span class="token punctuation">.</span><span class="token function">myTid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Looper<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mLooper <span class="token operator">=</span> Looper<span class="token punctuation">.</span><span class="token function">myLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    Process<span class="token punctuation">.</span><span class="token function">setThreadPriority</span><span class="token punctuation">(</span>mPriority<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token function">onLooperPrepared</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Looper<span class="token punctuation">.</span><span class="token function">loop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mTid <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从 <code>HandlerThread</code> 的实现来看，它和普通 <code>Thread</code> 有显著的不同之处，普通 <code>Thread</code> 主要用于在 <code>run()</code> 方法中执行一个耗时的任务，而 <code>HandlerThread</code> 在内部创建了消息队列，外界需要通过 <code>Handler</code> 的消息方式来通知 <code>HandlerThread</code> 执行一个具体的任务。</p><p>创建一个 <code>HandlerThread</code> 对象并调用 <code>HandlerThraed#start()</code> 方法启动线程，然后调用 <code>HandlerThread#getLooper()</code> 方法获取 <code>Looper</code> 对象作为参数创建 <code>Handler</code> 对象。</p><p><code>HandlerThread</code> 是一个很有用的类，它在 Android 中的一个具体的使用场景是 <code>IntentService</code>，由于 <code>HandlerThread</code> 的 <code>run()</code> 方法是一个无限循环，因此当明确不需要再使用 <code>HandlerThread</code> 时，可以通过它的，<code>quit()</code> 或者 <code>quitSafely()</code> 方法来终止线程的执行，这就是一个良好的编程习惯。</p><blockquote><p><code>HandlerThread</code> 为某些回调方法或者等待某些任务的执行设置一个专属的线程，并提供线程任务的调度机制。</p></blockquote><h3 id="IntentService"><a href="#IntentService" class="headerlink" title="IntentService"></a>IntentService</h3><p><strong><code>IntentService</code></strong>是一个特殊的 <code>Service</code>，它集成了 <code>Service</code> 并且它是一个抽象类，因此必须创建它的子类才能使用 <code>IntentService</code>。<code>IntentService</code> 可用于执行后台耗时的任务，当任务执行后它会自动停止，同时由于 <code>IntentService</code> 是服务的原因，这导致了它的优先级比单纯的线程要高的多，所以 <code>IntentService</code> 比较适合执行一些高优先级的的后台任务，因为它优先级高不容易被系统杀死。</p><p>在实现上，<code>IntentService</code> 封装了 <code>HandlerThread</code> 和 <code>Handler</code>，这一点可以从它的 <code>onCreate()</code> 方法中看出来：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    HandlerThread thread <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HandlerThread</span><span class="token punctuation">(</span><span class="token string">"IntentService["</span> <span class="token operator">+</span> mName <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    thread<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mServiceLooper <span class="token operator">=</span> thread<span class="token punctuation">.</span><span class="token function">getLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mServiceHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ServiceHandler</span><span class="token punctuation">(</span>mServiceLooper<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>第一次启动 <code>IntentService</code> 的时候，它的 <code>onCreate()</code> 方法会被调用，会创建一个 <code>HandlerThread</code>，然后使用它的 <code>Looper</code> 来构造一个 <code>Handler</code> 对象，这样通过 <code>mServiceHandler</code> 发送的消息最终都会在 <code>HandlerThread</code> 中执行，从这个角度来看，<code>IntentService</code> 也可以在后台执行任务，每次启动 <code>IntentService</code>，它的 <code>onStartCommand()</code> 都会调用一次，在这个方法中处理每个后台任务的<code>Intent</code>。下面来看一下 <code>onStartCommand()</code> 方法是如何处理外界的 <code>Intent</code>：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">onStartCommand</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> flags<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">onStart</span><span class="token punctuation">(</span>intent<span class="token punctuation">,</span> startId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> mRedelivery <span class="token operator">?</span> START_REDELIVER_INTENT <span class="token operator">:</span> START_NOT_STICKY<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到 <code>onStartCommand()</code> 方法调用了 <code>onStart()</code> 方法，下面来看一下 <code>onStart()</code> 方法的具体实现：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onStart</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Intent intent<span class="token punctuation">,</span> <span class="token keyword">int</span> startId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Message msg <span class="token operator">=</span> mServiceHandler<span class="token punctuation">.</span><span class="token function">obtainMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>arg1 <span class="token operator">=</span> startId<span class="token punctuation">;</span>    msg<span class="token punctuation">.</span>obj <span class="token operator">=</span> intent<span class="token punctuation">;</span>    mServiceHandler<span class="token punctuation">.</span><span class="token function">sendMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>可以看到 <code>onStart()</code> 方法仅仅是通过 <code>mServiceHandler</code> 发送了一消息，这个消息会在 <code>HandlerThread</code> 中处理。下面来看一下 <code>ServiceHandler</code> 具体实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">ServiceHandler</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ServiceHandler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>looper<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">onHandleIntent</span><span class="token punctuation">(</span><span class="token punctuation">(</span>Intent<span class="token punctuation">)</span> msg<span class="token punctuation">.</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">stopSelf</span><span class="token punctuation">(</span>msg<span class="token punctuation">.</span>arg1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过上面的代码可以看到 <code>mServiceHandler</code> 收到消息以后，会将 <code>Intent</code> 对象传递给 <code>onHandleIntent()</code> 方法处理，注意这个 <code>Intent</code> 对象的内容和外界的 <code>startService(intent)</code> 中的 <code>intent</code> 的内容是完全一致的，<code>IntentService</code> 也是按顺序执行后台任务的。</p><blockquote><p><code>IntentService</code> 适合于执行由 <code>UI</code> 触发的后台 <code>Service</code> 任务，并可以把后台任务执行的情况通过一定的机制反馈给 <code>UI</code>。</p></blockquote><h2 id="Android-线程间通信方式"><a href="#Android-线程间通信方式" class="headerlink" title="Android 线程间通信方式"></a>Android 线程间通信方式</h2><p>Android 线程间通信的可以归纳为以下两种情况：</p><ul><li>将任务从主线程抛到工作线程</li><li>将任务从工作线程抛到主线程</li></ul><p>将任务从主线程抛到工作线程可以使用前面提到的线程或线程池的方式实现。下面主要讲解一下将任务从工作线程抛到主线程的方式。</p><h3 id="Activity-runOnUiThread"><a href="#Activity-runOnUiThread" class="headerlink" title="Activity.runOnUiThread()"></a>Activity.runOnUiThread()</h3><p><strong><code>Activity.runOnUiThread()</code></strong>是一种常用的将任务从工作线程抛到主线程的方式。下面看一下 <code>Activity.runOnUiThread()</code> 方法的具体实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">runOnUiThread</span><span class="token punctuation">(</span>Runnable action<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> mUiThread<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mHandler<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        action<span class="token punctuation">.</span><span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>通过上面的代码可以看到如果当前线程是 UI 线程，直接运行该 <code>Runnable</code> 对象的 <code>run()</code> 方法，如果不在 UI 线程，则通过 <code>Activity</code> 持有的 <code>Handler</code> 对象调用 <code>post()</code> 方法。</p><h3 id="View-post"><a href="#View-post" class="headerlink" title="View.post()"></a>View.post()</h3><p><strong><code>View.post()</code></strong>也是一种常用的将任务从工作线程抛到主线程的方式。下面看一下 <code>View.post()</code> 方法的具体实现：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable action<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> AttachInfo attachInfo <span class="token operator">=</span> mAttachInfo<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>attachInfo <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> attachInfo<span class="token punctuation">.</span>mHandler<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// Postpone the runnable until we know on which thread it needs to run.</span>    <span class="token comment" spellcheck="true">// Assume that the runnable will be successfully placed after attach.</span>    <span class="token function">getRunQueue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>action<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>通过上面的代码可以看到如果当前 <code>View</code> 已经关联到父窗口，直接通过 <code>AttachInfo</code> 持有的 <code>Handler</code> 对象调用 <code>post()</code> 方法，如果该视图还没有关联到父窗口，则将任务添加到待处理任务队列中等待该视图被关联到父窗口时通过 <code>AttachInfo</code> 持有的 <code>Handler</code> 对象执行。</p><blockquote><p><code>View.postDelayed()</code> 方法的执行过程和 <code>View.post()</code> 方法相同，<code>View.postDelayed()</code> 方法除了可以传递 <code>Runnable</code> 对象外，还可以传递一个 <code>delayMillis</code> 参数表示执行 <code>Runnable</code> 之前的延迟(以毫秒为单位)。</p></blockquote><h3 id="AsyncTask-1"><a href="#AsyncTask-1" class="headerlink" title="AsyncTask"></a>AsyncTask</h3><p><strong><code>AsyncTask</code></strong>是 Android 给我们提供的一个处理异步任务的类。通过此类，可以实现 UI 线程和工作线程进行通讯，工作线程执行异步任务并把结果返回给 UI 线程，其内部封装了 <code>Thread</code> 和 <code>Handler</code>。</p><blockquote><p>注意：<code>AsyncTask</code> 作为匿名内部类使用时，会隐式地持有外部类的引用，可能会导致内存泄露。比如：在 <code>Activity</code> 里声明且实例化一个匿名的 <code>AsyncTask</code> 对象，则可能会发生内存泄漏，如果这个线程在 <code>Activity</code> 销毁后还一直在后台执行，那这个线程会继续持有这个 <code>Activity</code> 的引用从而不会被 <code>GC</code> 回收，直到线程执行完成。</p></blockquote><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p><strong><code>Handler</code></strong>是 Android 中相当经典的异步消息机制，在 Android 发展的历史长河中扮演着很重要的角色，无论是我们直接面对的应用层还是 FrameWork 层，使用的场景还是相当的多。<code>Activity.runOnUiThread()</code>、<code>View.post()</code> 以及 <code>AsyncTask</code> 内部都是使用的 <code>Handler</code> 将任务从工作线程抛到主线程，所以 <code>Handler</code> 是一种最常用的将任务从工作线程抛到主线程的方式。</p><p><code>Handler</code> 有以下两个主要用途：</p><ul><li>将未来某个时间点将要执行的 <code>Message</code> 或 <code>Runnable</code> 加入到消息队列；</li><li>在子线程把需要在另一个线程执行的操作加入到消息队列中去。</li></ul><p><code>Handler</code> 常用的构造方法、将 <code>Message</code> 或 <code>Runnable</code> 加入到消息队列的方法如下所示：</p><ul><li><p><code>Handler</code> 的构造方法有以下几种：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> async<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">Handler</span><span class="token punctuation">(</span>Looper looper<span class="token punctuation">,</span> Handler<span class="token punctuation">.</span>Callback callback<span class="token punctuation">,</span> <span class="token keyword">boolean</span> async<span class="token punctuation">)</span></code></pre></li><li><p><code>Handler</code> 将 <code>Message</code> 加入到消息队列的方法有以下几种：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendEmptyMessage</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendEmptyMessageDelayed</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendEmptyMessageAtTime</span><span class="token punctuation">(</span><span class="token keyword">int</span> what<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtTime</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">sendMessageAtFrontOfQueue</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span></code></pre></li><li><p><code>Handler</code> 将 <code>Runnable</code> 加入到消息队列的方法有以下几种：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">post</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postAtTime</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postAtTime</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Object token<span class="token punctuation">,</span> <span class="token keyword">long</span> uptimeMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postDelayed</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postDelayed</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">,</span> Object token<span class="token punctuation">,</span> <span class="token keyword">long</span> delayMillis<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">postAtFrontOfQueue</span><span class="token punctuation">(</span>Runnable r<span class="token punctuation">)</span></code></pre></li></ul><blockquote><p>无论 <code>Handler</code> 将 <code>Message</code> 还是 <code>Runnable</code> 加入 <code>MessageQueue</code>，最终都只是将 <code>Message</code> 加入到 <code>MessageQueue</code>。分析源码可以看到 <code>Handler</code> 将 <code>Runnable</code> 加入到消息队列的方法内部都是调用 <code>getPostMessage()</code> 方法把 <code>Runnable</code> 封装成 <code>Message</code> 对象的 <code>callback</code> 属性，然后再将得到的 <code>Message</code> 加入到消息队列的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java HashMap 的实现原理</title>
      <link href="/posts/2019/8d7d4236.html"/>
      <url>/posts/2019/8d7d4236.html</url>
      
        <content type="html"><![CDATA[<p>数据结构中有<code>数组</code>和<code>链表</code>这两个结构来存储数据。</p><ul><li><strong><code>数组</code></strong>存储区间连续，占用内存比较严重，故空间复杂的很大，但数组的二分查找时间复杂度小，为 <code>O(1)</code>。数组的特点是：<strong>寻址容易，插入和删除困难</strong>；</li><li><strong><code>链表</code></strong>存储区间离散，占用内存比较宽松，故空间复杂度很小，但链表的时间复杂度很大，为 <code>O(N)</code>。链表的特点是：<strong>寻址困难，插入和删除容易</strong>。</li></ul><p>综合这两者的优点，摒弃缺点，哈希表就诞生了，既满足了数据查找方面的特点，占用的空间也不大。</p><p><strong><code>哈希表</code></strong>可以说就是数组链表，底层还是数组，但是这个数组每一项就是一个链表。特点是：<strong>寻址容易，插入删除也容易，占用的空间也不大</strong>。</p><p>在这个数组中，每个元素存储的其实是一个链表的头，元素的存储位置一般情况是通过 <code>hash(key)%len</code> 获得，也就是元素的 <code>key</code> 的哈希值对数组长度取模得到。比如上述哈希表中，12%16=12,28%16=12,108%16=12,140%16=12。所以12、28、108以及140都存储在数组下标为12的位置。</p><blockquote><p>哈希表有多种不同的实现方法，<code>HashMap</code> 则使用的是<code>拉链法</code>，也叫作<code>链地址法</code>；</p></blockquote><h2 id="HashMap-简介"><a href="#HashMap-简介" class="headerlink" title="HashMap 简介"></a>HashMap 简介</h2><p><code>java.util.HashMap</code> 实现了 <code>java.util.Map</code> 接口，继承 <code>java.util.AbstractMap</code>。其中 <code>Map</code> 接口定义了键映射到值的规则，而 <code>AbstractMap</code> 类提供 <code>Map</code> 接口的骨干实现。</p><p><code>HashMap</code> 提供了三个构造函数：</p><ul><li><code>HashMap()：</code>构造一个具有默认初始容量 (16) 和默认加载因子 (0.75) 的空 HashMap。</li><li><code>HashMap(int initialCapacity)：</code>构造一个带指定初始容量和默认加载因子 (0.75) 的空 HashMap。</li><li><code>HashMap(int initialCapacity, float loadFactor)：</code>构造一个带指定初始容量和加载因子的空 HashMap。</li></ul><blockquote><p><code>HashMap</code> 是基于哈希表的 <code>Map</code> 接口的非同步实现。此实现提供所有可选的映射操作，并允许使用 <code>null</code> 值和 <code>null</code> 键。此类不保证映射的顺序，特别是它不保证该顺序恒久不变。</p></blockquote><h2 id="HashMap-的实现原理"><a href="#HashMap-的实现原理" class="headerlink" title="HashMap 的实现原理"></a>HashMap 的实现原理</h2><p><code>HashMap</code> 是开发中经常使用到的集合类，JDK 1.8 相对于 1.7 底层实现发生了一些改变。JDK 1.7 是<strong><code>数组+链表</code></strong>，1.8 则是<strong><code>数组+链表+红黑树结构(当链表长度大于8，转为红黑树)</code></strong>。</p><h3 id="JDK-1-7-的实现原理"><a href="#JDK-1-7-的实现原理" class="headerlink" title="JDK 1.7 的实现原理"></a>JDK 1.7 的实现原理</h3><h4 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h4><p>在 JDK 1.7 及之前，<code>HashMap</code> 由<strong><code>数组+链表</code></strong>组成，也就是<code>链表散列</code>，<strong>数组是 HashMap 的主体，链表实则是为了解决哈希冲突而存在的(拉链法解决哈希冲突)</strong>。JDK 1.7 中 <code>HashMap</code> 的数据结构如下图所示：<br><img src="https://henleylee.github.io/medias/java/hashmap_jdk_1_7_structure.png" alt="JDK1.7中HashMap的数据结构"></p><p><code>HashMap</code> 通过 <code>key</code> 的 <code>hashCode</code> 经过扰动函数处理过后得到 <code>hash</code> 值，然后通过 <code>(n - 1) &amp; hash</code> 判断当前元素存放的位置(这里的 n 指的是数组的长度)，如果当前位置存在元素的话，就判断该元素与要存入的元素的 <code>hash</code> 值以及 <code>key</code> 是否相同，如果相同的话，直接覆盖，不相同就通过拉链法解决冲突。</p><p>所谓扰动函数指的就是 <code>HashMap</code> 的 <code>hash()</code> 方法。使用 <code>hash()</code> 方法也就是扰动函数是为了防止一些实现比较差的 <code>hashCode()</code> 方法，换句话说使用扰动函数之后可以减少碰撞。</p><p><strong><code>拉链法</code></strong>是将链表和数组相结合。也就是说创建一个链表数组，数组中每一格就是一个链表。若遇到哈希冲突，则将冲突的值加到链表中即可。</p><h4 id="类中常量"><a href="#类中常量" class="headerlink" title="类中常量"></a>类中常量</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 默认初始容量(必须是2的n次幂)，HashMap 底层是数组，这个是数组默认的大小 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">/** 最大容量为2的30次方 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 默认的加载因子(在构造函数中未指定时使用的加载因子) */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token keyword">final</span> Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span><span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_TABLE <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 存储元素的数组(长度总是2的n次幂) */</span><span class="token keyword">transient</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table <span class="token operator">=</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> EMPTY_TABLE<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 存放元素的个数(注意的是这个值不等于数组的长度) */</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 每次扩容或者更改map结构的计数器 */</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 下次扩容的临界值(size>=threshold就会扩容，threshold=capacity*loadFactor) */</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 哈希表的加载因子(可以在初始化的时候显示指定) */</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span></code></pre><ul><li><strong><code>threshold：</code></strong>哈希表的阈值，也叫临界值，<code>threshold = capacity * loadFactor</code>。当 <code>HashMap</code> 的 <code>size&gt;=threshold</code> 的时候，那么就要考虑对数组的扩容了，也就是说，<code>threshold</code> 是衡量数组是否需要扩增的一个标准。</li><li><strong><code>loadFactor：</code></strong>哈希表的加载因子，也可以叫<code>负载因子</code>，用来<code>控制数组存放数据的疏密程度</code>，<code>loadFactor</code> 越趋近于 1，说明数组中存放的 <code>entry</code> 越多，链表的长度就越长。默认的 <code>HashMap</code> 的容量是 16，加载因子是 0.75，当我们在使用 <code>HashMap</code> 的时候，随着我们不断的 put 数据，当数量达到 <code>16 * 0.75 = 12</code> 的时候，就需要将当前的 16 进行扩容，而扩容就涉及到数据的复制，rehash 等，就消耗性能。所以，建议当我们知道 <code>HashMap</code> 的使用大小时，应该在初始化的时候指定大小，减少扩容带来的性能消耗。</li></ul><h4 id="Entry-类"><a href="#Entry-类" class="headerlink" title="Entry 类"></a>Entry 类</h4><p>存储元素的数组 <code>table</code> 中存放的是 <code>Entry</code> 类型的数据。下面简单看看 <code>Entry</code> 的定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Creates new entry.     */</span>    <span class="token function">Entry</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">,</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> n<span class="token punctuation">)</span> <span class="token punctuation">{</span>        value <span class="token operator">=</span> v<span class="token punctuation">;</span>        next <span class="token operator">=</span> n<span class="token punctuation">;</span>        key <span class="token operator">=</span> k<span class="token punctuation">;</span>        hash <span class="token operator">=</span> h<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        Map<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token punctuation">)</span> o<span class="token punctuation">;</span>        Object k1 <span class="token operator">=</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object k2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k1 <span class="token operator">==</span> k2 <span class="token operator">||</span> <span class="token punctuation">(</span>k1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Object v1 <span class="token operator">=</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Object v2 <span class="token operator">=</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>v1 <span class="token operator">==</span> v2 <span class="token operator">||</span> <span class="token punctuation">(</span>v1 <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> v1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>v2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> key<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">^</span>                <span class="token punctuation">(</span>value <span class="token operator">==</span> null <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> value<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 当向HashMap中添加元素的时候调用这个方法(这里没有实现是供子类回调用)     */</span>    <span class="token keyword">void</span> <span class="token function">recordAccess</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 当从HashMap中删除元素的时候调动这个方法(这里没有实现是供子类回调用)     */</span>    <span class="token keyword">void</span> <span class="token function">recordRemoval</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> m<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><strong><code>Entry</code></strong>是一个内部类，其中的 <code>key</code> 就是写入的键，<code>value</code> 就是写入的值，由于 <code>HashMap</code>由<strong>数组+链表</strong>的形式，这里的 <code>next</code> 就是用于实现链表结构。<code>hash</code> 存放的事当前 <code>key</code> 的 <code>hashcode</code> 值。</p><h4 id="put-方法"><a href="#put-方法" class="headerlink" title="put() 方法"></a>put() 方法</h4><p><strong><code>put()</code></strong>方法的过程是先计算 <code>hash</code>，然后通过 <code>hash</code> 与 <code>table.length</code> 取模计算 <code>index</code> 值，然后将 <code>key</code> 放到 <code>table[index]</code> 位置，当 <code>table[index]</code> 已存在其它元素时，会在 <code>table[index]</code> 位置形成一个链表，将新添加的元素放在 <code>table[index]</code>，原来的元素通过 <code>Entry</code> 的 <code>next</code> 进行链接，这样<code>以链表形式解决 hash 冲突问题</code>，当元素数量达到临界值(<code>capactiyfactor</code>)时，则进行扩容，使 <code>table</code> 数组长度变为 <code>table.length * 2</code>。下面分析 <code>put()</code> 方法的源码： </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果key为null，则处理null值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">putForNullKey</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据key计算出hashcode值</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据计算的hashcode值和数组长度定位在数组中的存储位置</span>    <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果table[i]位置是一个链表，则需要遍历判断里面的 hashcode、key 是否和传入 key 相等</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果相等则进行覆盖，并返回原来的值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 若没有在table[i]位置找到相同的key，则添加key到table[i]位置，新的元素总是在table[i]位置的第一个元素，原来的元素后移</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> V <span class="token function">putForNullKey</span><span class="token punctuation">(</span>V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 取出数组第1个位置(下标等于0)的节点，如果存在则覆盖不存在则新增，和put方法的逻辑一样</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">recordAccess</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    modCount<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果key等于null，则hash值等于0</span>    <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> null<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">addEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 判断当前HashMap的size与临界值的大小，判断是否需要扩容操作</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">>=</span> threshold<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果需要扩容，就进行2倍扩容</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将当前的key重新hash并定位</span>        hash <span class="token operator">=</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> key<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token number">0</span><span class="token punctuation">;</span>        bucketIndex <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 创建一个Entry，如果当前位置存在元素，就形成链表</span>    <span class="token function">createEntry</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> bucketIndex<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">createEntry</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">int</span> bucketIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>    table<span class="token punctuation">[</span>bucketIndex<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    size<span class="token operator">++</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>put()</code> 方法图解如下图所示：<br><img src="https://henleylee.github.io/medias/java/hashmap_jdk_1_7_put.png" alt="JDK1.7中HashMap的put()方法图解"></p><blockquote><p><code>put()</code> 方法会对 <code>key</code> 为 <code>null</code> 时进行特殊处理，<code>key</code> 为 <code>null</code> 的元素总是放到 <code>table[0]</code> 位置。</p></blockquote><h4 id="get-方法"><a href="#get-方法" class="headerlink" title="get() 方法"></a>get() 方法</h4><p><strong><code>get()</code></strong>方法的过程是先计算 <code>hash</code>，然后通过 <code>hash</code> 与 <code>table.length</code> 取模计算 <code>index</code> 值，然后遍历 <code>table[index]</code> 上的链表，直到找到 <code>key</code>，然后返回。下面分析 <code>get()</code> 方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 如果key为null，则处理null值</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token keyword">return</span> <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据key获取Entry</span>    Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> entry <span class="token operator">=</span> <span class="token function">getEntry</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 如果entry为null，则返回null；否则返回key对应的value</span>    <span class="token keyword">return</span> null <span class="token operator">==</span> entry <span class="token operator">?</span> null <span class="token operator">:</span> entry<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> V <span class="token function">getForNullKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span> e <span class="token operator">!=</span> null<span class="token punctuation">;</span> e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">getEntry</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 根据key计算hashcode值，然后定位到具体的位置</span>    <span class="token keyword">int</span> hash <span class="token operator">=</span> <span class="token punctuation">(</span>key <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断是否是链表，为链表则需要遍历直到 key 及 hashcode 相等时候就返回值</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">=</span> table<span class="token punctuation">[</span><span class="token function">indexFor</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> table<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span>         e <span class="token operator">!=</span> null<span class="token punctuation">;</span>         e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 根据 key、key 的 hashcode 是否相等来返回值</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> e<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 没取到就直接返回null</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>get()</code> 方法同样会对 <code>key</code> 为 <code>null</code> 时进行特殊处理，在 <code>table[0]</code> 的位置上查找 <code>key</code> 为 <code>null</code> 的元素。</p></blockquote><h4 id="resize-方法"><a href="#resize-方法" class="headerlink" title="resize() 方法"></a>resize() 方法</h4><p><strong><code>resize()</code></strong>方法的过程是先创建一个容量为 <code>table.length * 2</code>的新 <code>table</code>，修改临界值，然后把 <code>table</code> 里面元素重新计算位置并全部转移到新的 <code>table</code> 里面。下面分析 <code>resize()</code> 方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token keyword">int</span> newCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 保存当前table</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> oldTable <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存table大小</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> oldTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断之前的table长度是否大于等于默认最大容量MAXIMUM_CAPACITY</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">==</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将临界值改为Integer.MAX_VALUE并返回</span>        threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>        <span class="token keyword">return</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 使用新的容量创建一个新的链表数组</span>    Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>newCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> oldAltHashing <span class="token operator">=</span> useAltHashing<span class="token punctuation">;</span>    useAltHashing <span class="token operator">|=</span> sun<span class="token punctuation">.</span>misc<span class="token punctuation">.</span>VM<span class="token punctuation">.</span><span class="token function">isBooted</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>newCapacity <span class="token operator">>=</span> Holder<span class="token punctuation">.</span>ALTERNATIVE_HASHING_THRESHOLD<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">boolean</span> rehash <span class="token operator">=</span> oldAltHashing <span class="token operator">^</span> useAltHashing<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将当前数组中的元素都移动到新数组中</span>    <span class="token function">transfer</span><span class="token punctuation">(</span>newTable<span class="token punctuation">,</span> rehash<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 将当前数组指向新创建的数组</span>    table <span class="token operator">=</span> newTable<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重新计算临界值</span>    threshold <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> Math<span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>newCapacity <span class="token operator">*</span> loadFactor<span class="token punctuation">,</span> MAXIMUM_CAPACITY <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">void</span> <span class="token function">transfer</span><span class="token punctuation">(</span>Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> newTable<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 新数组长度</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> newTable<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 遍历当前数组的元素，重新计算每个元素所在数组位置</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e <span class="token operator">:</span> table<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 循环链表，挨个将每个节点插入到新的数组位置中</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>null <span class="token operator">!=</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>rehash<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span>hash <span class="token operator">=</span> null <span class="token operator">==</span> e<span class="token punctuation">.</span>key <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> <span class="token function">hash</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 重新计算该链表在数组中的索引位置</span>            <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token function">indexFor</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将下一个节点指向newTable[i]</span>            e<span class="token punctuation">.</span>next <span class="token operator">=</span> newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 将当前节点放置在newTable[i]位置</span>            newTable<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 下一次循环</span>            e <span class="token operator">=</span> next<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="JDK-1-8-的实现原理"><a href="#JDK-1-8-的实现原理" class="headerlink" title="JDK 1.8 的实现原理"></a>JDK 1.8 的实现原理</h3><h4 id="数据结构-1"><a href="#数据结构-1" class="headerlink" title="数据结构"></a>数据结构</h4><p>在 JDK 1.8 中，<code>HashMap</code> 由<strong><code>数组+链表+红黑树结构(当链表长度大于8，转为红黑树)</code></strong>组成，不过本质并未变。如果按照链表的方式存储，随着节点的增加数据会越来越多，这会导致查询节点的时间复杂度会逐渐增加，平均时间复杂度<code>O(n)</code>。为了提高查询效率，故在 JDK 1.8 中引入了改进方法红黑树。此数据结构的平均查询效率为 <code>O(long n)</code>。JDK 1.8 中 <code>HashMap</code> 的数据结构如下图所示：<br><img src="https://henleylee.github.io/medias/java/hashmap_jdk_1_8_structure.png" alt="JDK1.8中HashMap的数据结构"></p><h4 id="类中常量-1"><a href="#类中常量-1" class="headerlink" title="类中常量"></a>类中常量</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** 默认初始容量(必须是2的n次幂)，HashMap 底层是数组，这个是数组默认的大小 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DEFAULT_INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">4</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// aka 16</span><span class="token comment" spellcheck="true">/** 最大容量为2的30次方 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAXIMUM_CAPACITY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token number">30</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 默认的加载因子(在构造函数中未指定时使用的加载因子) */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">float</span> DEFAULT_LOAD_FACTOR <span class="token operator">=</span> <span class="token number">0.75f</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 将链表转为红黑树的阈值 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 将红黑树转为链表的阈值 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNTREEIFY_THRESHOLD <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 链表结构转为红黑树对应的最小数组大小为64 */</span><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MIN_TREEIFY_CAPACITY <span class="token operator">=</span> <span class="token number">64</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 存储元素的数组(长度总是2的n次幂) */</span><span class="token keyword">transient</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 存放具体元素的集合 */</span><span class="token keyword">transient</span> Set<span class="token operator">&lt;</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">>></span> entrySet<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 存放元素的个数(注意的是这个值不等于数组的长度) */</span><span class="token keyword">transient</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 每次扩容或者更改map结构的计数器 */</span><span class="token keyword">transient</span> <span class="token keyword">int</span> modCount<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 下次扩容的临界值(size>=threshold就会扩容，threshold=capacity*loadFactor) */</span><span class="token keyword">int</span> threshold<span class="token punctuation">;</span><span class="token comment" spellcheck="true">/** 哈希表的加载因子(可以在初始化的时候显示指定) */</span><span class="token keyword">final</span> <span class="token keyword">float</span> loadFactor<span class="token punctuation">;</span></code></pre><p>对比 JDK 1.7 中的常量，就会发现 JDK 1.8 中做了如下改变：</p><ul><li>增加了 <code>TREEIFY_THRESHOLD</code>，当链表的长度超过这个值的时候，就会将链表转换红黑树。</li><li><code>Entry</code> 修改为 <code>Node</code>，虽然 <code>Node</code> 的核心也是 <code>key</code>、<code>value</code>、<code>next</code> 和 <code>hash</code>。</li></ul><h4 id="Node-类"><a href="#Node-类" class="headerlink" title="Node 类"></a>Node 类</h4><p>存储元素的数组 <code>table</code> 中存放的是 <code>Node</code> 类型的数据。下面简单看看 <code>Node</code> 的定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Node</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">implements</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> hash<span class="token punctuation">;</span>    <span class="token keyword">final</span> K key<span class="token punctuation">;</span>    V value<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>    <span class="token function">Node</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>hash <span class="token operator">=</span> hash<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> next<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> K <span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> key<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> key <span class="token operator">+</span> <span class="token string">"="</span> <span class="token operator">+</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span> <span class="token operator">^</span> Objects<span class="token punctuation">.</span><span class="token function">hashCode</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> V <span class="token function">setValue</span><span class="token punctuation">(</span>V newValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        V oldValue <span class="token operator">=</span> value<span class="token punctuation">;</span>        value <span class="token operator">=</span> newValue<span class="token punctuation">;</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token keyword">instanceof</span> <span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span> e <span class="token operator">=</span> <span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token operator">></span><span class="token punctuation">)</span> o<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    Objects<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>value<span class="token punctuation">,</span> e<span class="token punctuation">.</span><span class="token function">getValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h4 id="TreeNode-类"><a href="#TreeNode-类" class="headerlink" title="TreeNode 类"></a>TreeNode 类</h4><p><strong><code>TreeNode</code></strong>是 JDK 1.8 新增的，属于数据结构中的<code>红黑树</code>，用作树节点类，继承自 <code>LinkedHashMap.Entry</code>，而 <code>LinkedHashMap.Entry</code> 继承自 <code>HashMap.Node</code>，因此可以用作常规节点或链表节点的扩展。下面简单看看 <code>TreeNode</code> 的定义：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">TreeNode</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap<span class="token punctuation">.</span>LinkedHashMapEntry</span><span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token punctuation">{</span>    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> parent<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// red-black tree links</span>    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> left<span class="token punctuation">;</span>    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> right<span class="token punctuation">;</span>    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> prev<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// needed to unlink next upon deletion</span>    <span class="token keyword">boolean</span> red<span class="token punctuation">;</span>    <span class="token function">TreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V val<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> val<span class="token punctuation">,</span> next<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns root of tree containing this node.     */</span>    <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> r <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">,</span> p<span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> r<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> r<span class="token punctuation">;</span>            r <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Finds the node starting at root p with the given hash and key.     * The kc argument caches comparableClassFor(key) upon first use     * comparing keys.     */</span>    <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">find</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> Object k<span class="token punctuation">,</span> Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> kc<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">do</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> ph<span class="token punctuation">,</span> dir<span class="token punctuation">;</span>            K pk<span class="token punctuation">;</span>            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> pl <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">,</span> pr <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">,</span> q<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">></span> h<span class="token punctuation">)</span>                p <span class="token operator">=</span> pl<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>                p <span class="token operator">=</span> pr<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pl <span class="token operator">==</span> null<span class="token punctuation">)</span>                p <span class="token operator">=</span> pr<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pr <span class="token operator">==</span> null<span class="token punctuation">)</span>                p <span class="token operator">=</span> pl<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">!=</span> null <span class="token operator">||</span>                    <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span>                p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> pl <span class="token operator">:</span> pr<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>q <span class="token operator">=</span> pr<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                <span class="token keyword">return</span> q<span class="token punctuation">;</span>            <span class="token keyword">else</span>                p <span class="token operator">=</span> pl<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Calls find for root node.     */</span>    <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">getTreeNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> h<span class="token punctuation">,</span> Object k<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Tree version of putVal.     */</span>    <span class="token keyword">final</span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">putTreeVal</span><span class="token punctuation">(</span>HashMap<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> map<span class="token punctuation">,</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">,</span>                                    <span class="token keyword">int</span> h<span class="token punctuation">,</span> K k<span class="token punctuation">,</span> V v<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> kc <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> searched <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> root <span class="token operator">=</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token function">root</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p <span class="token operator">=</span> root<span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> dir<span class="token punctuation">,</span> ph<span class="token punctuation">;</span>            K pk<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ph <span class="token operator">=</span> p<span class="token punctuation">.</span>hash<span class="token punctuation">)</span> <span class="token operator">></span> h<span class="token punctuation">)</span>                dir <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>ph <span class="token operator">&lt;</span> h<span class="token punctuation">)</span>                dir <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pk <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> k <span class="token operator">||</span> <span class="token punctuation">(</span>k <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> k<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>pk<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                <span class="token keyword">return</span> p<span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>kc <span class="token operator">==</span> null <span class="token operator">&amp;&amp;</span>                    <span class="token punctuation">(</span>kc <span class="token operator">=</span> <span class="token function">comparableClassFor</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>                    <span class="token punctuation">(</span>dir <span class="token operator">=</span> <span class="token function">compareComparables</span><span class="token punctuation">(</span>kc<span class="token punctuation">,</span> k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>searched<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> q<span class="token punctuation">,</span> ch<span class="token punctuation">;</span>                    searched <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                            <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">||</span>                            <span class="token punctuation">(</span><span class="token punctuation">(</span>ch <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span>                                    <span class="token punctuation">(</span>q <span class="token operator">=</span> ch<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> kc<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">)</span>                        <span class="token keyword">return</span> q<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                dir <span class="token operator">=</span> <span class="token function">tieBreakOrder</span><span class="token punctuation">(</span>k<span class="token punctuation">,</span> pk<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> xp <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">?</span> p<span class="token punctuation">.</span>left <span class="token operator">:</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> xpn <span class="token operator">=</span> xp<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> x <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">newTreeNode</span><span class="token punctuation">(</span>h<span class="token punctuation">,</span> k<span class="token punctuation">,</span> v<span class="token punctuation">,</span> xpn<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>dir <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span>                    xp<span class="token punctuation">.</span>left <span class="token operator">=</span> x<span class="token punctuation">;</span>                <span class="token keyword">else</span>                    xp<span class="token punctuation">.</span>right <span class="token operator">=</span> x<span class="token punctuation">;</span>                xp<span class="token punctuation">.</span>next <span class="token operator">=</span> x<span class="token punctuation">;</span>                x<span class="token punctuation">.</span>parent <span class="token operator">=</span> x<span class="token punctuation">.</span>prev <span class="token operator">=</span> xp<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>xpn <span class="token operator">!=</span> null<span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> xpn<span class="token punctuation">)</span><span class="token punctuation">.</span>prev <span class="token operator">=</span> x<span class="token punctuation">;</span>                <span class="token function">moveRootToFront</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> <span class="token function">balanceInsertion</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> null<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/* ------------------------------------------------------------ */</span>    <span class="token comment" spellcheck="true">// Red-black tree methods, all adapted from CLR</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">rotateLeft</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> root<span class="token punctuation">,</span>                                            TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> r<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> rl<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>r <span class="token operator">=</span> p<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>rl <span class="token operator">=</span> p<span class="token punctuation">.</span>right <span class="token operator">=</span> r<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                rl<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pp <span class="token operator">=</span> r<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token punctuation">(</span>root <span class="token operator">=</span> r<span class="token punctuation">)</span><span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token punctuation">.</span>left <span class="token operator">==</span> p<span class="token punctuation">)</span>                pp<span class="token punctuation">.</span>left <span class="token operator">=</span> r<span class="token punctuation">;</span>            <span class="token keyword">else</span>                pp<span class="token punctuation">.</span>right <span class="token operator">=</span> r<span class="token punctuation">;</span>            r<span class="token punctuation">.</span>left <span class="token operator">=</span> p<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>parent <span class="token operator">=</span> r<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> <span class="token function">rotateRight</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> root<span class="token punctuation">,</span>                                             TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p<span class="token punctuation">)</span> <span class="token punctuation">{</span>        TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> l<span class="token punctuation">,</span> pp<span class="token punctuation">,</span> lr<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>l <span class="token operator">=</span> p<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>lr <span class="token operator">=</span> p<span class="token punctuation">.</span>left <span class="token operator">=</span> l<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span>                lr<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>pp <span class="token operator">=</span> l<span class="token punctuation">.</span>parent <span class="token operator">=</span> p<span class="token punctuation">.</span>parent<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token punctuation">(</span>root <span class="token operator">=</span> l<span class="token punctuation">)</span><span class="token punctuation">.</span>red <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>pp<span class="token punctuation">.</span>right <span class="token operator">==</span> p<span class="token punctuation">)</span>                pp<span class="token punctuation">.</span>right <span class="token operator">=</span> l<span class="token punctuation">;</span>            <span class="token keyword">else</span>                pp<span class="token punctuation">.</span>left <span class="token operator">=</span> l<span class="token punctuation">;</span>            l<span class="token punctuation">.</span>right <span class="token operator">=</span> p<span class="token punctuation">;</span>            p<span class="token punctuation">.</span>parent <span class="token operator">=</span> l<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> root<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>从上面的源码中可以看到此类就是个红黑树节点，父节点、左子树、右子树、前一个元素的节点，还有个颜色值。</p><h4 id="put-方法-1"><a href="#put-方法-1" class="headerlink" title="put() 方法"></a>put() 方法</h4><p><strong><code>put()</code></strong>方法的过程是先计算 <code>hash</code>，然后通过 <code>hash</code> 与 <code>table.length</code> 取模计算 <code>index</code> 值，然后将 <code>key</code> 放到 <code>table[index]</code> 位置，当 <code>table[index]</code> 已存在其它元素时，会判断该节点是属于红黑树还是属于链表，如果该节点是红黑树则在红黑树中插入数据，是链表则在链表末尾插入元素，如果链表的长度达到将链表转为红黑树的阈值则将链表转为红黑树的阈值，最后判断存储元素的实际大小大于阈值时则进行扩容。下面分析 <code>put()</code> 方法的源码： </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">put</span><span class="token punctuation">(</span>K key<span class="token punctuation">,</span> V value<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 直接调用putVal()方法插入元素</span>    <span class="token keyword">return</span> <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> V <span class="token function">putVal</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> K key<span class="token punctuation">,</span> V value<span class="token punctuation">,</span> <span class="token keyword">boolean</span> onlyIfAbsent<span class="token punctuation">,</span> <span class="token keyword">boolean</span> evict<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> p<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">,</span> i<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table未初始化或者长度为0，进行扩容(resize中会判断是否进行初始化)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">||</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>        n <span class="token operator">=</span> <span class="token punctuation">(</span>tab <span class="token operator">=</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">//  根据当前key的hashcode定位到具体的桶中，并判断桶是否为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>p <span class="token operator">=</span> tab<span class="token punctuation">[</span>i <span class="token operator">=</span> <span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 桶为空，新生成结点放入桶中(此时，这个结点是放在数组中)</span>        tab<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>        Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">;</span>        K k<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果当前位置有值(hash冲突)，那么就要比较当前桶中的key、key的hashcode与写入的key是否相等</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>p<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> p<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 如果相等就赋值给 e</span>            e <span class="token operator">=</span> p<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果当前桶为红黑树，那就要按照红黑树的方式写入数据</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>p <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>            e <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> p<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">putTreeVal</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> tab<span class="token punctuation">,</span> hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 如果是个链表，就需要将当前的key、value封装成一个新节点插入到链表的末尾</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> binCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token punctuation">;</span> <span class="token operator">++</span>binCount<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 到达链表的尾部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> p<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 在尾部插入新结点</span>                    p<span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token function">newNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 判断当前链表的结点数量是否达到阈值，达到时就要转换为红黑树</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>binCount <span class="token operator">>=</span> TREEIFY_THRESHOLD <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// -1 for 1st</span>                        <span class="token function">treeifyBin</span><span class="token punctuation">(</span>tab<span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token comment" spellcheck="true">// 判断链表中结点的key值与插入的元素的key值是否相等</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 如果相等，则跳出循环</span>                    <span class="token keyword">break</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 用于遍历桶中的链表，与前面的e=p.next组合，可以遍历链表</span>                p <span class="token operator">=</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 表示在桶中找到key值、hash值与插入元素相等的结点</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// existing mapping for key</span>            <span class="token comment" spellcheck="true">// 记录e的value</span>            V oldValue <span class="token operator">=</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// onlyIfAbsent为false或者旧值为null</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>onlyIfAbsent <span class="token operator">||</span> oldValue <span class="token operator">==</span> null<span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 用新值替换旧值</span>                e<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 访问后回调</span>            <span class="token function">afterNodeAccess</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 返回旧值</span>            <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 结构性修改</span>    <span class="token operator">++</span>modCount<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 最后判断是否需要进行扩容(实际大小大于阈值则扩容)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">++</span>size <span class="token operator">></span> threshold<span class="token punctuation">)</span>        <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 插入后回调</span>    <span class="token function">afterNodeInsertion</span><span class="token punctuation">(</span>evict<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>put()</code> 方法图解如下图所示：<br><img src="https://henleylee.github.io/medias/java/hashmap_jdk_1_8_put.png" alt="JDK1.8中HashMap的put()方法图解"></p><blockquote><p><code>put()</code> 方法没有对 <code>key</code> 为 <code>null</code> 时进行特殊处理，但是 <code>key</code> 为 <code>null</code> 时的 <code>hash</code> 值总为 0，所以 <code>key</code> 为 <code>null</code> 的元素还是放到 <code>table[0]</code> 位置。</p></blockquote><h4 id="get-方法-1"><a href="#get-方法-1" class="headerlink" title="get() 方法"></a>get() 方法</h4><p><strong><code>get()</code></strong>方法的过程是先计算 <code>hash</code>，然后通过 <code>hash</code> 与 <code>table.length</code> 取模计算 <code>index</code> 值，然后判断 <code>table[index]</code> 是否为要查找的元素，若是则直接返回，若不是则查找下一个节点，会判断该节点是属于红黑树还是属于链表，如果该节点是红黑树则在红黑树中查找，是链表则在链表中遍历查找，直到找到 <code>key</code>，然后返回。下面分析 <code>get()</code> 方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> V <span class="token function">get</span><span class="token punctuation">(</span>Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 直接调用getNode()方法获取元素</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>e <span class="token operator">=</span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token function">hash</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">==</span> null <span class="token operator">?</span> null <span class="token operator">:</span> e<span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">getNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> hash<span class="token punctuation">,</span> Object key<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> tab<span class="token punctuation">;</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> first<span class="token punctuation">,</span> e<span class="token punctuation">;</span>    <span class="token keyword">int</span> n<span class="token punctuation">;</span>    K k<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// table已经初始化，长度大于0，根据hash寻找table中指定位置的桶也不为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>tab <span class="token operator">=</span> table<span class="token punctuation">)</span> <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>n <span class="token operator">=</span> tab<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span>            <span class="token punctuation">(</span>first <span class="token operator">=</span> tab<span class="token punctuation">[</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&amp;</span> hash<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断桶的第一个位置(有可能是链表、红黑树)的key是否为查询的key，是就直接返回value</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>first<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span> <span class="token comment" spellcheck="true">// always check first node</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> first<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> first<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 如果第一个不匹配，则判断它的下一个是红黑树还是链表(桶中不止一个结点)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> first<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 为红黑树结点</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>first <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                <span class="token comment" spellcheck="true">// 红黑树就按照树的查找方式在红黑树中查找</span>                <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> first<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getTreeNode</span><span class="token punctuation">(</span>hash<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 否则，在链表中遍历查找</span>            <span class="token keyword">do</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">==</span> hash <span class="token operator">&amp;&amp;</span>                        <span class="token punctuation">(</span><span class="token punctuation">(</span>k <span class="token operator">=</span> e<span class="token punctuation">.</span>key<span class="token punctuation">)</span> <span class="token operator">==</span> key <span class="token operator">||</span> <span class="token punctuation">(</span>key <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> key<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> e<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 没取到就直接返回null</span>    <span class="token keyword">return</span> null<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p><code>get()</code> 方法同样没有对 <code>key</code> 为 <code>null</code> 时进行特殊处理，但是 <code>key</code> 为 <code>null</code> 时的 <code>hash</code> 值总为 0，所以还是在 <code>table[0]</code> 的位置上查找 <code>key</code> 为 <code>null</code> 的元素。</p></blockquote><h4 id="resize-方法-1"><a href="#resize-方法-1" class="headerlink" title="resize() 方法"></a>resize() 方法</h4><p><strong><code>resize()</code></strong>方法的过程是若未初始化时先进行初始化，若已初始化则得到新的阈值和容量，然后根据新的容量创建一个新 <code>table</code>，然后把之前 <code>table</code> 里面元素重新计算位置并全部转移到新的 <code>table</code> 里面。下面分析 <code>resize()</code> 方法的源码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">resize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 保存当前table</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> oldTab <span class="token operator">=</span> table<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存table大小</span>    <span class="token keyword">int</span> oldCap <span class="token operator">=</span> <span class="token punctuation">(</span>oldTab <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> oldTab<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 保存当前阈值</span>    <span class="token keyword">int</span> oldThr <span class="token operator">=</span> threshold<span class="token punctuation">;</span>    <span class="token keyword">int</span> newCap<span class="token punctuation">,</span> newThr <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断之前table长度是否大于0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断之前的table长度是否大于等于默认最大容量MAXIMUM_CAPACITY</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>oldCap <span class="token operator">>=</span> MAXIMUM_CAPACITY<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将临界值改为Integer.MAX_VALUE并返回</span>            threshold <span class="token operator">=</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">;</span>            <span class="token keyword">return</span> oldTab<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 容量翻倍(使用左移，效率更高)</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>newCap <span class="token operator">=</span> oldCap <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span>                oldCap <span class="token operator">>=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 阈值翻倍</span>            newThr <span class="token operator">=</span> oldThr <span class="token operator">&lt;&lt;</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// double threshold</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 判断之前的阈值是否大于0</span>    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>oldThr <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// initial capacity was placed in threshold</span>        newCap <span class="token operator">=</span> oldThr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 当第一次调用resize的时候会执行这个代码，初始化table容量以及阈值</span>    <span class="token keyword">else</span> <span class="token punctuation">{</span>   <span class="token comment" spellcheck="true">// zero initial threshold signifies using defaults</span>        newCap <span class="token operator">=</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>DEFAULT_LOAD_FACTOR <span class="token operator">*</span> DEFAULT_INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 判断新阈值是否为0</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newThr <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">float</span> ft <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> newCap <span class="token operator">*</span> loadFactor<span class="token punctuation">;</span>        newThr <span class="token operator">=</span> <span class="token punctuation">(</span>newCap <span class="token operator">&lt;</span> MAXIMUM_CAPACITY <span class="token operator">&amp;&amp;</span> ft <span class="token operator">&lt;</span> <span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">)</span> MAXIMUM_CAPACITY <span class="token operator">?</span>                <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> ft <span class="token operator">:</span> Integer<span class="token punctuation">.</span>MAX_VALUE<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 保存新的阈值</span>    threshold <span class="token operator">=</span> newThr<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重新分配table的容量</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token string">"rawtypes"</span><span class="token punctuation">,</span> <span class="token string">"unchecked"</span><span class="token punctuation">}</span><span class="token punctuation">)</span>    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span> newTab <span class="token operator">=</span> <span class="token punctuation">(</span>Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">Node</span><span class="token punctuation">[</span>newCap<span class="token punctuation">]</span><span class="token punctuation">;</span>    table <span class="token operator">=</span> newTab<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 判断之前的table是否已经初始化过</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>oldTab <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//将以前table中的值copy到新的table中去</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> oldCap<span class="token punctuation">;</span> <span class="token operator">++</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> e<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 如果旧的hash桶数组在j结点处不为空，复制给e</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 将旧的hash桶数组在j结点处设置为空，方便gc</span>                oldTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> null<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果e后面没有Node结点</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>e<span class="token punctuation">.</span>next <span class="token operator">==</span> null<span class="token punctuation">)</span>                    <span class="token comment" spellcheck="true">// 直接对e的hash值对新的数组长度求模获得存储位置</span>                    newTab<span class="token punctuation">[</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> <span class="token punctuation">(</span>newCap <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 如果e是红黑树的类型，那么添加到红黑树中</span>                <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token keyword">instanceof</span> <span class="token class-name">TreeNode</span><span class="token punctuation">)</span>                    <span class="token punctuation">(</span><span class="token punctuation">(</span>TreeNode<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span><span class="token punctuation">)</span> e<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> newTab<span class="token punctuation">,</span> j<span class="token punctuation">,</span> oldCap<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token comment" spellcheck="true">// preserve order</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> loHead <span class="token operator">=</span> null<span class="token punctuation">,</span> loTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> hiHead <span class="token operator">=</span> null<span class="token punctuation">,</span> hiTail <span class="token operator">=</span> null<span class="token punctuation">;</span>                    Node<span class="token operator">&lt;</span>K<span class="token punctuation">,</span> V<span class="token operator">></span> next<span class="token punctuation">;</span>                    <span class="token keyword">do</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 将Node结点的next赋值给next</span>                        next <span class="token operator">=</span> e<span class="token punctuation">.</span>next<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 如果结点e的hash值与原hash桶数组的长度作与运算为0</span>                        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e<span class="token punctuation">.</span>hash <span class="token operator">&amp;</span> oldCap<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                            <span class="token comment" spellcheck="true">// 如果loTail为null</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                <span class="token comment" spellcheck="true">// 将e结点赋值给loHead</span>                                loHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                <span class="token comment" spellcheck="true">//否则将e赋值给loTail.next</span>                                loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token comment" spellcheck="true">// 将e赋值给hiTail</span>                            loTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                            <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">==</span> null<span class="token punctuation">)</span>                                hiHead <span class="token operator">=</span> e<span class="token punctuation">;</span>                            <span class="token keyword">else</span>                                hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> e<span class="token punctuation">;</span>                            hiTail <span class="token operator">=</span> e<span class="token punctuation">;</span>                        <span class="token punctuation">}</span>                    <span class="token punctuation">}</span> <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>e <span class="token operator">=</span> next<span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 如果loTail不为空</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>loTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 将loTail.next设置为空</span>                        loTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 将loHead赋值给新的hash桶数组[j]处</span>                        newTab<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> loHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token comment" spellcheck="true">// 如果hiTail不为空</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>hiTail <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// 将hiTail.next赋值为空</span>                        hiTail<span class="token punctuation">.</span>next <span class="token operator">=</span> null<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 将hiHead赋值给新的hash桶数组[j+旧hash桶数组长度]</span>                        newTab<span class="token punctuation">[</span>j <span class="token operator">+</span> oldCap<span class="token punctuation">]</span> <span class="token operator">=</span> hiHead<span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> newTab<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p><code>HashMap</code> 是我们开发中经常使用到的集合，JDK 1.8 相对于 1.7 发生了一些改变。JDK 1.8 主要优化<strong>减少了 hash 冲突，提高哈希表的存、取效率</strong>。它们的实现方式上有以下区别：</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>JDK 1.8 相对于 1.7 在<code>初始化</code>上发生了一些改变，JDK 1.7 是<strong>resize() 方法负责扩容，inflateTable() 负责创建表`</strong>，1.8 则是<strong><code>集成在扩容函数 resize() 方法中，在表为空时创建表</code></strong>。</p><h4 id="数据结构-2"><a href="#数据结构-2" class="headerlink" title="数据结构"></a>数据结构</h4><p>JDK 1.8 相对于 1.7 在<code>数据结构</code>上发生了一些改变，JDK 1.7 是<strong><code>数组+链表</code></strong>，1.8 则是<strong><code>数组+链表+红黑树结构(当链表的深度达到8的时候，也就是默认阈值，就会自动扩容把链表转成红黑树的数据结构来把时间复杂度从 O(n) 变成 O(logN) 提高了效率)</code></strong>。<br><img src="https://henleylee.github.io/medias/java/hashmap_differ_structure.png" alt="HashMap数据结构的区别"></p><h4 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h4><p>JDK 1.8 相对于 1.7 在<code>数据存储</code>上发生了一些改变，JDK 1.7 使用的是<strong><code>头插法</code></strong>，1.8 则使用的是<strong><code>尾插法</code></strong>。这样做的原因是因为 JDK 1.7 是用单链表进行的纵向延伸，当采用头插法时会容易出现逆序且环形链表死循环问题。但是在 JDK 1.8 之后是因为加入了红黑树使用尾插法，能够避免出现逆序且链表死循环的问题。<br><img src="https://henleylee.github.io/medias/java/hashmap_differ_store.png" alt="HashMap数据存储的区别"></p><h4 id="扩容机制"><a href="#扩容机制" class="headerlink" title="扩容机制"></a>扩容机制</h4><p>JDK 1.8 相对于 1.7 在<code>扩容后数据存储位置的计算方式</code>上发生了一些改变，JDK 1.7 是<strong><code>直接用 hash 值和需要扩容的二进制数进行 &amp; 运算</code></strong>，1.8 则是<strong><code>直接使用扩容前的原始位置或加上扩容的大小值</code></strong>。<br><img src="https://henleylee.github.io/medias/java/hashmap_differ_resize_1.png" alt="HashMap扩容后数据存储位置的计算方式的区别"></p><blockquote><p>在计算 hash 值的时候，JDK 1.7 用了9次扰动处理(4次位运算 + 5次异或)，而 JDK 1.8 只用了2次扰动处理(1次位运算 + 1次异或)。</p></blockquote><p>JDK 1.8 相对于 1.7 在<code>扩容流程</code>上也发生了一些改变：<br><img src="https://henleylee.github.io/medias/java/hashmap_differ_resize_2.png" alt="HashMap扩容流程的区别"></p><h4 id="key-为-null-的处理"><a href="#key-为-null-的处理" class="headerlink" title="key 为 null 的处理"></a>key 为 null 的处理</h4><p>JDK 1.8 相对于 1.7 在 <code>key 为 null 的处理</code>上发生了一些改变，JDK 1.7 对 key 为 null 的情况单独处理，1.8 则没有单独处理。但是两个版本中如果 key 为null，那么调用 <code>hash()</code> 方法得到的都将是 0，所以 key 为 null 的元素都始终位于哈希表 <code>table[0]</code> 中。</p><h2 id="额外补充"><a href="#额外补充" class="headerlink" title="额外补充"></a>额外补充</h2><h3 id="哈希表如何解决-hash-冲突"><a href="#哈希表如何解决-hash-冲突" class="headerlink" title="哈希表如何解决 hash 冲突"></a>哈希表如何解决 hash 冲突</h3><p><img src="https://henleylee.github.io/medias/java/hashmap_extra_hash_conflict.png" alt="哈希表如何解决hash冲突"></p><h3 id="HashMap-都具备哪些特点"><a href="#HashMap-都具备哪些特点" class="headerlink" title="HashMap 都具备哪些特点"></a>HashMap 都具备哪些特点</h3><p><img src="https://henleylee.github.io/medias/java/hashmap_extra_map_feature.png" alt="HashMap具备的特点"></p><h3 id="HashMap-中的-key-若为-Object-类型需实现哪些方法"><a href="#HashMap-中的-key-若为-Object-类型需实现哪些方法" class="headerlink" title="HashMap 中的 key 若为 Object 类型需实现哪些方法"></a>HashMap 中的 key 若为 Object 类型需实现哪些方法</h3><p><img src="https://henleylee.github.io/medias/java/hashmap_extra_key_method.png" alt="HashMap中的key若为Object类型需实现的方法"></p><h3 id="HashMap-中-String、Integer-这样的包装类为什么适合作为-key"><a href="#HashMap-中-String、Integer-这样的包装类为什么适合作为-key" class="headerlink" title="HashMap 中 String、Integer 这样的包装类为什么适合作为 key"></a>HashMap 中 String、Integer 这样的包装类为什么适合作为 key</h3><p><img src="https://henleylee.github.io/medias/java/hashmap_extra_key_reason.png" alt="HashMap中String、Integer这样的包装类适合作为key的原因"></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 中 equals() 和 hashCode() 的作用</title>
      <link href="/posts/2019/cc1a57ba.html"/>
      <url>/posts/2019/cc1a57ba.html</url>
      
        <content type="html"><![CDATA[<p><code>java.lang.Object</code> 类中定义了 <code>equals()</code> 和 <code>hashCode()</code> 方法，<code>Object</code> 类是所有 Java 类的基类，所以所有的 Java 类都实现了这两个方法。</p><h2 id="equals"><a href="#equals" class="headerlink" title="equals()"></a>equals()</h2><p><code>equals()</code> 方法的作用是<strong><code>用来判断两个对象是否相等</code></strong>。</p><p><code>equals()</code> 方法定义在 <code>java.lang.Object</code> 类中。通过判断两个对象的地址是否相等(即，是否是同一个对象)来区分它们是否相等。源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">==</span> obj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>既然 <code>Object</code> 类中定义了 <code>equals()</code> 方法，这就意味着所有的 Java 类都实现了 equals() 方法，所有的类都可以通过 <code>equals()</code> 方法去比较两个对象是否相等。但是，使用默认的 <code>equals()</code> 方法，等价于 <code>==</code>。因此，通常需要重写 <code>equals()</code> 方法：若两个对象的内容相等，则 <code>equals()</code> 方法返回 <code>true</code>；否则，返回 <code>fasle</code>。  </p><p><code>equals()</code> 方法的使用分为以下两种情况：</p><ul><li>若某个类没有重写 <code>equals()</code> 方法，当它通过 <code>equals()</code> 方法比较两个对象时，实际上是比较两个对象是不是同一个对象。这时，等价于通过 <code>==</code> 去比较这两个对象。</li><li>可以重写类的 <code>equals()</code> 方法，来让 <code>equals()</code> 方法通过其它方式比较两个对象是否相等。通常的做法是：若两个对象的内容相等，则 <code>equals()</code> 方法返回 <code>true</code>；否则，返回 <code>fasle</code>。</li></ul><blockquote><p><code>==</code> 的作用是判断两个对象的地址是否相等(即，判断两个对象是不是同一个对象)；<code>equals()</code> 的作用是判断两个对象是否相等。</p></blockquote><h2 id="hashCode"><a href="#hashCode" class="headerlink" title="hashCode()"></a>hashCode()</h2><p><code>hashCode()</code> 方法的作用是<strong><code>获取哈希码</code></strong>，也称为散列码；它实际上是返回一个 int 值。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><p><code>hashCode()</code> 方法定义在 <code>java.lang.Object</code> 类中，这就意味着所有的 Java 类都实现了 <code>hashCode()</code> 方法。</p><p>虽然，每个 Java 类都实现了 <code>hashCode()</code> 方法，但是，类的 <code>hashCode()</code> 方法一般仅用在散列表中(用于确定该类的每一个对象在散列表中的位置)。</p><blockquote><p>散列表：Java 集合中本质是散列表的类，如 HashMap、Hashtable、HashSet 等。也就是说：hashCode() 方法在散列表中才有用，在其它情况下没用。在散列表中 hashCode() 方法的作用是获取对象的散列码，进而确定该对象在散列表中的位置。</p></blockquote><h2 id="equals-和-hashCode-的关系"><a href="#equals-和-hashCode-的关系" class="headerlink" title="equals() 和 hashCode() 的关系"></a>equals() 和 hashCode() 的关系</h2><p>Java 对于 <code>eqauls()</code> 方法和 <code>hashCode()</code> 方法是这样规定的： </p><ul><li>同一对象上多次调用 hashCode() 方法，总是返回相同的整型值。</li><li>如果 a.equals(b)，则一定有 a.hashCode() 一定等于 b.hashCode()。 </li><li>如果 !a.equals(b)，则 a.hashCode() 不一定等于 b.hashCode()。此时如果 a.hashCode() 总是不等于 b.hashCode()，会提高 hashtables 的性能。</li><li>a.hashCode()==b.hashCode() 则 a.equals(b) 可真可假</li><li>a.hashCode()！= b.hashCode() 则 a.equals(b) 为假。 </li></ul><p>上面结论简记：</p><ul><li>如果两个对象 equals，Java 运行时环境会认为他们的 hashCode 一定相等。 </li><li>如果两个对象不 equals，他们的 hashCode 有可能相等。 </li><li>如果两个对象 hashCode 相等，他们不一定 equals。 </li><li>如果两个对象 hashCode 不相等，他们一定不 equals。 </li></ul><h2 id="关于-equals-和-hashCode-的重要规范"><a href="#关于-equals-和-hashCode-的重要规范" class="headerlink" title="关于 equals() 和 hashCode() 的重要规范"></a>关于 equals() 和 hashCode() 的重要规范</h2><ul><li>规范1：若重写 <code>equals()</code> 方法，有必要重写 <code>hashcode()</code> 方法，确保通过 <code>equals()</code> 方法判断结果为 <code>true</code> 的两个对象具备相等的 <code>hashcode()</code> 方法返回值。说得简单点就是：“如果两个对象相同，那么他们的 hashCode 应该相等”。不过请注意：这个只是规范，如果非要写一个类让 <code>equals()</code> 方法返回 <code>true</code> 而 <code>hashCode()</code> 方法返回两个不相等的值，编译和运行都是不会报错的。不过这样违反了 Java 规范，程序也就埋下了 BUG。 </li><li>规范2：如果 <code>equals()</code> 方法返回 <code>false</code>，即两个对象“不相同”，并不要求对这两个对象调用 <code>hashCode()</code> 方法得到两个不相同的数。说的简单点就是：“如果两个对象不相同，他们的 hashCode 可能相同”。 </li></ul><h2 id="为什么重写-equals-时总要重写-hashCode"><a href="#为什么重写-equals-时总要重写-hashCode" class="headerlink" title="为什么重写 equals() 时总要重写 hashCode()"></a>为什么重写 equals() 时总要重写 hashCode()</h2><p>一个很常见的错误根源在于没有重写 hashCode() 方法。在每个重写了 <code>equals()</code> 方法的类中，也必须重写 <code>hashCode()</code> 方法。如果不这样做的话，就会违反 Object.hashCode 的通用约定，从而导致该类无法结合所有基于散列的集合一起正常运作，这样的集合包括 HashMap、HashSet 和 Hashtable。</p><ul><li>在应用程序的执行期间，只要对象的 <code>equals()</code> 方法的比较操作所用到的信息没有被修改，那么对这同一个对象调用多次，<code>hashCode()</code> 方法都必须始终如一地返回同一个整数。在同一个应用程序的多次执行过程中，每次执行所返回的整数可以不一致。</li><li>如果两个对象根据 <code>equals()</code> 方法比较是相等的，那么调用这两个对象中任意一个对象的 <code>hashCode()</code> 方法都必须产生同样的整数结果。</li><li>如果两个对象根据 <code>equals()</code> 方法比较是不相等的，那么调用这两个对象中任意一个对象的 <code>hashCode()</code> 方法，则不一定要产生相同的整数结果。但是程序员应该知道，给不相等的对象产生截然不同的整数结果，有可能提高散列表的性能。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><code>equals()</code> 方法用于比较对象的内容是否相等(重写以后)；</li><li><code>hashCode()</code> 方法只有在集合中用到；</li><li>当重写了 <code>equals()</code> 方法时，比较对象是否相等将通过重写后的 <code>equals()</code> 方法进行比较(判断对象的内容是否相等)；</li><li>将对象放入到集合中时，首先判断要放入对象的 <code>hashCode()</code> 值与集合中的任意一个元素的 <code>hashCode()</code> 值是否相等，如果不相等直接将该对象放入集合中。如果 <code>hashCode()</code> 值相等，然后再通过 <code>equals()</code> 方法判断要放入对象与集合中的任意一个对象是否相等，如果 <code>equals()</code> 判断不相等，直接将该元素放入到集合中，否则不放入。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 中 ArrayList、LinkedList 和 Vector 的区别</title>
      <link href="/posts/2019/4eec1027.html"/>
      <url>/posts/2019/4eec1027.html</url>
      
        <content type="html"><![CDATA[<p>Java 中 <code>ArrayList</code>、<code>LinkedList</code>、<code>Vector</code> 是编程中经常使用的集合类，他们之间的区别也是经常在面试中会问到的问题。下面就<code>底层实现</code>、<code>执行效率</code>和<code>线程安全性</code>两个方法来看看三者的区别。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="底层实现"><a href="#底层实现" class="headerlink" title="底层实现"></a>底层实现</h3><p>实现接口：</p><ul><li><strong><code>ArrayList</code></strong>和<strong><code>Vector</code></strong>实现了 <code>java.util.RandomAccess</code> 接口；</li><li><strong><code>LinkedList</code></strong>实现了 <code>java.util.Deque</code> 接口。</li></ul><p>底层实现：</p><ul><li><strong><code>ArrayList</code></strong>和<strong><code>Vector</code></strong>的底层是基于<strong><code>动态数组</code></strong>实现的；</li><li><strong><code>LinkedList</code></strong>的底层是基于<strong><code>双向链表</code></strong>实现的。</li></ul><h3 id="执行效率"><a href="#执行效率" class="headerlink" title="执行效率"></a>执行效率</h3><h4 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h4><p><strong><code>ArrayList</code></strong>的底层是基于<code>动态数组</code>实现的，所以 <code>ArrayList</code> 拥有着数组的特性。</p><ul><li>优点：根据下标随机访问数组元素的效率高，向数组尾部添加元素的效率高。</li><li>缺点：删除数组中的数据以及向数组中间添加数据效率低，因为需要移动数组；当长度大于初始长度的时候，每添加一个数，都会需要扩容。</li></ul><p>　　</p><h4 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h4><p><strong><code>LinkedList</code></strong>的底层是基于<code>双向链表</code>实现的，所以 <code>LinkedList</code> 拥有着链表的特性。</p><ul><li>优点：添加、删除元素的效率高，只需要改变指针指向即可。</li><li>缺点：访问元素的平均效率低，需要对链表进行遍历。</li></ul><h4 id="Vector"><a href="#Vector" class="headerlink" title="Vector"></a>Vector</h4><p><strong><code>Vector</code></strong>和 <code>ArrayList</code> 一样，也是通过数组实现的，不同的是它支持线程的同步，即某一时刻只有一个线程能够写 <code>Vector</code>，但实现同步需要很高的花费，因此，访问它比访问<code>ArrayList</code>慢。 </p><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><p>在多线程并发的时候，<code>ArrayList</code> 和 <code>LinkedList</code> 是非线程安全的，并且是不同步的。<code>Vector</code> 的所有方法都用了 <code>synchronized</code> 关键字修饰，是线程安全的，但是 <code>Vector</code> 中的方法组合起来使用不是线程安全的。</p><blockquote><p>由 <code>Vector</code> 创建的 <code>Iterator</code>，虽然和 <code>ArrayList</code> 创建的 <code>Iterator</code> 是同一接口，但是，因为 <code>Vector</code> 是同步的，当一个 <code>Iterator</code> 被创建而且正在被使用，另一个线程改变了 <code>Vector</code> 的状态(例如，添加、删除元素)，这时调用 <code>Iterator</code> 的方法时将抛出 <code>ConcurrentModificationException</code>，因此必须捕获该异常。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>类</th><th>底层实现</th><th>线程安全性</th><th>执行效率</th><th>引进版本</th></tr></thead><tbody><tr><td>ArrayList</td><td>动态数组</td><td>非线程安全</td><td>随机访问、向尾部添加元素的效率高；删除、向中间添加元素效率低</td><td>JDK 1.2</td></tr><tr><td>LinkedList</td><td>双向链表</td><td>非线程安全</td><td>添加、删除元素效率高；访问元素的平均效率低</td><td>JDK 1.2</td></tr><tr><td>Vector</td><td>动态数组</td><td>线程安全</td><td>同 <code>ArrayList</code>，但是比 <code>ArrayList</code> 效率低</td><td>JDK 1.0</td></tr></tbody></table><ul><li><code>ArrayList</code> 和 <code>Vector</code> 的实现是基于动态数组，<code>LinkedList</code> 的实现是基于双向链表。 </li><li>对于随机访问，<code>ArrayList</code> 优于 <code>LinkedList</code>，<code>ArrayList</code> 可以根据下标以 O(1) 时间复杂度对元素进行随机访问。而 <code>LinkedList</code> 的每一个元素都依靠地址指针和它后一个元素连接在一起，在这种情况下，查找某个元素的时间复杂度是 O(n)。</li><li>对于插入和删除操作，<code>LinkedList</code> 优于 <code>ArrayList</code>，因为当元素被添加到 <code>LinkedList</code> 任意位置的时候，不需要像 <code>ArrayList</code> 那样重新计算大小或者是更新索引。 </li><li><code>LinkedList</code> 比 <code>ArrayList</code> 更占内存，因为 <code>LinkedList</code> 的节点除了存储数据，还存储了两个引用，一个指向前一个元素，一个指向后一个元素。</li><li>在多线程并发的时候，<code>ArrayList</code> 和 <code>LinkedList</code> 是非线程安全的，并且是不同步的，<code>Vector</code> 是线程安全的，但是 <code>Vector</code> 中的方法组合起来使用不是线程安全的。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 中 String、StringBuilder 和 StringBuffer 的区别</title>
      <link href="/posts/2019/c54ca406.html"/>
      <url>/posts/2019/c54ca406.html</url>
      
        <content type="html"><![CDATA[<p>Java 中 <code>String</code>、<code>StringBuilder</code>、<code>StringBuffer</code> 是编程中经常使用的字符串类，他们之间的区别也是经常在面试中会问到的问题。下面就<code>运算速度</code>(运算性能或执行效率)和<code>线程安全性</code>两个方法来看看三者的区别。</p><h2 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h2><h3 id="运算速度"><a href="#运算速度" class="headerlink" title="运算速度"></a>运算速度</h3><p><code>String</code> 是 <code>final</code> 类不能被继承且为<code>字符串常量</code>，而 <code>StringBuilder</code> 和 <code>StringBuffer</code> 均为<code>字符串变量</code>。String 对象一旦创建便不可更改，而后两者是可更改的，它们只能通过构造函数来建立对象，且对象被建立以后将在内存中分配内存空间，并初始保存一个 <code>null</code>，通过 <code>append()</code> 方法向 <code>StringBuffer</code> 和 <code>StringBuilder</code> 中赋值。</p><blockquote><p>String 类中使用字符数组保存字符串；StringBuilder 和 StringBuffer 都继承自 AbstractStringBuilder 类，在 AbstractStringBuilder 中也是使用字符数组保存字符串。</p></blockquote><p>请看如下示例代码：</p><pre class=" language-java"><code class="language-java">String str <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span>str <span class="token operator">=</span> str <span class="token operator">+</span> <span class="token string">"de"</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码先创建一个 String 对象 str，并赋值 abc 给 str，然后运行到第三行，JVM 会再创建一个新的 str 对象，并将原有 str 的值和 de 加起来再赋值给新的 str。而第一个创建的 str 对象被 JVM 的垃圾回收机制(GC)回收掉。所以 str 实际上并没有被更改，即 String 对象一旦创建就不可更改。</p><blockquote><p>因此，Java 中对 String 对象进行的操作实际上是一个不断创建并回收对象的过程，因此在运行速度上很慢。而 StringBuilder 和 StringBuffer 的对象是变量，对变量的操作是直接对该对象就行更改，因此不会进行反复的创建和回收。所以在运行速度上比较快。</p></blockquote><p>在某些特殊的情况下，String 的效率比 StringBuilder 和 StringBuffer 要快。请看如下示例代码：</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"123"</span> <span class="token operator">+</span> <span class="token string">"456"</span><span class="token punctuation">;</span>StringBuilder s2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"123"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s1<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>s2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述代码中 String 的操作速度反而要比 StringBuilder 快，这是因为在 JVM 眼里，第1行的代码操作和下列代码是完全一样的，所以很快。</p><pre class=" language-java"><code class="language-java">String s1 <span class="token operator">=</span> <span class="token string">"123456"</span><span class="token punctuation">;</span></code></pre><p>但如下的代码写法形式速度会很慢，JVM会不断地创建和回收对象来进行操作。</p><pre class=" language-java"><code class="language-java">String str1 <span class="token operator">=</span> <span class="token string">"123"</span><span class="token punctuation">;</span>String str2 <span class="token operator">=</span> <span class="token string">"456"</span><span class="token punctuation">;</span>String str <span class="token operator">=</span> str1 <span class="token operator">+</span> str2<span class="token punctuation">;</span></code></pre><blockquote><p>总结：三者在运行速度方面快慢顺序为：StringBuilder &gt; StringBuffer &gt; String。</p></blockquote><h3 id="线程安全性"><a href="#线程安全性" class="headerlink" title="线程安全性"></a>线程安全性</h3><h4 id="String-线程安全"><a href="#String-线程安全" class="headerlink" title="String(线程安全)"></a>String(线程安全)</h4><p><strong><code>String</code></strong>中的对象是不可变的，也就可以理解为常量，显然<strong><code>线程安全</code></strong>。</p><h4 id="StringBuffer-线程安全"><a href="#StringBuffer-线程安全" class="headerlink" title="StringBuffer(线程安全)"></a>StringBuffer(线程安全)</h4><p><strong><code>StringBuffer</code></strong>中的大部分方法由 <code>synchronized</code> 关键字修饰，在必要时可对方法进行同步，因此任意特定实例上的所有操作就好像是以串行顺序发生的，该顺序与所涉及的每个线程进行的方法调用顺序一致，所以是<strong><code>线程安全</code></strong>的。</p><h4 id="StringBuilder-非线程安全"><a href="#StringBuilder-非线程安全" class="headerlink" title="StringBuilder(非线程安全)"></a>StringBuilder(非线程安全)</h4><p><strong><code>StringBuilder</code></strong>中的方法没有 <code>synchronized</code> 关键字修饰，不能保证线程安全性，所以是<strong><code>非线程安全</code></strong>的。StringBuilder 是 JDK1.5 新增的，该类提供一个与 StringBuffer 兼容的 API，但不能保证同步，所以在性能上较高。该类被设计用作 StringBuffer 的一个简易替换，用在字符串缓冲区被单个线程使用的时候(这种情况很普遍)。如果可能，建议优先采用该类，因为在大多数实现中，它比 StringBuffer 要快，而且两者的方法基本相同。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><table><thead><tr><th>类</th><th>描述</th><th>线程安全性</th><th>运算速度</th><th>引进版本</th></tr></thead><tbody><tr><td>String</td><td>字符串常量</td><td>线程安全</td><td>最慢</td><td>JDK 1.0</td></tr><tr><td>StringBuffer</td><td>字符串变量</td><td>线程安全</td><td>慢</td><td>JDK 1.0</td></tr><tr><td>StringBuilder</td><td>字符串变量</td><td>非线程安全</td><td>快</td><td>JDK 1.5</td></tr></tbody></table><ul><li><strong><code>String：</code></strong>适用于少量的字符串操作的情况；</li><li><strong><code>StringBuffer：</code></strong>适用多线程下在字符缓冲区进行大量操作的情况；</li><li><strong><code>StringBuilder：</code></strong>适用于单线程下在字符缓冲区进行大量操作的情况。</li></ul><blockquote><p>在编译期就能够确定的字符串常量，没有必要创建 String、StringBuilder 或 StringBuffer 对象。直接使用字符串常量的<strong><code>+</code></strong>连接操作效率最高。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java ThreadLocal 详解</title>
      <link href="/posts/2019/27435a3e.html"/>
      <url>/posts/2019/27435a3e.html</url>
      
        <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p><code>java.lang.ThreadLocal</code> 表示<strong>线程本地存储区(Thread Local Storage，简称为 TLS)</strong>，每个线程都有自己的私有的本地存储区域，不同线程之间彼此不能访问对方的 TLS 区域。<code>ThreadLocal</code> 是 JDK 1.2 开始提供的，该类为解决多线程的并发问题提供了一种新的思路。使用这个工具类可以很简洁地编写出优美的多线程程序。</p><p>当使用 <code>ThreadLocal</code> 维护变量时，<code>ThreadLocal</code> 为每个使用该变量的线程提供独立的变量副本，所以每一个线程都可以独立地改变自己的副本，而不会影响其它线程所对应的副本。</p><p>从线程的角度看，目标变量就象是线程的本地变量，这也是类名中 <code>Local</code> 所要表达的意思。所以，在 Java 中编写线程局部变量的代码相对来说要笨拙一些，因此造成线程局部变量没有在 Java 开发者中得到很好的普及。</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p><code>Thread</code> 类中成员变量 <code>threadLocals</code>，它的类型是 <code>ThreadLocal.ThreadLocalMap</code>，每个线程都有一个这样的 <code>Map</code>，所以可以保存 N 个 <code>ThreadLocal</code> 键值对，并且不同线程的变量值不同。</p><p><code>ThreadLocal</code> 连接 <code>ThreadLocalMap</code> 和 <code>Thread</code>，来处理 <code>Thread</code> 的 <code>threadLocals</code> 属性，包括初始化属性赋值、获取变量、设置变量等。通过当前线程，获取线程上的 <code>ThreadLocalMap</code>，对数据进行 <code>get</code>、<code>set</code> 等操作。</p><p><code>ThreadLocalMap</code> 用来存储数据，存储了以 <code>ThreadLocal</code> 为 <code>key</code>，需要隔离的数据为 <code>value</code> 的 <code>Entry</code> 键值对数组结构。</p><h2 id="源码解析"><a href="#源码解析" class="headerlink" title="源码解析"></a>源码解析</h2><p><code>ThreadLocal</code> 的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocal</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * ThreadLocals rely on per-thread linear-probe hash maps attached     * to each thread (Thread.threadLocals and     * inheritableThreadLocals).  The ThreadLocal objects act as keys,     * searched via threadLocalHashCode.  This is a custom hash code     * (useful only within ThreadLocalMaps) that eliminates collisions     * in the common case where consecutively constructed ThreadLocals     * are used by the same threads, while remaining well-behaved in     * less common cases.     */</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> threadLocalHashCode <span class="token operator">=</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The next hash code to be given out. Updated atomically. Starts at     * zero.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> AtomicInteger nextHashCode <span class="token operator">=</span>        <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The difference between successively generated hash codes - turns     * implicit sequential thread-local IDs into near-optimally spread     * multiplicative hash values for power-of-two-sized tables.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> HASH_INCREMENT <span class="token operator">=</span> <span class="token number">0x61c88647</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * Returns the next hash code.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">nextHashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> nextHashCode<span class="token punctuation">.</span><span class="token function">getAndAdd</span><span class="token punctuation">(</span>HASH_INCREMENT<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns the current thread's "initial value" for this     * thread-local variable.  This method will be invoked the first     * time a thread accesses the variable with the {@link #get}     * method, unless the thread previously invoked the {@link #set}     * method, in which case the {@code initialValue} method will not     * be invoked for the thread.  Normally, this method is invoked at     * most once per thread, but it may be invoked again in case of     * subsequent invocations of {@link #remove} followed by {@link #get}.     *     * &lt;p>This implementation simply returns {@code null}; if the     * programmer desires thread-local variables to have an initial     * value other than {@code null}, {@code ThreadLocal} must be     * subclassed, and this method overridden.  Typically, an     * anonymous inner class will be used.     *     * @return the initial value for this thread-local     */</span>    <span class="token keyword">protected</span> T <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Creates a thread local variable. The initial value of the variable is     * determined by invoking the {@code get} method on the {@code Supplier}.     *     * @param &lt;S> the type of the thread local's value     * @param supplier the supplier to be used to determine the initial value     * @return a new thread local variable     * @throws NullPointerException if the specified supplier is null     * @since 1.8     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>S<span class="token operator">></span> ThreadLocal<span class="token operator">&lt;</span>S<span class="token operator">></span> <span class="token function">withInitial</span><span class="token punctuation">(</span>Supplier<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">S</span><span class="token operator">></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SuppliedThreadLocal</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span>supplier<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Creates a thread local variable.     * @see #withInitial(java.util.function.Supplier)     */</span>    <span class="token keyword">public</span> <span class="token function">ThreadLocal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Returns the value in the current thread's copy of this     * thread-local variable.  If the variable has no value for the     * current thread, it is first initialized to the value returned     * by an invocation of the {@link #initialValue} method.     *     * @return the current thread's value of this thread-local     */</span>    <span class="token keyword">public</span> T <span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            ThreadLocalMap<span class="token punctuation">.</span>Entry e <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">getEntry</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>                T result <span class="token operator">=</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span>e<span class="token punctuation">.</span>value<span class="token punctuation">;</span>                <span class="token keyword">return</span> result<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Variant of set() to establish initialValue. Used instead     * of set() in case user has overridden the set() method.     *     * @return the initial value     */</span>    <span class="token keyword">private</span> T <span class="token function">setInitialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        T value <span class="token operator">=</span> <span class="token function">initialValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Sets the current thread's copy of this thread-local variable     * to the specified value.  Most subclasses will have no need to     * override this method, relying solely on the {@link #initialValue}     * method to set the values of thread-locals.     *     * @param value the value to be stored in the current thread's copy of     *        this thread-local.     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">set</span><span class="token punctuation">(</span>T value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Thread t <span class="token operator">=</span> Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ThreadLocalMap map <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>t<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">!=</span> null<span class="token punctuation">)</span>            map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            <span class="token function">createMap</span><span class="token punctuation">(</span>t<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Removes the current thread's value for this thread-local     * variable.  If this thread-local variable is subsequently     * {@linkplain #get read} by the current thread, its value will be     * reinitialized by invoking its {@link #initialValue} method,     * unless its value is {@linkplain #set set} by the current thread     * in the interim.  This may result in multiple invocations of the     * {@code initialValue} method in the current thread.     *     * @since 1.5     */</span>     <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         ThreadLocalMap m <span class="token operator">=</span> <span class="token function">getMap</span><span class="token punctuation">(</span>Thread<span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>m <span class="token operator">!=</span> null<span class="token punctuation">)</span>             m<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Get the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param  t the current thread     * @return the map     */</span>    ThreadLocalMap <span class="token function">getMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> t<span class="token punctuation">.</span>threadLocals<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Create the map associated with a ThreadLocal. Overridden in     * InheritableThreadLocal.     *     * @param t the current thread     * @param firstValue value for the initial entry of the map     */</span>    <span class="token keyword">void</span> <span class="token function">createMap</span><span class="token punctuation">(</span>Thread t<span class="token punctuation">,</span> T firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        t<span class="token punctuation">.</span>threadLocals <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ThreadLocalMap</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>ThreadLocal</code> 的核心方法有如下几个：</p><ul><li><code>T initialValue()：</code>返回该线程局部变量的初始值。该方法是一个 <code>protected</code> 的方法，显然是为了让子类重写而设计的。这个方法是一个延迟调用方法，在线程第一次调用 <code>get()</code> 方法时才执行，并且仅执行一次。<code>ThreadLocal</code> 中的缺省实现直接返回一个 <code>null</code>。</li><li><code>ThreadLocal&lt;S&gt; withInitial(Supplier&lt;? extends S&gt; supplier)：</code>提供一个 <code>Supplier</code> 的 <code>lamda</code> 表达式用来当做初始值，该方法是 JDK 1.8 新增的方法。</li><li><code>T setInitialValue()：</code>设置初始值。在调用 <code>get()</code> 方法没有对应的值时，调用此方法。该方法是一个 <code>private</code> 方法，防止被重写。</li><li><code>T get()：</code>方法返回当前线程所对应的线程局部变量。先取出当前线程对应的 <code>threadLocalMap</code>，如果不存在则用创建一个，但是是用 <code>initialValue()</code> 方法的返回值作为 <code>value</code> 放入到 <code>map</code> 中，且返回 <code>initialValue()</code>，否则就直接从 <code>map</code> 取出 <code>this</code> 即 <code>ThreadLocal</code> 对应的 <code>value</code> 返回。</li><li><code>void set(T value)：</code>设置当前线程对应的线程局部变量的值。先取出当前线程对应的 <code>threadLocalMap</code>，如果不存在则用创建一个，否则将 <code>value</code> 放入以 <code>this</code>(即 <code>ThreadLocal</code>)为 <code>key</code> 的映射的 <code>map</code> 中，其实 <code>ThreadLocalMap</code> 内部和 <code>HashMap</code> 机制一样，存储了 <code>Entry</code> 键值对数组。</li><li><code>void remove()：</code>将当前线程局部变量的值删除，目的是为了减少内存的占用，该方法是 JDK 1.5 新增的方法。需要指出的是，当线程结束后，对应该线程的局部变量将自动被垃圾回收，所以显式调用该方法清除线程的局部变量并不是必须的操作，但它可以加快内存回收的速度。需要注意的是，如果 <code>remove()</code> 方法调用之后又调用了 <code>get()</code> 方法，会重新初始化一次，即再次调用 <code>initialValue()</code> 方法，除非在 <code>get()</code> 方法之前调用 <code>set()</code> 方法设置过值。</li></ul><p>从上面的分析中，可以看到，<code>ThreadLocal</code> 的实现离不开 <code>ThreadLocalMap</code> 类，<code>ThreadLocalMap</code> 类是 <code>ThreadLocal</code> 的静态内部类。每个 <code>Thread</code> 维护一个 <code>ThreadLocalMap</code> 映射表，这个映射表的 <code>key</code> 是 <code>ThreadLocal</code> 实例本身，<code>value</code> 是真正需要存储的 <code>Object</code>。这样的设计主要有以下几点优势：</p><ul><li>这样设计之后每个 Map 的 Entry 数量变小了：之前是 Thread 的数量，现在是 ThreadLocal 的数量，能提高性能；</li><li>当 Thread 销毁之后对应的 ThreadLocalMap 也就随之销毁了，能减少内存使用量。</li></ul><p><code>ThreadLocalMap</code> 看名字就知道是个 <code>map</code>，没错，这就是个 <code>HashMap</code> 机制实现的 <code>map</code>，用 <code>Entry</code> 数组来存储键值对，<code>key</code> 是 <code>ThreadLocal</code> 对象，<code>value</code> 则是具体的值。值得一提的是，为了方便 GC，<code>Entry</code> 继承了 <code>WeakReference</code>，也就是弱引用。里面有一些具体关于如何清理过期的数据、扩容等机制，思路基本和 <code>Hashmap</code> 差不多，有兴趣的可以自行阅读了解，一般只需知道大概的数据存储结构即可。<code>ThreadLocalMap</code> 的源码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">ThreadLocalMap</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * The entries in this hash map extend WeakReference, using     * its main ref field as the key (which is always a     * ThreadLocal object).  Note that null keys (i.e. entry.get()     * == null) mean that the key is no longer referenced, so the     * entry can be expunged from table.  Such entries are referred to     * as "stale entries" in the code that follows.     */</span>    <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Entry</span> <span class="token keyword">extends</span> <span class="token class-name">WeakReference</span><span class="token operator">&lt;</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">>></span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">/**         * The value associated with this ThreadLocal.         */</span>        Object value<span class="token punctuation">;</span>        <span class="token function">Entry</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> k<span class="token punctuation">,</span> Object v<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">(</span>k<span class="token punctuation">)</span><span class="token punctuation">;</span>            value <span class="token operator">=</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * The initial capacity -- MUST be a power of two.     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> INITIAL_CAPACITY <span class="token operator">=</span> <span class="token number">16</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The table, resized as necessary.     * table.length MUST always be a power of two.     */</span>    <span class="token keyword">private</span> Entry<span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The number of entries in the table.     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * The next size value at which to resize.     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> threshold<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Default to 0</span>    <span class="token comment" spellcheck="true">/**     * Set the resize threshold to maintain at worst a 2/3 load factor.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setThreshold</span><span class="token punctuation">(</span><span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>        threshold <span class="token operator">=</span> len <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * Construct a new map initially containing (firstKey, firstValue).     * ThreadLocalMaps are constructed lazily, so we only create     * one when we have at least one entry to put in it.     */</span>    <span class="token function">ThreadLocalMap</span><span class="token punctuation">(</span>ThreadLocal<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> firstKey<span class="token punctuation">,</span> Object firstValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        table <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>INITIAL_CAPACITY<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> firstKey<span class="token punctuation">.</span>threadLocalHashCode <span class="token operator">&amp;</span> <span class="token punctuation">(</span>INITIAL_CAPACITY <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        table<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">(</span>firstKey<span class="token punctuation">,</span> firstValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">setThreshold</span><span class="token punctuation">(</span>INITIAL_CAPACITY<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="与同步机制的比较"><a href="#与同步机制的比较" class="headerlink" title="与同步机制的比较"></a>与同步机制的比较</h2><p>ThreadLocal 和线程同步机制相比有什么优势呢？</p><ul><li><code>Synchronized</code> 用于线程间的数据共享。在同步机制中，通过对象的锁机制保证同一时间只有一个线程访问变量。这时该变量是多个线程共享的，使用同步机制要求程序慎密地分析什么时候对变量进行读写，什么时候需要锁定某个对象，什么时候释放对象锁等繁杂的问题，程序设计和编写难度相对较大。</li><li><code>ThreadLocal</code> 则用于线程间的数据隔离。ThreadLocal 则从另一个角度来解决多线程的并发访问。ThreadLocal 会为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。因为每一个线程都拥有自己的变量副本，从而也就没有必要对该变量进行同步了。ThreadLocal 提供了线程安全的共享对象，在编写多线程代码时，可以把不安全的变量封装进 ThreadLocal。</li></ul><p>概括起来说，对于多线程资源共享的问题，同步机制采用了“以时间换空间”的方式，而 ThreadLocal 采用了“以空间换时间”的方式。前者仅提供一份变量，让不同的线程排队访问，而后者为每一个线程都提供了一份变量，因此可以同时访问而互不影响。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>ThreadLocal</code> 是一个用于提供线程局部变量的工具类，它主要用于将私有线程和该线程存放的副本对象做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p><p><code>ThreadLocal</code> 是解决线程安全问题一个很好的思路，它通过为每一个线程提供一个独立的变量副本，从而隔离了多个线程对数据的访问冲突。在很多情况下，<code>ThreadLocal</code> 比直接使用 <code>synchronized</code> 同步机制解决线程安全问题更简单，更方便，且结果程序拥有更高的并发性。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 性能优化之绘制优化</title>
      <link href="/posts/2019/2e33cf5d.html"/>
      <url>/posts/2019/2e33cf5d.html</url>
      
        <content type="html"><![CDATA[<p>绘制性能的好坏 主要影响 ：Android应用中的页面显示速度</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>绘制影响 Android 性能的实质就是影响页面的<code>绘制</code>时间。</p><blockquote><p>一个页面通过递归完成测量和绘制过程，即 <code>measure</code>、<code>layout</code> 过程。</p></blockquote><p>因此可以从以下几个方面进行优化，从而提高 Android 应用中的页面显示速度：</p><ul><li>降低 View.onDraw() 的复杂度</li><li>避免过度绘制(Overdraw)</li></ul><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="降低-View-onDraw-的复杂度"><a href="#降低-View-onDraw-的复杂度" class="headerlink" title="降低 View.onDraw() 的复杂度"></a>降低 View.onDraw() 的复杂度</h3><h4 id="不要创建新的局部对象"><a href="#不要创建新的局部对象" class="headerlink" title="不要创建新的局部对象"></a>不要创建新的局部对象</h4><p>onDraw() 方法可能会被频繁调用。如果 onDraw() 方法内需创建局部对象，则会在瞬间产生大量的历史对象，这使得占用过多内存并导致系统频繁 GC，降低了程序的执行效率。因此，onDraw() 方法中不要创建新的局部对象。</p><h4 id="避免执行大量耗时操作"><a href="#避免执行大量耗时操作" class="headerlink" title="避免执行大量耗时操作"></a>避免执行大量耗时操作</h4><p>Google 官方性能优化标准要求，View 的最佳绘制频率为 60 fps(即：要求每帧绘制时间≤16ms)。如果 onDraw() 方法内执行大量耗时操作，会抢占 CPU 的时间片，从而导致 View 的绘制过程不流畅。因此，onDraw() 方法中避免执行大量耗时操作。</p><h3 id="避免过度绘制-Overdraw"><a href="#避免过度绘制-Overdraw" class="headerlink" title="避免过度绘制(Overdraw)"></a>避免过度绘制(Overdraw)</h3><h4 id="过度绘制的简介"><a href="#过度绘制的简介" class="headerlink" title="过度绘制的简介"></a>过度绘制的简介</h4><p>过度绘制是指屏幕上的某一像素点在同一帧中被重复绘制多次。</p><p>过度绘制发生的主要原因是因为多层次或重叠的 UI 结构。</p><blockquote><p>在多层次或重叠的 UI 结构里，若不可见的 UI 也在做绘制操作，则会导致某些像素区域被绘制多次。过度绘制则会导致屏幕显示的色块不同。</p></blockquote><p>过度绘制的主要影响如下：</p><ul><li>界面显示时，浪费资源去渲染不必要、看不见的背景；</li><li>多次绘制就会导致页面加载或滑动时的不流畅、掉帧(对用户体验来说就是 APP 卡顿)。</li></ul><h4 id="过度绘制的检测"><a href="#过度绘制的检测" class="headerlink" title="过度绘制的检测"></a>过度绘制的检测</h4><ul><li><p>方法一：通过开发者选项开启 GPU 过度绘制调试</p><blockquote><p>Android 手机的开发者选项中有<code>调试 GPU 过度绘制</code>的选项，打开步骤为<code>设置 -&gt; 开发者选项 -&gt; 调试GPU过度绘制 -&gt; 显示GPU过度绘制</code>。</p></blockquote></li><li><p>方法二：通过 adb 命令开启 GPU 过度绘制调试<br>开启调试 GPU 过度绘制的命令如下：</p><pre class=" language-shell"><code class="language-shell">$ adb shell setprop debug.hwui.overdraw show</code></pre><p>关闭调试 GPU 过度绘制的命令如下：</p><pre class=" language-shell"><code class="language-shell">$ adb shell setprop debug.hwui.overdraw false</code></pre><blockquote><p>执行命令之后可能需要重新启动要调试的应用。</p></blockquote></li></ul><h4 id="过度绘制的表现形式"><a href="#过度绘制的表现形式" class="headerlink" title="过度绘制的表现形式"></a>过度绘制的表现形式</h4><p>过度绘制会导致屏幕显示的色块不同，具体如下图所示：<br><img src="https://henleylee.github.io/medias/android/over_draw.png" alt="过度绘制的表现形式"></p><p>依据过度绘制的层度可以分成：</p><ul><li>无过度绘制：一个像素只被绘制了一次</li><li>过度绘制x1：一个像素被绘制了两次</li><li>过度绘制x2：一个像素被绘制了三次</li><li>过度绘制x3：一个像素被绘制了四次</li><li>过度绘制x4+：一个像素被绘制了五次及以上</li></ul><h4 id="过度绘制的优化原则"><a href="#过度绘制的优化原则" class="headerlink" title="过度绘制的优化原则"></a>过度绘制的优化原则</h4><p>很多过度绘制是难以避免的(如背景+文字导致的过度绘制)，只能尽可能避免过度绘制：</p><ul><li>尽可能地控制过度绘制的次数为 2 次(绿色)以下，蓝色最理想；</li><li>尽可能避免过度绘制的粉色和红色情况；</li><li>不允许 3 次以上的过度绘制(淡红色)面积超过屏幕大小的 1/4。</li></ul><h4 id="过度绘制的优化方案"><a href="#过度绘制的优化方案" class="headerlink" title="过度绘制的优化方案"></a>过度绘制的优化方案</h4><ul><li><p>优化方案1： 移除 Window 的默认背景<br>查看 Android 源码里的 <code>Theme</code> 主题，如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Theme<span class="token punctuation">"</span></span><span class="token punctuation">></span></span> ... <span class="token comment" spellcheck="true">&lt;!-- Window attributes --></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>windowBackground<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>@drawable/screen_background_selector_dark<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">></span></span> ...<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>也就是说继承 <code>Theme</code> 这个 style 的风格，默认情况下，新建一个 Activity 都是有背景的。一般情况下，该默认的 Window 背景基本用不上：因背景都自定义设置；若不移除，则导致所有界面都多 1 次绘制。<br>使用时只要在自己的 AppTheme 里面去除该背景色即可：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AppTheme<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android:Theme.Light.NoTitleBar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css"> &lt;item name=<span class="token string">"android:windowBackground"</span>>@null&lt;/item></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span></code></pre><p>或者在 Activity 的 onCreate() 方法中将背景置为 null 即可：</p><pre class=" language-java"><code class="language-java"><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setBackgroundDrawable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li><li><p>优化方案2：移除控件中不必要的背景</p><ul><li>场景1：ListView 与 Item：列表页(ListView)与其内子控件(Item)的背景相同，则可移除子控件(Item)布局中的背景；</li><li>场景2：ViewPager 与 Fragment：对于一个 ViewPager 和多个 Fragment 组成的首页界面，若每个 Fragment 都设有背景色，则可移除 ViewPager 的背景。</li></ul></li><li><p>优化方案3：减少布局文件的层级</p><blockquote><p>原理：减少不必要的嵌套(UI层级少)，则过度绘制的可能性低。<br>优化方式：使用<merge>标签并合适选择布局类型。</merge></p></blockquote></li><li><p>优化方案4：使用 Canvas 的 clipRect 和 clipPath 方法限制 View 的绘制区域</p><blockquote><p>作用：使用 Canvas 的 clipRect 和 clipPath 方法给 Canvas 设置一个裁剪区域，只有在该区域内才会被绘制，区域之外的都不绘制(如：android.support.v4.widget.DrawerLayout)。</p></blockquote></li><li><p>优化方案5：ImageView 的 background 和 imageDrawable 重叠</p><blockquote><p> Android 中，所有的 View 均可以设置 background。ImageView 除了能够设置 background 之外，还能设置 ImageDrawable。开发中，很多时候需要显示图片，在图片加载出来之前通常是需要显示一张默认图片的，很多时候会使用 ImageView 的 background 属性来设置默认背景图，而 imageDrawable 来设置需要加载的图片。这样会导致一个问题，当图片加载到页面后，默认背景图被挡住了，但是却仍然然需要绘制，导致过度绘制情况的发生。解决方案是把背景图和真正加载的图片都通过 imageDrawable 方法进行设置。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 性能优化之布局优化</title>
      <link href="/posts/2019/d59595e2.html"/>
      <url>/posts/2019/d59595e2.html</url>
      
        <content type="html"><![CDATA[<p>在 Android 中系统对 View 进行测量、布局和绘制时，都是通过对 View 树的遍历来进行操作的。如果一个 View 树的高度太高就会严重影响测量、布局和绘制的速度。Google 也在其 API 文档中建议 View 高度不宜超过10层。</p><h2 id="优化思路"><a href="#优化思路" class="headerlink" title="优化思路"></a>优化思路</h2><p>布局影响 Android 性能的实质就是影响页面的<code>测量</code>和<code>绘制</code>时间。</p><blockquote><p>一个页面通过递归完成测量和绘制过程，即 <code>measure</code>、<code>layout</code> 过程。</p></blockquote><p>因此可以从以下几个方面进行优化，从而提高 Android 应用中的页面显示速度：</p><ul><li>选择合适的布局类型</li><li>减少布局层级</li><li>提高布局复用性</li><li>减少测量绘制时间</li></ul><h2 id="优化方案"><a href="#优化方案" class="headerlink" title="优化方案"></a>优化方案</h2><h3 id="选择合适的布局类型"><a href="#选择合适的布局类型" class="headerlink" title="选择合适的布局类型"></a>选择合适的布局类型</h3><p>通过选择合理的布局类型，从而减少嵌套并提高布局性能。</p><blockquote><p>即：完成复杂的 UI 效果时，尽可能选择一个功能复杂的布局(如：RelativeLayout、ConstraintLayout)完成，而不要选择多个功能简单的布局(如：FrameLayout、LinearLayout)通过嵌套完成。</p></blockquote><p>提高布局性能就是要选择耗费性能(CPU 资源和时间)较少的布局。</p><ul><li>性能耗费低的布局：功能简单(如：FrameLayout、LinearLayout)</li><li>性能耗费高的布局：功能复杂(如：RelativeLayout、ConstraintLayout)</li></ul><blockquote><p>大约在 Android 4.0 之前，新建工程的默认的布局中根节点是 <code>LinearLayout</code>，而在之后已经改为 <code>RelativeLayout</code>，因为 <code>RelativeLayout</code> 性能更优，且可以简单实现 <code>LinearLayout</code> 嵌套才能实现的布局。2017 年 Google 发布了 Android Studio 2.3 正式版，在 Android Studio 2.3 版本中新建的项目中默认的根布局就是 <code>ConstraintLayout</code>，因为 <code>ConstraintLayout</code> 的性能比 <code>RelativeLayout</code> 更好。</p></blockquote><h3 id="尽可能少用-wrap-content"><a href="#尽可能少用-wrap-content" class="headerlink" title="尽可能少用 wrap_content"></a>尽可能少用 wrap_content</h3><p>布局属性 <code>wrap_content</code> 会增加布局测量时计算成本，应尽可能少用。在已知宽高为固定值的情况下，不使用 <code>wrap_content</code> 属性。</p><h3 id="使用布局标签"><a href="#使用布局标签" class="headerlink" title="使用布局标签"></a>使用布局标签</h3><h4 id="lt-include-标签"><a href="#lt-include-标签" class="headerlink" title="&lt;include> 标签"></a>&lt;include> 标签</h4><p><code>&lt;include&gt;</code> 标签常用于将布局中的公共部分提取出来供其他布局共用，以实现布局模块化，这在布局编写方便提供了大大的便利。</p><p>下面以在一个布局 main.xml 中用 <code>include</code> 引入另一个布局 foot.xml 为例。main.mxl 代码如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ListView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/simple_list_view<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginBottom</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@dimen/dp_80<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>include</span> <span class="token attr-name">layout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@layout/foot.xml<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">></span></span></code></pre><p>其中 <code>include</code> 引入的 foot.xml 为公用的页面底部，代码如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/button<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@dimen/dp_40<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_above</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/text<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>TextView</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/text<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@dimen/dp_40<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_alignParentBottom</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/app_name<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">></span></span></code></pre><p><code>&lt;include&gt;</code> 标签唯一需要的属性是 <code>layout</code> 属性，指定需要包含的布局文件。可以定义 <code>android:id</code> 和 <code>android:layout_*</code> 属性来覆盖被引入布局根节点的对应属性值。注意重新定义 <code>android:id</code> 后，子布局的顶结点 <code>id</code> 就变化了。</p><h4 id="lt-viewstub-标签"><a href="#lt-viewstub-标签" class="headerlink" title="&lt;viewstub> 标签"></a>&lt;viewstub> 标签</h4><p><code>&lt;viewstub&gt;</code> 标签同 <code>include</code> 标签一样可以用来引入一个外部布局，不同的是，<code>viewstub</code> 引入的布局默认不会扩张，即既不会占用显示也不会占用位置，从而在解析布局时节省 CPU 和内存。<code>&lt;viewstub&gt;</code> 标签常用来引入那些默认不会显示，只在特殊情况下显示的布局，如进度布局、网络失败显示的刷新布局、信息出错出现的提示布局等。</p><p>下面以在一个布局 main.xml 中加入网络错误时的提示页面 network_error.xml 为例。main.mxl 代码如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    ……    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ViewStub</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/network_error_layout<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@layout/network_error<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">></span></span></code></pre><p>其中 <code>viewstub</code> 引入的 network_error.xml 为只有在网络错误时才需要显示的布局，默认不会被解析，示例代码如下：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>RelativeLayout</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>match_parent<span class="token punctuation">"</span></span> <span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/network_setting<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@dimen/dp_160<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_centerHorizontal</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/network_setting<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>Button</span>        <span class="token attr-name"><span class="token namespace">android:</span>id</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/network_refresh<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_width</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@dimen/dp_160<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_height</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wrap_content<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_below</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@+id/network_setting<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_centerHorizontal</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>true<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>layout_marginTop</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@dimen/dp_10<span class="token punctuation">"</span></span>        <span class="token attr-name"><span class="token namespace">android:</span>text</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/network_refresh<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>RelativeLayout</span><span class="token punctuation">></span></span></code></pre><p>在 Java 中通过 <code>ViewStub viewStub = findViewById(id)</code> 找到 <code>ViewStub</code>，只有当一个 ViewStub 的 <code>inflate()</code> 方法被调用或者被设为可见时，这个 <code>ViewStub</code> 所指向的布局文件才会被加载，并替换当前 <code>ViewStub</code> 的位置。因此，ViewStub 存在于视图层次，直到 <code>setVisibility(int)</code> 或 <code>inflate()</code>方法被调用，否则是不加载控件的，所以消耗的资源小。通常也叫它为“懒惰的 include”。</p><blockquote><p>注意：对于一个 <code>ViewStub</code> 而言，当 <code>setVisibility(int)</code> 或 <code>inflate()</code> 方法被调用之后，这个 <code>ViewStub</code> 在布局中将被使用指定的 <code>View</code> 替换，所以被调用过 <code>inflate()</code> 方法的 <code>ViewStub</code>，如果被隐藏之后再次想要显示，将不能使用 <code>inflate()</code> 方法，但是可以再次使用 <code>setVisibility(int)</code> 方法设置为可见，这就是这两个方法的区别。</p></blockquote><h4 id="lt-merge-标签"><a href="#lt-merge-标签" class="headerlink" title="&lt;merge> 标签"></a>&lt;merge> 标签</h4><p>在使用了 <code>include</code> 后可能导致布局嵌套过多，多余不必要的 layout 节点，从而导致解析变慢，不必要的节点和嵌套可通过 <code>hierarchy viewer</code> 或 <code>设置-&gt;开发者选项-&gt;显示布局边界</code>查看。</p><p><code>&lt;merge&gt;</code> 标签可用于两种典型情况：</p><ul><li>布局顶结点是 <code>FrameLayout</code> 且不需要设置 <code>background</code> 或 <code>padding</code> 等属性，可以用 <code>merge</code> 代替，因为 <code>Activity</code> 根节点就是个 <code>FrameLayout</code>，所以可以用 <code>merge</code> 消除只剩一个。</li><li>某布局作为子布局被其他布局 <code>include</code> 时，使用 <code>merge</code> 当作该布局的根节点，这样在被引入时根结点会自动被忽略，而将其子节点全部合并到主布局中。</li></ul><p><code>&lt;merge&gt;</code> 只能作为 XML 布局的根标签使用。当Inflate以 <code>&lt;merge&gt;</code> 开头的布局文件时，必须指定一个父 <code>ViewGroup</code>，并且必须设定 <code>attachToRoot</code> 为 <code>true</code>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><table><thead><tr><th>标签</th><th>功能</th><th>描述</th></tr></thead><tbody><tr><td><code>&lt;include&gt;</code></td><td>提高布局复用性</td><td>提取布局间的公共部分，通过提高布局的复用性从而减少测量绘制时间</td></tr><tr><td><code>&lt;viewstub&gt;</code></td><td>减少测量绘制时间</td><td>减少测量绘制时间，可直接提高布局性能</td></tr><tr><td><code>&lt;merge&gt;</code></td><td>减少布局层级</td><td>减少布局层级，可直接减少测量绘制时间，提高布局性能</td></tr></tbody></table><h3 id="其他优化"><a href="#其他优化" class="headerlink" title="其他优化"></a>其他优化</h3><h4 id="用-SurfaceView-或-TextureView-代替普通-View"><a href="#用-SurfaceView-或-TextureView-代替普通-View" class="headerlink" title="用 SurfaceView 或 TextureView 代替普通 View"></a>用 SurfaceView 或 TextureView 代替普通 View</h4><p><code>SurfaceView</code> 或 <code>TextureView</code> 可以通过将绘图操作移动到另一个单独线程上提高性能。普通 View 的绘制过程都是在主线程(UI 线程)中完成，如果某些绘图操作影响性能就不好优化了，这时可以考虑使用 <code>SurfaceView</code> 和 <code>TextureView</code>，他们的绘图操作发生在 UI 线程之外的另一个线程上。</p><p>因为 <code>SurfaceView</code> 在常规视图系统之外，所以无法像常规试图一样移动、缩放或旋转一个 <code>SurfaceView</code>。<code>TextureView</code> 是 Android 4.0 引入的，除了与 <code>SurfaceView</code> 一样在单独线程绘制外，还可以像常规视图一样被改变。</p><h4 id="使用-RenderJavascript"><a href="#使用-RenderJavascript" class="headerlink" title="使用 RenderJavascript"></a>使用 RenderJavascript</h4><p><code>RenderScript</code> 是 Adnroid 3.0 引进的用来在 Android 上写高性能代码的一种语言，语法给予 C 语言的 C99 标准，他的结构是独立的，所以不需要为不同的 CPU 或者 GPU 定制代码。</p><h4 id="使用-OpenGL-绘图"><a href="#使用-OpenGL-绘图" class="headerlink" title="使用 OpenGL 绘图"></a>使用 OpenGL 绘图</h4><p>Android 支持使用 <code>OpenGL</code> API 的高性能绘图，这是 Android 可用的最高级的绘图机制，在游戏类对性能要求较高的应用中得到广泛使用。</p><p>Android 4.3 最大的改变，就是支持 <code>OpenGL ES 3.0</code>。相比 2.0，3.0 有更多的缓冲区对象、增加了新的着色语言、增加多纹理支持等等，将为 Android 游戏带来更出色的视觉体验。</p><h2 id="布局调优工具"><a href="#布局调优工具" class="headerlink" title="布局调优工具"></a>布局调优工具</h2><h3 id="Hierarchy-Viewer"><a href="#Hierarchy-Viewer" class="headerlink" title="Hierarchy Viewer"></a>Hierarchy Viewer</h3><p><code>Hierarchy Viewer</code> 是 Android Studio 提供的 UI 性能检测工具。可以帮助开发者可视化获得 UI 布局设计结构和各种属性信息，帮助优化布局设计。Hierarchy Viewer 可以方便地查看 Activity 布局，各个 View 的属性、布局测量和绘制的时间。具体介绍可见 <a href="https://developer.android.com/studio/profile/hierarchy-viewer" target="_blank" rel="noopener">Hierarchy Viewer</a></p><blockquote><p>Android Studio 3.1 或更高版本中，Hierarchy Viewer 已经被废弃，推荐在运行时使用 <code>Layout Inspector</code> 来检查应用程序的视图层次结构。</p></blockquote><h3 id="Layout-Inspector"><a href="#Layout-Inspector" class="headerlink" title="Layout Inspector"></a>Layout Inspector</h3><p><code>Layout Inspector</code> 是 Android Studio 替代 Hierarchy Viewer 的新方案。利用 Android Studio 中的布局检查器，可以在运行时从 Android Studio IDE 内检查自己应用的视图层次结构。如果布局在运行时(而不是完全在 XML 中)构建并且布局没有按预期显示，这种检查将非常有用。具体介绍可见 <a href="https://developer.android.com/studio/debug/layout-inspector" target="_blank" rel="noopener">Layout Inspector</a></p><p>按以下步骤操作，打开布局检查器：</p><ul><li>在连接的设备或模拟器上运行您的应用。</li><li>点击 Tools &gt; Android &gt; Layout Inspector。</li><li>在出现的 Choose Process 对话框中，选择想要检查的应用进程，然后点击 OK。</li></ul><blockquote><p>注意：设备必须运行 Android 4.1 或更高版本。</p></blockquote><h3 id="Lint"><a href="#Lint" class="headerlink" title="Lint"></a>Lint</h3><p><code>Lint</code> 是 Android Studio 提供的一款代码扫描分析工具，可以扫描、发现代码结构和质量问题并提供解决方案。Lint 发现的每个问题都有描述信息和等级(和测试发现 bug 很相似)，可方便定位问题并按照严重程度进行解决。具体介绍可见 <a href="https://developer.android.com/studio/write/lint" target="_blank" rel="noopener">Lint</a></p><h3 id="Systrace"><a href="#Systrace" class="headerlink" title="Systrace"></a>Systrace</h3><p><code>Systrace</code> 是 Android 4.1 中新增的性能数据采样和分析工具。它可帮助开发者收集 Android 关键子系统(如 Surfaceflinger、WindowManagerService 等 framework 部分关键模块、服务)的运行信息，从而帮助开发者更直观的分析系统瓶颈，改进性能。具体介绍可见 <a href="https://developer.android.google.cn/studio/command-line/systrace" target="_blank" rel="noopener">Systrace</a></p><p>Systrace 的功能包括跟踪系统的 I/O 操作、内核工作队列、CPU 负载以及 Android 各个子系统的运行状况等。在 Android 平台中，它主要由以下三部分组成：</p><ul><li>内核部分：Systrace 利用了 Linux Kernel 中的 ftrace 功能。所以要使用 Systrace 的话，必须开启 kernel 中和 ftrace 相关的模块。</li><li>数据采集部分：Android 定义了一个 Trace 类。应用程序可利用该类把统计信息输出给 ftrace。同时，Android 还有一个 atrace 程序，它可以从 ftrace 中读取统计信息然后交给数据分析工具来处理。</li><li>数据分析工具：Android 提供了一个 systrace.py(Python 脚步文件，位于 Android SDK 目录/tools/systrace 中，其内部将调用 atrace 程序)用来配置数据采集的方式(如采集数据的标签、输出文件名等)和收集 ftrace 统计数据并生成一个结果网页文件供用户查看。</li></ul><p>本质上，Systrace 是对 Linux Kernel 中 ftrace 的封装，应用程序需要利用 Android 提供的 Trace 类来使用 Systrace。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 性能优化之启动优化</title>
      <link href="/posts/2019/985e20fe.html"/>
      <url>/posts/2019/985e20fe.html</url>
      
        <content type="html"><![CDATA[<p>用户希望应用程序能够快速响应并加载。启动时间较慢的应用程序无法满足此预期，并且可能会令用户失望。这种糟糕的体验可能会导致用户在应用商店中对您的应用评分不佳，甚至卸载此应用。</p><p>因此想要优化应用程序的启动时间，需要以下几个步骤。首先，我们需要了解应用启动的内部原理。接下来，我们会讨论如何分析启动性能。最后，最后我们会介绍一些影响启动性能的常见问题，并提供一些相应的解决办法。</p><h2 id="应用启动原理"><a href="#应用启动原理" class="headerlink" title="应用启动原理"></a>应用启动原理</h2><p>应用程序启动可以在三种状态之一中进行，每种状态都会影响应用程序对用户可见所需的时间：冷启动，热启动或热启动。在冷启动时，您的应用程序从头开始。在其他状态中，系统需要将正在运行的应用程序从后台运行到前台。我们建议您始终根据冷启动的假设进行优化。这样做也可以改善热启动和热启动的性能。</p><p>为了优化您的应用程序以实现快速启动，了解系统和应用程序级别发生的情况以及它们在每种状态下的交互方式非常有用。</p><p>应用程序启动的类型可以分为三种，每种类型所花费的时间是不一样的：</p><ul><li><strong><code>冷启动：</code></strong>当启动应用时，后台没有该应用的进程，这时系统会首先会创建一个新的进程分配给该应用，这种启动方式就是冷启动。</li><li><strong><code>热启动：</code></strong>当启动应用时，后台已有该应用的进程，比如按下 Home 键，这种在已有进程的情况下，会从已有的进程中来启动应用，这种启动方式叫热启动。</li><li><strong><code>温启动：</code></strong>当启动应用时，后台已有该应用的进程，但是启动的入口 Activity 被干掉了，比如按了 Back 键，应用虽然退出了，但是该应用的进程是依然会保留在后台，这种启动方式叫温启动。</li></ul><p>冷启动模式下，应用进程完全不存在，系统要新建应用进程。在另外两种模式下，系统只需要将正在运行的应用程序从后台切换到前台。建议您始终根据冷启动的假设进行优化。冷启动速度得到提升了，这样做同样也可以改善热启动和热启动的性能。</p><p>那么在应用启动过程中，Android 系统和应用层都做了那些操作呢？理解了它们的内部原理，将会帮助我们做好启动性能优化。</p><h3 id="冷启动"><a href="#冷启动" class="headerlink" title="冷启动"></a>冷启动</h3><p>冷启动指应用重新开始创建：在启动之前，系统进程尚未创建应用程序的进程。冷启动通常发生在自设备启动以来首次启动应用程序或者系统主动杀掉了应用程序的情况下。和其他启动方式相比，冷启动模式需要系统和应用做更多的初始化操作，所以优化起来也有一定的挑战。</p><p>在冷启动的开始阶段，系统需要执行以下三个任务：</p><ol><li>加载并启动应用程序。</li><li>启动后立即显示应用程序的空白启动窗口。</li><li>创建应用程序进程。</li></ol><p>一旦系统创建了应用程序进程，应用程序进程就会执行下面步骤：</p><ol><li>创建应用程序对象。</li><li>启动主线程。</li><li>创建 Main Activity。</li><li>初始化构造 View。</li><li>在屏幕上布局。</li><li>执行初始化绘制操作。</li></ol><p>应用程序进程完成第一次绘制后，系统进程会用 Main Activity 来替换之前已经生成的背景窗口。这个时候，用户就可以使用应用程序了。</p><p>冷启动应用程序时，系统和应用程序处理彼此之间的工作的重要部分的直观表示，如下如所示：<br><img src="https://henleylee.github.io/medias/android/cold_launch.png" alt="冷启动应用程序重要部分的直观表示"></p><blockquote><p>冷启动性能问题可能会出现在应用创建和 Main Activity 创建过程中。</p></blockquote><h4 id="Application-创建"><a href="#Application-创建" class="headerlink" title="Application 创建"></a>Application 创建</h4><p>当应用程序启动时，空白的启动窗口将会一直保留在屏幕上，直到系统首次完成应用程序的绘制操作。此时，系统进程会替换掉应用程序的启动窗口，允许用户开始与应用程序进行交互。</p><p>如果在自己的应用程序中重载 <a href="https://developer.android.com/reference/android/app/Application.html#onCreate()" target="_blank" rel="noopener">Application.onCreate()</a> 方法，系统将会在应用程序对象上调用 <code>onCreate()</code> 方法。之后，应用程序会创建主线程(也称为 UI 线程)，并执行创建 Main Activity 的过程。</p><p>从这个时候开始,系统和应用程序级别的进程将按照<a href="https://developer.android.com/guide/topics/processes/process-lifecycle.html" target="_blank" rel="noopener">应用程序生命周期阶段</a>进行。</p><h4 id="Activity-创建"><a href="#Activity-创建" class="headerlink" title="Activity 创建"></a>Activity 创建</h4><p>当应用进程创建了Activity 后，Activity 会执行以下操作：</p><ol><li>初始化值。</li><li>调用构造方法。</li><li>调用当前生命周期的回调函数(例如 <a href="https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)" target="_blank" rel="noopener">Activity.onCreate()</a>)。</li></ol><p>通常情况下，<a href="https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)" target="_blank" rel="noopener">onCreate()</a> 方法对加载时间的影响最大，因为它要执行的操作更加繁重：加载和构造 View，还有初始化 Activity 运行所需的对象。</p><h3 id="热启动"><a href="#热启动" class="headerlink" title="热启动"></a>热启动</h3><p>应用程序的热启动和冷启动相比，更加简单，开销也更少。在热启动过程中，系统要做的只是把应用程序的 Activity 切换到前台来。如果应用程序的所有 Activity 都驻留在内存中，那么应用就可以避免重复进行对象初始化，布局加载和渲染。</p><p>但是，如果系统执行了内存回收操作并触发了回收事件，例如 <a href="https://developer.android.com/reference/android/content/ComponentCallbacks2.html#onTrimMemory(int)" target="_blank" rel="noopener">onTrimMemory()</a>，那么热启动时仍然需要重新创建这些对象。</p><p>在屏幕窗口的操作上，热启动操作具有和冷启动的一样的过程：系统进程将会一直显示一个空白屏幕直到应用完成对 Activity 的渲染。</p><h3 id="温启动"><a href="#温启动" class="headerlink" title="温启动"></a>温启动</h3><p>暖启动过程包含了冷启动过程的部分步骤，同时开销比热启动更小。</p><p>暖启动发生在以下几个场景下：</p><ul><li>用户退出了应用程序，但随后又重新启动它。这种情况下，应用进程可以继续运行，但是应用程序必须通过调用 <a href="https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)" target="_blank" rel="noopener">onCreate()</a> 重建 Activity。</li><li>应用程序内存被系统回收，然后用户又重新打开它。这个时候，应用程序进程和 Activity 都需要被创建，但应用可以从 Activity 的 <a href="https://developer.android.com/reference/android/app/Activity.html#onCreate(android.os.Bundle)" target="_blank" rel="noopener">onCreate()</a> 方法的 Bundle 类型参数中拿到系统保存的实例。</li></ul><h2 id="发现并定位问题"><a href="#发现并定位问题" class="headerlink" title="发现并定位问题"></a>发现并定位问题</h2><p>Android 提供了多种方式能让你能够发现并定位 App 的问题。Android vitals 可以给出问题告警，然后诊断工具可以帮助定位出问题。</p><h3 id="Android-vitals"><a href="#Android-vitals" class="headerlink" title="Android vitals"></a>Android vitals</h3><p>Android vitals 可以通过 <a href="https://play.google.com/apps/publish/signup/" target="_blank" rel="noopener">Play Console</a> 提醒您应用的启动时间过长，从而帮助您提高应用的性能。Android vitals 判断启动时间过长的标准如下：</p><ul><li>冷启动花费 5 秒或更长。</li><li>暖启动花费 2 秒或更长。</li><li>热启动花费 1.5 秒或更长。</li></ul><p>daily session 指的是 App 当天的启动情况。</p><p>Android vitals 并不会报告热启动的数据。关于 Google Play 如何收集 Android vitals 数据的详细信息，请参考 <a href="https://support.google.com/googleplay/android-developer/answer/7385505" target="_blank" rel="noopener">Play Console</a> 文档。</p><h3 id="测量慢启动耗时"><a href="#测量慢启动耗时" class="headerlink" title="测量慢启动耗时"></a>测量慢启动耗时</h3><p>为了正确评估应用启动性能，可以关注一些能够显示应用启动时长的数据指标。</p><h4 id="初始化显示耗时"><a href="#初始化显示耗时" class="headerlink" title="初始化显示耗时"></a>初始化显示耗时</h4><p>在 Android 4.4(API level 19) 和更高的版本中，Logcat 包含了一个名为 <code>Displayed</code> 值的输出行。这个值代表了从应用进程启动到完成 Activity 绘制所花费的时间。这个过程包含了以事件序列：</p><ol><li>启动应用进程。</li><li>初始化对象。</li><li>创建和初始化 Activity。</li><li>构建布局。</li><li>首次绘制应用。</li></ol><p>报告的日志行类似于以下示例：</p><pre><code>ActivityManager：显示com.android.myexample / .StartupTiming：+ 3s534ms</code></pre><p>如果要从命令行或者终端中追踪 logcat 输出，那么很容易能够找到这个时间值。需要注意的是要在 Android Studio 中查找已用时间，必须在 logcat 视图中禁用过滤器。禁用过滤器是必须的，因为输出此日志的是系统，而不是应用程序本身。</p><p>完成设置后，就可以很轻松地找到输出的时间值。下图显示了如何禁用过滤器，并在底部的 logcat 日志输出中显示了 <code>Displayed</code> 的值：<br><img src="https://henleylee.github.io/medias/android/displayed_logcat.png" alt="禁用过滤器并输出了 Displayed 的值"></p><p>Logcat 输出中显示的 Displayed 的值并不一定是所有资源都加载完成后显示的总耗时，它并不包括布局文件中没有引用的资源及初始化对象所引用的资源的加载时间，因为这个加载过程是一个内部过程，不阻塞应用初始内容的显示。</p><p>有时候，Logcat 输出中显示的 Displayed 所在行包含了一个附加字段 <code>total</code>。例如：</p><pre><code>ActivityManager: Displayed com.android.myexample/.StartupTiming: +3s534ms (total +1m22s643ms)</code></pre><p>这种情况下，第一个时间值表示绘制出第一个可见 Activity 的耗时。后面的 <code>total</code> 时间指从应用进程的启动开始，可能会包含另一个 Activity 的启动，但这个 Activity 并不可见。<code>total</code> 时间只会在启动单个 Activity 时长和总启动时长不一样才显示。</p><p>还可以使用 <a href="https://developer.android.com/studio/command-line/shell.html#am" target="_blank" rel="noopener">ADB Shell Activity Manager</a> 命令运行应用程序来测量初始显示的时间。示例如下：</p><pre class=" language-shell"><code class="language-shell">adb [-d|-e|-s <serialNumber>] shell am start -S -Wcom.example.app/.MainActivity-c android.intent.category.LAUNCHER-a android.intent.action.MAIN</code></pre><p><code>Displayed</code> 依旧会之前那样在 logcat 中输出，同时终端窗口也会有以下输出：</p><pre><code>Starting: IntentActivity: com.example.app/.MainActivityThisTime: 2044TotalTime: 2044WaitTime: 2054Complete</code></pre><p><code>-c</code> 和 <code>-a</code> 参数是可选的，可以指定 Intent 的 <a href="https://developer.android.com/guide/topics/manifest/category-element.html" target="_blank" rel="noopener"><category></category></a> 和 <a href="https://developer.android.com/guide/topics/manifest/action-element.html" target="_blank" rel="noopener"><action></action></a>。</p><h4 id="完全显示耗时"><a href="#完全显示耗时" class="headerlink" title="完全显示耗时"></a>完全显示耗时</h4><p>可以使用 <a href="https://developer.android.com/reference/android/app/Activity.html#reportFullyDrawn()" target="_blank" rel="noopener">reportFullyDrawn()</a> 方法来测量应用启动到所有资源和视图层次结构的完整显示之间所经过的时间，该方法在应用使用延迟加载的情况下是很有用的。在延迟加载中，应用程序不会阻止窗口的初始绘制，而是异步加载资源并更新视图层次结构。</p><p>如果由于延迟加载，应用的初始显示并不包括所有的资源，则可以将所有资源和视图的加载和显示视为单独的度量标准：例如：用户界面可能已经完成了文本的加载，但又必须从网络获取图像。</p><p>要解决这个问题，可以手动调用 <a href="https://developer.android.com/reference/android/app/Activity.html#reportFullyDrawn()" target="_blank" rel="noopener">reportFullyDrawn()</a>，让系统知道 Activity 已经完成了它的延迟加载。使用此方法时，logcat 将显示出从创建应用对象到调用 <a href="https://developer.android.com/reference/android/app/Activity.html#reportFullyDrawn()" target="_blank" rel="noopener">reportFullyDrawn()</a> 方法的时间。下面是 logcat 的输出示例：</p><pre><code>system_process I/ActivityManager: Fully drawn {package}/.MainActivity: +1s54ms</code></pre><p>如果确定出显示耗时要比预期的长，可以进一步继续尝试找出启动过程中的性能瓶颈。</p><h4 id="确定性能瓶颈"><a href="#确定性能瓶颈" class="headerlink" title="确定性能瓶颈"></a>确定性能瓶颈</h4><p>确定性能瓶颈的最好方法是使用 <code>Android Studio CPU Profiler</code>。有关信息，请参阅 <a href="https://developer.android.com/studio/profile/cpu-profiler" target="_blank" rel="noopener">Inspect CPU activity with CPU Profiler</a>。</p><p>还可以通过应用程序和 Activity 的 <code>onCreate()</code> 方法中的内联跟踪来深入了解潜在的瓶颈。要了解内联跟踪，请参阅 <a href="https://developer.android.com/reference/android/os/Trace.html" target="_blank" rel="noopener">Trace</a> 函数和 <a href="https://developer.android.com/studio/profile/systrace-commandline.html" target="_blank" rel="noopener">Systrace</a> 工具。</p><h2 id="影响启动性能的常见问题"><a href="#影响启动性能的常见问题" class="headerlink" title="影响启动性能的常见问题"></a>影响启动性能的常见问题</h2><p>下面讨论经常影响应用程序启动性能的几个问题。主要是关注应用与 Activity 对象的初始化以及画面的加载。</p><h3 id="APP-初始化开销大"><a href="#APP-初始化开销大" class="headerlink" title="APP 初始化开销大"></a>APP 初始化开销大</h3><p>Application 的创建过程中，如果执行复杂的逻辑或者初始化大量的对象，将会影响应用的启动体验。具体来说，就是如果继承了 Application 并在初始化时执行了不必要的代码。有些初始化可能是完全不需要的，比如：保存一个实际上由 Intent 启动的 APP 中的 Main Activity 的状态信息，通过 Intent 启动 Activitiy，应用只会使用先前初始化的状态数据的一部分。</p><p>其它在 APP 启动期间影响性能的操作还有数量众多的垃圾收集事件，或者在初始化过程中同时发生磁盘I/O，从而进一步阻塞初始化过程。垃圾收集是 Dalvik 运行时特别需要考虑的问题，Art 运行时并发地执行垃圾收集，最大限度地减少了操作的影响。</p><h4 id="问题诊断"><a href="#问题诊断" class="headerlink" title="问题诊断"></a>问题诊断</h4><p>这种情况下，可以使用方法跟踪或内联跟踪来诊断问题。</p><h4 id="方法跟踪"><a href="#方法跟踪" class="headerlink" title="方法跟踪"></a>方法跟踪</h4><p>运行 CPU Profiler 会发现 <a href="https://developer.android.com/reference/android/app/Instrumentation.html#callApplicationOnCreate(android.app.Application)" target="_blank" rel="noopener">callApplicationOnCreate()</a> 方法最终调用 <code>com.example.CustomApplication.onCreate()</code> 方法。</p><p>如果工具显示这些方法需要很长时间才能完成执行，那么就应该好好看看这些方法到底做了哪些操作。 </p><h4 id="内联跟踪"><a href="#内联跟踪" class="headerlink" title="内联跟踪"></a>内联跟踪</h4><p>使用内联跟踪来找出可能的引发问题的元凶，包括：</p><ul><li>应用的初始 <a href="https://developer.android.com/reference/android/app/Application.html#onCreate()" target="_blank" rel="noopener">onCreate()</a> 函数。</li><li>应用初始化的任何全局单例对象。</li><li>任何瓶颈期间可能发生的磁盘 I/O，反序列化，或紧凑的循环操作。</li></ul><h4 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h4><p>不论问题是否由非必要的初始化或磁盘 I/O 引起，解决方案都是要延迟初始化对象：仅初始化那些立即使用的对象。例如，采用单例模式而不是创建全局静态对象，在该模式中，应用程序仅在第一次访问时才创建对象。也可以考虑使用 <a href="http://google.github.io/dagger/" target="_blank" rel="noopener">Dagger</a> 之类的依赖注入框架，当第一次被注入时才创建对象和依赖。</p><h3 id="Activity-初始化操作复杂"><a href="#Activity-初始化操作复杂" class="headerlink" title="Activity 初始化操作复杂"></a>Activity 初始化操作复杂</h3><p>Activity 的创建通常包含大量高负载工作。一般来说，可以通过考虑以下方面的问题来优化工作提高性能：</p><ul><li>加载比较大或复杂的布局；</li><li>磁盘或网络 I/O 阻塞屏幕绘制；</li><li>加载和解码 Bitmap；</li><li>渲染 <a href="https://developer.android.com/reference/android/graphics/drawable/VectorDrawable.html" target="_blank" rel="noopener">VectorDrawable</a> 对象；</li><li>Activity 中子系统的初始化。</li></ul><h4 id="问题诊断-1"><a href="#问题诊断-1" class="headerlink" title="问题诊断"></a>问题诊断</h4><p>这种情况下，同样可以使用方法跟踪或内联跟踪来诊断问题。</p><h4 id="方法跟踪-1"><a href="#方法跟踪-1" class="headerlink" title="方法跟踪"></a>方法跟踪</h4><p>当运行 CPU Profiler 工具时，主要的关注点是 APP 中 Application 子类的构造方法和 <code>com.example.CustomApplication.onCreate()</code> 方法。</p><p>如果工具显示这些方法需要很长时间才能完成执行，那么就应该好好看看这些方法到底做了哪些操作。 </p><h4 id="内联跟踪-1"><a href="#内联跟踪-1" class="headerlink" title="内联跟踪"></a>内联跟踪</h4><p>使用内联跟踪来找出可能的引发问题的元凶，包括：</p><ul><li>应用的初始 <a href="https://developer.android.com/reference/android/app/Application.html#onCreate()" target="_blank" rel="noopener">onCreate()</a> 函数。</li><li>应用初始化的任何全局单例对象。</li><li>任何瓶颈期间可能发生的磁盘 I/O，反序列化，或紧凑的循环操作。</li></ul><h4 id="解决方案-1"><a href="#解决方案-1" class="headerlink" title="解决方案"></a>解决方案</h4><p>有很多可能的瓶颈，两个常见的问题和解决方法如下：</p><ul><li><p>视图的层级越多，布局的时候就会花更多时间，可以通过两个步骤优化：</p><ul><li>通过减少重复和布局嵌套是布局变得扁平化。</li><li>不要加载启动时对用户不可见的布局，可以使用 <a href="https://developer.android.com/reference/android/view/ViewStub.html" target="_blank" rel="noopener">ViewStub</a>。</li></ul></li><li><p>把所有资源的初始化放到主线程中也会减慢启动速度，可以这样优化：</p><ul><li>使用懒加载或非主线程初始化资源。</li><li>允许 APP 先展示 视图，然后再更新 Bitmap 或其它可见资源。</li></ul></li></ul><h3 id="设置启动页的主题"><a href="#设置启动页的主题" class="headerlink" title="设置启动页的主题"></a>设置启动页的主题</h3><p>可以让 APP 使用自定义主题加载，使 APP 的启动屏幕与其它界面保持主题一致，而不是使用系统主题，这样做也可以使 Activity 的启动看起来没那么慢。</p><p>通常实现启动屏幕主题化的方法是使用 <a href="https://developer.android.com/reference/android/R.attr.html#windowDisablePreview" target="_blank" rel="noopener"><code>windowDisablePreview</code></a> 属性去关闭初次启动时的白屏。然而，使用这种方法会导致更长的启动时间，并且，当用户点击启动图标后可能会因为无界面反馈而使用户感到疑惑。</p><h4 id="问题诊断-2"><a href="#问题诊断-2" class="headerlink" title="问题诊断"></a>问题诊断</h4><p>通常可以通过观察 APP 启动时是不是没有响应来确定是不是存在问题，这种情况下，屏幕仿佛被冰冻一样卡住，对输入事件也不会有响应。</p><h4 id="解决方案-2"><a href="#解决方案-2" class="headerlink" title="解决方案"></a>解决方案</h4><p>相比于禁用 preview window，可以遵循 <a href="http://www.google.com/design/spec/patterns/launch-screens.html#" target="_blank" rel="noopener">Material Design</a> 模式。可以使用 Acitivity 的 <a href="https://developer.android.com/reference/android/R.attr.html#windowBackground" target="_blank" rel="noopener"><code>windowBackground</code></a> 属性为启动屏幕提供一个简单的背景。 </p><p>例如，可以创建一个 xml 文件：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>layer-list</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>android</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/apk/res/android<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>opacity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>opaque<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>  <span class="token comment" spellcheck="true">&lt;!-- The background color, preferably the same as your normal theme --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span> <span class="token attr-name"><span class="token namespace">android:</span>drawable</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@android:color/white<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token comment" spellcheck="true">&lt;!-- Your product logo - 144dp color version of your app icon --></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>item</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bitmap</span>      <span class="token attr-name"><span class="token namespace">android:</span>src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/product_logo_144dp<span class="token punctuation">"</span></span>      <span class="token attr-name"><span class="token namespace">android:</span>gravity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>center<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>item</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>layer-list</span><span class="token punctuation">></span></span></code></pre><p>对应的 Manifest 文件：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name">...</span>    <span class="token attr-name"><span class="token namespace">android:</span>theme</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@style/AppTheme.Launcher<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span></code></pre><p>最简单的切换为正常主题的方式是在调用 <code>super.onCreate()</code> 和 <code>setContentView()</code> 前调用 <a href="https://developer.android.com/reference/android/view/ContextThemeWrapper.html#setTheme(int)" target="_blank" rel="noopener">setTheme(R.style.AppTheme)</a> ：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyMainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>  <span class="token annotation punctuation">@Override</span>  <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span>Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Make sure this is before calling super.onCreate</span>    <span class="token function">setTheme</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>style<span class="token punctuation">.</span>Theme_MyApp<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// ...</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://developer.android.com/topic/performance/vitals/launch-time" target="_blank" rel="noopener">App startup time</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 性能优化 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 事件分发机制详解</title>
      <link href="/posts/2019/f360d385.html"/>
      <url>/posts/2019/f360d385.html</url>
      
        <content type="html"><![CDATA[<p>Android 上的 View 是树形结构的，View 可能会重叠在一起，当我们点击的地方有多个 View 都可以响应的时候，这个点击事件应该给谁呢？事件分发机制就是为了处理这个问题的。</p><h2 id="事件分发基础认知"><a href="#事件分发基础认知" class="headerlink" title="事件分发基础认知"></a>事件分发基础认知</h2><h3 id="事件分发的对象是谁？"><a href="#事件分发的对象是谁？" class="headerlink" title="事件分发的对象是谁？"></a>事件分发的对象是谁？</h3><p><strong>答：点击事件(Touch 事件)</strong></p><ul><li><p>定义：当用户触摸屏幕时(View 或 ViewGroup 派生的控件)，将产生点击事件(Touch 事件)。</p><blockquote><p>Touch事件相关细节（发生触摸的位置、时间、历史记录、手势动作等）被封装成MotionEvent对象</p></blockquote></li><li><p>主要发生的 Touch 事件的事件类型有如下四种：</p></li></ul><table><thead><tr><th>事件类型</th><th>具体动作</th></tr></thead><tbody><tr><td>MotionEvent.ACTION_DOWN</td><td>按下 View(所有事件的开始)</td></tr><tr><td>MotionEvent.ACTION_MOVE</td><td>滑动 View</td></tr><tr><td>MotionEvent.ACTION_UP</td><td>抬起 View(与 DOWN 对应)</td></tr><tr><td>MotionEvent.ACTION_CANCEL</td><td>非人为原因结束事件</td></tr></tbody></table><ul><li>特别说明：事件列<br>从手指接触屏幕 至 手指离开屏幕，这个过程产生的一系列事件，就叫事件列。<blockquote><p>注意：一般情况下，事件列都是以 <code>DOWN</code> 事件开始、<code>UP</code> 事件结束，中间有无数的 <code>MOVE</code> 事件，如下图：<br><img src="https://henleylee.github.io/medias/touch/event_queue.png" alt="事件列"><br>即当一个 <code>MotionEvent</code> 产生后，系统需要把这个事件传递给一个具体的 <code>View</code> 去处理。</p></blockquote></li></ul><h3 id="事件分发的本质是什么？"><a href="#事件分发的本质是什么？" class="headerlink" title="事件分发的本质是什么？"></a>事件分发的本质是什么？</h3><p><strong>答：将点击事件(MotionEvent)传递到某个具体的 View 并处理的整个过程</strong></p><blockquote><p>即当一个点击事件发生后，系统需要将这个事件传递给一个具体的 View 去处理。这个事件传递的过程就是分发过程。</p></blockquote><h3 id="事件在哪些对象之间进行传递？"><a href="#事件在哪些对象之间进行传递？" class="headerlink" title="事件在哪些对象之间进行传递？"></a>事件在哪些对象之间进行传递？</h3><p><strong>答：Activity、ViewGroup、View</strong></p><blockquote><p>一个事件产生后，传递顺序是：<code>Activity(Window) -&gt; ViewGroup -&gt; View</code>，事件分发的顺序就是事件传递的顺序。</p></blockquote><table><thead><tr><th>对象</th><th>简介</th><th>备注</th></tr></thead><tbody><tr><td>Activity</td><td>控制生命周期并处理事件</td><td>统筹视图的加载和显示，通过其它回调方法与 Window、View 交互</td></tr><tr><td>ViewGroup</td><td>一组 View 的集合(包含多个子 View)</td><td>ViewGroup 继承自 View，区别于单一 View，多了可包含子 View 和定义布局参数的功能</td></tr><tr><td>View</td><td>所有 UI 组件的基类(不包含子 View 的组件)</td><td>不包含子 View 的单一 View，如 TextView、ImageView、Button 等</td></tr></tbody></table><p>Android 的 UI 界面是由 <code>Activity</code>、<code>ViewGroup</code>、<code>View</code> 及其派生类组合而成的。View 是所有 UI 组件的基类，ViewGroup 是容纳 UI 组件的容器，即一组 View 的集合(包含很多子 View 和子 VewGroup)。</p><h3 id="事件分发过程由哪些方法协作完成？"><a href="#事件分发过程由哪些方法协作完成？" class="headerlink" title="事件分发过程由哪些方法协作完成？"></a>事件分发过程由哪些方法协作完成？</h3><p><strong>答：dispatchTouchEvent() 、onInterceptTouchEvent() 和 onTouchEvent()</strong><br><img src="https://henleylee.github.io/medias/touch/event_method.png" alt="事件分发过程的方法"></p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p><img src="https://henleylee.github.io/medias/touch/event_base_summary.png" alt="事件分发基础认知总结"></p><h2 id="事件分发机制核心方法"><a href="#事件分发机制核心方法" class="headerlink" title="事件分发机制核心方法"></a>事件分发机制核心方法</h2><p>事件分发过程由 <code>dispatchTouchEvent()</code>、<code>onInterceptTouchEvent()</code> 和 <code>onTouchEvent()</code> 三个核心方法协助完成，如下图所示：<br><img src="https://henleylee.github.io/medias/touch/event_core_method.png" alt="事件分发机制核心方法"></p><h3 id="dispatchTouchEvent"><a href="#dispatchTouchEvent" class="headerlink" title="dispatchTouchEvent()"></a>dispatchTouchEvent()</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_intro.png" alt="dispatchTouchEvent()方法简介"></p><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_process.png" alt="dispatchTouchEvent()方法业务流程说明图"></p><h4 id="返回情况：默认"><a href="#返回情况：默认" class="headerlink" title="返回情况：默认"></a>返回情况：默认</h4><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_return_default.png" alt="dispatchTouchEvent()方法返回情况(默认)"></p><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_process_default.png" alt="dispatchTouchEvent()方法返回情况(默认)业务流程说明图"></p><h4 id="返回情况：返回true"><a href="#返回情况：返回true" class="headerlink" title="返回情况：返回true"></a>返回情况：返回true</h4><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_return_true.png" alt="dispatchTouchEvent()方法返回情况(返回true)"></p><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_process_true.png" alt="dispatchTouchEvent()方法返回情况(返回true)业务流程说明图"></p><blockquote><p>事件停止分发，逐层往上返回<code>(若无上层返回，则结束)</code>；后续事件会继续分发到该 View。</p></blockquote><h4 id="返回情况：返回false"><a href="#返回情况：返回false" class="headerlink" title="返回情况：返回false"></a>返回情况：返回false</h4><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_return_false.png" alt="dispatchTouchEvent()方法返回情况(返回false)"></p><p><img src="https://henleylee.github.io/medias/touch/event_dispatch_process_false.png" alt="dispatchTouchEvent()方法返回情况(返回false)业务流程说明图"></p><blockquote><p>将事件回传给上层的 <code>onTouchEvent()</code> 处理<code>(若无上层返回，则结束)</code>；当前 View 仍然接受此事件的其他事件<code>(与 onTouchEvent() 区别)</code>。</p></blockquote><h3 id="onInterceptTouchEvent"><a href="#onInterceptTouchEvent" class="headerlink" title="onInterceptTouchEvent()"></a>onInterceptTouchEvent()</h3><h4 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h4><p><img src="https://henleylee.github.io/medias/touch/event_intercept_intro.png" alt="onInterceptTouchEvent()方法简介"></p><blockquote><p><strong>注意：</strong><code>Activity</code>、<code>View</code> 都无该方法。</p></blockquote><p><img src="https://henleylee.github.io/medias/touch/event_intercept_process.png" alt="onInterceptTouchEvent()方法业务流程说明图"></p><h4 id="返回情况：返回true-1"><a href="#返回情况：返回true-1" class="headerlink" title="返回情况：返回true"></a>返回情况：返回true</h4><p><img src="https://henleylee.github.io/medias/touch/event_intercept_return_true.png" alt="onInterceptTouchEvent()方法返回情况(返回true)"></p><p><img src="https://henleylee.github.io/medias/touch/event_intercept_process_true.png" alt="onInterceptTouchEvent()方法返回情况(返回true)业务流程说明图"></p><blockquote><p>拦截事件，事件停止往下传递，ViewGroup 自己处理事件，调用父类 super.dispatchTouchEvent()，最终执行自己的 onTouchEvent()；同一个事件的其他事件列都交由该 View 处理；在同一个事件列中该方法不会再次被调用。</p></blockquote><h4 id="返回情况：返回false-默认"><a href="#返回情况：返回false-默认" class="headerlink" title="返回情况：返回false(默认)"></a>返回情况：返回false(默认)</h4><p><img src="https://henleylee.github.io/medias/touch/event_intercept_return_false.png" alt="onInterceptTouchEvent()方法返回情况(返回false)"></p><p><img src="https://henleylee.github.io/medias/touch/event_intercept_process_false.png" alt="onInterceptTouchEvent()方法返回情况(返回false)业务流程说明图"></p><blockquote><p>不拦截事件，事件继续往下传递，事件传递到子 View，调用父类 View.dispatchTouchEvent() 方法中去处理；当前 View 仍然接受此事件的其他事件<code>(与 onTouchEvent() 区别)</code>。</p></blockquote><h3 id="onTouchEvent"><a href="#onTouchEvent" class="headerlink" title="onTouchEvent()"></a>onTouchEvent()</h3><h4 id="简介-2"><a href="#简介-2" class="headerlink" title="简介"></a>简介</h4><p><img src="https://henleylee.github.io/medias/touch/event_touch_intro.png" alt="onTouchEvent()方法简介"></p><blockquote><p><strong>注意：</strong><code>Activity</code>、<code>View</code> 都无该方法。</p></blockquote><p><img src="https://henleylee.github.io/medias/touch/event_touch_process.png" alt="onTouchEvent()方法业务流程说明图"></p><h4 id="返回情况：返回true-2"><a href="#返回情况：返回true-2" class="headerlink" title="返回情况：返回true"></a>返回情况：返回true</h4><p><img src="https://henleylee.github.io/medias/touch/event_touch_return_true.png" alt="onTouchEvent()方法返回情况(返回true)"></p><p><img src="https://henleylee.github.io/medias/touch/event_touch_process_true.png" alt="onTouchEvent()方法返回情况(返回true)业务流程说明图"></p><blockquote><p>事件停止分发，逐层往上返回<code>(若无上层返回，则结束)</code>；后续事件序列让其处理。</p></blockquote><h4 id="返回情况：返回false-默认-1"><a href="#返回情况：返回false-默认-1" class="headerlink" title="返回情况：返回false(默认)"></a>返回情况：返回false(默认)</h4><p><img src="https://henleylee.github.io/medias/touch/event_touch_return_false.png" alt="onTouchEvent()方法返回情况(返回false)"></p><p><img src="https://henleylee.github.io/medias/touch/event_touch_process_false.png" alt="onTouchEvent()方法返回情况(返回false)业务流程说明图"></p><blockquote><p>将事件向上传递给给上层的 <code>onTouchEvent()</code> 处理<code>(若无上层返回，则结束)</code>；当前 View 不再接受此事件的其他事件<code>(与 dispatchTouchEvent()onInterceptTouchEvent() 区别)</code>。</p></blockquote><h3 id="三者关系"><a href="#三者关系" class="headerlink" title="三者关系"></a>三者关系</h3><p>下面将用一段伪代码来阐述上述三个方法的关系和点击事件传递规则：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 点击事件产生后*/</span><span class="token comment" spellcheck="true">// 步骤1：调用dispatchTouchEvent()</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 代表是否会消费事件</span>    <span class="token keyword">boolean</span> consume <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 步骤2：判断是否拦截事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">onInterceptTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// a. 若拦截，则将该事件交给当前View进行处理</span>        <span class="token comment" spellcheck="true">// 即调用onTouchEvent()方法去处理点击事件</span>        consume <span class="token operator">=</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// b. 若不拦截，则将该事件传递到下层</span>        <span class="token comment" spellcheck="true">// 即 下层元素的dispatchTouchEvent()就会被调用，重复上述过程</span>        <span class="token comment" spellcheck="true">// 直到点击事件被最终处理为止</span>        consume <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 步骤3：最终返回通知 该事件是否被消费（接收 &amp; 处理）</span>    <span class="token keyword">return</span> consume<span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="事件分发机制源码分析"><a href="#事件分发机制源码分析" class="headerlink" title="事件分发机制源码分析"></a>事件分发机制源码分析</h2><p>Android 中事件分发顺序：<strong><code>Activity(Window) -&gt; ViewGroup -&gt; View</code></strong>。</p><blockquote><p>即：一个点击事件发生后，事件先传递到 <code>Activity</code>、再传递到 <code>ViewGroup</code>、最终再传递到 <code>View</code>。</p></blockquote><p>因此，要想充分理解 Android 的事件分发机制，本质上是要理解：</p><ol><li><code>Activity</code> 对点击事件的分发机制</li><li><code>ViewGroup</code> 对点击事件的分发机制</li><li><code>View</code> 对点击事件的分发机制</li></ol><h3 id="Activity-的事件分发机制"><a href="#Activity-的事件分发机制" class="headerlink" title="Activity 的事件分发机制"></a>Activity 的事件分发机制</h3><p>当一个点击事件发生时，事件最先传到 <code>Activity</code> 的 <code>dispatchTouchEvent()</code> 方法进行事件分发。</p><blockquote><p>具体是由 <code>Activity</code> 的 <code>Window</code> 来完成。</p></blockquote><h4 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/*** 源码分析：Activity.dispatchTouchEvent()*/</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 一般事件列开始都是DOWN事件(按下事件)，故此处基本是true</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ev<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ->>分析1</span>        <span class="token function">onUserInteraction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ->>分析2</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">getWindow</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">superDispatchTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// ->>分析4</span>    <span class="token keyword">return</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 分析1：onUserInteraction() * 作用：实现屏保功能 * 注意： * a. 该方法为空方法 * b. 当此Activity在栈顶时，触屏点击按home、back、menu键等都会触发此方法 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onUserInteraction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 分析2：getWindow().superDispatchTouchEvent(ev) * 说明： * a. getWindow()就是获取Window类的对象 * b. Window类是抽象类，且PhoneWindow是Window类的唯一实现类；即此处的Window类对象就是PhoneWindow类对象 * c. Window类的superDispatchTouchEvent()是一个抽象方法，由子类PhoneWindow类实现 */</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">superDispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ->> 分析3</span>    <span class="token comment" spellcheck="true">// mDecor是顶层View(DecorView)的实例对象</span>    <span class="token keyword">return</span> mDecor<span class="token punctuation">.</span><span class="token function">superDispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 分析3：mDecor.superDispatchTouchEvent(event) * 定义：属于顶层View(DecorView) * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类就是ViewGroup */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">superDispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 调用父类的方法实际上就是调用ViewGroup的dispatchTouchEvent()方法</span>    <span class="token comment" spellcheck="true">// 即：将事件传递到ViewGroup去处理，详细请看ViewGroup的事件分发机制</span>    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 分析4：Activity.onTouchEvent() * 定义：属于顶层View(DecorView) * 说明： * a. DecorView类是PhoneWindow类的一个内部类 * b. DecorView继承自FrameLayout，是所有界面的父类 * c. FrameLayout是ViewGroup的子类，故DecorView的间接父类就是ViewGroup */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 当一个点击事件未被Activity下任何一个View接收/处理时</span>    <span class="token comment" spellcheck="true">// 应用场景：处理发生在Window边界外的触摸事件</span>    <span class="token comment" spellcheck="true">// ->> 分析5</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mWindow<span class="token punctuation">.</span><span class="token function">shouldCloseOnTouch</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">finish</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 即：只有在点击事件在Window边界外才会返回true，一般情况都返回false，分析完毕</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 分析5：mWindow.shouldCloseOnTouch(this, event) */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">shouldCloseOnTouch</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 主要是对于处理边界外点击事件的判断：是否是DOWN事件，event的坐标是否在边界内等</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mCloseOnTouchOutside <span class="token operator">&amp;&amp;</span> event<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN <span class="token operator">&amp;&amp;</span> <span class="token function">isOutOfBounds</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> event<span class="token punctuation">)</span> <span class="token operator">&amp;&amp;</span> <span class="token function">peekDecorView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 返回true：说明事件在边界外，即 消费事件</span>    <span class="token comment" spellcheck="true">// 返回false：未消费(默认)</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li><p>过程：当一个点击事件发生时，从 Activity 的事件分发开始(Activity.dispatchTouchEvent())<br><img src="https://henleylee.github.io/medias/touch/event_activity_summary_process.png" alt="Activity事件分发的过程"></p></li><li><p>核心方法总结：<br><img src="https://henleylee.github.io/medias/touch/event_activity_summary_mathod.png" alt="Activity事件分发的方法总结"></p></li></ul><h3 id="ViewGroup-的事件分发机制"><a href="#ViewGroup-的事件分发机制" class="headerlink" title="ViewGroup 的事件分发机制"></a>ViewGroup 的事件分发机制</h3><p>从 <code>Activity</code> 事件分发机制可知，<code>ViewGroup</code> 的事件分发机制从 <code>dispatchTouchEvent()</code> 开始。</p><h4 id="源码分析-1"><a href="#源码分析-1" class="headerlink" title="源码分析"></a>源码分析</h4><blockquote><p>Android 5.0 后，ViewGroup.dispatchTouchEvent() 的源码发生了变化(更加复杂)，但原理相同；为了更容易理解，故采用 Android 5.0 前的版本。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 源码分析：ViewGroup.dispatchTouchEvent（） */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 仅贴出关键代码</span>    <span class="token comment" spellcheck="true">// 重点分析1：ViewGroup每次事件分发时，都需调用onInterceptTouchEvent()询问是否拦截事件</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>disallowIntercept <span class="token operator">||</span> <span class="token operator">!</span><span class="token function">onInterceptTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 判断值1：disallowIntercept = 是否禁用事件拦截的功能(默认是false)，可通过调用requestDisallowInterceptTouchEvent()修改</span>        <span class="token comment" spellcheck="true">// 判断值2： !onInterceptTouchEvent(ev) = 对onInterceptTouchEvent()返回值取反</span>        <span class="token comment" spellcheck="true">// a. 若在onInterceptTouchEvent()中返回false（即不拦截事件），就会让第二个值为true，从而进入到条件判断的内部</span>        <span class="token comment" spellcheck="true">// b. 若在onInterceptTouchEvent()中返回true（即拦截事件），就会让第二个值为false，从而跳出了这个条件判断</span>        <span class="token comment" spellcheck="true">// c. 关于onInterceptTouchEvent() ->>分析1</span>        ev<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span>MotionEvent<span class="token punctuation">.</span>ACTION_DOWN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> scrolledXInt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> scrolledXFloat<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> scrolledYInt <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> scrolledYFloat<span class="token punctuation">;</span>        <span class="token keyword">final</span> View<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> mChildren<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> count <span class="token operator">=</span> mChildrenCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 重点分析2：通过for循环，遍历了当前ViewGroup下的所有子View</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> count <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> View child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>mViewFlags <span class="token operator">&amp;</span> VISIBILITY_MASK<span class="token punctuation">)</span> <span class="token operator">==</span> VISIBLE <span class="token operator">||</span> child<span class="token punctuation">.</span><span class="token function">getAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                child<span class="token punctuation">.</span><span class="token function">getHitRect</span><span class="token punctuation">(</span>frame<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment" spellcheck="true">// 判断当前遍历的View是不是正在点击的View，从而找到当前被点击的View</span>                <span class="token comment" spellcheck="true">// 若是，则进入条件判断内部</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>frame<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span>scrolledXInt<span class="token punctuation">,</span> scrolledYInt<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">final</span> <span class="token keyword">float</span> xc <span class="token operator">=</span> scrolledXFloat <span class="token operator">-</span> child<span class="token punctuation">.</span>mLeft<span class="token punctuation">;</span>                    <span class="token keyword">final</span> <span class="token keyword">float</span> yc <span class="token operator">=</span> scrolledYFloat <span class="token operator">-</span> child<span class="token punctuation">.</span>mTop<span class="token punctuation">;</span>                    ev<span class="token punctuation">.</span><span class="token function">setLocation</span><span class="token punctuation">(</span>xc<span class="token punctuation">,</span> yc<span class="token punctuation">)</span><span class="token punctuation">;</span>                    child<span class="token punctuation">.</span>mPrivateFlags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CANCEL_NEXT_UP_EVENT<span class="token punctuation">;</span>                    <span class="token comment" spellcheck="true">// 条件判断的内部调用了该View的dispatchTouchEvent()</span>                    <span class="token comment" spellcheck="true">// 即：实现了点击事件从ViewGroup到子View的传递（具体请看下面的View事件分发机制）</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>child<span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        mMotionTarget <span class="token operator">=</span> child<span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 调用子View的dispatchTouchEvent后是有返回值的</span>                        <span class="token comment" spellcheck="true">// 若该控件可点击，那么点击时，dispatchTouchEvent的返回值必定是true，因此会导致条件判断成立</span>                        <span class="token comment" spellcheck="true">// 于是给ViewGroup的dispatchTouchEvent()直接返回了true，即直接跳出，即把ViewGroup的点击事件拦截掉</span>                        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">boolean</span> isUpOrCancel <span class="token operator">=</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_UP<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>action <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_CANCEL<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>isUpOrCancel<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mGroupFlags <span class="token operator">&amp;=</span> <span class="token operator">~</span>FLAG_DISALLOW_INTERCEPT<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">final</span> View target <span class="token operator">=</span> mMotionTarget<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 重点分析3：若点击的是空白处(即无任何View接收事件)/拦截事件(手动复写onInterceptTouchEvent()，从而让其返回true)</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>target <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ev<span class="token punctuation">.</span><span class="token function">setLocation</span><span class="token punctuation">(</span>xf<span class="token punctuation">,</span> yf<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mPrivateFlags <span class="token operator">&amp;</span> CANCEL_NEXT_UP_EVENT<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ev<span class="token punctuation">.</span><span class="token function">setAction</span><span class="token punctuation">(</span>MotionEvent<span class="token punctuation">.</span>ACTION_CANCEL<span class="token punctuation">)</span><span class="token punctuation">;</span>            mPrivateFlags <span class="token operator">&amp;=</span> <span class="token operator">~</span>CANCEL_NEXT_UP_EVENT<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 调用ViewGroup父类的dispatchTouchEvent()，即View.dispatchTouchEvent()</span>        <span class="token comment" spellcheck="true">// 因此会执行ViewGroup的onTouch() ->> onTouchEvent() ->> performClick() ->> onClick()，即自己处理该事件，事件不会往下传递</span>        <span class="token comment" spellcheck="true">// 具体请参考View事件的分发机制中的View.dispatchTouchEvent()</span>        <span class="token comment" spellcheck="true">// 此处需与上面区别：子View的dispatchTouchEvent()</span>        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>ev<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 分析1：ViewGroup.onInterceptTouchEvent() * 作用：是否拦截事件 * 说明： * a. 返回true表示拦截，即事件停止往下传递(需手动设置，即复写onInterceptTouchEvent()，从而让其返回true) * b. 返回false表示不拦截(默认) */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onInterceptTouchEvent</span><span class="token punctuation">(</span>MotionEvent ev<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>ev<span class="token punctuation">.</span><span class="token function">isFromSource</span><span class="token punctuation">(</span>InputDevice<span class="token punctuation">.</span>SOURCE_MOUSE<span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> ev<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN            <span class="token operator">&amp;&amp;</span> ev<span class="token punctuation">.</span><span class="token function">isButtonPressed</span><span class="token punctuation">(</span>MotionEvent<span class="token punctuation">.</span>BUTTON_PRIMARY<span class="token punctuation">)</span>            <span class="token operator">&amp;&amp;</span> <span class="token function">isOnScrollbarThumb</span><span class="token punctuation">(</span>ev<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> ev<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h4><ul><li>结论：Android 事件分发总是先传递到 <code>ViewGroup</code>、再传递到 <code>View</code>。</li><li><p>过程：当点击了某个控件时<br><img src="https://henleylee.github.io/medias/touch/event_viewgroup_summary_process.png" alt="ViewGroup事件分发的过程"></p></li><li><p>核心方法总结：<br><img src="https://henleylee.github.io/medias/touch/event_viewgroup_summary_mathod.png" alt="ViewGroup事件分发的方法总结"></p></li></ul><h3 id="View-的事件分发机制"><a href="#View-的事件分发机制" class="headerlink" title="View 的事件分发机制"></a>View 的事件分发机制</h3><p>从 <code>ViewGroup</code> 事件分发机制知道，<code>View</code> 事件分发机制从 <code>dispatchTouchEvent()</code> 开始。</p><h4 id="源码分析-2"><a href="#源码分析-2" class="headerlink" title="源码分析"></a>源码分析</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 源码分析：View.dispatchTouchEvent() */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">dispatchTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 说明：只有以下3个条件都为真，dispatchTouchEvent()才返回true；否则执行onTouchEvent()</span>    <span class="token comment" spellcheck="true">// 条件1. mOnTouchListener != null</span>    <span class="token comment" spellcheck="true">// 条件2. (mViewFlags &amp; ENABLED_MASK) == ENABLED</span>    <span class="token comment" spellcheck="true">// 条件3. mOnTouchListener.onTouch(this, event)</span>    ListenerInfo li <span class="token operator">=</span> mListenerInfo<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>li <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> li<span class="token punctuation">.</span>mOnTouchListener <span class="token operator">!=</span> null            <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mViewFlags <span class="token operator">&amp;</span> ENABLED_MASK<span class="token punctuation">)</span> <span class="token operator">==</span> ENABLED            <span class="token operator">&amp;&amp;</span> li<span class="token punctuation">.</span>mOnTouchListener<span class="token punctuation">.</span><span class="token function">onTouch</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 条件1：mOnTouchListener != null * 说明：mOnTouchListener变量在View.setOnTouchListener()方法里赋值 */</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setOnTouchListener</span><span class="token punctuation">(</span>OnTouchListener l<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 即只要我们给控件注册了Touch事件，mOnTouchListener就一定被赋值(不为空)</span>    <span class="token function">getListenerInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>mOnTouchListener <span class="token operator">=</span> l<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 条件2：(mViewFlags &amp; ENABLED_MASK) == ENABLED * 说明： * a. 该条件是判断当前点击的控件是否enable * b. 由于很多View默认enable，故该条件恒定为true */</span> <span class="token comment" spellcheck="true">/** * 条件3：mOnTouchListener.onTouch(this, event) * 说明：即 回调控件注册Touch事件时的onTouch（）；需手动复写设置，具体如下（以按钮Button为例） */</span>button<span class="token punctuation">.</span><span class="token function">setOnTouchListener</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">OnTouchListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onTouch</span> <span class="token punctuation">(</span>View v<span class="token punctuation">,</span> MotionEvent event<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 若在onTouc()返回true，就会让上述三个条件全部成立，从而使得View.dispatchTouchEvent()直接返回true，事件分发结束</span><span class="token comment" spellcheck="true">// 若在onTouch()返回false，就会使得上述三个条件不全部成立，从而使得View.dispatchTouchEvent()中跳出if，执行onTouchEvent(event)</span></code></pre><p>接下来，继续进行 onTouchEvent(event) 的源码分析：</p><blockquote><p>Android 5.0 后 View.onTouchEvent() 源码发生了变化(更加复杂)，但原理相同；为了更容易理解，故采用 Android 5.0 前的版本。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 源码分析：View.onTouchEvent() */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">final</span> <span class="token keyword">int</span> viewFlags <span class="token operator">=</span> mViewFlags<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> ENABLED_MASK<span class="token punctuation">)</span> <span class="token operator">==</span> DISABLED<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> CLICKABLE<span class="token punctuation">)</span> <span class="token operator">==</span> CLICKABLE <span class="token operator">||</span> <span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> LONG_CLICKABLE<span class="token punctuation">)</span> <span class="token operator">==</span> LONG_CLICKABLE<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mTouchDelegate <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mTouchDelegate<span class="token punctuation">.</span><span class="token function">onTouchEvent</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 若该控件可点击，则进入switch判断中</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> CLICKABLE<span class="token punctuation">)</span> <span class="token operator">==</span> CLICKABLE <span class="token operator">||</span> <span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> LONG_CLICKABLE<span class="token punctuation">)</span> <span class="token operator">==</span> LONG_CLICKABLE<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// a. 若当前的事件 = 抬起View(主要分析)</span>            <span class="token keyword">case</span> MotionEvent<span class="token punctuation">.</span>ACTION_UP<span class="token operator">:</span>                <span class="token keyword">boolean</span> prepressed <span class="token operator">=</span> <span class="token punctuation">(</span>mPrivateFlags <span class="token operator">&amp;</span> PREPRESSED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>                    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment" spellcheck="true">// 经过种种判断，此处省略</span>                <span class="token comment" spellcheck="true">// 执行performClick() ->>分析1</span>                <span class="token function">performClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// b. 若当前的事件 = 按下View</span>            <span class="token keyword">case</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN<span class="token operator">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mPendingCheckForTap <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    mPendingCheckForTap <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">CheckForTap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                mPrivateFlags <span class="token operator">|=</span> PREPRESSED<span class="token punctuation">;</span>                mHasPerformedLongPress <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token function">postDelayed</span><span class="token punctuation">(</span>mPendingCheckForTap<span class="token punctuation">,</span> ViewConfiguration<span class="token punctuation">.</span><span class="token function">getTapTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// c. 若当前的事件 = 结束事件(非人为原因)</span>            <span class="token keyword">case</span> MotionEvent<span class="token punctuation">.</span>ACTION_CANCEL<span class="token operator">:</span>                mPrivateFlags <span class="token operator">&amp;=</span> <span class="token operator">~</span>PRESSED<span class="token punctuation">;</span>                <span class="token function">refreshDrawableState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token function">removeTapCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// d. 若当前的事件 = 滑动View</span>            <span class="token keyword">case</span> MotionEvent<span class="token punctuation">.</span>ACTION_MOVE<span class="token operator">:</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> event<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> event<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">int</span> slop <span class="token operator">=</span> mTouchSlop<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>x <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">-</span> slop<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>x <span class="token operator">>=</span> <span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> slop<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>y <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">-</span> slop<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token punctuation">(</span>y <span class="token operator">>=</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> slop<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// Outside button</span>                    <span class="token function">removeTapCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>mPrivateFlags <span class="token operator">&amp;</span> PRESSED<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment" spellcheck="true">// Remove any future long press/tap checks</span>                        <span class="token function">removeLongPressCallback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// Need to switch from pressed to not pressed</span>                        mPrivateFlags <span class="token operator">&amp;=</span> <span class="token operator">~</span>PRESSED<span class="token punctuation">;</span>                        <span class="token function">refreshDrawableState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 若该控件可点击，就一定返回true</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// 若该控件不可点击，就一定返回false</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * 分析1：performClick() */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">performClick</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mOnClickListener <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">playSoundEffect</span><span class="token punctuation">(</span>SoundEffectConstants<span class="token punctuation">.</span>CLICK<span class="token punctuation">)</span><span class="token punctuation">;</span>        mOnClickListener<span class="token punctuation">.</span><span class="token function">onClick</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 只要我们通过setOnClickListener()为控件View注册1个点击事件</span>        <span class="token comment" spellcheck="true">// 那么就会给mOnClickListener变量赋值（即不为空）</span>        <span class="token comment" spellcheck="true">// 则会往下回调onClick()并且performClick()返回true</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h4 id="总结-3"><a href="#总结-3" class="headerlink" title="总结"></a>总结</h4><ul><li><p>过程：每当控件被点击时<br><img src="https://henleylee.github.io/medias/touch/event_view_summary_process.png" alt="View事件分发的过程"></p></li><li><p>核心方法总结：<br><img src="https://henleylee.github.io/medias/touch/event_view_summary_mathod.png" alt="View事件分发的方法总结"></p></li></ul><h2 id="事件分发工作流程总结"><a href="#事件分发工作流程总结" class="headerlink" title="事件分发工作流程总结"></a>事件分发工作流程总结</h2><p><img src="https://henleylee.github.io/medias/touch/event_process_summary.png" alt="事件分发工作流程总结"></p><blockquote><p>左侧虚线：具备相关性 &amp; 逐层返回</p></blockquote><h3 id="以角色为核心的图解说明"><a href="#以角色为核心的图解说明" class="headerlink" title="以角色为核心的图解说明"></a>以角色为核心的图解说明</h3><p><img src="https://henleylee.github.io/medias/touch/event_process_summary_role.png" alt="以角色为核心的事件分发工作流程图解说明"></p><h3 id="以方法为核心的图解说明"><a href="#以方法为核心的图解说明" class="headerlink" title="以方法为核心的图解说明"></a>以方法为核心的图解说明</h3><p><img src="https://henleylee.github.io/medias/touch/event_process_summary_method.png" alt="以方法为核心的事件分发工作流程图解说明"></p><h2 id="事件分发额外知识"><a href="#事件分发额外知识" class="headerlink" title="事件分发额外知识"></a>事件分发额外知识</h2><h3 id="onTouch-和-onTouchEvent-的区别"><a href="#onTouch-和-onTouchEvent-的区别" class="headerlink" title="onTouch() 和 onTouchEvent() 的区别"></a>onTouch() 和 onTouchEvent() 的区别</h3><ul><li>这两个方法都是在 <code>View.dispatchTouchEvent()</code> 中调用；</li><li>但 <code>onTouch()</code> 优先于 <code>onTouchEvent()</code> 执行；若手动复写在 <code>onTouch()</code> 中返回 <code>true</code>(即：将事件消费掉)，将不会再执行 <code>onTouchEvent()</code>。</li></ul><blockquote><p>注意：若一个控件不可点击(即非enable)，那么给它注册 <code>onTouch()</code> 事件将永远得不到执行，对于该类控件，若需监听它的 touch 事件，就必须通过在该控件中重写 <code>onTouchEvent()</code> 方法来实现，具体原因看如下代码：</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// &amp;&amp;为短路与，即如果前面条件为false，将不再往下执行，故：onTouch() 能够得到执行需2个前提条件：</span><span class="token comment" spellcheck="true">// 1. mOnTouchListener的值不能为空</span><span class="token comment" spellcheck="true">// 2. 当前点击的控件必须是enable的</span>mOnTouchListener <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token punctuation">(</span>mViewFlags <span class="token operator">&amp;</span> ENABLED_MASK<span class="token punctuation">)</span> <span class="token operator">==</span> ENABLED <span class="token operator">&amp;&amp;</span> mOnTouchListener<span class="token punctuation">.</span><span class="token function">onTouch</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> event<span class="token punctuation">)</span></code></pre><h3 id="Touch-事件的后续事件-MOVE、UP-层级传递"><a href="#Touch-事件的后续事件-MOVE、UP-层级传递" class="headerlink" title="Touch 事件的后续事件(MOVE、UP)层级传递"></a>Touch 事件的后续事件(MOVE、UP)层级传递</h3><ul><li>如果给控件注册了 <code>Touch</code> 事件，每次点击都会触发一系列 <code>action</code> 事件(ACTION_DOWN、ACTION_MOVE、ACTION_UP 等)；</li><li>当 <code>dispatchTouchEvent()</code> 在进行事件分发的时候，只有前一个事件(如 ACTION_DOWN)返回 <code>true</code>，才会收到后一个事件(ACTION_MOVE 和 ACTION_UP)；<blockquote><p>即如果在执行 ACTION_DOWN 时返回 false，后面一系列的 ACTION_MOVE 和 ACTION_UP 事件都不会执行。</p></blockquote></li></ul><p>从上面对事件分发机制分析知：</p><ul><li><code>dispatchTouchEvent()</code> 和 <code>onTouchEvent()</code> 消费事件、终结事件传递(返回 true)；</li><li>而 <code>onInterceptTouchEvent()</code> 并不能消费事件，它相当于是一个分叉口起到分流导流的作用，对后续的 ACTION_MOVE 和 ACTION_UP 事件接收起到非常大的作用。<blockquote><p>注意：接收了 ACTION_DOWN 事件的函数不一定能收到后续事件(ACTION_MOVE、ACTION_UP)。</p></blockquote></li></ul><p>ACTION_MOVE 和 ACTION_UP 事件的传递结论：</p><ul><li><p>结论1：若对象(Activity、ViewGroup、View)的 <code>dispatchTouchEvent()</code> 方法分发事件后消费了事件(返回 true)，那么收到 ACTION_DOWN 的函数也能收到 ACTION_MOVE 和 ACTION_UP；</p><blockquote><p><img src="https://henleylee.github.io/medias/touch/event_action_conclusion_1.png" alt="ACTION_MOVE和ACTION_UP事件的传递结论1"><br>黑线：ACTION_DOWN 事件传递方向<br>红线：ACTION_MOVE、ACTION_UP 事件传递方向</p></blockquote></li><li><p>结论2：若对象(Activity、ViewGroup、View)的 <code>onTouchEvent()</code> 方法处理了事件(返回 true)，那么 ACTION_MOVE、ACTION_UP 的事件从上往下传到该 <code>View</code> 后就不再往下传递，而是直接传给自己的 <code>onTouchEvent()</code> 方法并结束本次事件传递过程。</p><blockquote><p><img src="https://henleylee.github.io/medias/touch/event_action_conclusion_2.png" alt="ACTION_MOVE和ACTION_UP事件的传递结论2"><br>黑线：ACTION_DOWN 事件传递方向<br>红线：ACTION_MOVE、ACTION_UP 事件传递方向</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 手势检测之 GestureDetector</title>
      <link href="/posts/2019/da8b8b2f.html"/>
      <url>/posts/2019/da8b8b2f.html</url>
      
        <content type="html"><![CDATA[<p>当用户触摸屏幕的时候，会产生许多手势，例如 down、up、scroll，filing 等等。</p><p>一般情况下，我们知道 <code>View</code> 类有个 <code>View.OnTouchListener</code> 内部接口，通过重写它的 <code>onTouch(View v, MotionEvent event)</code> 方法，可以处理一些触摸事件，但是这个方法太过简单，如果需要处理一些复杂的手势，用这个接口就会很麻烦(比如需要根据用户触摸的轨迹去判断是什么手势)。</p><p>Android SDK 提供了 <code>GestureDetector</code> 类来帮助开发者识别一些基本的触摸手势，主要是通过它的 <code>onTouchEvent(event)</code> 方法完成了不同手势的识别。虽然它能识别手势，但是不同的手势要怎么处理，应该是提供给程序员实现的。</p><h2 id="GestureDetector-介绍"><a href="#GestureDetector-介绍" class="headerlink" title="GestureDetector 介绍"></a>GestureDetector 介绍</h2><p>Detector 的意思就是探测者，所以 <code>GestureDetector</code> 就是用来监听手势的发生。<code>GestureDetector</code> 类对外提供了三个接口：<code>OnGestureListener</code>、<code>OnDoubleTapListener</code>、<code>OnContextClickListener</code>，用来回调不同类型的触摸事件。<code>GestureDetector</code> 的类图如下如所示：<br><img src="https://henleylee.github.io/medias/view/view_gesture_detector.png" alt="GestureDetector类图"></p><p><code>GestureDetector</code> 类里这些接口的方法，就是相应触摸事件的回调，实现了这些方法，就能实现传入触摸事件之后做出相应的回调。<code>GestureDetector</code> 还有一个内部类 <code>SimpleOnGestureListener</code>，实现了这三个接口。</p><h3 id="OnGestureListener"><a href="#OnGestureListener" class="headerlink" title="OnGestureListener"></a>OnGestureListener</h3><p><strong><code>OnGestureListener</code></strong> 接口主要用于手势检测，有以下类型事件：按下(Down)、触摸反馈(ShowPress)、长按(LongPress)、单击抬起(SingleTapUp)、滚动(Scroll)、抛(Fling)。<code>OnGestureListener</code> 接口包含以下方法：</p><ul><li><strong><code>boolean onDown(MotionEvent e)：</code></strong>用户按下屏幕就会触发。</li><li><strong><code>void onShowPress(MotionEvent e)：</code></strong>用户按下屏幕后100ms(Android 源码)还没有松开或者移动就会触发，官方在源码的解释是说一般用于告诉用户已经识别按下事件的回调。</li><li><strong><code>void onLongPress(MotionEvent e)：</code></strong>用户按下屏幕一定时间后(源码里默认是100ms+500ms)触发，触发之后不会触发其他回调，直至松开(UP事件)。 </li><li><strong><code>boolean onSingleTapUp(MotionEvent e)：</code></strong>用户手指松开(UP事件)的时候如果没有执行 onScroll() 和 onLongPress() 这两个回调的话，就会触发，说明这是一个点击抬起事件，但是不能区分是否双击事件的抬起。</li><li><strong><code>boolean onScroll(MotionEvent e1, MotionEvent e2, float distanceX, float distanceY)：</code></strong>手指滑动时就会触发(接收到 MOVE 事件，且位移大于一定距离)，e1、e2 分别是之前 DOWN 事件和当前的 MOVE 事件，distanceX 和 distanceY 分别表示自上次调用 onScroll() 以来，沿 X、Y 轴滑动的距离。 </li><li><strong><code>boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY)：</code></strong>用户按下屏幕执行抛操作之后的回调，MOVE 事件之后手松开(UP 事件)瞬间的 X 或者 Y 方向速度，如果达到一定数值(源码默认是每秒50px)，就是抛操作(也就是快速滑动的时候松手会有这个回调，因此基本上有 onFling() 必然有 onScroll())。</li></ul><h3 id="OnDoubleTapListener"><a href="#OnDoubleTapListener" class="headerlink" title="OnDoubleTapListener"></a>OnDoubleTapListener</h3><p><strong><code>OnDoubleTapListener</code></strong> 接口主要用于监听监听单击和双击事件，有以下类型事件：双击(DoubleTap)、单击确认(SingleTapConfirmed) 和 双击事件回调(DoubleTapEvent)。<code>OnDoubleTapListener</code> 接口包含以下方法：</p><ul><li><strong><code>boolean onSingleTapConfirmed(MotionEvent e)：</code></strong>当单击事件发生时(确认为单击事件而非双击事件)触发。</li><li><strong><code>boolean onDoubleTap(MotionEvent e)：</code></strong>当双击事件发生时触发。</li><li><strong><code>boolean onDoubleTapEvent(MotionEvent e)：</code></strong>onDoubleTap() 回调之后的输入事件(DOWN、MOVE、UP)都会触发这个方法(该方法可以实现一些双击后的控制，如让 View 双击后变得可拖动等)。</li></ul><h3 id="OnContextClickListener"><a href="#OnContextClickListener" class="headerlink" title="OnContextClickListener"></a>OnContextClickListener</h3><p><strong><code>OnContextClickListener</code></strong> 接口主要用于检测外部设备上的按钮是否按下，它是在 Android 6.0(API 23)才添加的一个接口。<code>OnContextClickListener</code> 接口包含以下方法：</p><ul><li><strong><code>boolean onContextClick(MotionEvent e)：</code></strong>外部设备上的按钮被按下就会触发。</li></ul><h3 id="SimpleOnGestureListener"><a href="#SimpleOnGestureListener" class="headerlink" title="SimpleOnGestureListener"></a>SimpleOnGestureListener</h3><p><strong><code>SimpleOnGestureListener</code></strong> 类是上述三个接口的空实现，一般情况下使用这个比较多，也比较方便。</p><h2 id="GestureDetector-使用"><a href="#GestureDetector-使用" class="headerlink" title="GestureDetector 使用"></a>GestureDetector 使用</h2><p><strong><code>GestureDetector</code></strong> 可以使用 <code>MotionEvent</code> 检测各种手势和事件。<code>GestureDetector.OnGestureListener</code> 回调将在特定的事件发生时通知用户。这个类只能用于检测触摸事件的 MotionEvent，不能用于轨迹球事件。 </p><h3 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h3><p>使用 <code>GestureDetector</code> 需要以下几个步骤：</p><ul><li>为 <code>View</code> 创建一个 <code>GestureDetector</code> 实例。</li><li>在  <code>View</code> 的 <code>onTouchEvent(MotionEvent ev)</code> 方法中，确保调用 <code>GestureDetector</code> 的 <code>onTouchEvent(MotionEvent ev)</code> 方法。回调中定义的方法将在事件发生时执行。</li><li>如果侦听 <code>onContextClick(MotionEvent ev)</code>，则必须在 <code>View</code> 的 <code>onGenericMotionEvent(MotionEvent ev)</code> 方法中调用 <code>GestureDetector</code> 的 <code>onGenericMotionEvent(MotionEvent ev)</code> 方法。</li></ul><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>GestureDetector</code> 一共有 5 种构造函数，但有 2 种被废弃了，1 种是重复的，所以只需要关注其中的 2 种构造函数即可，如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">GestureDetector</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> OnGestureListener listener<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">GestureDetector</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> OnGestureListener listener<span class="token punctuation">,</span> Handler handler<span class="token punctuation">)</span></code></pre><p>第 1 种构造函数里面需要传递两个参数，<code>Context</code>(上下文)和 <code>OnGestureListener</code>(手势监听器)，这个很容易理解，也是最经常使用的一种。</p><p>第 2 种构造函数则需要多传递一个 <code>Handler</code> 作为参数，这个有什么作用呢？其实作用也非常简单，这个 <code>Handler</code> 主要是为了给 <code>GestureDetector</code> 提供一个 <code>Looper</code>。</p><blockquote><p>在通常情况下是不需这个 <code>Handler</code> 的，因为它会在内部自动创建一个 <code>Handler</code> 用于处理数据，如果在主线程中创建 <code>GestureDetector</code>，那么它内部创建的 <code>Handler</code> 会自动获得主线程的 <code>Looper</code>，然而如果在一个没有创建 <code>Looper</code> 的子线程中创建 <code>GestureDetector</code> 则需要传递一个带有 <code>Looper</code> 的 <code>Handler</code> 给它，否则就会因为无法获取到 <code>Looper</code> 导致创建失败。<strong><code>重点是传递的 Handler 一定要有 Looper，重点是 Looper，而非 Handler</code></strong>。</p></blockquote><p>在没有 <code>Looper</code> 的地方使用 <code>GestureDetector</code> 时可以通过以下方法：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 方法一：在主线程创建 Handler，使用第 2 种构造方法进行创建</span><span class="token keyword">final</span> Handler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> GestureDetector detector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GestureDetector</span><span class="token punctuation">(</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">GestureDetector<span class="token punctuation">.</span>SimpleOnGestureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ... 省略其它代码 ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方法二：在子线程创建 Handler，并且指定 Looper，使用第 2 种构造方法进行创建</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Handler handler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span>Looper<span class="token punctuation">.</span><span class="token function">getMainLooper</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> GestureDetector detector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GestureDetector</span><span class="token punctuation">(</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">GestureDetector<span class="token punctuation">.</span>SimpleOnGestureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ... 省略其它代码 ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 方法三：子线程准备了 Looper，那么可以直接使用第 1 种构造方法进行创建</span><span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Looper<span class="token punctuation">.</span><span class="token function">prepare</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 初始化Looper(重点)</span>        <span class="token keyword">final</span> GestureDetector detector <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">GestureDetector</span><span class="token punctuation">(</span><span class="token function">getContext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">GestureDetector<span class="token punctuation">.</span>SimpleOnGestureListener</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// ... 省略其它代码 ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="相关方法"><a href="#相关方法" class="headerlink" title="相关方法"></a>相关方法</h3><p><code>GestureDetector</code> 中除了各类监听器之外，与 <code>GestureDetector</code> 相关的方法其实并不多，只有以下几个：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td>void setIsLongpressEnabled(boolean isLongpressEnabled)</td><td>通过布尔值设置是否允许触发长按事件，true 表示允许，false 表示不允许</td></tr><tr><td>boolean isLongpressEnabled()</td><td>判断当前是否允许触发长按事件，true 表示允许，false 表示不允许</td></tr><tr><td>boolean onTouchEvent(MotionEvent ev)</td><td>这个是其中一个重要的方法，在最开始已经演示过使用方式了</td></tr><tr><td>boolean onGenericMotionEvent(MotionEvent ev)</td><td>这个是在 API 23 之后才添加的内容，主要是为 OnContextClickListener 服务的，暂时不用关注</td></tr><tr><td>void setOnDoubleTapListener(OnDoubleTapListener listener)</td><td>设置 OnDoubleTapListener</td></tr><tr><td>void setContextClickListener(OnContextClickListener listener)</td><td>设置 ContextClickListener</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自定义 View 之 Draw</title>
      <link href="/posts/2019/98a748f6.html"/>
      <url>/posts/2019/98a748f6.html</url>
      
        <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在自定义 View 过程中，Draw 的主要作用就是<strong><code>绘制 View 视图</code></strong>。</p><blockquote><p>绘制 View 视图就是绘制 <code>View</code> 自身和装饰：背景、内容、滚动指示器、滚动条、和前景等。</p></blockquote><h2 id="draw-过程详解"><a href="#draw-过程详解" class="headerlink" title="draw 过程详解"></a>draw 过程详解</h2><p><strong><code>draw</code></strong> 过程根据 View 的类型分为以下两种情况：</p><ul><li><strong><code>单一 View：</code></strong>仅绘制 <code>View</code> 自身。</li><li><strong><code>ViewGroup：</code></strong>除了绘制 <code>View</code> 自身外，还需要绘制父容器中的其它所有子 <code>View</code>(遍历调用所有子元素的 <code>draw()</code> 和各子元素再递归去执行该流程)。</li></ul><h3 id="单一-View-的-draw-过程"><a href="#单一-View-的-draw-过程" class="headerlink" title="单一 View 的 draw 过程"></a>单一 View 的 draw 过程</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在没有现成的控件 View 满足需求、需自己实现时，则使用自定义单一 View。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>继承自 <code>View</code>、<code>SurfaceView</code> 或 其他 <code>View</code>；<code>不包含子 View</code>。</p><h4 id="绘制原理"><a href="#绘制原理" class="headerlink" title="绘制原理"></a>绘制原理</h4><p>绘制 View 视图一般分为2个步骤：</p><ol><li>View 绘制自身(含背景、内容)；</li><li>绘制装饰(滚动指示器、滚动条、和前景)。</li></ol><h4 id="绘制流程"><a href="#绘制流程" class="headerlink" title="绘制流程"></a>绘制流程</h4><p><img src="https://henleylee.github.io//medias/view/view_draw_single.png" alt="单一View的draw过程"></p><p>下面将 <code>draw</code> 过程中的方法进行详细分析：<code>draw</code> 过程入口为 <code>draw()</code></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 源码分析：draw()     * &lt;p>     * 作用：根据给定的 Canvas 自动渲染 View(包括其所有子 View)     * &lt;p>     * 绘制过程：     * 1. 绘制 View 背景     * 2. 绘制 View 内容     * 3. 绘制子 View     * 4. 绘制装饰(渐变框，滑动条等等)     * &lt;p>     * 注：     * a. 在调用该方法之前必须要完成 layout 过程     * b. 所有的视图最终都是调用 View 的 draw() 绘制视图(ViewGroup 没有复写此方法)     * c. 在自定义 View 时，不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制     * d. 若自定义的视图确实要复写该方法，那么需先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制     *     * @param canvas 渲染视图的画布     */</span>    <span class="token annotation punctuation">@CallSuper</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">/**         * 绘制遍历执行几个绘制步骤，必须以适当的顺序执行：         * 1.绘制背景         * 2.如有必要，保存画布的图层以备复原图层         * 3.绘制视图的内容         * 4.绘制子视图         * 5.如有必要，绘制淡化边缘并恢复图层         * 6.绘制装饰(例如滚动条)         */</span>        <span class="token keyword">int</span> saveCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤1： 绘制View本身的背景</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dirtyOpaque<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">drawBackground</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 若有必要，则保存图层(还有一个复原图层)</span>        <span class="token comment" spellcheck="true">// 优化技巧：当不需绘制 Layer 时，可以跳过“保存图层”和“复原图层”这两步</span>        <span class="token comment" spellcheck="true">// 因此在绘制时，节省 layer 可以提高绘制效率</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> viewFlags <span class="token operator">=</span> mViewFlags<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> horizontalEdges <span class="token operator">=</span> <span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> FADING_EDGE_HORIZONTAL<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> verticalEdges <span class="token operator">=</span> <span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> FADING_EDGE_VERTICAL<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>verticalEdges <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>horizontalEdges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 步骤3：绘制View本身的内容(View和ViewGroup中默认为空实现，需复写)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dirtyOpaque<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">onDraw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 步骤4：绘制子View</span>            <span class="token comment" spellcheck="true">// 由于单一View无子View，故View 中：默认为空实现</span>            <span class="token comment" spellcheck="true">// ViewGroup中：系统已经复写好对其子视图进行绘制我们不需要复写</span>            <span class="token function">dispatchDraw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">drawAutofilledHighlight</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 叠加层是视图内容的一部分，需要在前景下方绘制</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mOverlay <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mOverlay<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                mOverlay<span class="token punctuation">.</span><span class="token function">getOverlayView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dispatchDraw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 步骤6：绘制装饰(前景、滚动条等)</span>            <span class="token function">onDrawForeground</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 步骤7：绘制默认焦点高亮显示</span>            <span class="token function">drawDefaultFocusHighlight</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">debugDraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">debugDrawFocus</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>下面，继续分析在 <code>draw()</code> 中4个步骤调用的 <code>drawBackground()</code>、<code>onDraw()</code>、<code>dispatchDraw()</code>、<code>onDrawForeground()</code> 等方法：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 步骤1：drawBackground(canvas)     * &lt;p>     * 作用：绘制 View 本身的背景     *     * @param canvas 画布     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">drawBackground</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取背景Drawable</span>        <span class="token keyword">final</span> Drawable background <span class="token operator">=</span> mBackground<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>background <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 根据在 layout 过程中获取的 View 的位置参数，来设置背景的边界</span>        <span class="token function">setBackgroundBounds</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 获取 mScrollX 和 mScrollY值</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> scrollX <span class="token operator">=</span> mScrollX<span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> scrollY <span class="token operator">=</span> mScrollY<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>scrollX <span class="token operator">|</span> scrollY<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            background<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 若 mScrollX 和 mScrollY 有值，则对 canvas 的坐标进行偏移</span>            canvas<span class="token punctuation">.</span><span class="token function">translate</span><span class="token punctuation">(</span>scrollX<span class="token punctuation">,</span> scrollY<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用 Drawable 的 draw 方法绘制背景</span>            background<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            canvas<span class="token punctuation">.</span><span class="token function">translate</span><span class="token punctuation">(</span><span class="token operator">-</span>scrollX<span class="token punctuation">,</span> <span class="token operator">-</span>scrollY<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 步骤3：onDraw(canvas)     * &lt;p>     * 作用：绘制 View 本身的内容     * &lt;p>     * 注：     * a. 由于 View 的内容各不相同，所以该方法是一个空实现     * b. 在自定义绘制过程中，需由子类去实现复写该方法，从而绘制自身的内容     * c. 谨记：自定义 View 中必须且只需复写 onDraw() 方法     *     * @param canvas 画布     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onDraw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 复写该方法从而实现绘制逻辑</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 步骤4：dispatchDraw(canvas)     * &lt;p>     * 作用：绘制子 View     * &lt;p>     * 注：由于单一View中无子View，故为空实现     *     * @param canvas 画布     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">dispatchDraw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 空实现</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 步骤6： onDrawForeground(canvas)     * &lt;p>     * 作用：绘制装饰(滚动指示器、滚动条、前景等)     *     * @param canvas 画布     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onDrawForeground</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 绘制滚动指示器</span>        <span class="token function">onDrawScrollIndicators</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 绘制滚动条</span>        <span class="token function">onDrawScrollBars</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取前景Drawable</span>        <span class="token keyword">final</span> Drawable foreground <span class="token operator">=</span> mForegroundInfo <span class="token operator">!=</span> null <span class="token operator">?</span> mForegroundInfo<span class="token punctuation">.</span>mDrawable <span class="token operator">:</span> null<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 绘制前景</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>foreground <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mForegroundInfo<span class="token punctuation">.</span>mBoundsChanged<span class="token punctuation">)</span> <span class="token punctuation">{</span>                mForegroundInfo<span class="token punctuation">.</span>mBoundsChanged <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>                <span class="token keyword">final</span> Rect selfBounds <span class="token operator">=</span> mForegroundInfo<span class="token punctuation">.</span>mSelfBounds<span class="token punctuation">;</span>                <span class="token keyword">final</span> Rect overlayBounds <span class="token operator">=</span> mForegroundInfo<span class="token punctuation">.</span>mOverlayBounds<span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>mForegroundInfo<span class="token punctuation">.</span>mInsidePadding<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    selfBounds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                    selfBounds<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token function">getPaddingLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getPaddingTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                            <span class="token function">getWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getPaddingRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token function">getPaddingBottom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">final</span> <span class="token keyword">int</span> ld <span class="token operator">=</span> <span class="token function">getLayoutDirection</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                Gravity<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>mForegroundInfo<span class="token punctuation">.</span>mGravity<span class="token punctuation">,</span> foreground<span class="token punctuation">.</span><span class="token function">getIntrinsicWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span>                        foreground<span class="token punctuation">.</span><span class="token function">getIntrinsicHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> selfBounds<span class="token punctuation">,</span> overlayBounds<span class="token punctuation">,</span> ld<span class="token punctuation">)</span><span class="token punctuation">;</span>                foreground<span class="token punctuation">.</span><span class="token function">setBounds</span><span class="token punctuation">(</span>overlayBounds<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            foreground<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://henleylee.github.io//medias/view/view_draw_single_all.png" alt="单一View的draw过程总结"></p><h3 id="ViewGroup-的-draw-过程"><a href="#ViewGroup-的-draw-过程" class="headerlink" title="ViewGroup 的 draw 过程"></a>ViewGroup 的 draw 过程</h3><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>利用现有的组件根据特定的布局方式来组成新的组件。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>继承自 <code>ViewGroup</code> 或各种 <code>Layout</code>；<code>包含子 View</code>。</p><h4 id="绘制原理-1"><a href="#绘制原理-1" class="headerlink" title="绘制原理"></a>绘制原理</h4><p>绘制 ViewGroup 视图一般分为2个步骤：</p><ol><li>ViewGroup 绘制自身(含背景、内容)；</li><li>ViewGroup 遍历其所有子 View 并绘制其所有子 View。</li></ol><p><img src="https://henleylee.github.io//medias/view/view_group_tree.png" alt="ViewGroup自上而下遍历"></p><h4 id="绘制流程-1"><a href="#绘制流程-1" class="headerlink" title="绘制流程"></a>绘制流程</h4><p><img src="https://henleylee.github.io//medias/view/view_draw_group.png" alt="ViewGroup的draw过程"><br><code>ViewGroup</code> 和 <code>View</code> 同样拥有 <code>draw()</code> 和 <code>ondraw()</code>，但二者不同的：</p><p>下面将 <code>draw</code> 过程中的方法进行详细分析：<code>draw</code> 过程入口为 <code>draw()</code></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 源码分析：draw()     * &lt;p>     * 作用：根据给定的 Canvas 自动渲染 View(包括其所有子 View)     * &lt;p>     * 绘制过程：     * 1. 绘制 View 背景     * 2. 绘制 View 内容     * 3. 绘制子 View     * 4. 绘制装饰(渐变框，滑动条等等)     * &lt;p>     * 注：     * a. 在调用该方法之前必须要完成 layout 过程     * b. 所有的视图最终都是调用 View 的 draw() 绘制视图(ViewGroup 没有复写此方法)     * c. 在自定义 View 时，不应该复写该方法，而是复写 onDraw(Canvas) 方法进行绘制     * d. 若自定义的视图确实要复写该方法，那么需先调用 super.draw(canvas)完成系统的绘制，然后再进行自定义的绘制     *     * @param canvas 渲染视图的画布     */</span>    <span class="token annotation punctuation">@CallSuper</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">draw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">/**         * 绘制遍历执行几个绘制步骤，必须以适当的顺序执行：         * 1.绘制背景         * 2.如有必要，保存画布的图层以备复原图层         * 3.绘制视图的内容         * 4.绘制子视图         * 5.如有必要，绘制淡化边缘并恢复图层         * 6.绘制装饰(例如滚动条)         */</span>        <span class="token keyword">int</span> saveCount<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 步骤1： 绘制View本身的背景</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dirtyOpaque<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">drawBackground</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 若有必要，则保存图层(还有一个复原图层)</span>        <span class="token comment" spellcheck="true">// 优化技巧：当不需绘制 Layer 时，可以跳过“保存图层”和“复原图层”这两步</span>        <span class="token comment" spellcheck="true">// 因此在绘制时，节省 layer 可以提高绘制效率</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> viewFlags <span class="token operator">=</span> mViewFlags<span class="token punctuation">;</span>        <span class="token keyword">boolean</span> horizontalEdges <span class="token operator">=</span> <span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> FADING_EDGE_HORIZONTAL<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> verticalEdges <span class="token operator">=</span> <span class="token punctuation">(</span>viewFlags <span class="token operator">&amp;</span> FADING_EDGE_VERTICAL<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>verticalEdges <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>horizontalEdges<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 步骤3：绘制View本身的内容(View和ViewGroup中默认为空实现，需复写)</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>dirtyOpaque<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">onDraw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 步骤4：绘制子View</span>            <span class="token comment" spellcheck="true">// 由于单一View无子View，故View 中：默认为空实现</span>            <span class="token comment" spellcheck="true">// ViewGroup中：系统已经复写好对其子视图进行绘制我们不需要复写</span>            <span class="token function">dispatchDraw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">drawAutofilledHighlight</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 叠加层是视图内容的一部分，需要在前景下方绘制</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>mOverlay <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>mOverlay<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                mOverlay<span class="token punctuation">.</span><span class="token function">getOverlayView</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">dispatchDraw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token comment" spellcheck="true">// 步骤6：绘制装饰(前景、滚动条等)</span>            <span class="token function">onDrawForeground</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 步骤7：绘制默认焦点高亮显示</span>            <span class="token function">drawDefaultFocusHighlight</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">debugDraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">debugDrawFocus</span><span class="token punctuation">(</span>canvas<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>            <span class="token keyword">return</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>由于在 <code>draw()</code> 中绘制步骤调用的 <code>drawBackground()</code>、<code>onDraw()</code>、<code>onDrawForeground()</code> 方法，与单一 View 的 draw 过程类似，下面只详细分析一下与单一 View 的 draw 过程最大不同的步骤：<code>dispatchDraw()</code></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 源码分析：dispatchDraw()     * &lt;p>     * 作用：遍历所有子 View 并绘制子 View     * &lt;p>     * 注：     * a. ViewGroup 中：由于系统为我们实现了该方法，故不需重写该方法     * b. View 中默认为空实现(因为没有子View可以去绘制)     *     * @param canvas 画布     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">dispatchDraw</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> childrenCount <span class="token operator">=</span> mChildrenCount<span class="token punctuation">;</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 1. 遍历子View</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> childrenCount<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>transientIndex <span class="token operator">>=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> mTransientIndices<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>transientIndex<span class="token punctuation">)</span> <span class="token operator">==</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">final</span> View transientChild <span class="token operator">=</span> mTransientViews<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>transientIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>transientChild<span class="token punctuation">.</span>mViewFlags <span class="token operator">&amp;</span> VISIBILITY_MASK<span class="token punctuation">)</span> <span class="token operator">==</span> VISIBLE <span class="token operator">||</span>                        transientChild<span class="token punctuation">.</span><span class="token function">getAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 2. 绘制子View视图 ->>分析1</span>                    more <span class="token operator">|=</span> <span class="token function">drawChild</span><span class="token punctuation">(</span>canvas<span class="token punctuation">,</span> transientChild<span class="token punctuation">,</span> drawingTime<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析1：drawChild()     * &lt;p>     * 作用：绘制子 View     *     * @param canvas      绘制子视图的画布     * @param child       要绘制的子视图     * @param drawingTime 绘制开始的时间     */</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">drawChild</span><span class="token punctuation">(</span>Canvas canvas<span class="token punctuation">,</span> View child<span class="token punctuation">,</span> <span class="token keyword">long</span> drawingTime<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 最终还是调用了子 View 的 draw() 方法进行子 View 的绘制</span>        <span class="token keyword">return</span> child<span class="token punctuation">.</span><span class="token function">draw</span><span class="token punctuation">(</span>canvas<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">,</span> drawingTime<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://henleylee.github.io//medias/view/view_draw_group_all.png" alt="ViewGroup的draw过程总结"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://henleylee.github.io//medias/view/view_draw_all.png" alt="View的draw过程总结"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自定义 View 之 Layout</title>
      <link href="/posts/2019/3293dfd0.html"/>
      <url>/posts/2019/3293dfd0.html</url>
      
        <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在自定义 View 过程中，Layout 的主要作用就是<strong><code>计算 View 的位置</code></strong>。</p><blockquote><p>计算 View 的位置就是计算 <code>View</code> 的四个顶点位置：<code>Left</code>、<code>Top</code>、<code>Right</code> 和 <code>Bottom</code>。</p></blockquote><h2 id="layout-过程详解"><a href="#layout-过程详解" class="headerlink" title="layout 过程详解"></a>layout 过程详解</h2><p><strong><code>layout</code></strong> 过程根据 View 的类型分为以下两种情况：</p><ul><li><strong><code>单一 View：</code></strong>仅计算 <code>View</code> 自身的位置。</li><li><strong><code>ViewGroup：</code></strong>除了计算 <code>View</code> 自身的位置外，还需要确定子 <code>View</code> 在父容器中的位置(遍历调用所有子元素的 <code>layout()</code> 和各子元素再递归去执行该流程)。</li></ul><h3 id="单一-View-的-layout-过程"><a href="#单一-View-的-layout-过程" class="headerlink" title="单一 View 的 layout 过程"></a>单一 View 的 layout 过程</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在没有现成的控件 View 满足需求、需自己实现时，则使用自定义单一 View。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>继承自 <code>View</code>、<code>SurfaceView</code> 或 其他 <code>View</code>；<code>不包含子 View</code>。</p><h4 id="计算流程"><a href="#计算流程" class="headerlink" title="计算流程"></a>计算流程</h4><p><img src="https://henleylee.github.io//medias/view/view_layout_single.png" alt="单一View的layout过程"></p><p>下面将 <code>layout</code> 过程中的方法进行详细分析：<code>layout</code> 过程入口为 <code>layout()</code></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 源码分析：layout()     * &lt;p>     * 作用：确定 View 本身的位置，即设置 View 本身的四个顶点位置     *     * @param l 相对于父视图的左侧位置     * @param t 相对于父视图的顶部位置     * @param r 相对于父视图的右侧位置     * @param b 相对于父视图的底部位置     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layout</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前视图的四个顶点</span>        <span class="token keyword">int</span> oldL <span class="token operator">=</span> mLeft<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldT <span class="token operator">=</span> mTop<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldB <span class="token operator">=</span> mBottom<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldR <span class="token operator">=</span> mRight<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 确定View的位置：setFrame() / setOpticalFrame()</span>        <span class="token comment" spellcheck="true">// 即初始化四个顶点的值、判断当前View大小和位置是否发生了变化并返回</span>        <span class="token comment" spellcheck="true">// ->>分析1、分析2</span>        <span class="token keyword">boolean</span> changed <span class="token operator">=</span> <span class="token function">isLayoutModeOptical</span><span class="token punctuation">(</span>mParent<span class="token punctuation">)</span> <span class="token operator">?</span>                <span class="token function">setOpticalFrame</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> t<span class="token punctuation">,</span> r<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">setFrame</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> t<span class="token punctuation">,</span> r<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. 若视图的大小和位置发生变化，会重新确定该View所有的子View在父容器的位置：onLayout()</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>changed <span class="token operator">||</span> <span class="token punctuation">(</span>mPrivateFlags <span class="token operator">&amp;</span> PFLAG_LAYOUT_REQUIRED<span class="token punctuation">)</span> <span class="token operator">==</span> PFLAG_LAYOUT_REQUIRED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">onLayout</span><span class="token punctuation">(</span>changed<span class="token punctuation">,</span> l<span class="token punctuation">,</span> t<span class="token punctuation">,</span> r<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout()是一个空实现->>分析3</span>            <span class="token comment" spellcheck="true">// 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout()在ViewGroup为一个抽象方法，需重写实现</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析1：setFrame()     * &lt;p>     * 作用：根据传入的4个位置值，设置View本身的四个顶点位置，最终确定View本身的位置     *     * @param left   相对于父视图的左侧位置     * @param top    相对于父视图的顶部位置     * @param right  相对于父视图的右侧位置     * @param bottom 相对于父视图的底部位置     */</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">setFrame</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLeft <span class="token operator">!=</span> left <span class="token operator">||</span> mRight <span class="token operator">!=</span> right <span class="token operator">||</span> mTop <span class="token operator">!=</span> top <span class="token operator">||</span> mBottom <span class="token operator">!=</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>            changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// 通过以下赋值语句记录下了视图的位置信息，即确定View的四个顶点，从而确定了视图的位置</span>            mLeft <span class="token operator">=</span> left<span class="token punctuation">;</span>            mTop <span class="token operator">=</span> top<span class="token punctuation">;</span>            mRight <span class="token operator">=</span> right<span class="token punctuation">;</span>            mBottom <span class="token operator">=</span> bottom<span class="token punctuation">;</span>            mRenderNode<span class="token punctuation">.</span><span class="token function">setLeftTopRightBottom</span><span class="token punctuation">(</span>mLeft<span class="token punctuation">,</span> mTop<span class="token punctuation">,</span> mRight<span class="token punctuation">,</span> mBottom<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> changed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析2：setOpticalFrame()     * &lt;p>     * 作用：根据传入的4个位置值，设置View本身的四个顶点位置，最终确定View本身的位置     *     * @param left   相对于父视图的左侧位置     * @param top    相对于父视图的顶部位置     * @param right  相对于父视图的右侧位置     * @param bottom 相对于父视图的底部位置     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">setOpticalFrame</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Insets parentInsets <span class="token operator">=</span> mParent <span class="token keyword">instanceof</span> <span class="token class-name">View</span> <span class="token operator">?</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>View<span class="token punctuation">)</span> mParent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOpticalInsets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> Insets<span class="token punctuation">.</span>NONE<span class="token punctuation">;</span>        Insets childInsets <span class="token operator">=</span> <span class="token function">getOpticalInsets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 内部实际上是调用setFrame()</span>        <span class="token keyword">return</span> <span class="token function">setFrame</span><span class="token punctuation">(</span>                left <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>left <span class="token operator">-</span> childInsets<span class="token punctuation">.</span>left<span class="token punctuation">,</span>                top <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>top <span class="token operator">-</span> childInsets<span class="token punctuation">.</span>top<span class="token punctuation">,</span>                right <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>left <span class="token operator">+</span> childInsets<span class="token punctuation">.</span>right<span class="token punctuation">,</span>                bottom <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>top <span class="token operator">+</span> childInsets<span class="token punctuation">.</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析3：onLayout()     * &lt;p>     * 注：对于单一View的laytou过程     *     a. 由于单一View是没有子View的，故onLayout()是一个空实现     *     b. 由于在layout()中已经对自身View进行了位置计算，所以单一View的layout过程在layout()后就已完成     *     * @param changed 当前View的大小和位置是否改变了     * @param left    相对于父视图的左侧位置     * @param top     相对于父视图的顶部位置     * @param right   相对于父视图的右侧位置     * @param bottom  相对于父视图的底部位置     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onLayout</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> changed<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://henleylee.github.io//medias/view/view_layout_single_all.png" alt="单一View的layout过程总结"></p><h3 id="ViewGroup-的-layout-过程"><a href="#ViewGroup-的-layout-过程" class="headerlink" title="ViewGroup 的 layout 过程"></a>ViewGroup 的 layout 过程</h3><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>利用现有的组件根据特定的布局方式来组成新的组件。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>继承自 <code>ViewGroup</code> 或各种 <code>Layout</code>；<code>包含子 View</code>。</p><h4 id="计算原理"><a href="#计算原理" class="headerlink" title="计算原理"></a>计算原理</h4><p>自上而下、一层层地传递下去，直到完成整个 View 树的 <code>layout()</code> 过程：</p><ol><li>计算自身 <code>ViewGroup</code> 的位置：<code>layout()</code>。</li><li>遍历所有子 <code>View</code> 并确定子 <code>View</code> 自身在 ViewGroup 中的位置(调用子 View 的 layout() 方法)：onLayout()。</li></ol><p><img src="https://henleylee.github.io//medias/view/view_group_tree.png" alt="ViewGroup自上而下遍历"></p><h4 id="计算流程-1"><a href="#计算流程-1" class="headerlink" title="计算流程"></a>计算流程</h4><p><img src="https://henleylee.github.io//medias/view/view_layout_group.png" alt="ViewGroup的layout过程"><br><code>ViewGroup</code> 和 <code>View</code> 同样拥有 <code>layout()</code> 和 <code>onLayout()</code>，但二者不同的：</p><ul><li>一开始计算 <code>ViewGroup</code> 位置时，调用的是 <code>ViewGroup</code>的 <code>layout()</code> 和 <code>onLayout()</code>；</li><li>当开始遍历子 <code>View</code> 并计算子 <code>View</code> 位置时，调用的是子 <code>View</code> 的 <code>layout()</code> 和 <code>onLayout()</code>。</li></ul><p>下面将 <code>layout</code> 过程中的方法进行详细分析：<code>layout</code> 过程入口为 <code>layout()</code></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 源码分析：layout()     * &lt;p>     * 作用：确定 View 本身的位置，即设置 View 本身的四个顶点位置     *     * @param l 相对于父视图的左侧位置     * @param t 相对于父视图的顶部位置     * @param r 相对于父视图的右侧位置     * @param b 相对于父视图的底部位置     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">layout</span><span class="token punctuation">(</span><span class="token keyword">int</span> l<span class="token punctuation">,</span> <span class="token keyword">int</span> t<span class="token punctuation">,</span> <span class="token keyword">int</span> r<span class="token punctuation">,</span> <span class="token keyword">int</span> b<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 当前视图的四个顶点</span>        <span class="token keyword">int</span> oldL <span class="token operator">=</span> mLeft<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldT <span class="token operator">=</span> mTop<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldB <span class="token operator">=</span> mBottom<span class="token punctuation">;</span>        <span class="token keyword">int</span> oldR <span class="token operator">=</span> mRight<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 确定View的位置：setFrame() / setOpticalFrame()</span>        <span class="token comment" spellcheck="true">// 即初始化四个顶点的值、判断当前View大小和位置是否发生了变化并返回</span>        <span class="token comment" spellcheck="true">// ->>分析1、分析2</span>        <span class="token keyword">boolean</span> changed <span class="token operator">=</span> <span class="token function">isLayoutModeOptical</span><span class="token punctuation">(</span>mParent<span class="token punctuation">)</span> <span class="token operator">?</span>                <span class="token function">setOpticalFrame</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> t<span class="token punctuation">,</span> r<span class="token punctuation">,</span> b<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">setFrame</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> t<span class="token punctuation">,</span> r<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. 若视图的大小和位置发生变化，会重新确定该View所有的子View在父容器的位置：onLayout()</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>changed <span class="token operator">||</span> <span class="token punctuation">(</span>mPrivateFlags <span class="token operator">&amp;</span> PFLAG_LAYOUT_REQUIRED<span class="token punctuation">)</span> <span class="token operator">==</span> PFLAG_LAYOUT_REQUIRED<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">onLayout</span><span class="token punctuation">(</span>changed<span class="token punctuation">,</span> l<span class="token punctuation">,</span> t<span class="token punctuation">,</span> r<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 对于单一View的laytou过程：由于单一View是没有子View的，故onLayout()是一个空实现->>分析3</span>            <span class="token comment" spellcheck="true">// 对于ViewGroup的laytou过程：由于确定位置与具体布局有关，所以onLayout()在ViewGroup为一个抽象方法，需重写实现</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析1：setFrame()     * &lt;p>     * 作用：根据传入的4个位置值，设置View本身的四个顶点位置，最终确定View本身的位置     *     * @param left   相对于父视图的左侧位置     * @param top    相对于父视图的顶部位置     * @param right  相对于父视图的右侧位置     * @param bottom 相对于父视图的底部位置     */</span>    <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">setFrame</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> changed <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mLeft <span class="token operator">!=</span> left <span class="token operator">||</span> mRight <span class="token operator">!=</span> right <span class="token operator">||</span> mTop <span class="token operator">!=</span> top <span class="token operator">||</span> mBottom <span class="token operator">!=</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>            changed <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// 通过以下赋值语句记录下了视图的位置信息，即确定View的四个顶点，从而确定了视图的位置</span>            mLeft <span class="token operator">=</span> left<span class="token punctuation">;</span>            mTop <span class="token operator">=</span> top<span class="token punctuation">;</span>            mRight <span class="token operator">=</span> right<span class="token punctuation">;</span>            mBottom <span class="token operator">=</span> bottom<span class="token punctuation">;</span>            mRenderNode<span class="token punctuation">.</span><span class="token function">setLeftTopRightBottom</span><span class="token punctuation">(</span>mLeft<span class="token punctuation">,</span> mTop<span class="token punctuation">,</span> mRight<span class="token punctuation">,</span> mBottom<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> changed<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析2：setOpticalFrame()     * &lt;p>     * 作用：根据传入的4个位置值，设置View本身的四个顶点位置，最终确定View本身的位置     *     * @param left   相对于父视图的左侧位置     * @param top    相对于父视图的顶部位置     * @param right  相对于父视图的右侧位置     * @param bottom 相对于父视图的底部位置     */</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">setOpticalFrame</span><span class="token punctuation">(</span><span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Insets parentInsets <span class="token operator">=</span> mParent <span class="token keyword">instanceof</span> <span class="token class-name">View</span> <span class="token operator">?</span>                <span class="token punctuation">(</span><span class="token punctuation">(</span>View<span class="token punctuation">)</span> mParent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getOpticalInsets</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">:</span> Insets<span class="token punctuation">.</span>NONE<span class="token punctuation">;</span>        Insets childInsets <span class="token operator">=</span> <span class="token function">getOpticalInsets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 内部实际上是调用setFrame()</span>        <span class="token keyword">return</span> <span class="token function">setFrame</span><span class="token punctuation">(</span>                left <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>left <span class="token operator">-</span> childInsets<span class="token punctuation">.</span>left<span class="token punctuation">,</span>                top <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>top <span class="token operator">-</span> childInsets<span class="token punctuation">.</span>top<span class="token punctuation">,</span>                right <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>left <span class="token operator">+</span> childInsets<span class="token punctuation">.</span>right<span class="token punctuation">,</span>                bottom <span class="token operator">+</span> parentInsets<span class="token punctuation">.</span>top <span class="token operator">+</span> childInsets<span class="token punctuation">.</span>bottom<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析3：onLayout()     * &lt;p>     * 注：对于单一View的laytou过程     *     a. 由于单一View是没有子View的，故onLayout()是一个空实现     *     b. 由于在layout()中已经对自身View进行了位置计算，所以单一View的layout过程在layout()后就已完成     *     c. 复写原理：遍历子View、计算当前子View的四个位置值并确定自身子View的位置(调用子 View 的 layout() 方法)     *     * @param changed 当前View的大小和位置是否改变了     * @param left    相对于父视图的左侧位置     * @param top     相对于父视图的顶部位置     * @param right   相对于父视图的右侧位置     * @param bottom  相对于父视图的底部位置     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onLayout</span><span class="token punctuation">(</span><span class="token keyword">boolean</span> changed<span class="token punctuation">,</span> <span class="token keyword">int</span> left<span class="token punctuation">,</span> <span class="token keyword">int</span> top<span class="token punctuation">,</span> <span class="token keyword">int</span> right<span class="token punctuation">,</span> <span class="token keyword">int</span> bottom<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. 遍历子View：循环所有子View</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token function">getChildCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            View child <span class="token operator">=</span> <span class="token function">getChildAt</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2. 计算当前子View的四个位置值</span>            <span class="token comment" spellcheck="true">// 2.1 位置的计算逻辑，需自己实现，也是自定义View的关键</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token comment" spellcheck="true">// 2.2 对计算后的位置值进行赋值</span>            <span class="token keyword">int</span> mLeft <span class="token operator">=</span> left<span class="token punctuation">;</span>            <span class="token keyword">int</span> mTop <span class="token operator">=</span> top<span class="token punctuation">;</span>            <span class="token keyword">int</span> mRight <span class="token operator">=</span> right<span class="token punctuation">;</span>            <span class="token keyword">int</span> mBottom <span class="token operator">=</span> bottom<span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 3. 根据上述4个位置的计算值，设置子View的4个顶点：调用子view的layout() &amp; 传递计算过的参数</span>            <span class="token comment" spellcheck="true">// 即确定了子View在父容器的位置</span>            child<span class="token punctuation">.</span><span class="token function">layout</span><span class="token punctuation">(</span>mLeft<span class="token punctuation">,</span> mTop<span class="token punctuation">,</span> mRight<span class="token punctuation">,</span> mBottom<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 该过程类似于单一View的layout过程中的layout()和onLayout()，此处不作过多描述</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://henleylee.github.io//medias/view/view_layout_group_all.png" alt="ViewGroup的layout过程总结"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://henleylee.github.io//medias/view/view_layout_all.png" alt="View的layout过程总结"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自定义 View 之 Measure</title>
      <link href="/posts/2019/48d8e111.html"/>
      <url>/posts/2019/48d8e111.html</url>
      
        <content type="html"><![CDATA[<h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><p>在自定义 View 过程中，Measure 的主要作用就是<strong><code>测量 View 的宽/高</code></strong>。</p><blockquote><p>在某些情况下，需要多次测量(<code>measure</code>)才能确定 View 最终的宽/高；该情况下，<code>measure</code> 过程后得到的宽/高可能不准确；此处建议：在 <code>layout</code> 过程中 <code>onLayout()</code> 去获取最终的宽/高。</p></blockquote><h2 id="LayoutParams"><a href="#LayoutParams" class="headerlink" title="LayoutParams"></a>LayoutParams</h2><p><strong><code>android.view.ViewGroup.LayoutParams</code></strong> 类是 <code>android.view.ViewGroup</code> 的一个内部类，表示布局参数。</p><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><p><code>LayoutParams</code> 的主要作用是用来指定 View 的高度(height)和 宽度(width)等布局参数。</p><h3 id="具体使用"><a href="#具体使用" class="headerlink" title="具体使用"></a>具体使用</h3><p><code>LayoutParams</code> 主要通过以下参数指定：</p><table><thead><tr><th>参数</th><th>解释</th></tr></thead><tbody><tr><td>具体值</td><td>指定具体的宽/高(dp / px)</td></tr><tr><td>fill_parent</td><td>强制性使子视图的大小扩展至与父视图大小相等(不含 padding)</td></tr><tr><td>match_parent</td><td>与 fill_parent 相同，用于 Android 2.3 及以上版本</td></tr><tr><td>wrap_content</td><td>自适应大小，强制性地使视图扩展以便显示其全部内容(含 padding)</td></tr></tbody></table><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token function">LayoutParams</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>content<span class="token punctuation">.</span>Context context<span class="token punctuation">,</span> android<span class="token punctuation">.</span>util<span class="token punctuation">.</span>AttributeSet attrs<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">LayoutParams</span><span class="token punctuation">(</span><span class="token keyword">int</span> width<span class="token punctuation">,</span> <span class="token keyword">int</span> height<span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token function">LayoutParams</span><span class="token punctuation">(</span>android<span class="token punctuation">.</span>view<span class="token punctuation">.</span>ViewGroup<span class="token punctuation">.</span>LayoutParams source<span class="token punctuation">)</span></code></pre><h2 id="MeasureSpec"><a href="#MeasureSpec" class="headerlink" title="MeasureSpec"></a>MeasureSpec</h2><p><strong><code>android.view.View.MeasureSpec</code></strong> 类是 <code>android.view.View</code> 的一个内部类，表示测量规格。</p><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><p><code>MeasureSpec</code> 的主要作用是用来作为测量 View 的大小(宽/高)的依据。</p><h3 id="组成"><a href="#组成" class="headerlink" title="组成"></a>组成</h3><p><code>MeasureSpec</code> 由测量模式(<code>mode</code>)和测量大小(<code>size</code>)。MeasureSpec 是 View 中的内部类，基本都是二进制运算。由于 int 是 32 位的，用<strong>高两位表示 mode，低 30 位表示 size</strong>，MODE_SHIFT = 30 的作用是移位。</p><h3 id="测量模式"><a href="#测量模式" class="headerlink" title="测量模式"></a>测量模式</h3><p>测量模式(<code>mode</code>)的类型有3种：UNSPECIFIED、EXACTLY 和 AT_MOST。具体如下：</p><table><thead><tr><th>模式</th><th>描述</th><th>应用场景</th></tr></thead><tbody><tr><td>UNSPECIFIED</td><td>父控件没有给子视图任何限制，子视图可以设置为任意大小(不常用)</td><td>ListView，ScrollView</td></tr><tr><td>EXACTLY</td><td>父控件为子视图指定了确切的尺寸，子视图大小必须在该指定尺寸内</td><td>具体数值或 march_parent</td></tr><tr><td>AT_MOST</td><td>父控件为子视图指定一个最大尺寸，子视图必须确保自身和所有子视图可适应在该尺寸内</td><td>wrap_content</td></tr></tbody></table><h3 id="具体使用-1"><a href="#具体使用-1" class="headerlink" title="具体使用"></a>具体使用</h3><p><code>MeasureSpec</code> 类用1个变量封装了2个数据(size  和 mode)：通过使用二进制，将测量模式(mode)和测量大小(size)打包成一个 int 值来，并提供了打包和解包的方法。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 获取测量模式(Mode)</span><span class="token keyword">int</span> specMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getMode</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 获取测量大小(Size)</span><span class="token keyword">int</span> specSize <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 通过 Mode 和 Size 生成新的 SpecMode</span><span class="token keyword">int</span> measureSpec<span class="token operator">=</span>MeasureSpec<span class="token punctuation">.</span><span class="token function">makeMeasureSpec</span><span class="token punctuation">(</span>size<span class="token punctuation">,</span> mode<span class="token punctuation">)</span></code></pre><h3 id="源码分析"><a href="#源码分析" class="headerlink" title="源码分析"></a>源码分析</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * MeasureSpec 类的源码分析 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MeasureSpec</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 进位大小为2的30次方(int的大小为32位，所以进位30位就是要使用int的最高位和倒数第二位也就是32和31位做标志位)</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MODE_SHIFT <span class="token operator">=</span> <span class="token number">30</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 运算遮罩，0x3为16进制，10进制为3，二进制为11。3向左进位30，就是11 00000000000(11后跟30个0)</span>    <span class="token comment" spellcheck="true">// 遮罩的作用：用1标注需要的值，0标注不要的值。因为1与任何数做与运算都得任何数，0与任何数做与运算都得0</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MODE_MASK <span class="token operator">=</span> <span class="token number">0x3</span> <span class="token operator">&lt;&lt;</span> MODE_SHIFT<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// UNSPECIFIED的模式设置：0向左进位30 = 00后跟30个0，即00 00000000000</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> UNSPECIFIED <span class="token operator">=</span> <span class="token number">0</span> <span class="token operator">&lt;&lt;</span> MODE_SHIFT<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// EXACTLY的模式设置：1向左进位30 = 01后跟30个0 ，即01 00000000000</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> EXACTLY <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> MODE_SHIFT<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// AT_MOST的模式设置：2向左进位30 = 10后跟30个0，即10 00000000000</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> AT_MOST <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">&lt;&lt;</span> MODE_SHIFT<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 根据提供的size和mode得到一个详细的测量结果吗，即 measureSpec     * &lt;p>     * 设计目的：使用一个32位的二进制数，其中：32和31位代表测量模式(mode)、后30位代表测量大小(size)     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">makeMeasureSpec</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> mode<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// measureSpec = size + mode；此为二进制的加法，而不是十进制！</span>        <span class="token keyword">return</span> size <span class="token operator">+</span> mode<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过 measureSpec 获得测量模式(mode)     * &lt;p>     * 原理：保留measureSpec的高2位（即测量模式）、使用0替换后30位     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getMode</span><span class="token punctuation">(</span><span class="token keyword">int</span> measureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 测量模式(mode) = measureSpec &amp; MODE_MASK;</span>        <span class="token comment" spellcheck="true">// MODE_MASK = 运算遮罩 = 11 00000000000(11后跟30个0)</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>measureSpec <span class="token operator">&amp;</span> MODE_MASK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 作用：通过 measureSpec 获得测量大小(size)     * &lt;p>     * 原理：将 MODE_MASK 取反，也就是变成了00 111111(00后跟30个1)，将32,31替换成0也就是去掉 mode，保留后30位的 size     *     * @param measureSpec the measure specification to extract the size from     * @return the size in pixels defined in the supplied measure specification     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> measureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 测量大小(size) = measureSpec &amp; ~MODE_MASK;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>measureSpec <span class="token operator">&amp;</span> <span class="token operator">~</span>MODE_MASK<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 打印 mode 和 size 的信息     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token keyword">int</span> measureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> mode <span class="token operator">=</span> <span class="token function">getMode</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> <span class="token function">getSize</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        StringBuilder sb <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token string">"MeasureSpec: "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">==</span> UNSPECIFIED<span class="token punctuation">)</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"UNSPECIFIED "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">==</span> EXACTLY<span class="token punctuation">)</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"EXACTLY "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>mode <span class="token operator">==</span> AT_MOST<span class="token punctuation">)</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"AT_MOST "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">else</span>            sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>mode<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        sb<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span>size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> sb<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="measure-过程详解"><a href="#measure-过程详解" class="headerlink" title="measure 过程详解"></a>measure 过程详解</h2><p><strong><code>measure</code></strong> 过程根据 View 的类型分为以下两种情况：</p><ul><li><strong><code>单一 View：</code></strong>仅测量 <code>View</code> 自身的大小。</li><li><strong><code>ViewGroup：</code></strong>对 <code>ViewGroup</code> 视图中的所有子 <code>View</code> 都进行测量(遍历调用所有子元素的 <code>measure()</code> 和各子元素再递归去执行该流程)。</li></ul><h3 id="单一-View-的-measure-过程"><a href="#单一-View-的-measure-过程" class="headerlink" title="单一 View 的 measure 过程"></a>单一 View 的 measure 过程</h3><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><p>在没有现成的控件 View 满足需求、需自己实现时，则使用自定义单一 View。</p><h4 id="使用方法"><a href="#使用方法" class="headerlink" title="使用方法"></a>使用方法</h4><p>继承自 <code>View</code>、<code>SurfaceView</code> 或 其他 <code>View</code>；<code>不包含子 View</code>。</p><h4 id="测量流程"><a href="#测量流程" class="headerlink" title="测量流程"></a>测量流程</h4><p><img src="https://henleylee.github.io/medias/view/view_measure_single.png" alt="单一View的measure过程"></p><p>下面将 <code>measure</code> 过程中的方法进行详细分析：<code>measure</code> 过程入口为 <code>measure()</code></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 源码分析：measure()     * &lt;p>     * 定义：Measure 过程的入口；属于 View 类 &amp; final 类型，即子类不能重写此方法     * &lt;p>     * 作用：基本测量逻辑的判断     *     * @param widthMeasureSpec  View 的宽度测量规格     * @param heightMeasureSpec View 的高度测量规格     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">measure</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>forceLayout <span class="token operator">||</span> needsLayout<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">int</span> cacheIndex <span class="token operator">=</span> forceLayout <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> mMeasureCache<span class="token punctuation">.</span><span class="token function">indexOfKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> sIgnoreMeasureCache<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用 onMeasure() 计算视图大小 ->>分析1</span>                <span class="token function">onMeasure</span><span class="token punctuation">(</span>widthMeasureSpec<span class="token punctuation">,</span> heightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        mPrivateFlags3 <span class="token operator">&amp;=</span> <span class="token operator">~</span>PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * &lt;p>     * 分析1：onMeasure()     * &lt;p>     * 作用：a. 根据 View 宽/高的测量规格计算 View 的宽/高值：getDefaultSize()     *       b. 存储测量后的 View 宽/高：setMeasuredDimension()     *     * @param widthMeasureSpec  View 的宽度测量规格     * @param heightMeasureSpec View 的高度测量规格     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onMeasure</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// setMeasuredDimension()：获得 View 宽/高的测量值 ->>分析2</span>        <span class="token comment" spellcheck="true">// 传入的参数通过 getDefaultSize() 获得 ->>分析3</span>        <span class="token function">setMeasuredDimension</span><span class="token punctuation">(</span><span class="token function">getDefaultSize</span><span class="token punctuation">(</span><span class="token function">getSuggestedMinimumWidth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> widthMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">,</span>                <span class="token function">getDefaultSize</span><span class="token punctuation">(</span><span class="token function">getSuggestedMinimumHeight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> heightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析2：setMeasuredDimension()     * &lt;p>     * 作用：存储测量后的 View 宽/高     * &lt;p>     * 注：该方法即为重写 onMeasure() 所要实现的最终目的     * &lt;p>     * 此方法必须由 onMeasure(int, int) 调用来存储测量的宽度和高度     *     * @param measuredWidth  测量后 View 的宽度值     * @param measuredHeight 测量后 View 的高度值     */</span>    <span class="token keyword">protected</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">setMeasuredDimension</span><span class="token punctuation">(</span><span class="token keyword">int</span> measuredWidth<span class="token punctuation">,</span> <span class="token keyword">int</span> measuredHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">boolean</span> optical <span class="token operator">=</span> <span class="token function">isLayoutModeOptical</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>optical <span class="token operator">!=</span> <span class="token function">isLayoutModeOptical</span><span class="token punctuation">(</span>mParent<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Insets insets <span class="token operator">=</span> <span class="token function">getOpticalInsets</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> opticalWidth <span class="token operator">=</span> insets<span class="token punctuation">.</span>left <span class="token operator">+</span> insets<span class="token punctuation">.</span>right<span class="token punctuation">;</span>            <span class="token keyword">int</span> opticalHeight <span class="token operator">=</span> insets<span class="token punctuation">.</span>top <span class="token operator">+</span> insets<span class="token punctuation">.</span>bottom<span class="token punctuation">;</span>            measuredWidth <span class="token operator">+=</span> optical <span class="token operator">?</span> opticalWidth <span class="token operator">:</span> <span class="token operator">-</span>opticalWidth<span class="token punctuation">;</span>            measuredHeight <span class="token operator">+=</span> optical <span class="token operator">?</span> opticalHeight <span class="token operator">:</span> <span class="token operator">-</span>opticalHeight<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// setMeasuredDimensionRaw()：设置 View 宽/高的测量值 ->>分析4</span>        <span class="token function">setMeasuredDimensionRaw</span><span class="token punctuation">(</span>measuredWidth<span class="token punctuation">,</span> measuredHeight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析4：setMeasuredDimensionRaw()     * &lt;p>     * 作用：设置测量的尺寸     *     * @param measuredWidth  测量后 View 的宽度值     * @param measuredHeight 测量后 View 的高度值     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">setMeasuredDimensionRaw</span><span class="token punctuation">(</span><span class="token keyword">int</span> measuredWidth<span class="token punctuation">,</span> <span class="token keyword">int</span> measuredHeight<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 将测量后子View的宽 / 高值进行传递</span>        mMeasuredWidth <span class="token operator">=</span> measuredWidth<span class="token punctuation">;</span>        mMeasuredHeight <span class="token operator">=</span> measuredHeight<span class="token punctuation">;</span>        mPrivateFlags <span class="token operator">|=</span> PFLAG_MEASURED_DIMENSION_SET<span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/**     * 分析3：getDefaultSize()     * &lt;p>     * 作用：根据 View 宽/高的测量规格计算 View 的宽/高值     *     * @param size        View 的默认大小     * @param measureSpec 宽/高的测量规格(含模式和测量大小)     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getDefaultSize</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span> <span class="token keyword">int</span> measureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 设置默认大小</span>        <span class="token keyword">int</span> result <span class="token operator">=</span> size<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 获取宽/高测量规格的模式 &amp; 测量大小</span>        <span class="token keyword">int</span> specMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getMode</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> specSize <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span>measureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>specMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 模式为 UNSPECIFIED 时，使用提供的默认大小 = 参数 Size</span>            <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>UNSPECIFIED<span class="token operator">:</span>                result <span class="token operator">=</span> size<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 模式为 AT_MOST、EXACTLY 时，使用 View 测量后的宽/高值 = measureSpec 中的 Size</span>            <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>AT_MOST<span class="token operator">:</span>            <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token operator">:</span>                result <span class="token operator">=</span> specSize<span class="token punctuation">;</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 返回 View 的宽/高值</span>        <span class="token keyword">return</span> result<span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="https://henleylee.github.io/medias/view/view_measure_single_all.png" alt="单一View的measure过程总结"></p><h3 id="ViewGroup-的-measure-过程"><a href="#ViewGroup-的-measure-过程" class="headerlink" title="ViewGroup 的 measure 过程"></a>ViewGroup 的 measure 过程</h3><h4 id="应用场景-1"><a href="#应用场景-1" class="headerlink" title="应用场景"></a>应用场景</h4><p>利用现有的组件根据特定的布局方式来组成新的组件。</p><h4 id="使用方法-1"><a href="#使用方法-1" class="headerlink" title="使用方法"></a>使用方法</h4><p>继承自 <code>ViewGroup</code> 或各种 <code>Layout</code>；<code>包含子 View</code>。</p><h4 id="测量原理"><a href="#测量原理" class="headerlink" title="测量原理"></a>测量原理</h4><p>自上而下、一层层地传递下去，直到完成整个 View 树的 <code>measure()</code> 过程：</p><ol><li>遍历测量所有子 <code>View</code> 的尺寸。</li><li>将所有子 <code>View</code> 的尺寸进行合并，最终得到 <code>ViewGroup</code> 父视图的测量值。</li></ol><p><img src="https://henleylee.github.io/medias/view/view_group_tree.png" alt="ViewGroup自上而下遍历"></p><h4 id="测量流程-1"><a href="#测量流程-1" class="headerlink" title="测量流程"></a>测量流程</h4><p><img src="https://henleylee.github.io/medias/view/view_measure_group.png" alt="ViewGroup的measure过程"></p><p>下面将 <code>measure</code> 过程中的方法进行详细分析：<code>measure</code> 过程入口为 <code>measure()</code></p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 源码分析：measure()     * &lt;p>     * 定义：Measure 过程的入口；属于 View 类 &amp; final 类型，即子类不能重写此方法     * &lt;p>     * 作用：基本测量逻辑的判断     *     * @param widthMeasureSpec  View 的宽度测量规格     * @param heightMeasureSpec View 的高度测量规格     */</span>    <span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">measure</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>forceLayout <span class="token operator">||</span> needsLayout<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token keyword">int</span> cacheIndex <span class="token operator">=</span> forceLayout <span class="token operator">?</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">:</span> mMeasureCache<span class="token punctuation">.</span><span class="token function">indexOfKey</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheIndex <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> sIgnoreMeasureCache<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 调用 onMeasure() 计算视图大小 ->>分析1</span>                <span class="token function">onMeasure</span><span class="token punctuation">(</span>widthMeasureSpec<span class="token punctuation">,</span> heightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        mPrivateFlags3 <span class="token operator">&amp;=</span> <span class="token operator">~</span>PFLAG3_MEASURE_NEEDED_BEFORE_LAYOUT<span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * &lt;p>     * 分析1：onMeasure()     * &lt;p>     * 作用：遍历所有子 View 并进行测量     * &lt;p>     * 注：ViewGroup 是一个抽象类，没有重写 View 的 onMeasure() 方法，需自身重写     *     * @param widthMeasureSpec  View 的宽度测量规格     * @param heightMeasureSpec View 的高度测量规格     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onMeasure</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span></code></pre><p>由于不同的 <code>ViewGroup</code> 子类(<code>LinearLayout</code>、<code>RelativeLayout</code>、<code>自定义 ViewGroup 子类</code>等)具备不同的布局特性，这导致它们的子 <code>View</code> 的测量方法各有不同，而 <code>onMeasure()</code> 方法的作用就是测量 View 的宽/高值。因此 ViewGroup 的 measure 过程无法像单一 View 的 measure 过程那样可以对 onMeasure() 做统一的实现。这个也是单一 View 的 measure 过程与 ViewGroup 过程最大的不同。</p><blockquote><p>注：其实，在单一 View 的 measure 过程中，getDefaultSize() 只是简单的测量了宽高值，在实际使用时有时需更精细的测量，所以有时候也需重写 onMeasure() 方法。</p></blockquote><p>在自定义 <code>ViewGroup</code> 中，关键在于：根据需求复写 <code>onMeasure()</code> 从而实现子 View 测量逻辑。复写 <code>onMeasure()</code> 的实现如下：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 根据自身的测量逻辑复写 onMeasure()，分为3步     * 1. 遍历所有子 View 并测量：measureChildren()     * 2. 合并所有子 View 的尺寸大小,最终得到V iewGroup 父视图的测量值(自身实现)     * 3. 存储测量后 View 宽/高的值：调用 setMeasuredDimension()     *     * @param widthMeasureSpec     * @param heightMeasureSpec     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onMeasure</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 定义存放测量后的View宽/高的变量</span>        <span class="token keyword">int</span> widthMeasure<span class="token punctuation">;</span>        <span class="token keyword">int</span> heightMeasure<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 1. 遍历所有子 View 并测量：measureChildren()</span>        <span class="token comment" spellcheck="true">// ->> 分析1</span>        <span class="token function">measureChildren</span><span class="token punctuation">(</span>widthMeasureSpec<span class="token punctuation">,</span> heightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. 合并所有子View的尺寸大小，最终得到ViewGroup父视图的测量值(自身实现)</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token comment" spellcheck="true">// 3. 存储测量后View宽/高的值：调用setMeasuredDimension()</span>        <span class="token comment" spellcheck="true">// 类似单一View的过程，此处不作过多描述</span>        <span class="token function">setMeasuredDimension</span><span class="token punctuation">(</span>widthMeasure<span class="token punctuation">,</span> heightMeasure<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析1：measureChildren()     * &lt;p>     * 作用：遍历子 View 并调用 measureChild() 方法进行下一步测量     *     * @param widthMeasureSpec  父视图的宽度测量规格     * @param heightMeasureSpec 父视图的高度测量规格     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">measureChildren</span><span class="token punctuation">(</span><span class="token keyword">int</span> widthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> heightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> size <span class="token operator">=</span> mChildrenCount<span class="token punctuation">;</span>        <span class="token keyword">final</span> View<span class="token punctuation">[</span><span class="token punctuation">]</span> children <span class="token operator">=</span> mChildren<span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 遍历所有子View</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">final</span> View child <span class="token operator">=</span> children<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 调用measureChild()进行下一步的测量 ->>分析1</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>child<span class="token punctuation">.</span>mViewFlags <span class="token operator">&amp;</span> VISIBILITY_MASK<span class="token punctuation">)</span> <span class="token operator">!=</span> GONE<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">measureChild</span><span class="token punctuation">(</span>child<span class="token punctuation">,</span> widthMeasureSpec<span class="token punctuation">,</span> heightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 分析2：measureChild()     * &lt;p>     * 作用：a. 计算单个子 View 的 MeasureSpec     *      b. 测量每个子 View 最后的宽 / 高：调用子 View 的 measure()     *     * @param child 要测量的子 View     * @param parentWidthMeasureSpec 父视图的宽度测量规格     * @param parentHeightMeasureSpec 父视图的高度测量规格     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">measureChild</span><span class="token punctuation">(</span>View child<span class="token punctuation">,</span> <span class="token keyword">int</span> parentWidthMeasureSpec<span class="token punctuation">,</span> <span class="token keyword">int</span> parentHeightMeasureSpec<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 1. 获取子视图的布局参数</span>        <span class="token keyword">final</span> LayoutParams lp <span class="token operator">=</span> child<span class="token punctuation">.</span><span class="token function">getLayoutParams</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 2. 根据父视图的 MeasureSpec 和布局参数LayoutParams，计算单个子View的MeasureSpec</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> childWidthMeasureSpec <span class="token operator">=</span> <span class="token function">getChildMeasureSpec</span><span class="token punctuation">(</span>parentWidthMeasureSpec<span class="token punctuation">,</span>                mPaddingLeft <span class="token operator">+</span> mPaddingRight<span class="token punctuation">,</span> lp<span class="token punctuation">.</span>width<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> <span class="token keyword">int</span> childHeightMeasureSpec <span class="token operator">=</span> <span class="token function">getChildMeasureSpec</span><span class="token punctuation">(</span>parentHeightMeasureSpec<span class="token punctuation">,</span>                mPaddingTop <span class="token operator">+</span> mPaddingBottom<span class="token punctuation">,</span> lp<span class="token punctuation">.</span>height<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 3. 将计算好的子View的MeasureSpec值传入measure()，进行最后的测量</span>        <span class="token comment" spellcheck="true">// 下面的流程即类似单一View的过程，此处不作过多描述</span>        child<span class="token punctuation">.</span><span class="token function">measure</span><span class="token punctuation">(</span>childWidthMeasureSpec<span class="token punctuation">,</span> childHeightMeasureSpec<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">/**     * 分析3：getChildMeasureSpec()     * &lt;p>     * 作用：根据父 View 的 MeasureSpec 与子 View 的 LayoutParams 计算子 View 的 MeasureSpec     *     * @param spec           父 View 的宽/高测量规格     * @param padding        View 当前尺寸的的内边距和外边距(padding、margin)     * @param childDimension 子 View 在当前尺寸下的布局参数宽/高值     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getChildMeasureSpec</span><span class="token punctuation">(</span><span class="token keyword">int</span> spec<span class="token punctuation">,</span> <span class="token keyword">int</span> padding<span class="token punctuation">,</span> <span class="token keyword">int</span> childDimension<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 父View的模式和大小</span>        <span class="token keyword">int</span> specMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getMode</span><span class="token punctuation">(</span>spec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> specSize <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">getSize</span><span class="token punctuation">(</span>spec<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过父View计算出的子View</span>        <span class="token keyword">int</span> size <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> specSize <span class="token operator">-</span> padding<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 子View想要的实际大小和模式(需要计算)</span>        <span class="token keyword">int</span> resultSize <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> resultMode <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过父View的MeasureSpec和子View的LayoutParams属性来确定子View的大小</span>        <span class="token keyword">switch</span> <span class="token punctuation">(</span>specMode<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 当父View的模式为EXACITY时，父View为子View指定了确切的尺寸</span>            <span class="token comment" spellcheck="true">// 一般是父View设置为match_parent或者固定值的ViewGroup</span>            <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token operator">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">// 当子View的LayoutParams>0也就是有确切的值</span>                    <span class="token comment" spellcheck="true">// 子View大小为子自身所赋的值，模式大小为EXACTLY</span>                    resultSize <span class="token operator">=</span> childDimension<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">==</span> LayoutParams<span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 子View大小为父View大小，模式为EXACTLY</span>                    resultSize <span class="token operator">=</span> size<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">==</span> LayoutParams<span class="token punctuation">.</span>WRAP_CONTENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 子View决定自己的大小，但最大不能超过父View，模式为AT_MOST</span>                    resultSize <span class="token operator">=</span> size<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>AT_MOST<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当父View的模式为AT_MOST时，父View为子View指定一个最大尺寸</span>            <span class="token comment" spellcheck="true">// 一般是父View设置为wrap_content</span>            <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>AT_MOST<span class="token operator">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 子View大小为子自身所赋的值，模式大小为EXACTLY</span>                    resultSize <span class="token operator">=</span> childDimension<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">==</span> LayoutParams<span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 子View大小为父View大小，模式为AT_MOST</span>                    resultSize <span class="token operator">=</span> size<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>AT_MOST<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">==</span> LayoutParams<span class="token punctuation">.</span>WRAP_CONTENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 子View决定自己的大小，但最大不能超过父View，模式为AT_MOST</span>                    resultSize <span class="token operator">=</span> size<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>AT_MOST<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 当父View的模式为UNSPECIFIED时，父View没有给子View任何限制，子View可以设置为任意大小</span>            <span class="token comment" spellcheck="true">// 多见于ListView、GridView</span>            <span class="token keyword">case</span> MeasureSpec<span class="token punctuation">.</span>UNSPECIFIED<span class="token operator">:</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">>=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 子View大小为子自身所赋的值，模式大小为EXACTLY</span>                    resultSize <span class="token operator">=</span> childDimension<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>EXACTLY<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">==</span> LayoutParams<span class="token punctuation">.</span>MATCH_PARENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 因为父View为UNSPECIFIED，所以MATCH_PARENT的话子类大小为0</span>                    resultSize <span class="token operator">=</span> View<span class="token punctuation">.</span>sUseZeroUnspecifiedMeasureSpec <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> size<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>UNSPECIFIED<span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>childDimension <span class="token operator">==</span> LayoutParams<span class="token punctuation">.</span>WRAP_CONTENT<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token comment" spellcheck="true">// 因为父View为UNSPECIFIED，所以WRAP_CONTENT的话子类大小为0</span>                    resultSize <span class="token operator">=</span> View<span class="token punctuation">.</span>sUseZeroUnspecifiedMeasureSpec <span class="token operator">?</span> <span class="token number">0</span> <span class="token operator">:</span> size<span class="token punctuation">;</span>                    resultMode <span class="token operator">=</span> MeasureSpec<span class="token punctuation">.</span>UNSPECIFIED<span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> MeasureSpec<span class="token punctuation">.</span><span class="token function">makeMeasureSpec</span><span class="token punctuation">(</span>resultSize<span class="token punctuation">,</span> resultMode<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p><img src="https://henleylee.github.io/medias/view/view_measure_group_all.png" alt="ViewGroup的measure过程总结"></p><h2 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h2><p><img src="https://henleylee.github.io/medias/view/view_measure_all.png" alt="View的measure过程总结"></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自定义 View 之速查表</title>
      <link href="/posts/2019/c2e9266d.html"/>
      <url>/posts/2019/c2e9266d.html</url>
      
        <content type="html"><![CDATA[<h2 id="Paint-常用操作"><a href="#Paint-常用操作" class="headerlink" title="Paint 常用操作"></a>Paint 常用操作</h2><p><strong><code>android.graphics.Paint</code></strong> 表示画笔，要将图像绘制在画布上，就必须先调整画笔，画笔除了可以绘制点、线、面之外，还能通过画笔绘制文字等。</p><table><thead><tr><th>作用描述</th><th>相关 API</th><th>备注</th></tr></thead><tbody><tr><td>重置画笔</td><td>reset</td><td>将画笔恢复到默认设置</td></tr><tr><td>替换画笔</td><td>set</td><td>用新的画笔替换到当前画笔的所有属性</td></tr><tr><td>设置标志</td><td>setFlags</td><td>设置定义好的一些标志，如抗锯齿、防抖动等</td></tr><tr><td>隐藏模式</td><td>setHinting</td><td>设置画笔的隐藏模式</td></tr><tr><td>抗锯齿</td><td>setAntiAlias</td><td>设置抗锯齿效果，设置 true 则边缘会将锯齿模糊化</td></tr><tr><td>防抖动</td><td>setDither</td><td>设置防抖动，设置 true 则图片看上去会更柔和点</td></tr><tr><td>画笔样式</td><td>setStyle</td><td>设置画笔的样式，FILL 表示填充，STROKE 表示描边，FILL_AND_STROKE 表示填充加描边</td></tr><tr><td>画笔颜色</td><td>setColor、setAlpha、setARGB</td><td>设置画笔的颜色、Alpha 值、ARGB 值</td></tr><tr><td>描边样式</td><td>setStrokeWidth、setStrokeMiter、setStrokeCap、setStrokeJoin</td><td>依次为描边的宽度、斜切值、笔帽、结合方式</td></tr><tr><td>着色器</td><td>setShader</td><td>设置或清除着色器</td></tr><tr><td>阴影层</td><td>setShadowLayer、clearShadowLayer</td><td>设置、清除阴影层</td></tr><tr><td>颜色过滤器</td><td>setColorFilter</td><td>设置或清除颜料的颜色过滤器，并返回参数</td></tr><tr><td>图像混合模式</td><td>setXfermode</td><td>设置图形重叠时的处理方式，如合并，取交集或并集</td></tr><tr><td>路径效果</td><td>setPathEffect</td><td>设置绘制轮廓的路径效果，通常使用 PathEffect 的子类</td></tr><tr><td>边缘效果</td><td>setMaskFilter</td><td>设置绘制图片的边缘效果，可以有模糊和浮雕，通常使用 MaskFilter 的子类</td></tr><tr><td>字体样式</td><td>setTypeface</td><td>设置字体样式，包括粗体、斜体、衬线体、非衬线体等</td></tr><tr><td>文本变换</td><td>setTextScaleX、setTextSkewX</td><td>设置文本的缩放比例、倾斜弧度</td></tr><tr><td>文本对齐方式</td><td>setTextAlign</td><td>设置绘画的文本对齐方式</td></tr><tr><td>文本特殊效果</td><td>setUnderlineText、setStrikeThruText</td><td>设置绘制下划线、删除线</td></tr><tr><td>文本字间距</td><td>setLetterSpacing、setWordSpacing</td><td>设置文本字间距，默认为 0，前者单位为 em，后者单位为 px</td></tr><tr><td>文本测量</td><td>measureText、breakText</td><td>测量文本的宽度、字符数(如果测量的宽度超过 maxWidth，则提前停止)</td></tr></tbody></table><h2 id="Canvas-常用操作"><a href="#Canvas-常用操作" class="headerlink" title="Canvas 常用操作"></a>Canvas 常用操作</h2><p><strong><code>android.graphics.Canvas</code></strong> 表示画布，用于完成在 View 上的绘图。</p><table><thead><tr><th>作用描述</th><th>相关 API</th><th>备注</th></tr></thead><tbody><tr><td>绘制颜色</td><td>drawColor、drawRGB、drawARGB</td><td>使用单一颜色填充整个画布</td></tr><tr><td>绘制基本形状</td><td>drawPoint、drawPoints、drawLine、drawLines、drawRect、drawRoundRect、drawOval、drawCircle、drawArc</td><td>依次为点、线、矩形、圆角矩形、椭圆、圆、圆弧</td></tr><tr><td>绘制图片</td><td>drawBitmap、drawPicture</td><td>绘制位图和图片</td></tr><tr><td>绘制文本</td><td>drawText、drawPosText、drawTextOnPath</td><td>依次为绘制文字、绘制文字时指定每个文字位置、根据路径绘制文字</td></tr><tr><td>绘制路径</td><td>drawPath</td><td>绘制路径，绘制贝塞尔曲线时也需要用到该函数</td></tr><tr><td>顶点操作</td><td>drawVertices、drawBitmapMesh</td><td>通过对顶点操作可以使图像形变，drawVertices 直接对画布作用、drawBitmapMesh 只对绘制的 Bitmap 作用</td></tr><tr><td>画布剪裁</td><td>clipPath、clipRect</td><td>设置画布的显示区域</td></tr><tr><td>画布快照</td><td>save、restore、saveLayerXxx、restoreToCount、getSaveCount</td><td>依次为保存当前状态、回滚到上一次保存的状态、保存图层状态、会滚到指定状态、获取保存次数</td></tr><tr><td>画布变换</td><td>translate、scale、rotate、skew</td><td>依次为位移、缩放、旋转、错切</td></tr><tr><td>Matrix(矩阵)</td><td>getMatrix、setMatrix、concat</td><td>实际画布的位移，缩放等操作的都是图像矩阵 Matrix，只不过 Matrix 比较难以理解和使用，故封装了一些常用的方法</td></tr></tbody></table><h2 id="Path-常用操作"><a href="#Path-常用操作" class="headerlink" title="Path 常用操作"></a>Path 常用操作</h2><p><strong><code>android.graphics.Path</code></strong> 表示路径，封装了一些复合的几何路径，其中包括直线、二次曲线、三次曲线等几何路径，它可以通过 <code>canvas.drawPath(path, paint)</code> 方法完成绘图。</p><table><thead><tr><th>作用描述</th><th>相关 API</th><th>备注</th></tr></thead><tbody><tr><td>移动起点</td><td>moveTo</td><td>移动下一次操作的起点位置</td></tr><tr><td>设置终点</td><td>setLastPoint</td><td>重置当前 Path 中最后一个点位置，如果在绘制之前调用，效果和 moveTo 相同</td></tr><tr><td>连接直线</td><td>lineTo</td><td>添加上一个点到当前点之间的直线到 Path</td></tr><tr><td>闭合路径</td><td>close</td><td>连接第一个点连接到最后一个点，形成一个闭合区域</td></tr><tr><td>添加内容</td><td>addRect、addRoundRect、addOval、addCircle、addPath、addArc、arcTo</td><td>添加(矩形、圆角矩形、椭圆、圆、路径、圆弧)到当前 Path (注意 addArc 和 arcTo 的区别)</td></tr><tr><td>是否为空</td><td>isEmpty</td><td>判断 Path 是否为空</td></tr><tr><td>是否为矩形</td><td>isRect</td><td>判断 Path 是否是一个矩形</td></tr><tr><td>替换路径</td><td>set</td><td>用新的路径替换到当前路径所有内容</td></tr><tr><td>偏移路径</td><td>offset</td><td>对当前路径之前的操作进行偏移(不会影响之后的操作)</td></tr><tr><td>贝塞尔曲线</td><td>quadTo、cubicTo</td><td>分别为二次和三次贝塞尔曲线的方法</td></tr><tr><td>rXxx方法</td><td>rMoveTo、rLineTo、rQuadTo、rCubicTo</td><td>不带 r 的方法是基于原点的坐标系(偏移量)，rXxx 方法是基于当前点坐标系(偏移量)</td></tr><tr><td>填充模式</td><td>setFillType、getFillType、isInverseFillType、toggleInverseFillType</td><td>设置、获取、判断和切换填充模式</td></tr><tr><td>提示方法</td><td>incReserve</td><td>提示 Path 还有多少个点等待加入(这个方法貌似会让Path优化存储结构)</td></tr><tr><td>布尔操作</td><td>op</td><td>对两个 Path 进行布尔运算(即取交集、并集等操作)</td></tr><tr><td>计算边界</td><td>computeBounds</td><td>计算 Path 的边界</td></tr><tr><td>重置路径</td><td>reset、rewind</td><td>清除 Path 中的内容 reset 不保留内部数据结构，但会保留 FillType；rewind 会保留内部的数据结构，但不保留 FillType</td></tr><tr><td>矩阵操作</td><td>transform</td><td>矩阵变换</td></tr></tbody></table><h2 id="Matrix-常用操作"><a href="#Matrix-常用操作" class="headerlink" title="Matrix 常用操作"></a>Matrix 常用操作</h2><p><strong><code>android.graphics.Matrix</code></strong> 表示矩阵，它本身不能对图像或 View 进行变换，但它可与其他 API 结合来控制图形、View 的变换，如 <code>Canvas</code>。</p><table><thead><tr><th>作用描述</th><th>相关 API</th><th>备注</th></tr></thead><tbody><tr><td>基本方法</td><td>equals、hashCode、toString、toShortString</td><td>比较、获取哈希值、转换为字符串</td></tr><tr><td>数值操作</td><td>set、reset、setValues、getValues</td><td>设置、重置、设置数值、获取数值</td></tr><tr><td>数值计算</td><td>mapPoints、mapRadius、mapRect、mapVectors</td><td>计算变换后的数值</td></tr><tr><td>设置(set)</td><td>setConcat、setRotate、setScale、setSkew、setTranslate</td><td>设置变换</td></tr><tr><td>前乘(pre)</td><td>preConcat、preRotate、preScale、preSkew、preTranslate</td><td>前乘变换</td></tr><tr><td>后乘(post)</td><td>postConcat、postRotate、postScale、postSkew、postTranslate</td><td>后乘变换</td></tr><tr><td>特殊方法</td><td>setPolyToPoly、setRectToRect、rectStaysRect、setSinCos</td><td>一些特殊操作</td></tr><tr><td>矩阵相关</td><td>invert、isAffine(API21)、isIdentity</td><td>求逆矩阵、是否为仿射矩阵、是否为单位矩阵</td></tr></tbody></table><h2 id="贝塞尔曲线常用操作"><a href="#贝塞尔曲线常用操作" class="headerlink" title="贝塞尔曲线常用操作"></a>贝塞尔曲线常用操作</h2><p>贝塞尔曲线(<a href="https://en.wikipedia.org/wiki/B%c3%a9zier_curve" target="_blank" rel="noopener">Bézier curve</a>)，又称贝兹曲线或贝济埃曲线，是应用于二维图形应用程序的数学曲线。一般的矢量图形软件通过它来精确画出曲线，贝兹曲线由线段与节点组成，节点是可拖动的支点，线段像可伸缩的皮筋，我们在绘图工具上看到的钢笔工具就是来做这种矢量曲线的。</p><p>曲线定义：起始点、终止点(也称锚点)、控制点。通过调整控制点，贝塞尔曲线的形状会发生变化。</p><table><thead><tr><th>贝塞尔曲线</th><th>相关 API</th><th style="text-align:center">演示动画</th></tr></thead><tbody><tr><td>一阶曲线</td><td>lineTo</td><td style="text-align:center"><img src="https://henleylee.github.io/medias/bezier/bezier_1.gif" alt=""></td></tr><tr><td>二阶曲线</td><td>quadTo</td><td style="text-align:center"><img src="https://henleylee.github.io/medias/bezier/bezier_2.gif" alt=""></td></tr><tr><td>三阶曲线</td><td>cubicTo</td><td style="text-align:center"><img src="https://henleylee.github.io/medias/bezier/bezier_3.gif" alt=""></td></tr><tr><td>四阶曲线</td><td>无</td><td style="text-align:center"><img src="https://henleylee.github.io/medias/bezier/bezier_4.gif" alt=""></td></tr><tr><td>五阶曲线</td><td>无</td><td style="text-align:center"><img src="https://henleylee.github.io/medias/bezier/bezier_5.gif" alt=""></td></tr></tbody></table><h3 id="原理和公式"><a href="#原理和公式" class="headerlink" title="原理和公式"></a>原理和公式</h3><p>下面介绍一下贝塞尔曲线的原理和公式：<br>以下公式中：<code>B(t)</code>为 <code>t</code> 时间下点的坐标；<code>P0</code> 为起点，<code>Pn</code> 为终点，<code>Pi</code> 为控制点。</p><h4 id="一阶贝塞尔曲线-线段"><a href="#一阶贝塞尔曲线-线段" class="headerlink" title="一阶贝塞尔曲线(线段)"></a>一阶贝塞尔曲线(线段)</h4><p><img src="https://henleylee.github.io/medias/bezier/bezier_1.png" alt=""><br><img src="https://henleylee.github.io/medias/bezier/bezier_1.gif" alt=""><br>原理：由 P0 至 P1 的连续点， 描述的一条线段</p><h4 id="二阶贝塞尔曲线-抛物线"><a href="#二阶贝塞尔曲线-抛物线" class="headerlink" title="二阶贝塞尔曲线(抛物线)"></a>二阶贝塞尔曲线(抛物线)</h4><p><img src="https://henleylee.github.io/medias/bezier/bezier_2.png" alt=""><br><img src="https://henleylee.github.io/medias/bezier/bezier_2.gif" alt=""><br>原理：由 P0 至 P1 的连续点 Q0，描述一条线段。<br>      由 P1 至 P2 的连续点 Q1，描述一条线段。<br>      由 Q0 至 Q1 的连续点 B(t)，描述一条二次贝塞尔曲线。</p><p>经验：P1-P0为曲线在P0处的切线。</p><h4 id="三阶贝塞尔曲线"><a href="#三阶贝塞尔曲线" class="headerlink" title="三阶贝塞尔曲线"></a>三阶贝塞尔曲线</h4><p><img src="https://henleylee.github.io/medias/bezier/bezier_3.png" alt=""><br><img src="https://henleylee.github.io/medias/bezier/bezier_3.gif" alt=""></p><h4 id="四阶贝塞尔曲线"><a href="#四阶贝塞尔曲线" class="headerlink" title="四阶贝塞尔曲线"></a>四阶贝塞尔曲线</h4><p><img src="https://henleylee.github.io/medias/bezier/bezier_4.gif" alt=""></p><h4 id="五阶贝塞尔曲线"><a href="#五阶贝塞尔曲线" class="headerlink" title="五阶贝塞尔曲线"></a>五阶贝塞尔曲线</h4><p><img src="https://henleylee.github.io/medias/bezier/bezier_5.gif" alt=""></p><h4 id="通用公式"><a href="#通用公式" class="headerlink" title="通用公式"></a>通用公式</h4><p><img src="https://henleylee.github.io/medias/bezier/bezier_common.png" alt=""></p><h3 id="工具网站"><a href="#工具网站" class="headerlink" title="工具网站"></a>工具网站</h3><ul><li><a href="http://cubic-bezier.com/" target="_blank" rel="noopener">cubic-bezier</a></li><li><a href="http://myst729.github.io/bezier-curve/" target="_blank" rel="noopener">bezier-curve</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自定义 View 之基础</title>
      <link href="/posts/2019/55df9ec1.html"/>
      <url>/posts/2019/55df9ec1.html</url>
      
        <content type="html"><![CDATA[<h2 id="View-的分类"><a href="#View-的分类" class="headerlink" title="View 的分类"></a>View 的分类</h2><p>视图 View 主要分为两类：</p><table><thead><tr><th style="text-align:center">类别</th><th style="text-align:center">解释</th><th style="text-align:left">特点</th></tr></thead><tbody><tr><td style="text-align:center">单一视图</td><td style="text-align:center">即一个View，如 TextView</td><td style="text-align:left">不包含子 View</td></tr><tr><td style="text-align:center">视图容器</td><td style="text-align:center">即多个 View 组成的 ViewGroup，如 LinearLayout</td><td style="text-align:left">包含子 View</td></tr></tbody></table><h2 id="View-类简介"><a href="#View-类简介" class="headerlink" title="View 类简介"></a>View 类简介</h2><ul><li>View 类是 Android 中各种组件的基类，如 View 是 ViewGroup 的基类。</li><li>View 表现为显示在屏幕上的各种视图，在屏幕上占据一个矩形区域，负责绘图和事件处理。<blockquote><p>Android 中的 UI 组件都由 View、ViewGroup 组成。</p></blockquote></li><li><p>View 的构造函数：共有4个，具体如下：</p><pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomView</span> <span class="token keyword">extends</span> <span class="token class-name">View</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 如果View是在Java代码里面new的，则调用第一个构造函数</span>     <span class="token keyword">public</span> <span class="token function">CustomView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 如果View是在xml里声明的，则调用第二个构造函数，自定义属性是从AttributeSet参数传进来的</span>     <span class="token keyword">public</span> <span class="token function">CustomView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> AttributeSet attrs<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 不会自动调用，一般是在第二个构造函数里主动调用，如View有style属性时</span>     <span class="token keyword">public</span> <span class="token function">CustomView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> AttributeSet attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> defStyleAttr<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> defStyleAttr<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token comment" spellcheck="true">// 不会自动调用，一般是在第二个构造函数里主动调用，如View有style属性时(API21之后才使用)</span>     <span class="token keyword">public</span> <span class="token function">CustomView</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> AttributeSet attrs<span class="token punctuation">,</span> <span class="token keyword">int</span> defStyleAttr<span class="token punctuation">,</span> <span class="token keyword">int</span> defStyleRes<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">super</span><span class="token punctuation">(</span>context<span class="token punctuation">,</span> attrs<span class="token punctuation">,</span> defStyleAttr<span class="token punctuation">,</span> defStyleRes<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre><blockquote><p>自定义 View 必须重写至少一个构造函数。</p></blockquote></li></ul><h2 id="View-视图结构"><a href="#View-视图结构" class="headerlink" title="View 视图结构"></a>View 视图结构</h2><p>对于多 View 的视图，结构是<strong><code>树形结构</code></strong>：最顶层是 ViewGroup，ViewGroup 下可能有多个 ViewGroup 或 View，如下图：<br><img src="https://henleylee.github.io/medias/view/view_structure.png" alt="View 视图结构"></p><blockquote><p>无论是 measure 过程、layout 过程还是 draw 过程，<strong>永远都是从 View 树的根节点开始测量或计算（即从树的顶端开始），一层一层、一个分支一个分支地进行（即树形递归）</strong>，最终计算整个 View 树中各个 View，最终确定整个 View 树的相关属性。</p></blockquote><h2 id="Android-坐标系"><a href="#Android-坐标系" class="headerlink" title="Android 坐标系"></a>Android 坐标系</h2><p>Android 的坐标系定义为：</p><ul><li>屏幕的左上角为坐标原点；</li><li>向右为 X 轴增大方向；</li><li>向下为 Y 轴增大方向。</li></ul><p>具体如下图：<br><img src="https://henleylee.github.io/medias/view/android_coordinate_system.png" alt="Android 坐标系"></p><p>区别于一般的数学坐标系：<br><img src="https://henleylee.github.io/medias/view/other_coordinate_system.png" alt="其他坐标系"></p><h3 id="View-位置描述"><a href="#View-位置描述" class="headerlink" title="View 位置描述"></a>View 位置描述</h3><p>View 的位置由4个顶点决定的（如下A、B、C、D）：<br><img src="https://henleylee.github.io/medias/view/view_location.png" alt="View 位置"></p><p>4个顶点的位置描述分别由4个值决定：</p><ul><li>Top：子 View 上边界到父 View 上边界的距离；</li><li>Left：子 View 左边界到父 View 左边界的距离；</li><li>Bottom：子 View 下边距到父 View 上边界的距离；</li><li>Right：子 View 右边界到父 View 左边界的距离。</li></ul><p>如下图：<br><img src="https://henleylee.github.io/medias/view/view_location_get.png" alt="View 位置"><br>可以按顶点位置来记忆：</p><ul><li>Top：子 View 左上角距父 View 顶部的距离；</li><li>Left：子 View 左上角距父 View 左侧的距离；</li><li>Bottom：子 View 右下角距父 View 顶部的距离；</li><li>Right：子 View 右下角距父 View 左侧的距离。</li></ul><blockquote><p>View 的位置是相对于父控件而言的。</p></blockquote><h3 id="View-位置获取方式"><a href="#View-位置获取方式" class="headerlink" title="View 位置获取方式"></a>View 位置获取方式</h3><ul><li><p>View的位置是通过 <code>view.getxxx()</code> 函数进行获取：</p><pre class=" language-java"><code class="language-java"> <span class="token function">getTop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取子 View 左上角距父 View 顶部的距离</span> <span class="token function">getLeft</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 获取子 View 左上角距父 View 左侧的距离</span> <span class="token function">getBottom</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 获取子 View 右下角距父 View 顶部的距离</span> <span class="token function">getRight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 获取子 View 右下角距父 View 左侧的距离</span></code></pre></li><li><p>与 MotionEvent 中 <code>get()</code> 和 <code>getRaw()</code> 的区别：</p><pre class=" language-java"><code class="language-java"> <span class="token comment" spellcheck="true">// get() ：触摸点相对于其所在组件坐标系的坐标</span> event<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        event<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// getRaw() ：触摸点相对于屏幕默认坐标系的坐标</span> event<span class="token punctuation">.</span><span class="token function">getRawX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     event<span class="token punctuation">.</span><span class="token function">getRawY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>具体如下图所示：<br><img src="https://henleylee.github.io/medias/view/motion_event_location_get.png" alt="MotionEvent 坐标"></p></li></ul><h2 id="Android-的角度与弧度"><a href="#Android-的角度与弧度" class="headerlink" title="Android 的角度与弧度"></a>Android 的角度与弧度</h2><ul><li>自定义 View 实际上是将一些简单的形状通过计算，从而组合到一起形成的效果。<blockquote><p>这会涉及到画布的相关操作(旋转)、正余弦函数计算等，即会涉及到角度(angle)与弧度(radian)的相关知识。</p></blockquote></li><li>角度和弧度都是描述角的一种度量单位，区别如下图：<br><img src="https://henleylee.github.io/medias/view/differ_angle_radian.png" alt="角度与弧度的区别"></li></ul><p>在默认的屏幕坐标系中角度增大方向为顺时针。<br><img src="https://henleylee.github.io/medias/view/angle_increase_direction.png" alt="角度增大方向"></p><blockquote><p>注：在常见的数学坐标系中角度增大方向为逆时针。</p></blockquote><h2 id="Android-中的颜色"><a href="#Android-中的颜色" class="headerlink" title="Android 中的颜色"></a>Android 中的颜色</h2><p>Android 中的颜色值通常遵循 <code>RGB/ARGB</code> 标准，使用时通常以 <code>#</code> 字符开头，以<code>16进制</code>表示。 </p><ul><li><strong><code>RGB</code></strong>依次代表红色(Red)、绿色(Green)、蓝色(Blue)。</li><li><strong><code>ARGB</code></strong>依次代表透明度(Alpha)、红色(Red)、绿色(Green)、蓝色(Blue)。</li></ul><blockquote><p>eg: <code>#FF00CC99</code> 其中FF是透明度，00是红色值，CC是绿色值，99是蓝色值。</p></blockquote><h3 id="颜色模式"><a href="#颜色模式" class="headerlink" title="颜色模式"></a>颜色模式</h3><p>Android 支持的颜色模式有以下几种：</p><table><thead><tr><th>颜色模式</th><th>描述</th></tr></thead><tbody><tr><td><code>ARGB8888</code></td><td>四通道高精度(32位)</td></tr><tr><td><code>ARGB4444</code></td><td>四通道低精度(24位)</td></tr><tr><td><code>RGB565</code></td><td>屏幕默认模式(16位)</td></tr><tr><td><code>Alpha8</code></td><td>仅有透明通道(8位)</td></tr></tbody></table><blockquote><p>其中字母表示通道类型，数值表示该类型用多少位二进制来描述。如 <code>ARGB8888</code> 则表示有四个通道(ARGB)，每个对应的通道均用 <code>8</code> 位来描述。</p></blockquote><blockquote><p><strong>注意：</strong>我们常用的是 <code>ARGB8888</code> 和 <code>ARGB4444</code>，而在所有的安卓设备屏幕上默认的模式都是 <code>RGB565</code>。</p></blockquote><p>以 <code>ARGB8888</code> 为例介绍颜色定义：</p><table><thead><tr><th>类型</th><th>解释</th><th>0(0x00)</th><th>255(0xFF)</th></tr></thead><tbody><tr><td><code>A(Alpha)</code></td><td>透明度</td><td>透明</td><td>不透明</td></tr><tr><td><code>R(Red)</code></td><td>红色</td><td>无色</td><td>红色</td></tr><tr><td><code>G(Green)</code></td><td>绿色</td><td>无色</td><td>绿色</td></tr><tr><td><code>B(Blue)</code></td><td>蓝色</td><td>无色</td><td>蓝色</td></tr></tbody></table><p>其中 <code>A</code> <code>R</code> <code>G</code> <code>B</code> 的取值范围均为<code>0~255</code>(即16进制的<code>0x00~0xFF</code>)：</p><ul><li><strong><code>A：</code></strong>从<code>00</code>到<code>FF</code>表示从透明到不透明。</li><li><strong><code>RGB：</code></strong>从<code>00</code>到<code>FF</code>表示颜色从浅到深。</li></ul><blockquote><p>当 <code>RGB</code>全取最小值(<code>0</code>或<code>0x000000</code>)时颜色为<strong>黑色</strong>，全取最大值(<code>255</code>或<code>0xFFFFFF</code>)时颜色为<strong>白色</strong>。</p></blockquote><h3 id="颜色定义"><a href="#颜色定义" class="headerlink" title="颜色定义"></a>颜色定义</h3><h4 id="在-Java-中定义颜色"><a href="#在-Java-中定义颜色" class="headerlink" title="在 Java 中定义颜色"></a>在 Java 中定义颜色</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 使用Color类定义颜色</span><span class="token keyword">int</span> color <span class="token operator">=</span> Color<span class="token punctuation">.</span>GRAY<span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 灰色</span><span class="token comment" spellcheck="true">// 使用ARGB值进行表示</span><span class="token keyword">int</span> color <span class="token operator">=</span> Color<span class="token punctuation">.</span><span class="token function">argb</span><span class="token punctuation">(</span><span class="token number">127</span><span class="token punctuation">,</span> <span class="token number">255</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 半透明红色</span><span class="token keyword">int</span> color <span class="token operator">=</span> <span class="token number">0xaaff0000</span><span class="token punctuation">;</span>                   <span class="token comment" spellcheck="true">// 带有透明度的红色</span></code></pre><h4 id="在-xml-中定义颜色"><a href="#在-xml-中定义颜色" class="headerlink" title="在 xml 中定义颜色"></a>在 xml 中定义颜色</h4><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 定义了红色（没有alpha（透明）通道）--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#ff0000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span>    <span class="token comment" spellcheck="true">&lt;!-- 定义了蓝色（没有alpha（透明）通道）--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00ff00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre><p>在 xml 文件中以 <code>#</code> 开头定义颜色，后面跟十六进制的值，有如下几种定义方式：</p><pre><code>#f00            // 低精度 - 不带透明通道红色#af00           // 低精度 - 带透明通道红色#ff0000         // 高精度 - 不带透明通道红色#aaff0000       // 高精度 - 带透明通道红色</code></pre><h3 id="颜色引用"><a href="#颜色引用" class="headerlink" title="颜色引用"></a>颜色引用</h3><h4 id="在-Java-中引用-xml-中定义的颜色"><a href="#在-Java-中引用-xml-中定义的颜色" class="headerlink" title="在 Java 中引用 xml 中定义的颜色"></a>在 Java 中引用 xml 中定义的颜色</h4><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">//方法1</span><span class="token keyword">int</span> color <span class="token operator">=</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getColor</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>color<span class="token punctuation">.</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">//方法2（API 23及以上）</span><span class="token keyword">int</span> color <span class="token operator">=</span> <span class="token function">getColor</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>color<span class="token punctuation">.</span>red<span class="token punctuation">)</span><span class="token punctuation">;</span> </code></pre><h4 id="在-xml-文件-layout或style-中引用或定义颜色"><a href="#在-xml-文件-layout或style-中引用或定义颜色" class="headerlink" title="在 xml 文件(layout或style)中引用或定义颜色"></a>在 xml 文件(layout或style)中引用或定义颜色</h4><pre class=" language-xml"><code class="language-xml"><span class="token comment" spellcheck="true">&lt;!--在style文件中引用--></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>style</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>AppTheme<span class="token punctuation">"</span></span> <span class="token attr-name">parent</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>Theme.AppCompat.Light.DarkActionBar<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token style language-css">    &lt;item name=<span class="token string">"colorPrimary"</span>>@color/red&lt;/item></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>style</span><span class="token punctuation">></span></span><span class="token comment" spellcheck="true">&lt;!--在layout文件中引用在/res/values/color.xml中定义的颜色--></span>android:background="@color/red"<span class="token comment" spellcheck="true">&lt;!--在layout文件中创建并使用颜色--></span>android:background="#ff0000"</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Gradle 学习之 Android DSL 扩展</title>
      <link href="/posts/2018/5b2977c1.html"/>
      <url>/posts/2018/5b2977c1.html</url>
      
        <content type="html"><![CDATA[<p>在 Android 项目的每个 Module 中的  build.gradle 配置文件中都有一个名称为 <code>android</code> 的函数，该函数接收闭包作为参数，然而其实在 <a href="https://docs.gradle.org/current/dsl/org.gradle.api.invocation.Gradle.html" target="_blank" rel="noopener">Gradle API 文档</a>中是不存在这个函数的。</p><p>那么 <code>android</code> 函数怎么会出现在这里呢？答案就是 <code>apply plugin: &#39;com.android.application&#39;</code>。这个插件提供了 Android 构建所需要的各种 script。 </p><p><a href="http://google.github.io/android-gradle-dsl/" target="_blank" rel="noopener">Android Plugin DSL Reference</a>：Android 插件 DSL 扩展文档，各个版本的都有。 </p><h2 id="Gradle-扩展类型"><a href="#Gradle-扩展类型" class="headerlink" title="Gradle 扩展类型"></a>Gradle 扩展类型</h2><p><code>BaseExtension</code> 是所有 Android 插件的基本扩展，使用过程中不直接使用此扩展，而是使用以下之一：</p><ul><li><strong><code>AppExtension：</code></strong>用于构建 <code>Android app module</code> 的 <code>com.android.application</code> 插件扩展。</li><li><strong><code>LibraryExtension：</code></strong>用于构建 <code>Android library module</code> 的 <code>com.android.library</code> 插件扩展。</li><li><strong><code>TestExtension：</code></strong>用于构建 <code>Android test module</code> 的 <code>com.android.test</code> 插件扩展。</li><li><strong><code>FeatureExtension：</code></strong>用于构建 <code>Android Instant Apps</code> 的 <code>com.android.feature</code> 插件扩展。</li></ul><h2 id="Gradle-通用配置块"><a href="#Gradle-通用配置块" class="headerlink" title="Gradle 通用配置块"></a>Gradle 通用配置块</h2><p>Android Plugin 一些通用的 Script blocks，对于以上四种类型的扩展都支持。</p><h3 id="defaultConfig"><a href="#defaultConfig" class="headerlink" title="defaultConfig"></a>defaultConfig</h3><p><strong><code>defaultConfig{}</code></strong> 闭包用于配置 Android 插件应用于所有构建变体的变体属性。DSL 对象为 <code>DefaultConfig</code>。</p><p><code>DefaultConfig</code> 具有以下属性：</p><ul><li><strong><code>applicationId：</code></strong>应用程序ID。</li><li><strong><code>applicationIdSuffix：</code></strong>应用程序ID后缀。</li><li><strong><code>consumerProguardFiles：</code></strong>包含在发布的 AAR 中的 ProGuard 规则文件。</li><li><strong><code>dimension：</code></strong>指定 product flavor 所属的 flavor 维度。</li><li><strong><code>externalNativeBuild：</code></strong>指定使用 CMake 或 ndk-build 的外部 native 构建选项。</li><li><strong><code>javaCompileOptions：</code></strong>配置 Java 编译器选项。</li><li><strong><code>manifestPlaceholders：</code></strong>清单占位符。</li><li><strong><code>multiDexEnabled：</code></strong>是否为此变体启用 Multi-Dex。</li><li><strong><code>multiDexKeepFile：</code></strong>文本文件，指定将编译到主 dex 文件中的其他类。</li><li><strong><code>multiDexKeepProguard：</code></strong>带有其他 ProGuard 规则的文本文件，用于确定将哪些类编译到主 dex 文件中。</li><li><strong><code>ndk：</code></strong>封装 NDK 的每个变体配置，例如 ABI 过滤器。</li><li><strong><code>proguardFiles：</code></strong>指定插件应使用的 ProGuard 配置文件。</li><li><strong><code>signingConfig：</code></strong>签署此产品风格使用的配置。</li><li><strong><code>testApplicationId：</code></strong>测试应用程序 ID。</li><li><strong><code>testInstrumentationRunner：</code></strong>测试仪器运行器类名称。</li><li><strong><code>testInstrumentationRunnerArguments：</code></strong>测试仪器运行器自定义参数。</li><li><strong><code>vectorDrawables：</code></strong>用于配置 VectorDrawable 的构建时支持的选项。</li><li><strong><code>versionCode：</code></strong>版本号。</li><li><strong><code>versionName：</code></strong>版本名称。</li><li><strong><code>versionNameSuffix：</code></strong>版本名称后缀。</li><li><strong><code>wearAppUnbundled：</code></strong>返回是否为嵌入式磨损应用启用非捆绑模式。如果为true，则可以使应用程序从嵌入式磨损应用程序转换为直接由Play商店分发的应用程序。</li></ul><h3 id="compileOptions"><a href="#compileOptions" class="headerlink" title="compileOptions"></a>compileOptions</h3><p><strong><code>compileOptions{}</code></strong> 闭包用于配置 Java 编译器选项。DSL 对象为 <code>CompileOptions</code>。</p><p><code>CompileOptions</code> 具有以下属性：</p><ul><li><strong><code>encoding：</code></strong>Java 源文件编码。</li><li><strong><code>incremental：</code></strong>Java 编译是否应该使用 Gradle 的新增量模型。</li><li><strong><code>sourceCompatibility：</code></strong>Java 源代码的语言级别。</li><li><strong><code>targetCompatibility：</code></strong>生成的 Java 字节码的版本。</li></ul><h3 id="dexOptions"><a href="#dexOptions" class="headerlink" title="dexOptions"></a>dexOptions</h3><p><strong><code>dexOptions{}</code></strong> 闭包用于配置 DEX 工具选项。DSL 对象为 <code>DexOptions</code>。</p><p><code>DexOptions</code> 具有以下属性：</p><ul><li><strong><code>additionalParameters：</code></strong>要传递给 dx 的附加参数列表。</li><li><strong><code>javaMaxHeapSize：</code></strong>指定调用 dx 时的 -Xmx 值。</li><li><strong><code>jumboMode：</code></strong>是否在 dx(–force-jumbo) 中启用 jumbo 模式。</li><li><strong><code>keepRuntimeAnnotatedClasses：</code></strong>在遗留 multidex 的主 dex 中保留所有具有运行时注解的类。</li><li><strong><code>maxProcessCount：</code></strong>可用于 dex 的最大并发进程数(默认为 4)。</li><li><strong><code>preDexLibraries：</code></strong>是否预先 dex 库。这可以改善增量构建，但是干净的构建可能会更慢。</li><li><strong><code>threadCount：</code></strong>运行 dx 时要使用的线程数(默认为 4)。</li></ul><h3 id="aaptOptions"><a href="#aaptOptions" class="headerlink" title="aaptOptions"></a>aaptOptions</h3><p><strong><code>aaptOptions{}</code></strong> 闭包用于配置 Android Asset Packaging Tool(AAPT)的选项。DSL 对象为 <code>AaptOptions</code>。</p><p><code>AaptOptions</code> 具有以下属性：</p><ul><li><strong><code>additionalParameters：</code></strong>要传递给 aapt 的参数列表。</li><li><strong><code>cruncherEnabled：</code></strong>是否要处理 PNG(已弃用)。</li><li><strong><code>cruncherProcesses：</code></strong>获得要使用的 cruncher 进程数(更多的 cruncher 进程会更快地处理文件，但需要更多的内存和CPU)。</li><li><strong><code>failOnMissingConfigEntry：</code></strong>如果找不到配置条目，则强制 aapt 返回错误。</li><li><strong><code>ignoreAssets：</code></strong>指定要忽略的资产的模式。</li><li><strong><code>ignoreAssetsPattern：</code></strong>指定要忽略的资产的模式。</li><li><strong><code>noCompress：</code></strong>不会在APK中压缩存储的文件的扩展名(添加空扩展名，即设置为<code>&#39;&#39;</code>将禁用所有文件的压缩)。</li></ul><h3 id="adbOptions"><a href="#adbOptions" class="headerlink" title="adbOptions"></a>adbOptions</h3><p><strong><code>adbOptions{}</code></strong> 闭包用于配置 Android Debug Bridge(ADB)的选项。DSL 对象为 <code>AdbOptions</code>。</p><p><code>AdbOptions</code> 具有以下属性：</p><ul><li><strong><code>installOptions：</code></strong>配置 FULL_APK 安装选项列表。</li><li><strong><code>timeOutInMs：</code></strong>配置用于所有 ADB 操作的超时时间。</li></ul><h3 id="dataBinding"><a href="#dataBinding" class="headerlink" title="dataBinding"></a>dataBinding</h3><p><strong><code>dataBinding{}</code></strong> 闭包用于配置数据绑定库的选项。DSL 对象为 <code>DataBindingOptions</code>。</p><p><code>DataBindingOptions</code> 具有以下属性：</p><ul><li><strong><code>addDefaultAdapters：</code></strong>是否添加默认数据绑定适配器。</li><li><strong><code>enabled：</code></strong>是否启用数据绑定。</li><li><strong><code>enabledForTests：</code></strong>是否为测试项目运行数据绑定代码生成</li><li><strong><code>version：</code></strong>要使用的数据绑定版本。</li></ul><h3 id="externalNativeBuild"><a href="#externalNativeBuild" class="headerlink" title="externalNativeBuild"></a>externalNativeBuild</h3><p><strong><code>externalNativeBuild{}</code></strong> 闭包用于配置使用 CMake 或 ndk-build 的外部 native 构建选项。DSL 对象为 <code>ExternalNativeBuild</code>。</p><p><code>ExternalNativeBuild</code> 具有以下属性：</p><ul><li><strong><code>cmake：</code></strong>配置 CMake 构建选项。</li><li><strong><code>ndkBuild：</code></strong>配置 ndk-build 选项。</li></ul><h3 id="lintOptions"><a href="#lintOptions" class="headerlink" title="lintOptions"></a>lintOptions</h3><p><strong><code>lintOptions{}</code></strong> 闭包用于配置 lint 工具的选项。DSL 对象为 <code>LintOptions</code>。</p><p><code>LintOptions</code> 具有以下属性：</p><ul><li><strong><code>abortOnError：</code></strong>lint 是否应该在发现错误时设置进程的退出代码</li><li><strong><code>absolutePaths：</code></strong>lint 是否应在错误输出中显示完整路径(默认情况下，路径相对于从中调用 lint 的路径)。</li><li><strong><code>check：</code></strong>要检查的确切问题集，或者为 null 以运行默认启用的问题以及通过 LintOptions.getEnable() 和不通过问题禁用的任何问题 LintOptions.getDisable()。如果为非 null，则允许调用者修改此集合。</li><li><strong><code>checkAllWarnings：</code></strong>返回 lint 是否应检查所有警告，包括默认情况下关闭的警告。</li><li><strong><code>checkReleaseBuilds：</code></strong>返回 lint 是否应在发布版本期间检查致命错误(默认为 true)。如果找到严重性为 fatal 的问题，则会中止发布版本。</li><li><strong><code>disable：</code></strong>要解决的问题 ID 集。允许呼叫者修改此集合。</li><li><strong><code>enable：</code></strong>要启用的问题 ID 集。允许呼叫者修改此集合。要启用给定问题，请将问题 ID 添加到返回的集。</li><li><strong><code>explainIssues：</code></strong>返回 lint 是否应包含问题错误的解释(请注意，HTML 和 XML 报告有意无条件地执行此操作，忽略此设置)。</li><li><strong><code>htmlOutput：</code></strong>指定写入 HTML 报告的可选路径。</li><li><strong><code>htmlReport：</code></strong>是否应该编写 HTML 报告(默认为 true)。</li><li><strong><code>ignoreWarnings：</code></strong>返回 lint 是否仅检查错误(忽略警告)。</li><li><strong><code>lintConfig：</code></strong>用作回退的默认配置文件。</li><li><strong><code>noLines：</code></strong>lint 是否应在输出中包含发生错误的源行(默认为 true)。</li><li><strong><code>quiet：</code></strong>返回 lint 是否应该是安静的(例如，不写信息性消息，例如写入报告文件的路径)。</li><li><strong><code>severityOverrides：</code></strong>严重性覆盖的可选映射。映射从问题 ID 映射到要使用的相应严重性，必须是 fatal、error、warning 或 ignore。</li><li><strong><code>showAll：</code></strong>返回 lint 是否应包含所有输出(例如，包括所有备用位置，不截断长消息等)。</li><li><strong><code>textOutput：</code></strong>指定写入文本报告的可选路径。特殊值 stdout 可用于指向标准输出。</li><li><strong><code>textReport：</code></strong>我们是否应该撰写文本报告(默认为 false)。</li><li><strong><code>warningsAsErrors：</code></strong>返回 lint 是否应将所有警告视为错误。</li><li><strong><code>xmlOutput：</code></strong>指定写入 XML 报告的可选路径</li><li><strong><code>xmlReport：</code></strong>我们是否应该编写XML报告(默认为 true)。</li></ul><h3 id="sourceSets"><a href="#sourceSets" class="headerlink" title="sourceSets"></a>sourceSets</h3><p><strong><code>sourceSets{}</code></strong> 闭包用于配置所有变体的源集。DSL 对象为 <code>NamedDomainObjectContainer&lt;AndroidSourceSet&gt;</code>。</p><p><code>AndroidSourceSet</code> 具有以下属性：</p><ul><li><strong><code>name：</code></strong>此源集的名称。</li><li><strong><code>aidl：</code></strong>此源集的 Android AIDL 源目录。</li><li><strong><code>assets：</code></strong>此源集的 Android Assets 目录。</li><li><strong><code>java：</code></strong>将由 Java 编译器编译到类输出目录中的 Java 源代码。</li><li><strong><code>jni：</code></strong>此源集的 Android JNI 源目录。</li><li><strong><code>jniLibs：</code></strong>此源集的 Android JNI libs 目录。</li><li><strong><code>manifest：</code></strong>此源集的 Android Manifest 文件。</li><li><strong><code>renderscript：</code></strong>此源集的 Android RenderScript 源目录。</li><li><strong><code>res：</code></strong>此源集的 Android 资源目录。</li><li><strong><code>resources：</code></strong>要复制到 javaResources 输出目录中的 Java 资源。</li><li><strong><code>compileConfigurationName：</code></strong>此源集的编译配置的名称(已弃用)。</li><li><strong><code>packageConfigurationName：</code></strong>此源集的运行时配置的名称(已弃用)。</li><li><strong><code>providedConfigurationName：</code></strong>此源集的仅编译配置的名称(已弃用)。</li></ul><h3 id="packagingOptions"><a href="#packagingOptions" class="headerlink" title="packagingOptions"></a>packagingOptions</h3><p><strong><code>packagingOptions{}</code></strong> 闭包用于配置 APK 打包选项。DSL 对象为 <code>PackagingOptions</code>。</p><p><code>PackagingOptions</code> 具有以下属性：</p><ul><li><strong><code>doNotStrip：</code></strong>不应删除调试符号的 native 库模式列表。</li><li><strong><code>excludes：</code></strong>排除路径列表。</li><li><strong><code>merges：</code></strong>在 APK 中连接并打包所有出现的模式的列表。</li><li><strong><code>pickFirsts：</code></strong>选择第一个出现在 APK 中的模式列表。第一个选择模式确实打包在 APK 中，但是只有第一个出现的模式被打包。</li></ul><h3 id="signingConfigs"><a href="#signingConfigs" class="headerlink" title="signingConfigs"></a>signingConfigs</h3><p><strong><code>signingConfigs{}</code></strong> 闭包用于配置可以应用于BuildType和ProductFlavor配置的签名信息。DSL 对象为 <code>NamedDomainObjectContainer&lt;SigningConfig&gt;</code>。</p><p><code>SigningConfig</code> 具有以下属性：</p><ul><li><strong><code>storeFile：</code></strong>存储签名时使用的文件。</li><li><strong><code>storePassword：</code></strong>存储签名时使用的密码。</li><li><strong><code>storeType：</code></strong>签名时使用的存储类型。</li><li><strong><code>keyAlias：</code></strong>签名时使用的密钥别名。</li><li><strong><code>keyPassword：</code></strong>签名时使用的密钥密码。</li><li><strong><code>v1SigningEnabled：</code></strong>是否启用了使用 JAR 签名方案(即 V1签名)进行签名。</li><li><strong><code>v2SigningEnabled：</code></strong>是否启用了使用 APK 签名方案(即 V2签名)进行签名。</li></ul><h3 id="buildTypes"><a href="#buildTypes" class="headerlink" title="buildTypes"></a>buildTypes</h3><p><strong><code>buildTypes{}</code></strong> 闭包用于配置项目的所有构建类型。DSL 对象为 <code>NamedDomainObjectContainer&lt;BuildType&gt;</code>。</p><p><code>BuildType</code> 具有以下属性：</p><ul><li><strong><code>applicationIdSuffix：</code></strong>应用程序 ID 后缀。</li><li><strong><code>consumerProguardFiles：</code></strong>包含在发布的 AAR 中的 ProGuard 规则文件。</li><li><strong><code>crunchPngs：</code></strong>是否要处理 PNG。</li><li><strong><code>debuggable：</code></strong>此构建类型是否应生成可调试的 APK。</li><li><strong><code>embedMicroApp：</code></strong>是否应使用此构建类型将链接的 Android Wear 应用程序嵌入到 Variant 中。</li><li><strong><code>javaCompileOptions：</code></strong>配置 Java 编译器选项。</li><li><strong><code>jniDebuggable：</code></strong>是否将此构建类型配置为生成具有可调试 JNI 代码的 APK。</li><li><strong><code>manifestPlaceholders：</code></strong>清单占位符。</li><li><strong><code>matchingFallbacks：</code></strong>指定当直接变体与本地模块依赖项不匹配时插件应尝试使用的构建类型的排序列表。</li><li><strong><code>minifyEnabled：</code></strong>是否启用删除未使用的 Java 代码。</li><li><strong><code>multiDexEnabled：</code></strong>是否为此变体启用了 Multi-Dex。</li><li><strong><code>multiDexKeepFile：</code></strong>文本文件，指定将编译到主 dex 文件中的其他类。</li><li><strong><code>multiDexKeepProguard：</code></strong>带有其他 ProGuard 规则的文本文件，用于确定将哪些类编译到主 dex 文件中。</li><li><strong><code>name：</code></strong>此构建类型的名称。</li><li><strong><code>proguardFiles：</code></strong>指定插件应使用的ProGuard配置文件。</li><li><strong><code>pseudoLocalesEnabled：</code></strong>指定插件是否应为pseudolocales生成资源。</li><li><strong><code>renderscriptDebuggable：</code></strong>是否将构建类型配置为生成具有可调试 RenderScript 代码的 APK。</li><li><strong><code>renderscriptOptimLevel：</code></strong>renderscript编译器使用的优化级别。</li><li><strong><code>shrinkResources：</code></strong>是否启用了未使用资源的缩减。默认为 false;</li><li><strong><code>signingConfig：</code></strong>签名配置。</li><li><strong><code>testCoverageEnabled：</code></strong>是否为此构建类型启用了测试覆盖率。</li><li><strong><code>useProguard：</code></strong>指定是否始终使用 ProGuard 进行代码和资源收缩。</li><li><strong><code>versionNameSuffix：</code></strong>版本名称后缀。</li><li><strong><code>zipAlignEnabled：</code></strong>是否为此构建类型启用了 ZipAlign。</li></ul><h3 id="productFlavors"><a href="#productFlavors" class="headerlink" title="productFlavors"></a>productFlavors</h3><p><strong><code>productFlavors{}</code></strong> 闭包用于配置项目的所有产品风味。DSL 对象为 <code>NamedDomainObjectContainer&lt;ProductFlavor&gt;</code>。</p><p><code>ProductFlavor</code> 具有以下属性：</p><ul><li><strong><code>applicationId：</code></strong>应用程序 ID。</li><li><strong><code>applicationIdSuffix：</code></strong>应用程序 ID 后缀。</li><li><strong><code>consumerProguardFiles：</code></strong>包含在发布的 AAR 中的 ProGuard 规则文件。</li><li><strong><code>dimension：</code></strong>指定 product flavor 所属的 flavor 维度。</li><li><strong><code>externalNativeBuild：</code></strong>指定使用 CMake 或 ndk-build 的外部 native 构建选项。</li><li><strong><code>javaCompileOptions：</code></strong>配置 Java 编译器选项。</li><li><strong><code>manifestPlaceholders：</code></strong>清单占位符。</li><li><strong><code>matchingFallbacks：</code></strong>指定当直接变体与本地模块依赖项不匹配时，插件应尝试使用的产品样式的排序列表。</li><li><strong><code>multiDexEnabled：</code></strong>是否为此变体启用 Multi-Dex。</li><li><strong><code>multiDexKeepFile：</code></strong>文本文件，指定将编译到主 dex 文件中的其他类。</li><li><strong><code>multiDexKeepProguard：</code></strong>带有其他 ProGuard 规则的文本文件，用于确定将哪些类编译到主 dex 文件中。</li><li><strong><code>ndk：</code></strong>封装 NDK 的每个变体配置，例如 ABI 过滤器。</li><li><strong><code>proguardFiles：</code></strong>指定插件应使用的 ProGuard 配置文件。</li><li><strong><code>signingConfig：</code></strong>签署此产品风格使用的配置。</li><li><strong><code>testApplicationId：</code></strong>测试应用程序 ID。</li><li><strong><code>testInstrumentationRunner：</code></strong>测试仪器运行器类名称。</li><li><strong><code>testInstrumentationRunnerArguments：</code></strong>测试仪器运行器自定义参数。</li><li><strong><code>vectorDrawables：</code></strong>用于配置 VectorDrawable 的构建时支持的选项。</li><li><strong><code>versionCode：</code></strong>版本号。</li><li><strong><code>versionName：</code></strong>版本名称。</li><li><strong><code>versionNameSuffix：</code></strong>版本名称后缀。</li><li><strong><code>wearAppUnbundled：</code></strong>返回是否为嵌入式磨损应用启用非捆绑模式。如果为 true，则可以使应用程序从嵌入式磨损应用程序转换为直接由 Play 商店分发的应用程序。</li></ul><h3 id="splits"><a href="#splits" class="headerlink" title="splits"></a>splits</h3><p><strong><code>splits{}</code></strong> 闭包用于配置构建多个APK或APK分割。DSL 对象为 <code>Splits</code>。</p><p><code>Splits</code> 具有以下属性：</p><ul><li><strong><code>abi：</code></strong>封装用于构建每个 ABI APK 的设置。</li><li><strong><code>abiFilters：</code></strong>插件将为 ABI 列表生成单独的 APK。</li><li><strong><code>density：</code></strong>封装用于构建每密度 APK 的设置。</li><li><strong><code>densityFilters：</code></strong>该插件将为其生成单独 APK 的屏幕密度配置列表。</li><li><strong><code>language：</code></strong>封装用于构建每个语言(或地区) APK 的设置。</li><li><strong><code>languageFilters：</code></strong>插件将为其生成单独 APK 的语言(或地区)列表。</li></ul><h3 id="testOptions"><a href="#testOptions" class="headerlink" title="testOptions"></a>testOptions</h3><p><strong><code>testOptions{}</code></strong> 闭包用于配置构建多个APK或APK分割。DSL 对象为 <code>TestOptions</code>。</p><p><code>TestOptions</code> 具有以下属性：</p><ul><li><strong><code>animationsDisabled：</code></strong>在从命令行运行的检测测试期间禁用动画。</li><li><strong><code>execution：</code></strong>指定是否使用设备上的测试编制。</li><li><strong><code>reportDir：</code></strong>报表目录的名称。</li><li><strong><code>resultsDir：</code></strong>结果目录的名称。</li><li><strong><code>unitTests：</code></strong>配置单元测试选项。</li></ul><h3 id="variantFilter"><a href="#variantFilter" class="headerlink" title="variantFilter"></a>variantFilter</h3><p><strong><code>variantFilter{}</code></strong> 闭包用于配置 Android 插件应包含或从 Gradle 项目中删除的变体。DSL 对象为 <code>Action&lt;VariantFilter&gt;</code>。</p><p><code>VariantFilter</code> 具有以下属性：</p><ul><li><strong><code>buildType：</code></strong>构建类型。</li><li><strong><code>defaultConfig：</code></strong>表示默认配置的 ProductFlavor。</li><li><strong><code>flavors：</code></strong>风味列表或空列表。</li></ul><h3 id="jacoco-已弃用"><a href="#jacoco-已弃用" class="headerlink" title="jacoco (已弃用)"></a>jacoco (已弃用)</h3><p><strong><code>jacoco{}</code></strong> 闭包用于配置用于脱机检测和覆盖报告的 JaCoCo 版本。DSL 对象为 <code>JacocoOptions</code>。</p><p><code>JacocoOptions</code> 具有以下属性：</p><ul><li><strong><code>version：</code></strong>要使用的 JaCoCo 版本。</li></ul><h2 id="AppExtension"><a href="#AppExtension" class="headerlink" title="AppExtension"></a>AppExtension</h2><p><strong><code>AppExtension</code></strong> 就是应用程序插件的 Android 扩展。<code>com.android.build.gradle.AppExtension</code> 类继承自 <code>com.android.build.gradle.BaseExtension</code>。</p><p><code>AppExtension</code> 除了继承自 <code>com.android.build.gradle.AppExtension</code> 的属性外，还有自有的属性。</p><h3 id="applicationVariants"><a href="#applicationVariants" class="headerlink" title="applicationVariants"></a>applicationVariants</h3><p><strong><code>applicationVariants</code></strong> 用于返回应用程序项目包含的构建变体集合(<code>DomainObjectSet&lt;ApplicationVariant&gt;</code>)。</p><blockquote><p>要处理这个集合中的元素，应该使用 <code>all</code> 迭代器，这是因为插件只有在项目评估之后才填充这个集合。与 <code>each</code> 迭代器不同，在插件创建它们时使用 <code>all</code> 进程的未来元素。</p></blockquote><p>以下示例遍历所有 applicationVariants 元素，将构建变量注入清单文件中：</p><pre class=" language-gradle"><code class="language-gradle">android.applicationVariants.all { variant ->    def mergedFlavor = variant.getMergedFlavor()    // Defines the value of a build variable you can use in the manifest.    mergedFlavor.manifestPlaceholders = [hostName:"www.example.com/${variant.versionName}"]}</code></pre><h3 id="testBuildType"><a href="#testBuildType" class="headerlink" title="testBuildType"></a>testBuildType</h3><p><strong><code>testBuildType</code></strong> 指定插件用于测试模块的构建类型。</p><p>默认情况下，Android 插件使用 <code>debug</code> 构建类型。这意味着当您使用 <code>gradlew connectedAndroidTest</code> 部署检测测试时，它会使用模块 <code>debug</code> 构建类型中的代码和资源来创建测试 APK。然后，该插件将模块的 APK 和测试 APK 的 <code>debug</code> 版本部署到连接的设备，并运行测试。</p><p>要将测试构建类型更改为 <code>debug</code> 以外的其他类型，请按如下所示进行指定：</p><pre class=" language-gradle"><code class="language-gradle">android {    // Changes the test build type for instrumented tests to "stage".    testBuildType "stage"}</code></pre><h3 id="testVariants"><a href="#testVariants" class="headerlink" title="testVariants"></a>testVariants</h3><p><strong><code>testVariants</code></strong> 用于返回 Android 测试构建变体的集合(<code>DomainObjectSet&lt;TestVariant&gt;</code>)。</p><blockquote><p>要处理这个集合中的元素，应该使用 <code>all</code> 迭代器，这是因为插件只有在项目评估之后才填充这个集合。与 <code>each</code> 迭代器不同，在插件创建它们时使用 <code>all</code> 进程的未来元素。</p></blockquote><h3 id="unitTestVariants"><a href="#unitTestVariants" class="headerlink" title="unitTestVariants"></a>unitTestVariants</h3><p><strong><code>unitTestVariants</code></strong> 用于返回 Android 单元测试构建变体的集合(<code>DomainObjectSet&lt;UnitTestVariant&gt;</code>)。</p><blockquote><p>要处理这个集合中的元素，应该使用 <code>all</code> 迭代器，这是因为插件只有在项目评估之后才填充这个集合。与 <code>each</code> 迭代器不同，在插件创建它们时使用 <code>all</code> 进程的未来元素。</p></blockquote><h3 id="flavorDimensions"><a href="#flavorDimensions" class="headerlink" title="flavorDimensions"></a>flavorDimensions</h3><p><strong><code>flavorDimensions</code></strong> 用于配置项目的产品风味维度的名称。</p><p>使用 Android plugin 3.0.0 及更高版本配置产品 product flavors 时，必须使用 <code>flavorDimensions</code> 属性指定至少一个 flavor 维度，然后将每个 flavor 分配给维度。否则，您将收到以下构建错误：</p><pre><code>Error:All flavors must now belong to a named flavor dimension.The flavor &#39;flavor_name&#39; is not assigned to a flavor dimension.</code></pre><p>默认情况下，当仅指定一个维度时，配置的所有 flavor 都将自动属于该维度。如果指定多个维度，则需要手动将每个 flavor 分配给维度，如下面的示例所示：</p><pre class=" language-gradle"><code class="language-gradle">android {    ...    // Specifies the flavor dimensions you want to use. The order in which you    // list each dimension determines its priority, from highest to lowest,    // when Gradle merges variant sources and configurations. You must assign    // each product flavor you configure to one of the flavor dimensions.    flavorDimensions 'api', 'version'    productFlavors {      demo {        // Assigns this product flavor to the 'version' flavor dimension.        dimension 'version'        ...    }      full {        dimension 'version'        ...      }      minApi24 {        // Assigns this flavor to the 'api' dimension.        dimension 'api'        minSdkVersion '24'        versionNameSuffix "-minApi24"        ...      }      minApi21 {        dimension "api"        minSdkVersion '21'        versionNameSuffix "-minApi21"        ...      }   }}</code></pre><h3 id="useLibrary"><a href="#useLibrary" class="headerlink" title="useLibrary"></a>useLibrary</h3><p><strong><code>useLibrary</code></strong> 用于将指定的库包含到类路径中。</p><p>通常使用此属性来支持随 Android SDK 一起提供的可选平台库。以下示例将 <code>Apache HTTP API</code> 库添加到项目类路径：</p><pre class=" language-gradle"><code class="language-gradle">android {    // Adds a platform library that ships with the Android SDK.    useLibrary 'org.apache.http.legacy'}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Plugin for Gradle 3.0.0</title>
      <link href="/posts/2018/2f48e782.html"/>
      <url>/posts/2018/2f48e782.html</url>
      
        <content type="html"><![CDATA[<p>Android Studio 升级到 3.0 之后，Gradle Plugin 和 Gradle 不升级也是可以继续使用的，但很多新的特性如：Java 8 支持、新的依赖匹配机制、AAPT2 等新功能都无法正常使用~ 所以长期看来，最后还是得升级的。</p><h2 id="升级-Gradle-配置"><a href="#升级-Gradle-配置" class="headerlink" title="升级 Gradle 配置"></a>升级 Gradle 配置</h2><p>Gradle plugin 3.0.0 要求 Gradle 4.1 或者更高的版本。</p><h3 id="更新-Gradle-版本"><a href="#更新-Gradle-版本" class="headerlink" title="更新 Gradle 版本"></a>更新 Gradle 版本</h3><p>如果正在使用 Android Studio 3.0 或更高版本打开现有项目，请按照提示操作，将现有项目自动更新到兼容版本的 Gradle。要手动更新 Gradle，请更新 <code>/gradle/wrapper</code> 目录下的 <code>gradle-wrapper.properties</code> 文件中的网址，如下所示：</p><pre class=" language-gradle"><code class="language-gradle">distributionUrl=https\://services.gradle.org/distributions/gradle-4.1-all.zip</code></pre><h3 id="配置-Gradle-Plugin"><a href="#配置-Gradle-Plugin" class="headerlink" title="配置 Gradle Plugin"></a>配置 Gradle Plugin</h3><p>如果正在使用 Android Studio 3.0 或更高版本打开现有项目，请按照提示操作，将现有项目自动更新到最新版本的 Android Gradle Plugin。要手动更新 Gradle Plugin，请在项目根目录下的 <code>build.gradle</code> 文件中更改插件版本并添加 Maven 仓库，如下所示：</p><pre class=" language-gradle"><code class="language-gradle">buildscript {    repositories {        ...        // You need to add the following repository to download the new plugin.        google()    }    dependencies {        classpath 'com.android.tools.build:gradle:3.0.0-beta4'    }}</code></pre><h2 id="flavor-dimensions"><a href="#flavor-dimensions" class="headerlink" title="flavor dimensions"></a>flavor dimensions</h2><p>Android Studio 3.0 之前，进行多模块依赖开发的情况下，项目是正常运行的，然而升级到 3.0 之后，原本的项目就出现了问题，具体问题如下：</p><pre><code>All flavors must now belong to a named flavor dimension. Learn more at https://d.android.com/r/tools/flavorDimensions-missing-error-message.html</code></pre><p>要解决此错误，请将每个风味分配至一个给定维度，如下面的示例中所示。由于依赖项匹配现在由插件处理，应当谨慎地为风味维度命名。</p><pre class=" language-gradle"><code class="language-gradle">// Specifies a flavor dimension.flavorDimensions "color"productFlavors {     red {      // Assigns this product flavor to the 'color' flavor dimension.      // This step is optional if you are using only one dimension.      dimension "color"      ...    }    blue {      dimension "color"      ...    }}</code></pre><blockquote><p>在 <code>android{}</code> 里面加入 <code>flavorDimensions</code> 定义风味维度，然后在 <code>productFlavors</code> 中中的每个 <code>flavor</code> 指定所属的风味维度。</p></blockquote><h2 id="使用新依赖项配置"><a href="#使用新依赖项配置" class="headerlink" title="使用新依赖项配置"></a>使用新依赖项配置</h2><p>Gradle 3.4 引入了新的 <a href="https://docs.gradle.org/current/userguide/java_library_plugin.html#sec:java_library_configurations_graph" target="_blank" rel="noopener">Java 库插件配置</a>，允许您控制到编译和运行时类路径的发布（适用于模块间依赖项）。Android Plugin 3.0.0 正在迁移到这些新依赖项配置。要迁移项目，只需更新依赖项以使用新配置，而非已弃用配置，如下表中所列：</p><table><thead><tr><th>新配置</th><th>已弃用配置</th><th>行为</th></tr></thead><tbody><tr><td>implementation</td><td>compile</td><td>依赖项在编译时对模块可用，并且仅在运行时对模块的消费者可用。对于大型多项目构建，使用 <code>implementation</code> 而不是 <code>api/compile</code> 可以显著缩短构建时间，因为它可以减少构建系统需要重新编译的项目量。大多数应用和测试模块都应使用此配置。</td></tr><tr><td>api</td><td>compile</td><td>依赖项在编译时对模块可用，并且在编译时和运行时还对模块的消费者可用。此配置的行为类似于 <code>compile</code>（现在已弃用），一般情况下，您应当仅在库模块中使用它。应用模块应使用 <code>implementation</code>，除非想要将其 API 公开给单独的测试模块。</td></tr><tr><td>compileOnly</td><td>provided</td><td>依赖项仅在编译时对模块可用，并且在编译或运行时对其消费者不可用。此配置的行为类似于 <code>provided</code>（现在已弃用）。</td></tr><tr><td>runtimeOnly</td><td>apk</td><td>依赖项仅在运行时对模块及其消费者可用。此配置的行为类似于 <code>apk</code>（现在已弃用）。</td></tr></tbody></table><p>Gralde 插件 3.0 之前的 <code>build.gradle</code> 文件中依赖项默认都是 <code>compile</code>，3.0 之后的依赖项默认是 <code>implementation</code>。</p><blockquote><p><strong>注：</strong> <code>compile</code>、<code>provided</code> 和 <code>apk</code> 目前仍然可用。不过，它们将在下一个主要版本的 Android 插件中消失。</p></blockquote><h3 id="Gradle-依赖配置指令"><a href="#Gradle-依赖配置指令" class="headerlink" title="Gradle 依赖配置指令"></a>Gradle 依赖配置指令</h3><ul><li><strong><code>implementation(compile)：</code></strong>只在内部使用此 Module，不会向外部暴露其依赖的 Module 内容。</li><li><strong><code>api(compile)：</code></strong>和 compile 的作用一样，当前 Module 会暴露其依赖的其他 Module 内容。使用该方式依赖的库将会参与编译和打包。</li><li><strong><code>compileOnly(provided)：</code></strong>使用该方式依赖的库只在编译时有效，不会参与打包 。</li><li><strong><code>runtimeOnly(apk)：</code></strong>使用该方式依赖的库只在生成 APK 的时候参与打包，编译时不会参与。</li><li><strong><code>testImplementation(testCompile)：</code></strong>只在单元测试代码的编译以及最终打包测试 APK 时有效。</li><li><strong><code>debugImplementation(debugCompile)：</code></strong>只在 debug 模式的编译和最终的 Debug APK 打包时有效。</li><li><strong><code>releaseImplementation(releaseCompile)：</code></strong>仅仅针对 release 模式的编译和最终的 Release APK 打包。</li></ul><h3 id="implementation-和-api的区别"><a href="#implementation-和-api的区别" class="headerlink" title="implementation 和 api的区别"></a>implementation 和 api的区别</h3><ul><li><strong><code>implementation：</code></strong>该命令编译的依赖，对该项目有依赖的项目将无法访问到使用该命令编译的依赖中的任何程序，也就是将该依赖隐藏在内部，而不对外部公开，不具有依赖的传递性。Gradle 构建速度比 api 要快。</li><li><strong><code>api：</code></strong>等同于 compile 指令，该操作命令会修改外部接口，Module 和所有依赖的 Module 都需要重新编译，具有依赖传递性。Gradle 构建速度比 implementation 慢。</li></ul><h2 id="使用注解处理器依赖项配置"><a href="#使用注解处理器依赖项配置" class="headerlink" title="使用注解处理器依赖项配置"></a>使用注解处理器依赖项配置</h2><p>在之前版本的 Android Plugin for Gradle 中，编译类路径中的依赖项将自动添加到处理器类路径中。也就是说，可以向编译类路径中添加一个注解处理器，它将按预期工作。不过，由于向处理器添加了大量不需要的依赖项，这会对性能造成显著影响。</p><p>使用新插件时，必须使用 <strong><code>annotationProcessor</code></strong> 依赖项配置将注解处理器添加到处理器类路径中，如下所示：</p><pre class=" language-gradle"><code class="language-gradle">dependencies {    ...    annotationProcessor 'com.google.dagger:dagger-compiler:<version-number>'}</code></pre><p>如果 JAR 文件包含以下文件，插件会将依赖项假设为注解处理器：<code>META-INF/services/javax.annotation.processing.Processor</code>。如果插件在编译类路径中检测到注解处理器，构建将失败，并且可以看到一条错误消息，其中列出了编译类路径中的每一个注解处理器。要修复错误，只需更改这些依赖项的配置以使用 <code>annotationProcessor</code>。如果依赖项包含也需要位于编译类路径中的组件，请再次声明该依赖项并使用 <code>compile</code> 依赖项配置。</p><blockquote><p><strong>android-apt 插件用户：</strong>此行为变更目前不影响 <code>android-apt</code> 插件。不过，插件将不会与未来版本的 Android Plugin for Gradle 兼容。</p></blockquote><h3 id="停用错误检查"><a href="#停用错误检查" class="headerlink" title="停用错误检查"></a>停用错误检查</h3><p>如果编译类路径中的依赖项包含不需要的注解处理器，可以将以下代码添加到 <code>build.gradle</code> 文件中，停用错误检查。请记住，添加到编译类路径中的注解处理器仍不会添加到处理器类路径中。</p><pre class=" language-gradle"><code class="language-gradle">android {    ...    defaultConfig {        ...        javaCompileOptions {            annotationProcessorOptions {                includeCompileClasspath false            }        }    }}</code></pre><h2 id="API-变更"><a href="#API-变更" class="headerlink" title="API 变更"></a>API 变更</h2><p>Android Plugin 3.0.0 引入了一些移除特定功能的 API 变更，可能会破坏您现有的构建。后期版本的插件可能会引入新的公共 API 来取代破坏的功能。</p><h3 id="变体输出"><a href="#变体输出" class="headerlink" title="变体输出"></a>变体输出</h3><p>使用 Variant API 操作变体输出在新插件中已不再受支持。不过，这种方式仍然适用于简单任务，例如在构建时更改 APK 名称，如下所示：</p><pre class=" language-gradle"><code class="language-gradle">// If you use each() to iterate through the variant objects,// you need to start using all(). That's because each() iterates// through only the objects that already exist during configuration time—// but those object don't exist at configuration time with the new model.// However, all() adapts to the new model by picking up object as they are// added during execution.android.applicationVariants.all { variant ->    variant.outputs.all {        outputFileName = "${variant.name}-${variant.versionName}.apk"    }}</code></pre><p>不过，涉及访问 <code>outputFile</code> 对象的更复杂任务不再奏效。这是因为配置阶段期间不再创建变体特定的任务。这就让插件无法提前了解其全部输出，不过这会加快配置速度。</p><h3 id="manifestOutputFile"><a href="#manifestOutputFile" class="headerlink" title="manifestOutputFile"></a>manifestOutputFile</h3><p><code>processManifest.manifestOutputFile()</code> 函数不再可用，如果您尝试调用该函数，您将遇到以下错误：</p><pre><code>A problem occurred configuring project &#39;:myapp&#39;.   Could not get unknown property &#39;manifestOutputFile&#39; for task &#39;:myapp:processDebugManifest&#39;   of type com.android.build.gradle.tasks.ProcessManifest.</code></pre><p>可以调用 <code>processManifest.manifestOutputDirectory()</code> 来返回包含所有已生成 manifest 的目录的路径，而不是调用 <code>manifestOutputFile()</code> 来获取每个变体的 manifest 文件。然后，可以找到某个 manifest 并向其应用自己的逻辑。</p><p>下面的示例可以在 manifest 中动态更改版本代码：</p><pre class=" language-gradle"><code class="language-gradle">android.applicationVariants.all { variant ->    variant.outputs.all { output ->        output.processManifest.doLast {            // Stores the path to the maifest.            String manifestPath = "$manifestOutputDirectory/AndroidManifest.xml"            // Stores the contents of the manifest.            def manifestContent = file(manifestPath).getText()            // Changes the version code in the stored text.            manifestContent = manifestContent.replace('android:versionCode="1"',                    String.format('android:versionCode="%s"', generatedCode))            // Overwrites the manifest with the new text.            file(manifestPath).write(manifestContent)        }    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android build.gradle 配置详解</title>
      <link href="/posts/2018/9986453e.html"/>
      <url>/posts/2018/9986453e.html</url>
      
        <content type="html"><![CDATA[<h2 id="Gradle-简介"><a href="#Gradle-简介" class="headerlink" title="Gradle 简介"></a>Gradle 简介</h2><p>Android Studio 是采用 <code>Gradle</code> 来构建项目的。<code>Gradle</code> 是一个非常先进的项目构建工具，若想用 Gradle 构建 Android 项目，需要创建一个脚本，此脚本被称为 <code>build.gradle</code>。</p><p>Gradle 构建脚本并非基于传统的 <code>XML</code> 文件(如Ant和Maven)，而是 <code>Groovy</code> 的领域专业语言(<code>DSL</code>)。<code>Groovy</code> 是一种基于 <code>JVM</code> 的动态语言，优势更加显著。</p><blockquote><p>若只是用它构建普通的工程，可以不去学 Groovy 语言；若想深入的研究自定义的构建插件，可以考虑学 Groovy，因为 Groovy 语言是基于 JVM 的动态语言，所以有 Java 基础的同学学习 Groovy 语言不会很难。</p></blockquote><h2 id="build-gradle-文件"><a href="#build-gradle-文件" class="headerlink" title="build.gradle 文件"></a>build.gradle 文件</h2><p>在一个 Android 项目中一般会出现至少 2 个 <code>build.gradle</code> 文件，一个是 <code>Project</code> 的 gradle 文件，其他的都是 <code>Module</code> 的 gradle 文件。</p><blockquote><p>如果项目目录结构切换到 Android 模式下，则所有的 <code>gradle</code> 文件都在 <code>Gradle Scripts</code> 分组下。</p></blockquote><h3 id="Project-的-build-gradle-文件"><a href="#Project-的-build-gradle-文件" class="headerlink" title="Project 的 build.gradle 文件"></a>Project 的 build.gradle 文件</h3><p><strong><code>Project</code></strong> 的 <code>build.gradle</code> 文件对应的默认配置如下：</p><pre class=" language-gradle"><code class="language-gradle">// Top-level build file where you can add configuration options common to all sub-projects/modules.// 配置 Gradle 脚本执行所需依赖分别是对应的 Maven 库和插件buildscript {    // 配置 Gradle 脚本依赖项上所需要的存储库    repositories {        google()    // 从 Android Studio 3.0 后新增了 google() 配置，可以引用 google 上的开源项目        jcenter()   // 是一个代码托管仓库，声明了 jcenter() 配置，可以引用 jcenter 上的开源项目    }    // 配置 Gradle 脚本所需要的依赖项    dependencies {        // Android 项目的 Gradle 插件，Gradle 是一个强大的项目构建工具        classpath 'com.android.tools.build:gradle:3.2.1'        // NOTE: Do not place your application dependencies here; they belong        // in the individual module build.gradle files    }}// 配置项目本身及其每个子项目所需要的依赖allprojects {    // 配置此项目所需依赖的存储库    repositories {        google()        jcenter()    }}// 运行 gradle clean 时，执行此处定义的 task 任务。该任务继承自 Delete，删除根目录中的 build 目录。// 相当于执行Delete.delete(rootProject.buildDir)。task clean(type: Delete) {    delete rootProject.buildDir}</code></pre><p>可以看到 Project 的 build.gradle 配置包含以下内容：</p><ul><li><strong><code>buildscript{}：</code></strong>配置 Gradle 脚本执行所需依赖分别是对应的 Maven 库和插件。<ul><li><strong><code>repositories{}：</code></strong>配置 Gradle 脚本依赖项上所需要的存储库。</li><li><strong><code>dependencies{}：</code></strong>配置 Gradle 脚本所需要的依赖项。</li></ul></li><li><strong><code>allprojects{}：</code></strong>配置项目本身及其每个子项目所需要的依赖。</li><li><strong><code>task clean(type: Delete){}：</code></strong>运行 gradle clean 时，执行此处定义的 task 任务。该任务继承自 Delete，删除根目录中的 build 目录。</li></ul><h3 id="Module-的-build-gradle-文件"><a href="#Module-的-build-gradle-文件" class="headerlink" title="Module 的 build.gradle 文件"></a>Module 的 build.gradle 文件</h3><p><strong><code>Module</code></strong> 的 <code>build.gradle</code> 文件对应的默认配置如下：</p><pre class=" language-gradle"><code class="language-gradle">apply plugin: 'com.android.application'android {    compileSdkVersion 28    buildToolsVersion "28.0.0"    defaultConfig {        applicationId "com.android.application"        minSdkVersion 14        targetSdkVersion 28        versionCode 1        versionName "1.0"        testInstrumentationRunner "android.support.test.runner.AndroidJUnitRunner"    }    buildTypes {        release {            minifyEnabled false            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'        }    }}dependencies {    implementation fileTree(dir: 'libs', include: ['*.jar'])    implementation 'com.android.support:appcompat-v7:28.0.0'    implementation 'com.android.support:design:28.0.0'    implementation 'com.android.support.constraint:constraint-layout:1.1.3'    implementation 'com.android.support:support-vector-drawable:28.0.0'    testImplementation 'junit:junit:4.12'    androidTestImplementation 'com.android.support.test:runner:1.0.2'    androidTestImplementation 'com.android.support.test.espresso:espresso-core:3.0.2'}</code></pre><p>可以看到 Module 的 build.gradle 配置包含以下内容：</p><ul><li><strong><code>apply plugin：</code></strong>配置 Module 应用的插件。</li><li><strong><code>android：</code></strong>配置项目构建的各种属性。<ul><li><strong><code>compileSdkVersion：</code></strong>配置编译版本。</li><li><strong><code>buildToolsVersion：</code></strong>配置构建工具的版本。</li><li><strong><code>defaultConfig{}：</code></strong>配置 Android 插件应用于所有构建变体的变体属性。</li><li><strong><code>buildTypes{}：</code></strong>配置项目的所有构建类型。</li></ul></li><li><strong><code>dependencies{}：</code></strong>配置项目的依赖项。</li></ul><h4 id="apply-plugin-文件"><a href="#apply-plugin-文件" class="headerlink" title="apply plugin 文件"></a>apply plugin 文件</h4><p><strong><code>apply plugin：</code></strong>配置 Module 应用的插件。一般位于文件中第一行，该插件一般有两种值可选：</p><ul><li><strong><code>com.android.application：</code></strong>表示该模块为应用程序模块，可以直接运行，打包得到的是 <code>.apk</code> 文件。</li><li><strong><code>com.android.library：</code></strong>表示该模块为库模块，只能作为代码库依附于别的应用程序模块来运行，打包得到的是 <code>.aar</code> 文件。</li></ul><p>配置代码如下：</p><pre class=" language-gradle"><code class="language-gradle">apply plugin: 'com.android.application'// apply plugin: 'com.android.library'</code></pre><blockquote><p><code>apply plugin: &#39;com.android.application&#39;</code> 等同于 <code>project.plugins.apply(&quot;com.android.application&quot;)</code>。</p></blockquote><p><code>apply plugin</code> 除了可以指定上面两种插件之外，还可以指定其他的插件，代码如下：</p><pre class=" language-gradle"><code class="language-gradle">apply plugin: 'kotlin-android'apply plugin: 'kotlin-android-extensions'apply plugin: 'kotlin-kapt'apply plugin: 'com.jakewharton.butterknife'</code></pre><h4 id="android-闭包"><a href="#android-闭包" class="headerlink" title="android{} 闭包"></a>android{} 闭包</h4><p><strong><code>android：</code></strong>闭包主要用于配置项目构建的各种属性，代码中由 <code>com.android.build.gradle.AppExtension</code> 类表示，该类继承自 <code>com.android.build.gradle.BaseExtension</code>。<code>BaseExtension</code> 是所有 Android 插件的基本扩展，使用过程中不直接使用此扩展，而是使用以下之一：</p><blockquote><p><code>AppExtension</code> 用于构建 <code>Android app module</code> 的 <code>com.android.application</code> 插件扩展。<br><code>LibraryExtension</code> 用于构建 <code>Android library module</code> 的 <code>com.android.library</code> 插件扩展。<br><code>TestExtension</code> 用于构建 <code>Android test module</code> 的 <code>com.android.test</code> 插件扩展。<br><code>FeatureExtension</code> 用于构建 <code>Android Instant Apps</code> 的 <code>com.android.feature</code> 插件扩展。</p></blockquote><h5 id="compileSdkVersion"><a href="#compileSdkVersion" class="headerlink" title="compileSdkVersion"></a>compileSdkVersion</h5><p><strong><code>compileSdkVersion：</code></strong>用于配置编译时的 Android SDK 版本。</p><h5 id="buildToolsVersion"><a href="#buildToolsVersion" class="headerlink" title="buildToolsVersion"></a>buildToolsVersion</h5><p><strong><code>buildToolsVersion：</code></strong>用于配置编译时使用的构建工具的版本。Android Studio 3.0 后去除此项配置。</p><h5 id="defaultConfig-闭包"><a href="#defaultConfig-闭包" class="headerlink" title="defaultConfig{} 闭包"></a>defaultConfig{} 闭包</h5><p><strong><code>defaultConfig{}：</code></strong>闭包用于配置 Android 插件应用于所有构建变体的变体属性。<code>defaultConfig{}</code> 主要包含以下配置：</p><ul><li><strong><code>applicationId：</code></strong>指定项目的包名，在创建项目的时候已经指定了包名，当要修改整个项目的包名时可以在此更改。</li><li><strong><code>minSdkVersion：</code></strong>指定项目最低兼容的版本，如果设备低于这个版本将无法安装这个应用。</li><li><strong><code>targetSdkVersion：</code></strong>指定项目的目标版本，表示在该目标版本上已经做过充分测试，系统会为该应用启动一些对应该目标系统的最新功能特性，Android 系统平台的行为变更，只有 <code>targetSdkVersion</code> 的属性值被设置为大于或等于该系统平台的 API 版本时，才会生效。</li><li><strong><code>versionCode：</code></strong>指定项目的版本号，一般每次打包上线时该值只能增加，打包后看不见。</li><li><strong><code>versionName：</code></strong>指定项目的版本名称，展示在应用市场上。</li><li><strong><code>testInstrumentationRunner：</code></strong>指定项目的测试运行程序类名。</li></ul><h5 id="buildTypes-闭包"><a href="#buildTypes-闭包" class="headerlink" title="buildTypes{} 闭包"></a>buildTypes{} 闭包</h5><p><strong><code>buildTypes{}：</code></strong>闭包主要用于配置项目的所有构建类型。<code>buildTypes{}</code> 一般包含两个子闭包，一个是 <code>debug</code> 闭包，用于指定生成测试版安装文件的配置，可以忽略不写；另一个是 <code>release</code> 闭包，用于指定生成正式版安装文件的配置。两者能配置的参数相同，最大的区别默认属性配置不一样。<br>详细的配置内容如下：</p><pre class=" language-gradle"><code class="language-gradle">buildTypes {    release {        buildConfigField("boolean", "LOG_DEBUG", "false")        buildConfigField("String", "URL_PERFIX", "\"https://release.cn/\"")        minifyEnabled false        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'        signingConfig signingConfigs.release        pseudoLocalesEnabled false        zipAlignEnabled true        applicationIdSuffix 'release'        versionNameSuffix 'release'    }    debug {        buildConfigField("boolean", "LOG_DEBUG", "true")        buildConfigField("String", "URL_PERFIX", "\"https://test.com/\"")        minifyEnabled false        proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'        signingConfig signingConfigs.debug        debuggable false        jniDebuggable false        renderscriptDebuggable false        zipAlignEnabled true        pseudoLocalesEnabled false        applicationIdSuffix 'debug'        versionNameSuffix 'debug'    }}</code></pre><p><strong><code>buildTypes{}：</code></strong>主要包含以下配置：</p><ul><li><strong><code>minifyEnabled：</code></strong>指定是否对代码进行混淆，true 表示对代码进行混淆，false表示对代码不进行混淆，默认的是 false。</li><li><strong><code>proguardFiles：</code></strong>指定混淆的规则文件，这里指定了 proguard-android.txt 文件和 proguard-rules.pro 文件两个文件，proguard-android.txt 文件为默认的混淆文件，里面定义了一些通用的混淆规则。proguard-rules.pro 文件位于当前项目的根目录下，可以在该文件中定义一些项目特有的混淆规则。</li><li><strong><code>buildConfigField：</code></strong>用于解决 Beta 版本服务和 Release 版本服务地址不同或者一些 Log 打印需求控制的。例如：配置buildConfigField(“boolean”, “LOG_DEBUG”, “true”)，这个方法接收三个非空的参数，第一个：确定值的类型，第二个：指定key的名字，第三个：传值，调用的时候BuildConfig.LOG_DEBUG即可调用。</li><li><strong><code>debuggable：</code></strong>指定是否支持断点调试，release 默认为 false，debug 默认为 true。</li><li><strong><code>jniDebuggable：</code></strong>指定是否可以调试 NDK 代码，使用 lldb 进行 C 和 C++ 代码调试，release 默认为 false</li><li><strong><code>signingConfig：</code></strong>指定签名信息，通过 signingConfigs.release 或者 signingConfigs.debug，配置相应的签名，但是添加此配置前必须先添加 signingConfigs 闭包，添加相应的签名信息。</li><li><strong><code>renderscriptDebuggable：</code></strong>指定是否开启渲染脚本就是一些 C 写的渲染方法，默认为 false。</li><li><strong><code>renderscriptOptimLevel：</code></strong>指定渲染等级，默认是 3。</li><li><strong><code>pseudoLocalesEnabled：</code></strong>指定是否在 APK 中生成伪语言环境，帮助国际化的东西，一般使用的不多。</li><li><strong><code>applicationIdSuffix：</code></strong>指定添加 applicationId 的后缀，一般使用的不多。</li><li><strong><code>versionNameSuffix：</code></strong>指定添加版本名称的后缀，一般使用的不多。</li><li><strong><code>zipAlignEnabled：</code></strong>指定是否对 APK 包执行 ZIP 对齐优化，减小 ZIP 体积，增加运行效率，release 和 debug 默认都为true。</li></ul><h4 id="dependencies-闭包"><a href="#dependencies-闭包" class="headerlink" title="dependencies{} 闭包"></a>dependencies{} 闭包</h4><p><strong><code>dependencies{}：</code></strong>闭包主要用于配置项目的依赖项。一般 Android 项目中一共有以下三种依赖方式：</p><ul><li><strong><code>库依赖：</code></strong>可以对项目中的库模块添加依赖关系。</li><li><strong><code>本地依赖：</code></strong>可以对本地的 Jar 包或目录添加依赖关系</li><li><strong><code>远程依赖：</code></strong>则可以对远程仓库上的开源项目添加依赖关系。</li></ul><p>各种依赖方式的代码如下：</p><pre class=" language-gradle"><code class="language-gradle">// 本地依赖声明implementation fileTree(dir: 'libs', include: ['*.jar'])// 库依赖声明implementation project(':library')// 远程依赖声明implementation 'com.android.support:appcompat-v7:28.0.0'</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Gradle </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中的颜色</title>
      <link href="/posts/2018/936e3ab3.html"/>
      <url>/posts/2018/936e3ab3.html</url>
      
        <content type="html"><![CDATA[<p>Android 中的颜色值通常遵循 <code>RGB/ARGB</code> 标准，使用时通常以 <code>#</code> 字符开头，以<code>16进制</code>表示。 </p><ul><li><strong><code>RGB</code></strong>依次代表红色(Red)、绿色(Green)、蓝色(Blue)。</li><li><strong><code>ARGB</code></strong>依次代表透明度(Alpha)、红色(Red)、绿色(Green)、蓝色(Blue)。</li></ul><blockquote><p>eg: <code>#FF00CC99</code> 其中FF是透明度，00是红色值，CC是绿色值，99是蓝色值。</p></blockquote><h2 id="颜色模式"><a href="#颜色模式" class="headerlink" title="颜色模式"></a>颜色模式</h2><p>Android 支持的颜色模式有以下几种：</p><table><thead><tr><th>颜色模式</th><th>描述</th></tr></thead><tbody><tr><td><code>ARGB8888</code></td><td>四通道高精度(32位)</td></tr><tr><td><code>ARGB4444</code></td><td>四通道低精度(24位)</td></tr><tr><td><code>RGB565</code></td><td>屏幕默认模式(16位)</td></tr><tr><td><code>Alpha8</code></td><td>仅有透明通道(8位)</td></tr></tbody></table><blockquote><p>其中字母表示通道类型，数值表示该类型用多少位二进制来描述。如 <code>ARGB8888</code> 则表示有四个通道(ARGB)，每个对应的通道均用 <code>8</code> 位来描述。</p></blockquote><blockquote><p><strong>注意：</strong>我们常用的是 <code>ARGB8888</code> 和 <code>ARGB4444</code>，而在所有的安卓设备屏幕上默认的模式都是 <code>RGB565</code>。</p></blockquote><h2 id="颜色定义"><a href="#颜色定义" class="headerlink" title="颜色定义"></a>颜色定义</h2><p>以 <code>ARGB8888</code> 为例介绍颜色定义：</p><table><thead><tr><th>类型</th><th>解释</th><th>0(0x00)</th><th>255(0xFF)</th></tr></thead><tbody><tr><td><code>A(Alpha)</code></td><td>透明度</td><td>透明</td><td>不透明</td></tr><tr><td><code>R(Red)</code></td><td>红色</td><td>无色</td><td>红色</td></tr><tr><td><code>G(Green)</code></td><td>绿色</td><td>无色</td><td>绿色</td></tr><tr><td><code>B(Blue)</code></td><td>蓝色</td><td>无色</td><td>蓝色</td></tr></tbody></table><p>其中 <code>A</code> <code>R</code> <code>G</code> <code>B</code> 的取值范围均为<code>0~255</code>(即16进制的<code>0x00~0xFF</code>)：</p><ul><li><strong><code>A：</code></strong>从<code>00</code>到<code>FF</code>表示从透明到不透明。</li><li><strong><code>RGB：</code></strong>从<code>00</code>到<code>FF</code>表示颜色从浅到深。</li></ul><blockquote><p>当 <code>RGB</code>全取最小值(<code>0</code>或<code>0x000000</code>)时颜色为<strong>黑色</strong>，全取最大值(<code>255</code>或<code>0xFFFFFF</code>)时颜色为<strong>白色</strong>。</p></blockquote><h2 id="Android-中的-Color"><a href="#Android-中的-Color" class="headerlink" title="Android 中的 Color"></a>Android 中的 Color</h2><p><code>android.graphics.Color</code> 类提供了创建、转换和操作颜色的方法。</p><h3 id="颜色常量"><a href="#颜色常量" class="headerlink" title="颜色常量"></a>颜色常量</h3><p><code>android.graphics.Color</code> 类中提供了一些常用的颜色常量。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BLACK       <span class="token operator">=</span> <span class="token number">0xFF000000</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> DKGRAY      <span class="token operator">=</span> <span class="token number">0xFF444444</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> GRAY        <span class="token operator">=</span> <span class="token number">0xFF888888</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> LTGRAY      <span class="token operator">=</span> <span class="token number">0xFFCCCCCC</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> WHITE       <span class="token operator">=</span> <span class="token number">0xFFFFFFFF</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> RED         <span class="token operator">=</span> <span class="token number">0xFFFF0000</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> GREEN       <span class="token operator">=</span> <span class="token number">0xFF00FF00</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> BLUE        <span class="token operator">=</span> <span class="token number">0xFF0000FF</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> YELLOW      <span class="token operator">=</span> <span class="token number">0xFFFFFF00</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> CYAN        <span class="token operator">=</span> <span class="token number">0xFF00FFFF</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> MAGENTA     <span class="token operator">=</span> <span class="token number">0xFFFF00FF</span><span class="token punctuation">;</span><span class="token annotation punctuation">@ColorInt</span> <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> TRANSPARENT <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span></code></pre><h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p><code>android.graphics.Color</code> 类中提供了一些构造颜色值的静态方法。</p><pre class=" language-java"><code class="language-java">Color<span class="token punctuation">.</span><span class="token function">alpha</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 提取alpha成分</span>Color<span class="token punctuation">.</span><span class="token function">red</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>        <span class="token comment" spellcheck="true">// 提取红色成分</span>Color<span class="token punctuation">.</span><span class="token function">green</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 提取绿色成分</span>Color<span class="token punctuation">.</span><span class="token function">blue</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>       <span class="token comment" spellcheck="true">// 提取蓝色成分</span>Color<span class="token punctuation">.</span><span class="token function">rgb</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue<span class="token punctuation">)</span>              <span class="token comment" spellcheck="true">// 根据red、green、blue成分返回一个颜色值</span>Color<span class="token punctuation">.</span><span class="token function">argb</span><span class="token punctuation">(</span>alpha<span class="token punctuation">,</span> red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 根据alpha、red、green、blue成分返回一个颜色值</span>Color<span class="token punctuation">.</span><span class="token function">parseColor</span><span class="token punctuation">(</span>colorString<span class="token punctuation">)</span>            <span class="token comment" spellcheck="true">// 解析颜色字符串并返回一个颜色值</span>Color<span class="token punctuation">.</span><span class="token function">luminance</span><span class="token punctuation">(</span>color<span class="token punctuation">)</span>                   <span class="token comment" spellcheck="true">// 返回颜色的相对亮度</span>Color<span class="token punctuation">.</span><span class="token function">RGBToHSV</span><span class="token punctuation">(</span>red<span class="token punctuation">,</span> green<span class="token punctuation">,</span> blue<span class="token punctuation">,</span> hsv<span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 将RGB转换为HSV</span>Color<span class="token punctuation">.</span><span class="token function">colorToHSV</span><span class="token punctuation">(</span>color<span class="token punctuation">,</span> <span class="token keyword">float</span> hsv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>     <span class="token comment" spellcheck="true">// 将ARGB颜色转换为HSV</span>Color<span class="token punctuation">.</span><span class="token function">HSVToColor</span><span class="token punctuation">(</span>hsv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>                  <span class="token comment" spellcheck="true">// 将HSV转换为ARGB颜色，alpha默认为0xFF</span>Color<span class="token punctuation">.</span><span class="token function">HSVToColor</span><span class="token punctuation">(</span>alpha<span class="token punctuation">,</span> hsv<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>           <span class="token comment" spellcheck="true">// 将HSV转换为ARGB颜色</span></code></pre><h3 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h3><p><code>android.graphics.Color</code> 类中提供了一些构造方法。</p><pre class=" language-java"><code class="language-java"><span class="token function">Color</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">)</span><span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> <span class="token keyword">float</span><span class="token punctuation">,</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>ColorSpace<span class="token punctuation">)</span><span class="token function">Color</span><span class="token punctuation">(</span><span class="token keyword">float</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> android<span class="token punctuation">.</span>graphics<span class="token punctuation">.</span>ColorSpace<span class="token punctuation">)</span></code></pre><blockquote><p>Color 类提供的四个构造方法中，只有无参的构造方法可以使用，其他几个构造方法都是私有的。但是可以通过 <code>Color.valueOf()</code> 和 <code>Color.convert()</code> 方法去构造一个颜色。</p></blockquote><h2 id="颜色透明度"><a href="#颜色透明度" class="headerlink" title="颜色透明度"></a>颜色透明度</h2><h3 id="透明度"><a href="#透明度" class="headerlink" title="透明度"></a>透明度</h3><ul><li>透明度分为256阶，取值范围是<code>0-255</code>，在计算机中，我们就用16进制(<code>00-FF</code>)表示，<strong><code>全透明就是00，完全不透明就是FF</code></strong>。</li><li>透明度和不透明度是两个概念，他们加起来等于1，或者说100%</li><li>ARGB 中的透明度 alpha，表示的是不透明度。</li></ul><h3 id="计算方法"><a href="#计算方法" class="headerlink" title="计算方法"></a>计算方法</h3><p>在开发过程中，UI/UE 给的标注图上，所有颜色值是 RGB，但是透明度经常都是百分比，使用过程中我们需要进行换算，换算过程如下：</p><ol><li>将透明度转换成不透明度。</li><li>不透明度乘以255。</li><li>将计算结果转换成16进制。</li><li>将不透明度和颜色值拼接成ARGB格式。</li></ol><p>计算代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> alpha <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">round</span><span class="token punctuation">(</span><span class="token number">255</span> <span class="token operator">*</span> i <span class="token operator">*</span> <span class="token number">1.0f</span> <span class="token operator">/</span> <span class="token number">100f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String hexStr <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">toHexString</span><span class="token punctuation">(</span>alpha<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>hexStr<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            hexStr <span class="token operator">=</span> <span class="token string">"0"</span> <span class="token operator">+</span> hexStr<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">"%, "</span> <span class="token operator">+</span> hexStr<span class="token punctuation">.</span><span class="token function">toUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="干货-懒程序员必备"><a href="#干货-懒程序员必备" class="headerlink" title="干货(懒程序员必备)"></a>干货(懒程序员必备)</h3><p>颜色值(#AARRGGBB)的透明度百分比和十六进制对应关系，如下表所示：</p><table><thead><tr><th>透明度</th><th>十六进制</th></tr></thead><tbody><tr><td>100%</td><td>FF</td></tr><tr><td>99%</td><td>FC</td></tr><tr><td>98%</td><td>FA</td></tr><tr><td>97%</td><td>F7</td></tr><tr><td>96%</td><td>F5</td></tr><tr><td>95%</td><td>F2</td></tr><tr><td>94%</td><td>F0</td></tr><tr><td>93%</td><td>ED</td></tr><tr><td>92%</td><td>EB</td></tr><tr><td>91%</td><td>E8</td></tr><tr><td>90%</td><td>E6</td></tr><tr><td>89%</td><td>E3</td></tr><tr><td>88%</td><td>E0</td></tr><tr><td>87%</td><td>DE</td></tr><tr><td>86%</td><td>DB</td></tr><tr><td>85%</td><td>D9</td></tr><tr><td>84%</td><td>D6</td></tr><tr><td>83%</td><td>D4</td></tr><tr><td>82%</td><td>D1</td></tr><tr><td>81%</td><td>CF</td></tr><tr><td>80%</td><td>CC</td></tr><tr><td>79%</td><td>C9</td></tr><tr><td>78%</td><td>C7</td></tr><tr><td>77%</td><td>C4</td></tr><tr><td>76%</td><td>C2</td></tr><tr><td>75%</td><td>BF</td></tr><tr><td>74%</td><td>BD</td></tr><tr><td>73%</td><td>BA</td></tr><tr><td>72%</td><td>B8</td></tr><tr><td>71%</td><td>B5</td></tr><tr><td>70%</td><td>B3</td></tr><tr><td>69%</td><td>B0</td></tr><tr><td>68%</td><td>AD</td></tr><tr><td>67%</td><td>AB</td></tr><tr><td>66%</td><td>A8</td></tr><tr><td>65%</td><td>A6</td></tr><tr><td>64%</td><td>A3</td></tr><tr><td>63%</td><td>A1</td></tr><tr><td>62%</td><td>9E</td></tr><tr><td>61%</td><td>9C</td></tr><tr><td>60%</td><td>99</td></tr><tr><td>59%</td><td>96</td></tr><tr><td>57%</td><td>94</td></tr><tr><td>56%</td><td>91</td></tr><tr><td>56%</td><td>8F</td></tr><tr><td>55%</td><td>8C</td></tr><tr><td>54%</td><td>8A</td></tr><tr><td>53%</td><td>87</td></tr><tr><td>52%</td><td>85</td></tr><tr><td>51%</td><td>82</td></tr><tr><td>50%</td><td>80</td></tr><tr><td>49%</td><td>7D</td></tr><tr><td>48%</td><td>7A</td></tr><tr><td>47%</td><td>78</td></tr><tr><td>46%</td><td>75</td></tr><tr><td>45%</td><td>73</td></tr><tr><td>44%</td><td>70</td></tr><tr><td>43%</td><td>6E</td></tr><tr><td>42%</td><td>6B</td></tr><tr><td>41%</td><td>69</td></tr><tr><td>40%</td><td>66</td></tr><tr><td>39%</td><td>63</td></tr><tr><td>38%</td><td>61</td></tr><tr><td>37%</td><td>5E</td></tr><tr><td>36%</td><td>5C</td></tr><tr><td>35%</td><td>59</td></tr><tr><td>34%</td><td>57</td></tr><tr><td>33%</td><td>54</td></tr><tr><td>32%</td><td>52</td></tr><tr><td>31%</td><td>4F</td></tr><tr><td>30%</td><td>4D</td></tr><tr><td>28%</td><td>4A</td></tr><tr><td>28%</td><td>47</td></tr><tr><td>27%</td><td>45</td></tr><tr><td>26%</td><td>42</td></tr><tr><td>25%</td><td>40</td></tr><tr><td>24%</td><td>3D</td></tr><tr><td>23%</td><td>3B</td></tr><tr><td>22%</td><td>38</td></tr><tr><td>21%</td><td>36</td></tr><tr><td>20%</td><td>33</td></tr><tr><td>19%</td><td>30</td></tr><tr><td>18%</td><td>2E</td></tr><tr><td>17%</td><td>2B</td></tr><tr><td>16%</td><td>29</td></tr><tr><td>15%</td><td>26</td></tr><tr><td>14%</td><td>24</td></tr><tr><td>13%</td><td>21</td></tr><tr><td>12%</td><td>1F</td></tr><tr><td>11%</td><td>1C</td></tr><tr><td>10%</td><td>1A</td></tr><tr><td>9%</td><td>17</td></tr><tr><td>8%</td><td>14</td></tr><tr><td>7%</td><td>12</td></tr><tr><td>6%</td><td>0F</td></tr><tr><td>5%</td><td>0D</td></tr><tr><td>4%</td><td>0A</td></tr><tr><td>3%</td><td>08</td></tr><tr><td>2%</td><td>05</td></tr><tr><td>1%</td><td>03</td></tr><tr><td>0%</td><td>00</td></tr></tbody></table><h2 id="常用的颜色值"><a href="#常用的颜色值" class="headerlink" title="常用的颜色值"></a>常用的颜色值</h2><p>补充一些常用的颜色值：</p><pre class=" language-xml"><code class="language-xml"><span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>white<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFFFFF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--白色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ivory<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFFFF0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--象牙色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightyellow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFFFE0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮黄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>yellow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFFF00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--黄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>snow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFFAFA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--雪白色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>floralwhite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFFAF0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--花白色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lemonchiffon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFFACD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--柠檬绸色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cornsilk<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFF8DC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--米绸色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seashell<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFF5EE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--海贝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lavenderblush<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFF0F5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--淡紫红 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>papayawhip<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFEFD5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--番木色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blanchedalmond<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFEBCD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--白杏色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mistyrose<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFE4E1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--浅玫瑰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>bisque<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFE4C4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--桔黄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>moccasin<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFE4B5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--鹿皮色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navajowhite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFDEAD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--纳瓦白 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>peachpuff<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFDAB9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--桃色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gold<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFD700<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--金色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>pink<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFC0CB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--粉红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightpink<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFB6C1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮粉红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orange<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFA500<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--橙色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightsalmon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FFA07A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮肉色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkorange<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF8C00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗桔黄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>coral<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF7F50<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--珊瑚色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>hotpink<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF69B4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--热粉红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tomato<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF6347<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--西红柿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orangered<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF4500<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--红橙色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deeppink<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF1493<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--深粉红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fuchsia<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF00FF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--紫红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>magenta<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF00FF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--红紫色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>red<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FF0000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>oldlace<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FDF5E6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--老花色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightgoldenrodyellow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FAFAD2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮金黄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>linen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FAF0E6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亚麻色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>antiquewhite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FAEBD7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--古董白 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>salmon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#FA8072<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--鲜肉色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>ghostwhite<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F8F8FF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--幽灵白 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mintcream<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F5FFFA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--薄荷色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>whitesmoke<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F5F5F5<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--烟白色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>beige<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F5F5DC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--米色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>wheat<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F5DEB3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--浅黄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sandybrown<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F4A460<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--沙褐色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>azure<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F0FFFF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--天蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>honeydew<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F0FFF0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--蜜色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aliceblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F0F8FF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--艾利斯兰 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>khaki<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F0E68C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--黄褐色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightcoral<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#F08080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮珊瑚色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>palegoldenrod<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#EEE8AA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--苍麒麟色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>violet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#EE82EE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--紫罗兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darksalmon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#E9967A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗肉色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lavender<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#E6E6FA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--淡紫色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightcyan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#E0FFFF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮青色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>burlywood<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#DEB887<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--实木色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>plum<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#DDA0DD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--洋李色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gainsboro<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#DCDCDC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--淡灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>crimson<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#DC143C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗深红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>palevioletred<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#DB7093<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--苍紫罗兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>goldenrod<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#DAA520<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--金麒麟色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orchid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#DA70D6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--淡紫色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>thistle<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#D8BFD8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--蓟色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightgray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#D3D3D3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightgrey<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#D3D3D3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>tan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#D2B48C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--茶色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chocolate<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#D2691E<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--巧可力色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>peru<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#CD853F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--秘鲁色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>indianred<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#CD5C5C<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--印第安红 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumvioletred<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#C71585<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中紫罗兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>silver<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#C0C0C0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--银色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkkhaki<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#BDB76B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗黄褐色--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>rosybrown<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#BC8F8F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--褐玫瑰红 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumorchid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#BA55D3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中粉紫色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkgoldenrod<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#B8860B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗金黄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>firebrick<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#B22222<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--火砖色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>powderblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#B0E0E6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--粉蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightsteelblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#B0C4DE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮钢兰色--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>paleturquoise<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#AFEEEE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--苍宝石绿 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>greenyellow<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#ADFF2F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--黄绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#ADD8E6<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkgray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#A9A9A9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkgrey<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#A9A9A9<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>brown<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#A52A2A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--褐色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>sienna<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#A0522D<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--赭色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkorchid<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#9932CC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗紫色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>palegreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#98FB98<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--苍绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkviolet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#9400D3<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗紫罗兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumpurple<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#9370DB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中紫色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightgreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#90EE90<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkseagreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#8FBC8F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗海兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>saddlebrown<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#8B4513<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--重褐色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkmagenta<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#8B008B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗洋红 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkred<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#8B0000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗红色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blueviolet<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#8A2BE2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--紫罗兰蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightskyblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#87CEFA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮天蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>skyblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#87CEEB<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--天蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>gray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#808080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>grey<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#808080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>olive<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#808000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--橄榄色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>purple<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#800080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--紫色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>maroon<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#800000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--粟色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aquamarine<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#7FFFD4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--碧绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>chartreuse<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#7FFF00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--黄绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lawngreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#7CFC00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--草绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumslateblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#7B68EE<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中暗蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightslategray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#778899<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮蓝灰 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightslategrey<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#778899<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮蓝灰 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slategray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#708090<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--灰石色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slategrey<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#708090<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--灰石色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>olivedrab<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#6B8E23<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--深绿褐色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>slateblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#6A5ACD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--石蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dimgray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#696969<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dimgrey<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#696969<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumaquamarine<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#66CDAA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cornflowerblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#6495ED<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--菊兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cadetblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#5F9EA0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--军兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkolivegreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#556B2F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗橄榄绿--></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>indigo<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#4B0082<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--靛青色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumturquoise<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#48D1CC<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中绿宝石 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkslateblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#483D8B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗灰蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>steelblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#4682B4<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--钢兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>royalblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#4169E1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--皇家蓝 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>turquoise<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#40E0D0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--青绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumseagreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#3CB371<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中海蓝 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>limegreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#32CD32<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--橙绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkslategray<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#2F4F4F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗瓦灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkslategrey<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#2F4F4F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗瓦灰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>seagreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#2E8B57<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--海绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>forestgreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#228B22<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--森林绿 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lightseagreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#20B2AA<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--亮海蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>dodgerblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#1E90FF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--闪兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>midnightblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#191970<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中灰兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>aqua<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00FFFF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--浅绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>cyan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00FFFF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--青色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>springgreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00FF7F<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--春绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>lime<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00FF00<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--酸橙色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumspringgreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00FA9A<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中春绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkturquoise<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00CED1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗宝石绿 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>deepskyblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00BFFF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--深天蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkcyan<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#008B8B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗青色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>teal<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#008080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--水鸭色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>green<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#008000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkgreen<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#006400<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗绿色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>blue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#0000FF<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>mediumblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#0000CD<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--中兰色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>darkblue<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#00008B<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--暗蓝色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>navy<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#000080<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--海军色 --></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>color</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>black<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>#000000<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>color</span><span class="token punctuation">></span></span> <span class="token comment" spellcheck="true">&lt;!--黑色 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>resources</span><span class="token punctuation">></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 1.3 的新特性</title>
      <link href="/posts/2018/38070c2.html"/>
      <url>/posts/2018/38070c2.html</url>
      
        <content type="html"><![CDATA[<h2 id="Kotlin-1-3-新特性"><a href="#Kotlin-1-3-新特性" class="headerlink" title="Kotlin 1.3 新特性"></a>Kotlin 1.3 新特性</h2><p>Kotlin 1.3 新特性包含以下几个方面：</p><ul><li>协程正式发布</li><li>多平台项目</li><li>其他语言特性</li><li>标准库</li></ul><h2 id="协程正式发布"><a href="#协程正式发布" class="headerlink" title="协程正式发布"></a>协程正式发布</h2><p>历经了漫长而充足的的测试，协程终于正式发布了！这意味着自 Kotlin 1.3 起，协程的语言支持与 API 已<a href="https://kotlinlang.org/docs/reference/evolution/components-stability.html" target="_blank" rel="noopener">完全稳定</a>。</p><p>Kotlin 1.3 引入了挂起函数的可调用引用以及在反射 API 中对协程的支持。</p><p>更多信息请参考 <a href="https://kotlinlang.org/docs/reference/coroutines-overview.html" target="_blank" rel="noopener">协程概述</a>。</p><h2 id="Kotlin-Native"><a href="#Kotlin-Native" class="headerlink" title="Kotlin/Native"></a>Kotlin/Native</h2><p>Kotlin 1.3 继续改进与完善原生平台。更多信息请参考 <a href="https://kotlinlang.org/docs/reference/native-overview.html" target="_blank" rel="noopener">Kotlin/Native 概述</a>。</p><h2 id="多平台项目"><a href="#多平台项目" class="headerlink" title="多平台项目"></a>多平台项目</h2><p>在 1.3 中，Kotlin 完全修改了多平台项目的模型，以提高表现力与灵活性，并使共享公共代码更加容易。此外，多平台项目现在也支持 Kotlin/Native！</p><p>与旧版模型的主要区别在于：</p><ul><li>在旧版模型中，需要将公共代码与平台相关代码分别放在独立的模块中，以 <code>expectedBy</code> 依赖项链接。现在，公共代码与平台相关代码放在相同模块的不同源根(source root)中，使项目更易于配置。</li><li>对于不同的已支持平台，现在有大量的<a href="https://kotlinlang.org/docs/reference/building-mpp-with-gradle.html#supported-platforms" target="_blank" rel="noopener">预设的平台配置</a>。</li><li>更改了<a href="https://kotlinlang.org/docs/reference/building-mpp-with-gradle.html#adding-dependencies" target="_blank" rel="noopener">依赖配置</a>；现在为每个源根分别指定依赖项。</li><li>源集(source set)现在可以在任意平台子集之间共享(例如，在一个目标平台为 JS、Android 与 iOS 的模块中，可以有一个只在 Android 与 iOS 之间共享的源集)。</li><li>现在支持<a href="https://kotlinlang.org/docs/reference/building-mpp-with-gradle.html#publishing-a-multiplatform-library" target="_blank" rel="noopener">发布多平台库</a>了。</li></ul><p>更多信息请参考 <a href="https://kotlinlang.org/docs/reference/multiplatform.html" target="_blank" rel="noopener">Multiplatform Programming</a>。</p><h2 id="契约"><a href="#契约" class="headerlink" title="契约"></a>契约</h2><p>Kotlin 编译器会做大量的静态分析工作，以提供警告并减少模版代码。其中最显著的特性之一就是智能转换——能够根据类型检测自动转换类型。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> s<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">// 编译器自动将“s”转换为“String”</span><span class="token punctuation">}</span></code></pre><p>然而，一旦将这些检测提取到单独的函数中，所有智能转换都立即消失了：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> String<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">isNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token operator">=</span> <span class="token keyword">this</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">isNotNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> s<span class="token punctuation">.</span>length <span class="token comment" spellcheck="true">// 没有智能转换 :(</span><span class="token punctuation">}</span></code></pre><p>为了改善在此类场景中的行为，Kotlin 1.3 引入了称为 <code>契约</code> 的实验性机制。</p><p><code>契约</code> 让一个函数能够以编译器理解的方式显式描述其行为。目前支持两大类场景：</p><ul><li><p>通过声明函数调用的结果与所传参数值之间的关系来改进智能转换分析：</p><pre class=" language-kotlin"><code class="language-kotlin">  <span class="token keyword">fun</span> <span class="token function">require</span><span class="token punctuation">(</span>condition<span class="token operator">:</span> Boolean<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment" spellcheck="true">// 这是一种语法格式，告诉编译器：</span>      <span class="token comment" spellcheck="true">// “如果这个函数成功返回，那么传入的‘condition’为 true”</span>      contract <span class="token punctuation">{</span> <span class="token function">returns</span><span class="token punctuation">(</span><span class="token punctuation">)</span> implies condition <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>condition<span class="token punctuation">)</span> <span class="token keyword">throw</span> <span class="token function">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">)</span>  <span class="token punctuation">}</span>  <span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span>s<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token function">require</span><span class="token punctuation">(</span>s <span class="token keyword">is</span> String<span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// s 在这里智能转换为“String”，因为否则</span>      <span class="token comment" spellcheck="true">// “require”会抛出异常</span>  <span class="token punctuation">}</span></code></pre></li></ul><ul><li><p>在存在高阶函数的情况下改进变量初始化的分析：</p><pre class=" language-kotlin"><code class="language-kotlin"> <span class="token keyword">fun</span> <span class="token function">synchronize</span><span class="token punctuation">(</span>lock<span class="token operator">:</span> Any<span class="token operator">?</span><span class="token punctuation">,</span> block<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token comment" spellcheck="true">// 告诉编译器：</span>     <span class="token comment" spellcheck="true">// “这个函数会在此时此处调用‘block’，并且刚好只调用一次”</span>     contract <span class="token punctuation">{</span> <span class="token function">callsInPlace</span><span class="token punctuation">(</span>block<span class="token punctuation">,</span> EXACTLY_ONCE<span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">val</span> x<span class="token operator">:</span> Int     <span class="token function">synchronize</span><span class="token punctuation">(</span>lock<span class="token punctuation">)</span> <span class="token punctuation">{</span>         x <span class="token operator">=</span> <span class="token number">42</span> <span class="token comment" spellcheck="true">// 编译器知道传给“synchronize”的 lambda 表达式刚好</span>                <span class="token comment" spellcheck="true">// 只调了一次，因此不会报重复赋值错</span>     <span class="token punctuation">}</span>     <span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 编译器知道一定会调用该 lambda 表达式而执行</span>                <span class="token comment" spellcheck="true">// 初始化操作，因此可以认为“x”在这里已初始化</span> <span class="token punctuation">}</span></code></pre></li></ul><h3 id="标准库中的契约"><a href="#标准库中的契约" class="headerlink" title="标准库中的契约"></a>标准库中的契约</h3><p><code>stdlib</code>(kotlin 标准库)已经利用契约带来了如上所述的对代码分析的改进。这部分契约是<strong>稳定版</strong>的，这意味着你现在就可以从改进的代码分析中受益，而无需任何额外的 opt-ins：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">//sampleStart</span><span class="token keyword">fun</span> <span class="token function">bar</span><span class="token punctuation">(</span>x<span class="token operator">:</span> String<span class="token operator">?</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>x<span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"length of '<span class="token interpolation variable">$x</span>' is <span class="token interpolation"><span class="token delimiter variable">${</span>x<span class="token punctuation">.</span>length<span class="token delimiter variable">}</span></span>"</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 哇，已经智能转换为非空！</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">//sampleEnd</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token function">bar</span><span class="token punctuation">(</span><span class="token string">"42"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="自定义契约"><a href="#自定义契约" class="headerlink" title="自定义契约"></a>自定义契约</h3><p>可以为自己的函数声明契约，不过这个特性是<strong>实验性</strong>的，因为目前的语法尚处于早期原型状态，并且很可能还会更改。另外还要注意，目前 Kotlin 编译器并不会验证契约，因此程序员有责任编写正确合理的契约。</p><p>通过调用标准库(stdlib)函数 <code>contract</code> 来引入自定义契约，该函数提供了 DSL 作用域：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> String<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">isNullOrEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>    contract <span class="token punctuation">{</span>        <span class="token function">returns</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token function">implies</span> <span class="token punctuation">(</span><span class="token keyword">this</span><span class="token label symbol">@isNullOrEmpty</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">this</span> <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>更多关于语法与兼容性注意事项的详细信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/kotlin-contracts.md" target="_blank" rel="noopener">KEEP</a>。</p><h2 id="其他语言特性"><a href="#其他语言特性" class="headerlink" title="其他语言特性"></a>其他语言特性</h2><h3 id="将-when-主语捕获到变量中"><a href="#将-when-主语捕获到变量中" class="headerlink" title="将 when 主语捕获到变量中"></a>将 <code>when</code> 主语捕获到变量中</h3><p>在 Kotlin 1.3 中，可以将 <code>when</code> 表达式主语捕获到变量中：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Request<span class="token punctuation">.</span><span class="token function">getBody</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span>        <span class="token keyword">when</span> <span class="token punctuation">(</span><span class="token keyword">val</span> response <span class="token operator">=</span> <span class="token function">executeRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">is</span> Success <span class="token operator">-></span> response<span class="token punctuation">.</span>body            <span class="token keyword">is</span> HttpError <span class="token operator">-></span> <span class="token keyword">throw</span> <span class="token function">HttpException</span><span class="token punctuation">(</span>response<span class="token punctuation">.</span>status<span class="token punctuation">)</span>        <span class="token punctuation">}</span></code></pre><p>虽然已经可以在 <code>when</code> 表达式前面提取这个变量，但是在 <code>when</code> 中的 <code>val</code> 使其作用域刚好限制在 <code>when</code> 主体中，从而防止命名空间污染。</p><p>更多关于 <code>when</code> 表达式的详细信息请参考 <a href="https://kotlinlang.org/docs/reference/control-flow.html#when-expression" target="_blank" rel="noopener">When Expression</a>。</p><h3 id="接口中伴生对象的-JvmStatic-与-JvmField"><a href="#接口中伴生对象的-JvmStatic-与-JvmField" class="headerlink" title="接口中伴生对象的 @JvmStatic 与 @JvmField"></a>接口中伴生对象的 @JvmStatic 与 @JvmField</h3><p>对于 Kotlin 1.3，可以使用注解 <code>@JvmStatic</code> 与 <code>@JvmField</code> 标记接口的 <code>companion</code> 对象成员。在类文件中会将这些成员提升到相应接口中并标记为 <code>static</code>。</p><p>例如，以下 Kotlin 代码：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Foo <span class="token punctuation">{</span>    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>        <span class="token annotation builtin">@JvmField</span>        <span class="token keyword">val</span> answer<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">42</span>        <span class="token annotation builtin">@JvmStatic</span>        <span class="token keyword">fun</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>相当于这段 Java 代码：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">interface</span> <span class="token class-name">Foo</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> answer <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sayHello</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ……</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="注解类中的内嵌声明"><a href="#注解类中的内嵌声明" class="headerlink" title="注解类中的内嵌声明"></a>注解类中的内嵌声明</h3><p>在 Kotlin 1.3 中，注解可以有内嵌的类、接口、对象与伴生对象：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">annotation</span> <span class="token keyword">class</span> Foo <span class="token punctuation">{</span>    <span class="token keyword">enum</span> <span class="token keyword">class</span> Direction <span class="token punctuation">{</span> UP<span class="token punctuation">,</span> DOWN<span class="token punctuation">,</span> LEFT<span class="token punctuation">,</span> RIGHT <span class="token punctuation">}</span>    <span class="token keyword">annotation</span> <span class="token keyword">class</span> Bar    <span class="token keyword">companion</span> <span class="token keyword">object</span> <span class="token punctuation">{</span>        <span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">42</span>        <span class="token keyword">val</span> bar<span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">42</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="无参的-main"><a href="#无参的-main" class="headerlink" title="无参的 main"></a>无参的 main</h3><p>按照惯例，Kotlin 程序的入口点是一个签名类似于 <code>main(args: Array&lt;String&gt;)</code> 的函数，其中 <code>args</code> 表示传给该程序的命令行参数。然而，并非每个应用程序都支持命令行参数，因此这个参数往往到最后都没有用到。</p><p>Kotlin 1.3 引入了一种更简单的无参 <code>main</code> 形式。现在 Kotlin 版的 <code>Hello,World</code> 缩短了19个字符！</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello, world!"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="更多元的函数"><a href="#更多元的函数" class="headerlink" title="更多元的函数"></a>更多元的函数</h3><p>在 Kotlin 中，函数类型用来表示带有许多参数的泛型类：<code>Function0&lt;R&gt;</code>, <code>Function1&lt;P0, R&gt;</code>, <code>Function2&lt;P0, P1, R&gt;</code>,… 这种方式有着列表是有限的问题，最多支持到 <code>Function22</code>。</p><p>Kotlin 1.3 放宽了限制，并且增加了函数更多元的支持：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">trueEnterpriseComesToKotlin</span><span class="token punctuation">(</span>block<span class="token operator">:</span> <span class="token punctuation">(</span>Any<span class="token punctuation">,</span> Any<span class="token punctuation">,</span> <span class="token operator">..</span><span class="token punctuation">.</span> <span class="token comment" spellcheck="true">/* 42 more */</span><span class="token punctuation">,</span> Any<span class="token punctuation">)</span> <span class="token operator">-></span> Any<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">block</span><span class="token punctuation">(</span><span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">..</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token function">Any</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="渐进式模式"><a href="#渐进式模式" class="headerlink" title="渐进式模式"></a>渐进式模式</h3><p>Kotlin 非常注重代码的稳定性和向后兼容性：Kotlin 的兼容策略为 “打破构建的变化”(既一个变化使得之前能够编译成功的代码，编译失败)只能在大版本中被引入(例如 1.2，1.3等)。</p><p>为了保证了代码安全和正确，我们相信，可以缩短许多用户修复编译器严峻问题的周期。所以，Kotlin 1.3 引入了<strong>渐进式</strong> 编译器模式，找个模式可以通过向编译器传递 <code>-progressive</code> 来开启。</p><p>在渐进式模式中，一些语法上的问题能够及时的得到修复。所有的修复手段都包含两条重要的属性：</p><ul><li>保留源码对旧的编译器的兼容性支持，意味着所有对于<strong>渐进式</strong>编译器能编译的代码，也将能被<strong>非渐进式</strong>编译器编译。</li><li>在某些场景，只会让代码更<strong>安全</strong> — 例如，一些不健壮的智能转换将会被禁止，自动生成的代码将会变的更加稳定、可预测，等。</li></ul><p>开启渐进式模式可能需要你重新某些代码，但不会太多 — 所有的开启渐进式需要修改都是精挑细选、仔细琢磨后的，而且提供工具迁移帮助。<br>我们期望对于那些一直保持最新代码版本的人，渐进式模式将会是一个非常棒的选择。</p><h3 id="内联类"><a href="#内联类" class="headerlink" title="内联类"></a>内联类</h3><blockquote><p>内联类从 Kotlin 1.3 开始支持，而且现阶段是<strong>实验性</strong>的。更多详情请查看 <a href="https://kotlinlang.org/docs/reference/inline-classes.html#experimental-status-of-inline-classes" target="_blank" rel="noopener">Experimental status of inline classes</a>。</p></blockquote><p>Kotlin 1.3 引入了一种新的声明方式 — <code>内联类</code>。内联类可视为常规类的限制版，值得一提的是，内联类必须有一个确切的属性：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token keyword">val</span> s<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre><p>Kotlin 编译器将会利用这个限制，积极的提升内联类在运行时的表现，并且使用底层的属性值来替换内联类的实例，用于省略构造方法调用，减小 GC 压力，开启其他优化操作：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">class</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token keyword">val</span> s<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//sampleStart</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 下一行不会调用构造方法</span>    <span class="token comment" spellcheck="true">// 而且在运行时，'name' 只会包含字符串 "Kotlin"</span>    <span class="token keyword">val</span> name <span class="token operator">=</span> <span class="token function">Name</span><span class="token punctuation">(</span><span class="token string">"Kotlin"</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span>s<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//sampleEnd</span></code></pre><p>更多关于内联类的详细信息请参考 <a href="https://kotlinlang.org/docs/reference/inline-classes.html" target="_blank" rel="noopener">Inline classes</a>。</p><h3 id="无符号整型"><a href="#无符号整型" class="headerlink" title="无符号整型"></a>无符号整型</h3><blockquote><p>无符号整型从 Kotlin 1.3 开始支持，而且现阶段是<strong>实验性</strong>的。更多详情请查看 <a href="https://kotlinlang.org/docs/reference/basic-types.html#experimental-status-of-unsigned-integers" target="_blank" rel="noopener">Experimental status of unsigned integers</a>。</p></blockquote><p>Kotlin 1.3 引入了无符号整型类型：</p><ul><li><code>kotlin.UByte</code>: an unsigned 8-bit integer, ranges from 0 to 255</li><li><code>kotlin.UShort</code>: an unsigned 16-bit integer, ranges from 0 to 65535</li><li><code>kotlin.UInt</code>: an unsigned 32-bit integer, ranges from 0 to 2^32 - 1</li><li><code>kotlin.ULong</code>: an unsigned 64-bit integer, ranges from 0 to 2^64 - 1</li></ul><p>无符号类型也支持大多数有符号类型的功能：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//sampleStart</span><span class="token comment" spellcheck="true">// 你可以使用字面前缀定义无符号类型：</span><span class="token keyword">val</span> uint <span class="token operator">=</span> 42u <span class="token keyword">val</span> ulong <span class="token operator">=</span> 42uL<span class="token keyword">val</span> ubyte<span class="token operator">:</span> UByte <span class="token operator">=</span> 255u<span class="token comment" spellcheck="true">// 你可以把有符号类型通过标准库向无符号类型转换，反之亦然：</span><span class="token keyword">val</span> int <span class="token operator">=</span> uint<span class="token punctuation">.</span><span class="token function">toInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> byte <span class="token operator">=</span> ubyte<span class="token punctuation">.</span><span class="token function">toByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> ulong2 <span class="token operator">=</span> byte<span class="token punctuation">.</span><span class="token function">toULong</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 无符号类型支持同义操作符：</span><span class="token keyword">val</span> x <span class="token operator">=</span> 20u <span class="token operator">+</span> 22u<span class="token keyword">val</span> y <span class="token operator">=</span> 1u <span class="token operator">shl</span> <span class="token number">8</span><span class="token keyword">val</span> z <span class="token operator">=</span> <span class="token string">"128"</span><span class="token punctuation">.</span><span class="token function">toUByte</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> range <span class="token operator">=</span> 1u<span class="token operator">..</span>5u<span class="token comment" spellcheck="true">//sampleEnd</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ubyte: <span class="token interpolation variable">$ubyte</span>, byte: <span class="token interpolation variable">$byte</span>, ulong2: <span class="token interpolation variable">$ulong2</span>"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"x: <span class="token interpolation variable">$x</span>, y: <span class="token interpolation variable">$y</span>, z: <span class="token interpolation variable">$z</span>, range: <span class="token interpolation variable">$range</span>"</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>更多关于无符号整型的详细信息请参考 <a href="https://kotlinlang.org/docs/reference/basic-types.html#unsigned-integers" target="_blank" rel="noopener">Unsigned integers</a>。</p><h3 id="JvmDefault"><a href="#JvmDefault" class="headerlink" title="@JvmDefault"></a>@JvmDefault</h3><blockquote><p><code>@JvmDefault</code> 从 Kotlin 1.3 开始支持，而且现阶段是<strong>实验性</strong>的。更多详情请查看 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index.html" target="_blank" rel="noopener">JvmDefault</a>。</p></blockquote><p>Kotlin 兼容很多 Java 版本，包含接口中不允许方法默认实现的 Java6 和 Java7 。方便起见，Kotlin 编译器可以解决这个问题，但是这个解决方案将不会和 Java8 中的  <code>default</code>  方法兼容。</p><p>对于和 Java 的交互，这可能是个问题，所以 Kotlin 1.3 引入了 <code>@JvmDefalut</code> 注解。被该注解标记的方法将会被 JVM 编译为 <code>default</code> 方法。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">interface</span> Foo <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 将会被编译为默认方法</span>    <span class="token annotation builtin">@JvmDefault</span>    <span class="token keyword">fun</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Int <span class="token operator">=</span> <span class="token number">42</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意：</strong>将你的 API 标记为 <code>@JvmDefault</code> 将会对二进制兼容性有严重影响。在项目中使用 <code>@Default</code> 之前，请仔细阅读 <a href="https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-default/index.html" target="_blank" rel="noopener">JvmDefault</a>。</p></blockquote><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="多平台随机数"><a href="#多平台随机数" class="headerlink" title="多平台随机数"></a>多平台随机数</h3><p>在 Kotlin 1.3 之前，没有办法在所有平台上统一来生成随机数 — 我们只能采取依赖平台的特定解决方案，比如 JVM 上的 <code>java.util.Random</code>。这个版本将会解决这个问题，通过引入 <code>kotlin.random.Random</code>，这是个支持所有平台的类：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>random<span class="token punctuation">.</span>Random<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//sampleStart</span>    <span class="token keyword">val</span> number <span class="token operator">=</span> Random<span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 数字区间 [0, limit)</span>    <span class="token function">println</span><span class="token punctuation">(</span>number<span class="token punctuation">)</span><span class="token comment" spellcheck="true">//sampleEnd</span><span class="token punctuation">}</span></code></pre><h3 id="isNullOrEmpty-与-orEmpty"><a href="#isNullOrEmpty-与-orEmpty" class="headerlink" title="isNullOrEmpty 与 orEmpty"></a>isNullOrEmpty 与 orEmpty</h3><p>某些类型的 <code>isNullOrEmpty</code> 和 <code>orEmpty</code> 扩展函数已经存在于标准库中，对于前者，如果函数接受者是 <code>null</code> 或者为空将会返回 <code>true</code>；对于后者， 如果接收者是 <code>null</code>，将会返回一个空实例。</p><p>Kotlin 1.3 为 <code>collections</code>、<code>maps</code> 和对象数组提供了类似的扩展函数。</p><h3 id="非空数组间拷贝元素"><a href="#非空数组间拷贝元素" class="headerlink" title="非空数组间拷贝元素"></a>非空数组间拷贝元素</h3><p>对于非空数组类型，包括无符号数组类型，函数 <code>array.copyInto(targetArray, targetOffset, startIndex, endIndex)</code> 使得数组拷贝在 Kotlin 中更加简单。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//sampleStart</span>    <span class="token keyword">val</span> sourceArr <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token string">"k"</span><span class="token punctuation">,</span> <span class="token string">"o"</span><span class="token punctuation">,</span> <span class="token string">"t"</span><span class="token punctuation">,</span> <span class="token string">"l"</span><span class="token punctuation">,</span> <span class="token string">"i"</span><span class="token punctuation">,</span> <span class="token string">"n"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> targetArr <span class="token operator">=</span> sourceArr<span class="token punctuation">.</span><span class="token function">copyInto</span><span class="token punctuation">(</span>arrayOfNulls<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> startIndex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">,</span> endIndex <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>targetArr<span class="token punctuation">.</span><span class="token function">contentToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    sourceArr<span class="token punctuation">.</span><span class="token function">copyInto</span><span class="token punctuation">(</span>targetArr<span class="token punctuation">,</span> startIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> endIndex <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>targetArr<span class="token punctuation">.</span><span class="token function">contentToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//sampleEnd</span><span class="token punctuation">}</span></code></pre><h3 id="associateWith"><a href="#associateWith" class="headerlink" title="associateWith"></a>associateWith</h3><p>对于 <code>list</code> 一个非常常见的场景是，希望通过把 <code>list</code> 的每个元素作为 <code>key</code>，然后和某个 <code>value</code> 关联起来，来构建一个 <code>map</code>。这可以通过 <code>associate { it to getValue(it) }</code> 函数来完成，但是现在我们引入了一个更为效率和便捷的实现方式：<code>keys.associateWith { getValue(it) }</code>。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//sampleStart</span>    <span class="token keyword">val</span> keys <span class="token operator">=</span> <span class="token string">'a'</span><span class="token operator">..</span><span class="token string">'f'</span>    <span class="token keyword">val</span> map <span class="token operator">=</span> keys<span class="token punctuation">.</span><span class="token function">associateWith</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">repeat</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">capitalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    map<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">//sampleEnd</span><span class="token punctuation">}</span></code></pre><h3 id="ifEmpty-与-ifBlank"><a href="#ifEmpty-与-ifBlank" class="headerlink" title="ifEmpty 与 ifBlank"></a>ifEmpty 与 ifBlank</h3><p><code>Collections</code>、<code>maps</code>、<code>object arrays</code>、<code>char sequence</code> 和 <code>sequence</code> 现在都有 <code>ifEmpty</code> 函数，用于指定一个默认值，当接收者为空时：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//sampleStart</span>    <span class="token keyword">fun</span> <span class="token function">printAllUppercase</span><span class="token punctuation">(</span><span class="token keyword">data</span><span class="token operator">:</span> List<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">val</span> result <span class="token operator">=</span> <span class="token keyword">data</span>        <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">all</span> <span class="token punctuation">{</span> c <span class="token operator">-></span> c<span class="token punctuation">.</span><span class="token function">isUpperCase</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token punctuation">}</span>            <span class="token punctuation">.</span><span class="token function">ifEmpty</span> <span class="token punctuation">{</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"&lt;no uppercase>"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>        result<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token function">printAllUppercase</span><span class="token punctuation">(</span><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"foo"</span><span class="token punctuation">,</span> <span class="token string">"Bar"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token function">printAllUppercase</span><span class="token punctuation">(</span><span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"FOO"</span><span class="token punctuation">,</span> <span class="token string">"BAR"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//sampleEnd</span><span class="token punctuation">}</span></code></pre><p><code>Char sequences</code> 和 <code>strings</code> 还额外拥有 <code>ifBlank</code> 扩展，和 <code>ifEmpty</code> 功能类似，但是用于检查一个 <code>string</code> 是否全是空格。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment" spellcheck="true">//sampleStart</span>    <span class="token keyword">val</span> s <span class="token operator">=</span> <span class="token string">"    \n"</span>    <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ifBlank</span> <span class="token punctuation">{</span> <span class="token string">"&lt;blank>"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span><span class="token function">ifBlank</span> <span class="token punctuation">{</span> <span class="token keyword">null</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">//sampleEnd</span><span class="token punctuation">}</span></code></pre><h3 id="反射中的密封类"><a href="#反射中的密封类" class="headerlink" title="反射中的密封类"></a>反射中的密封类</h3><p>我们向 <code>kotlin-reflect</code> 添加了一个新的 API ： <code>KClass.sealedSubclasses</code>，用于列出所有密封类的子类型。</p><h3 id="微小的改变"><a href="#微小的改变" class="headerlink" title="微小的改变"></a>微小的改变</h3><ul><li><code>Boolean</code> 类型现在支持伴生对象。</li><li><code>Any?.hashCode()</code>  扩展函数会在 <code>null</code> 的时候返回 0。</li><li><code>Char</code> 类型现在提供了 <code>MIN_VALUE</code>/<code>MAX_VALUE</code> 常量。</li><li><code>SIZE_BYTES</code> 和  <code>SIZE_BITS</code> 会作为原生类型伴生对象常量。</li></ul><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="IDE-中的代码风格支持"><a href="#IDE-中的代码风格支持" class="headerlink" title="IDE 中的代码风格支持"></a>IDE 中的代码风格支持</h3><p>Kotlin 1.3 在 IDE 中引入了<a href="https://kotlinlang.org/docs/reference/coding-conventions.html" target="_blank" rel="noopener">推荐代码风格</a>支持。具体迁移指南查看 <a href="https://kotlinlang.org/docs/reference/code-style-migration-guide.html" target="_blank" rel="noopener">Code Style Migration Guide</a>。</p><h3 id="kotlinx-serialization"><a href="#kotlinx-serialization" class="headerlink" title="kotlinx.serialization"></a>kotlinx.serialization</h3><p><a href="https://github.com/Kotlin/kotlinx.serialization" target="_blank" rel="noopener">kotlinx.serialization</a> 是一个提供支持多平台的序列化/反序列化的库。之前作为一个独立的库，从 Kotlin 1.3 起，它将会和其他编译器插件一样，包含在 Kotlin 编译器发行版中。主要区别在于，你不在需要自行关注 IDE 的序列化插件和 Kotlin IDE 插件的兼容性问题：因为 Kotlin IDE 插件已经支持序列化！</p><blockquote><p>值得注意的是，即便 kotlinx.serialization  包含在 Kotlin 编译器发行版中，它仍是一个<strong>实验性</strong>功能。</p></blockquote><h3 id="脚本更新"><a href="#脚本更新" class="headerlink" title="脚本更新"></a>脚本更新</h3><blockquote><p>注意，脚本是个<strong>实验性</strong>功能，对于现有的 API, 并没有任何兼容性的保障。</p></blockquote><p>Kotlin 1.3 将继续完善 script API，引入了一些自定义脚本实验性的支持，比如添加额外属性，提供静态或者动态依赖等。</p><p>更多详细信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/scripting-support.md" target="_blank" rel="noopener">Kotlin Scripting support</a>。</p><h3 id="草稿文件支持"><a href="#草稿文件支持" class="headerlink" title="草稿文件支持"></a>草稿文件支持</h3><p>Kotlin 1.3 引入了对可运行的<strong>草稿文件</strong>支持。草稿文件是一个以 <code>.kts</code> 扩展名结尾的 kotlin 脚本文件，可以在编辑器里直接运行和获取计算结果。</p><p>更多详细信息请参考 <a href="https://www.jetbrains.com/help/idea/scratches.html" target="_blank" rel="noopener">Scratches</a>。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kotlinlang.org/docs/reference/whatsnew13.html" target="_blank" rel="noopener">What’s New in Kotlin 1.3</a></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 1.2 的新特性</title>
      <link href="/posts/2018/9e8f91b4.html"/>
      <url>/posts/2018/9e8f91b4.html</url>
      
        <content type="html"><![CDATA[<h2 id="Kotlin-1-2-新特性"><a href="#Kotlin-1-2-新特性" class="headerlink" title="Kotlin 1.2 新特性"></a>Kotlin 1.2 新特性</h2><p>Kotlin 1.2 新特性包含以下几个方面：</p><ul><li>多平台项目</li><li>其他语言特性</li><li>标准库</li><li>JVM 后端</li><li>JavaScript 后端</li></ul><h2 id="多平台项目"><a href="#多平台项目" class="headerlink" title="多平台项目"></a>多平台项目</h2><p>多平台项目是 Kotlin 1.2 中的一个新的<strong><code>实验性</code></strong>的特性，允许你在支持 Kotlin 的目标平台——JVM、JavaScript 以及(将来的) Native 之间重用代码。在多平台项目中，你有三种模块：</p><ul><li>一个公共模块包含平台无关代码，以及无实现的依赖平台的 API 声明。</li><li>平台模块包含通用模块中的平台相关声明在指定平台的实现，以及其他平台相关代码。</li><li>常规模块针对指定的平台，既可以是平台模块的依赖，也可以依赖平台模块。</li></ul><p>当你为指定平台编译多平台项目时，既会生成公共代码也会生成平台相关代码。</p><p>多平台项目支持的一个主要特点是可以通过<strong>预期声明与实际声明</strong>来表达公共代码对平台相关部分的依赖关系。一个预期声明指定一个 API(类、接口、注解、顶层声明等)。一个实际声明要么是该 API 的平台相关实现，要么是一个引用到在一个外部库中该 API 的一个既有实现的别名。下面是一个示例：</p><p>在公共代码中：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 预期平台相关 API:</span>expect <span class="token keyword">fun</span> <span class="token function">hello</span><span class="token punctuation">(</span>world<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> String​<span class="token keyword">fun</span> <span class="token function">greet</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 该预期 API 的用法：</span>    <span class="token keyword">val</span> greeting <span class="token operator">=</span> <span class="token function">hello</span><span class="token punctuation">(</span><span class="token string">"multi-platform world"</span><span class="token punctuation">)</span>    <span class="token function">println</span><span class="token punctuation">(</span>greeting<span class="token punctuation">)</span><span class="token punctuation">}</span>​expect <span class="token keyword">class</span> <span class="token function">URL</span><span class="token punctuation">(</span>spec<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">getHost</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String    <span class="token keyword">open</span> <span class="token keyword">fun</span> <span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> String<span class="token punctuation">}</span></code></pre><p>在 JVM 平台代码中：</p><pre class=" language-kotlin"><code class="language-kotlin">actual <span class="token keyword">fun</span> <span class="token function">hello</span><span class="token punctuation">(</span>world<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> String <span class="token operator">=</span>    <span class="token string">"Hello, <span class="token interpolation variable">$world</span>, on the JVM platform!"</span>​<span class="token comment" spellcheck="true">// 使用既有平台相关实现：</span>actual typealias URL <span class="token operator">=</span> java<span class="token punctuation">.</span>net<span class="token punctuation">.</span>URL</code></pre><p>关于构建多平台项目的详细信息与步骤，请参考 <a href="http://kotlinlang.org/docs/reference/multiplatform.html" target="_blank" rel="noopener">Multiplatform Programming</a>。</p><h2 id="其他语言特性"><a href="#其他语言特性" class="headerlink" title="其他语言特性"></a>其他语言特性</h2><h3 id="注解中的数组字面值"><a href="#注解中的数组字面值" class="headerlink" title="注解中的数组字面值"></a>注解中的数组字面值</h3><p>自 Kotlin 1.2 起，注解的数组参数可以使用新的数组常量语法传入，而无需使用 <code>arrayOf</code> 函数：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token annotation builtin">@CacheConfig</span><span class="token punctuation">(</span>cacheNames <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"books"</span><span class="token punctuation">,</span> <span class="token string">"default"</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> BookRepositoryImpl <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// ……</span><span class="token punctuation">}</span></code></pre><p>数组常量语法被限制为注释参数。</p><h3 id="lateinit-顶层属性与局部变量"><a href="#lateinit-顶层属性与局部变量" class="headerlink" title="lateinit 顶层属性与局部变量"></a>lateinit 顶层属性与局部变量</h3><p><code>lateinit</code> 修饰符现在可以用在顶级属性和局部变量上。例如，当一个 lambda 作为构造函数参数传递给一个对象时，后者可以用于引用另一个必须稍后定义的对象：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> Node<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token keyword">val</span> value<span class="token operator">:</span> T<span class="token punctuation">,</span> <span class="token keyword">val</span> next<span class="token operator">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-></span> Node<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span>​<span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 三个节点的环：</span>    <span class="token keyword">lateinit</span> <span class="token keyword">var</span> third<span class="token operator">:</span> Node<span class="token operator">&lt;</span>Int<span class="token operator">></span>​    <span class="token keyword">val</span> second <span class="token operator">=</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token punctuation">{</span> third <span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> first <span class="token operator">=</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token punctuation">{</span> second <span class="token punctuation">}</span><span class="token punctuation">)</span>​    third <span class="token operator">=</span> <span class="token function">Node</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> next <span class="token operator">=</span> <span class="token punctuation">{</span> first <span class="token punctuation">}</span><span class="token punctuation">)</span>​    <span class="token keyword">val</span> nodes <span class="token operator">=</span> <span class="token function">generateSequence</span><span class="token punctuation">(</span>first<span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Values in the cycle: <span class="token interpolation"><span class="token delimiter variable">${</span>nodes<span class="token punctuation">.</span><span class="token function">take</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">joinToString</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token delimiter variable">}</span></span>}, ..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="检查-lateinit-变量是否已初始化"><a href="#检查-lateinit-变量是否已初始化" class="headerlink" title="检查 lateinit 变量是否已初始化"></a>检查 lateinit 变量是否已初始化</h3><p>现在可以通过属性引用的 <code>isInitialized</code> 来检测该 <code>lateinit</code> 变量是否已初始化：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"isInitialized before assignment: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token operator">::</span>lateinitVar<span class="token punctuation">.</span>isInitialized<span class="token punctuation">)</span>lateinitVar <span class="token operator">=</span> <span class="token string">"value"</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"isInitialized after assignment: "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token operator">::</span>lateinitVar<span class="token punctuation">.</span>isInitialized<span class="token punctuation">)</span></code></pre><h3 id="内联函数带有默认函数式参数"><a href="#内联函数带有默认函数式参数" class="headerlink" title="内联函数带有默认函数式参数"></a>内联函数带有默认函数式参数</h3><p>内联函数现在允许其内联函数参数具有默认值：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> Iterable<span class="token operator">&lt;</span>E<span class="token operator">></span><span class="token punctuation">.</span><span class="token function">strings</span><span class="token punctuation">(</span>transform<span class="token operator">:</span> <span class="token punctuation">(</span>E<span class="token punctuation">)</span> <span class="token operator">-></span> String <span class="token operator">=</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span>    map <span class="token punctuation">{</span> <span class="token function">transform</span><span class="token punctuation">(</span>it<span class="token punctuation">)</span> <span class="token punctuation">}</span>​<span class="token keyword">val</span> defaultStrings <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">strings</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> customStrings <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">strings</span> <span class="token punctuation">{</span> <span class="token string">"(<span class="token interpolation variable">$it</span>)"</span> <span class="token punctuation">}</span> </code></pre><h3 id="源自显式类型转换的信息会用于类型推断"><a href="#源自显式类型转换的信息会用于类型推断" class="headerlink" title="源自显式类型转换的信息会用于类型推断"></a>源自显式类型转换的信息会用于类型推断</h3><p>Kotlin 编译器现在可以使用类型转换信息进行类型推断。如果调用一个返回类型参数 <code>T</code> 并将返回值转换为特定类型 <code>Foo</code> 的泛型方法，则编译器现在可以理解此调用的 <code>T</code> 需要绑定到 <code>Foo</code> 类型。</p><p>这对 Android 开发者来说尤其重要，因为编译器现在可以在 Android API level 26 中正确分析范型 <code>findViewById</code> 调用：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> button <span class="token operator">=</span> <span class="token function">findViewById</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>button<span class="token punctuation">)</span> <span class="token keyword">as</span> Button</code></pre><h3 id="智能类型转换改进"><a href="#智能类型转换改进" class="headerlink" title="智能类型转换改进"></a>智能类型转换改进</h3><p>当一个变量从一个安全调用表达式中被赋值并且被检查为 null 时，<code>智能转换</code>也被应用到安全调用接收器中：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> firstChar <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token keyword">as</span><span class="token operator">?</span> CharSequence<span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">firstOrNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>firstChar <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">count</span> <span class="token punctuation">{</span> it <span class="token operator">==</span> firstChar <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// s: Any 会智能转换为 CharSequence</span>​<span class="token keyword">val</span> firstItem <span class="token operator">=</span> <span class="token punctuation">(</span>s <span class="token keyword">as</span><span class="token operator">?</span> Iterable<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">firstOrNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">if</span> <span class="token punctuation">(</span>firstItem <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token keyword">return</span> s<span class="token punctuation">.</span><span class="token function">count</span> <span class="token punctuation">{</span> it <span class="token operator">==</span> firstItem <span class="token punctuation">}</span> <span class="token comment" spellcheck="true">// s: Any 会智能转换为 Iterable&lt;*></span></code></pre><p>智能转换现在也允许用于在 lambda 表达式中局部变量，只要这些局部变量仅在 lambda 表达式之前修改即可：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> flag <span class="token operator">=</span> args<span class="token punctuation">.</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token keyword">var</span> x<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> x <span class="token operator">=</span> <span class="token string">"Yahoo!"</span>run <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>x <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">println</span><span class="token punctuation">(</span>x<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// x 会智能转换为 String</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="支持-foo-作为-this-foo-的简写"><a href="#支持-foo-作为-this-foo-的简写" class="headerlink" title="支持 ::foo 作为 this::foo 的简写"></a>支持 ::foo 作为 this::foo 的简写</h3><p>现在绑定到 <code>this</code> 成员的可调用引用可以无需显式接收者，可以使用 <code>::foo</code> 替代 <code>this::foo</code>，写入一个绑定的可调用的引用，而不用明确的接收器。这也使得可调用的引用在你引用外部接收者的成员的 lambda 中更方便使用。</p><h3 id="阻断性变更：try-块后可靠智能转换"><a href="#阻断性变更：try-块后可靠智能转换" class="headerlink" title="阻断性变更：try 块后可靠智能转换"></a>阻断性变更：try 块后可靠智能转换</h3><p>Kotlin 以前将 <code>try</code> 块中的赋值语句用于块后的智能转换，这可能会破坏类型安全与空安全并导致运行时失败。这个版本修复了此问题，使智能转换更加严格，但可能会破坏一些依靠这种智能转换的代码。</p><p>如果要切换到旧版智能转换行为，请传入回退标志 <code>-Xlegacy-smart-cast-after-try</code> 作为编译器参数，该参数会在 Kotlin 1.3中弃用。</p><h3 id="弃用：数据类弃用-copy"><a href="#弃用：数据类弃用-copy" class="headerlink" title="弃用：数据类弃用 copy"></a>弃用：数据类弃用 copy</h3><p>当从已经具有相同签名的 <code>copy</code> 函数的类型派生数据类时，为数据类生成的 <code>copy</code> 实现使用父类型的默认函数，会导致出现与预期相反的行为，如果父类型没有默认参数，则在运行时失败</p><p>导致 <code>copy</code> 冲突的继承在 Kotlin 1.2 中已弃用并带有警告，而在 Kotlin 1.3中将会是错误。</p><h3 id="弃用：枚举项中的嵌套类型"><a href="#弃用：枚举项中的嵌套类型" class="headerlink" title="弃用：枚举项中的嵌套类型"></a>弃用：枚举项中的嵌套类型</h3><p>在枚举项中，由于初始化逻辑中的问题，定义一个非 <code>inner class</code> 的嵌套类型的功能已经被弃用。在 Kotlin 1.2 中这将会引起警告，并将在 Kotlin 1.3 中报错。</p><h3 id="弃用：vararg-中的单命名参数"><a href="#弃用：vararg-中的单命名参数" class="headerlink" title="弃用：vararg 中的单命名参数"></a>弃用：vararg 中的单命名参数</h3><p>为了与注解中的数组常量保持一致，在命名的表单(<code>foo(items = i)</code>) 中为 <code>vararg</code> 参数传递的单个项目已被弃用。请使用具有相应数组工厂函数的展开运算符：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token function">foo</span><span class="token punctuation">(</span>items <span class="token operator">=</span> <span class="token operator">*</span><span class="token function">intArrayOf</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>在这种情况下，有一种优化可以消除冗余数组的创建，从而防止性能下降。单一参数的表单在 Kotlin 1.2 中会引起警告，并将在 Kotlin 1.3 中被移除。</p><h3 id="弃用：扩展-Throwable-的泛型类的内部类"><a href="#弃用：扩展-Throwable-的泛型类的内部类" class="headerlink" title="弃用：扩展 Throwable 的泛型类的内部类"></a>弃用：扩展 Throwable 的泛型类的内部类</h3><p>继承自 <code>Throwable</code> 的泛型的内部类可能会违反 throw-catch 场景中的类型安全性，因此已被弃用，在 Kotlin 1.2 中会被警告，在 Kotlin 1.3 中将会报错。</p><h3 id="弃用：修改只读属性的幕后字段"><a href="#弃用：修改只读属性的幕后字段" class="headerlink" title="弃用：修改只读属性的幕后字段"></a>弃用：修改只读属性的幕后字段</h3><p>在自定义 getter 中通过赋值 <code>field = ...</code> 来改变只读属性的幕后字段字段已被弃用，在 Kotlin 1.2 中会被警告，在 Kotlin 1.3 中将会报错。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="Kotlin-标准库构件与拆分包"><a href="#Kotlin-标准库构件与拆分包" class="headerlink" title="Kotlin 标准库构件与拆分包"></a>Kotlin 标准库构件与拆分包</h3><p>Kotlin 标准库现在完全兼容 Java 9 的模块系统，它会禁止对包进行拆分(多个 jar 文件声明的类在同一包中)。为了支持这一点，引入了新的构件 <code>kotlin-stdlib-jdk7</code> 和 <code>kotlin-stdlib-jdk8</code>，取代了旧版的 <code>kotlin-stdlib-jre7</code> 和 <code>kotlin-stdlib-jre8</code>。</p><p>新构件中的声明从 Kotlin 的角度来看在相同的包名下是可见的，但是对 Java 而言它们有不同的包名。因此，切换到新的构件不需要对源代码进行任何更改。</p><p>确保与新的模块系统兼容的另一个更改是从 <code>kotlin-reflect</code> 库中移除了 <code>kotlin.reflect</code> 包中的弃用声明。如果正在使用它们，则需要使用 <code>kotlin.reflect.full</code> 包中的声明，自 Kotlin 1.1 起就支持这个包了。</p><h3 id="windowed、chunked、zipWithNext"><a href="#windowed、chunked、zipWithNext" class="headerlink" title="windowed、chunked、zipWithNext"></a>windowed、chunked、zipWithNext</h3><p>用于 <code>Iterable&lt;T&gt;</code>、<code>Sequence&lt;T&gt;</code> 与 <code>CharSequence</code> 的新的扩展包含了诸如：缓冲或批处理(<code>chunked</code>)、滑动窗口和计算滑动平均值(<code>windowed</code>)以及处理成对的后续条目(<code>zipWithNext</code>)等用例：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> items <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">map</span> <span class="token punctuation">{</span> it <span class="token operator">*</span> it <span class="token punctuation">}</span><span class="token keyword">val</span> chunkedIntoLists <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">chunked</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">val</span> points3d <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">chunked</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token function">Triple</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">val</span> windowed <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">windowed</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token keyword">val</span> slidingAverage <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">windowed</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">average</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token keyword">val</span> pairwiseDifferences <span class="token operator">=</span> items<span class="token punctuation">.</span><span class="token function">zipWithNext</span> <span class="token punctuation">{</span> a<span class="token punctuation">,</span> b <span class="token operator">-></span> b <span class="token operator">-</span> a <span class="token punctuation">}</span></code></pre><p>​</p><h3 id="fill、replaceAll、shuffle-shuffled"><a href="#fill、replaceAll、shuffle-shuffled" class="headerlink" title="fill、replaceAll、shuffle/shuffled"></a>fill、replaceAll、shuffle/shuffled</h3><p>添加了一系列扩展函数用于处理列表：针对 <code>MutableList</code> 的 <code>fill</code>、<code>replaceAll</code> 和 <code>shuffle</code> ，以及针对只读 <code>List</code> 的 <code>shuffled</code>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> items <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toMutableList</span><span class="token punctuation">(</span><span class="token punctuation">)</span>items<span class="token punctuation">.</span><span class="token function">shuffle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Shuffled items: <span class="token interpolation variable">$items</span>"</span><span class="token punctuation">)</span>items<span class="token punctuation">.</span><span class="token function">replaceAll</span> <span class="token punctuation">{</span> it <span class="token operator">*</span> <span class="token number">2</span> <span class="token punctuation">}</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Items doubled: <span class="token interpolation variable">$items</span>"</span><span class="token punctuation">)</span>items<span class="token punctuation">.</span><span class="token function">fill</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Items filled with 5: <span class="token interpolation variable">$items</span>"</span><span class="token punctuation">)</span></code></pre><h3 id="kotlin-stdlib-中的数学运算"><a href="#kotlin-stdlib-中的数学运算" class="headerlink" title="kotlin-stdlib 中的数学运算"></a>kotlin-stdlib 中的数学运算</h3><p>为满足用户长期以来的需求，Kotlin 1.2 中增加了用于数学运算的 <code>kotlin.math</code> API，也是 JVM 和 JS 的通用 API，包含以下内容：</p><ul><li>常量：<code>PI</code> 与 <code>E</code>；</li><li>三角函数：<code>cos</code>、<code>sin</code>、<code>tan</code> 及其反函数：<code>acos</code>、<code>asin</code>、<code>atan</code>、<code>atan2</code>；</li><li>双曲函数：<code>cosh</code>、<code>sinh</code>、<code>tanh</code> 及其反函数：<code>acosh</code>、<code>asinh</code>、<code>atanh</code></li><li>指数函数：<code>pow</code>(扩展函数)、<code>sqrt</code>、<code>hypot</code>、<code>exp</code>、<code>expm1</code>；</li><li>对数函数：<code>log</code>、<code>log2</code>、<code>log10</code>、<code>ln</code>、<code>ln1p</code>；</li><li>取整函数:<ul><li><code>ceil</code>、<code>floor</code>、<code>truncate</code>、<code>round</code>(奇进偶舍)函数；</li><li><code>roundToInt</code>、<code>roundToLong</code>(四舍五入)扩展函数；</li></ul></li><li>符号函数与绝对值：<ul><li><code>abs</code> 与 <code>sign</code> 函数；</li><li><code>absoluteValue</code> 与 <code>sign</code> 扩展属性；</li><li><code>withSign</code> 扩展函数；</li></ul></li><li>两个数的最值函数：<code>max</code> 与 <code>min</code>；</li><li>二进制表示：<ul><li><code>ulp</code> 扩展属性；</li><li><code>nextUp</code>、<code>nextDown</code>、<code>nextTowards</code> 扩展函数；</li><li><code>toBits</code>、<code>toRawBits</code>、<code>Double.fromBits</code>(这些在 kotlin 包中)。</li></ul></li></ul><p>同系列(但不包括常量)的函数也针对 <code>Float</code> 型参数提供了。</p><h3 id="用于-BigInteger-与-BigDecimal-的操作符与转换"><a href="#用于-BigInteger-与-BigDecimal-的操作符与转换" class="headerlink" title="用于 BigInteger 与 BigDecimal 的操作符与转换"></a>用于 BigInteger 与 BigDecimal 的操作符与转换</h3><p>Kotlin 1.2 引入了一组用于操作 <code>BigInteger</code> 和 <code>BigDecimal</code> 以及使用从其他数字类型进行转换的函数。具体如下：</p><ul><li><code>toBigInteger</code> 用于 <code>Int</code> 与 <code>Long</code>；</li><li><code>toBigDecimal</code> 用于 <code>Int</code>、<code>Long</code>、<code>Float</code>、<code>Double</code> 以及 <code>BigInteger</code>；</li><li>算术与位运算操作符函数：<ul><li>二元操作符 <code>+</code>、<code>-</code>、<code>*</code>、<code>/</code>、<code>%</code> 以及中缀函数 <code>and</code>、<code>or</code>、<code>xor</code>、<code>shl</code>、<code>shr</code>；</li><li>一元操作符 <code>-</code>、<code>++</code>、<code>--</code> 以及函数 <code>inv</code>。</li></ul></li></ul><h3 id="浮点数到位的转换"><a href="#浮点数到位的转换" class="headerlink" title="浮点数到位的转换"></a>浮点数到位的转换</h3><p>添加了用于将 <code>Double</code> 及 <code>Float</code> 与其位表示形式相互转换的函数：</p><ul><li><code>toBits</code> 与 <code>toRawBits</code> 对于 <code>Double</code> 返回 <code>Long</code> 而对于 <code>Float</code> 返回 <code>Int</code>；</li><li><code>Double.fromBits</code> 与 <code>Float.fromBits</code> 用于从位表示形式中转换为浮点数。</li></ul><h3 id="正则表达式现在可序列化"><a href="#正则表达式现在可序列化" class="headerlink" title="正则表达式现在可序列化"></a>正则表达式现在可序列化</h3><p><code>kotlin.text.Regex</code> 类现在已经是 <code>Serializable</code> 的了，并且可以在可序列化的层次结构中使用。</p><h3 id="如果满足条件，Closeable-use-可以调用-Throwable-addSuppressed"><a href="#如果满足条件，Closeable-use-可以调用-Throwable-addSuppressed" class="headerlink" title="如果满足条件，Closeable.use 可以调用 Throwable.addSuppressed"></a>如果满足条件，Closeable.use 可以调用 Throwable.addSuppressed</h3><p>当在其他异常处理后，关闭资源期间抛出异常时，<code>Closeable.use</code> 函数可调用 <code>Throwable.addSuppressed</code>。</p><p>要启用这个行为，需要在依赖关系中包含 <code>kotlin-stdlib-jdk7</code>。</p><h2 id="JVM-后端"><a href="#JVM-后端" class="headerlink" title="JVM 后端"></a>JVM 后端</h2><h3 id="构造函数调用规范化"><a href="#构造函数调用规范化" class="headerlink" title="构造函数调用规范化"></a>构造函数调用规范化</h3><p>自 1.0 以来，Kotlin 就开始支持复杂控制流的表达式，例如 try-catch 表达式和内联函数调用。根据 Java 虚拟机规范这样的代码是合法的。不幸的是，当构造函数调用的参数中存在这样的表达式时，一些字节码处理工具不能很好地处理这些代码。</p><p>为了减少使用此类字节码处理工具的用户的这个问题，我们添加了一个命令行选项(<code>-Xnormalize-constructor-calls=MODE</code>)，它会告诉编译器为这样的结构生成更多的类 Java 字节码。这里 <code>MODE</code> 的值是以下之一：</p><ul><li><code>disable</code>(默认值)——以和 Kotlin 1.0 和 1.1 相同的方式生成字节码；</li><li><code>enable</code>——为构造函数调用生成类似 Java 的字节码，这可以改变类加载和初始化的顺序；</li><li><code>preserve-class-initialization</code>——为构造函数调用生成类似 Java 的字节码，并确保保持类初始化顺序。这可能会影响应用程序的整体性能；仅用在多个类之间共享一些复杂状态并在类初始化时更新的场景中。</li></ul><p>“手工”的解决方法是将控制流的子表达式的值存储在变量中，而不是直接在调用参数中对它们进行求值。它类似于 <code>-Xnormalize-constructor-calls=enable</code>。</p><h3 id="Java-默认方法调用"><a href="#Java-默认方法调用" class="headerlink" title="Java 默认方法调用"></a>Java 默认方法调用</h3><p>在 Kotlin 1.2 之前，接口成员在使用 JVM 1.6 的情况下重写 Java 默认方法会在父调用中产生警告：<code>Super calls to Java default methods are deprecated in JVM target 1.6. Recompile with &#39;-jvm-target 1.8&#39;</code>。在 Kotlin 1.2 中，这将会报错，因此需要使用 JVM 1.8 来编译这些代码。</p><h3 id="阻断性变更：平台类型-x-equals-null-的一致行为"><a href="#阻断性变更：平台类型-x-equals-null-的一致行为" class="headerlink" title="阻断性变更：平台类型 x.equals(null) 的一致行为"></a>阻断性变更：平台类型 x.equals(null) 的一致行为</h3><p>在映射到 Java 原生类型(<code>Int!</code>、<code>Boolean!</code>、<code>Short!</code>、<code>Long!</code>、<code>Float!</code>、<code>Double!</code>、<code>Char!</code>)的平台类型上调用 <code>x.equals(null)</code>，当 <code>x</code> 为 <code>null</code> 时错误地返回了 <code>true</code>。自 Kotlin 1.2 起，在平台类型的空值上调用 <code>x.equals(……)</code> 都会<strong>抛出 NPE</strong>(但 <code>x == ...</code> 不会)。</p><p>要返回到 1.2 之前的行为，请将标志 <code>-Xno-exception-on-explicit-equals-for-boxed-null</code> 传给编译器。</p><h3 id="阻断性变更：通过内联的扩展接收器修复平台的-null-转义"><a href="#阻断性变更：通过内联的扩展接收器修复平台的-null-转义" class="headerlink" title="阻断性变更：通过内联的扩展接收器修复平台的 null 转义"></a>阻断性变更：通过内联的扩展接收器修复平台的 null 转义</h3><p>在平台类型空值上调用的内联扩展函数并没有检查接收器是否为 null，并因此允许 null 转义到其他代码中。Kotlin 1.2 在调用点强制执行此检查，如果接收方为空，则抛出异常。</p><p>要切换到旧版行为，请将回退标志 <code>-Xno-receiver-assertions</code> 传给编译器。</p><h2 id="JavaScript-后端"><a href="#JavaScript-后端" class="headerlink" title="JavaScript 后端"></a>JavaScript 后端</h2><h3 id="默认启用对类型化数组-TypedArrays-的支持"><a href="#默认启用对类型化数组-TypedArrays-的支持" class="headerlink" title="默认启用对类型化数组(TypedArrays)的支持"></a>默认启用对类型化数组(TypedArrays)的支持</h3><p>JS typed arrays 支持将 Kotlin 原生数组(如 <code>IntArray</code>、<code>DoubleArray</code> 等)转换为 <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Typed_arrays" target="_blank" rel="noopener">JavaScript 的类型数组</a>，以前这是可选功能，现在默认情况下已启用。</p><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="将警告视为错误"><a href="#将警告视为错误" class="headerlink" title="将警告视为错误"></a>将警告视为错误</h3><p>编译器现在提供了一个将所有警告视为错误的选项。在命令行中使用 <code>-Werror</code>，或使用以下的 Gradle 代码：</p><pre class=" language-gradle"><code class="language-gradle">compileKotlin {    kotlinOptions.allWarningsAsErrors = true}</code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kotlinlang.org/docs/reference/whatsnew12.html" target="_blank" rel="noopener">What’s New in Kotlin 1.2</a></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 1.1 的新特性</title>
      <link href="/posts/2018/e2eeb46f.html"/>
      <url>/posts/2018/e2eeb46f.html</url>
      
        <content type="html"><![CDATA[<h2 id="Kotlin-1-1-新特性"><a href="#Kotlin-1-1-新特性" class="headerlink" title="Kotlin 1.1 新特性"></a>Kotlin 1.1 新特性</h2><p>Kotlin 1.1 新特性包含以下几个方面：</p><ul><li>协程</li><li>其它语言特性</li><li>标准库</li><li>JVM 后端</li><li>JavaScript 后端</li></ul><h2 id="协程"><a href="#协程" class="headerlink" title="协程"></a>协程</h2><p>Kotlin 1.1 的关键新特性就是<strong><code>协程</code></strong>，它带来了 <code>async/wait</code>、<code>yield</code> 以及类似的编程模式的支持。Kotlin 设计的关键特性是所有协程都是由库实现的，而不是语言。所以开发者不需要与任何特定的编程范例或者并行库进行绑定。</p><p>协程是一个高效且轻量级的线程，可以挂起并稍后恢复执行。协程是又挂起函数支持的：调用这个函数可能会挂起一个协程，并开启一个新的协程，大多数情况下采用匿名挂起函数(也就是可挂起 lambda 表达式)。</p><p>让我们看一下在 <a href="https://github.com/kotlin/kotlinx.coroutines" target="_blank" rel="noopener">kotlinx.coroutines</a> 库中实现的 <code>async/await</code>:</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token comment" spellcheck="true">// 在后台线程池中运行该代码</span><span class="token keyword">fun</span> <span class="token function">asyncOverlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">async</span><span class="token punctuation">(</span>CommonPool<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 启动两个异步操作</span>    <span class="token keyword">val</span> original <span class="token operator">=</span> <span class="token function">asyncLoadImage</span><span class="token punctuation">(</span><span class="token string">"original"</span><span class="token punctuation">)</span>    <span class="token keyword">val</span> overlay <span class="token operator">=</span> <span class="token function">asyncLoadImage</span><span class="token punctuation">(</span><span class="token string">"overlay"</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 然后应用叠加到两个结果</span>    <span class="token function">applyOverlay</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> overlay<span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 在 UI 上下文中启动新的协程</span><span class="token function">launch</span><span class="token punctuation">(</span>UI<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 等待异步叠加完成</span>    <span class="token keyword">val</span> image <span class="token operator">=</span> <span class="token function">asyncOverlay</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">await</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// 然后在 UI 中显示</span>    <span class="token function">showImage</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>async { …… }</code> 启动一个协程，当使用 <code>await()</code> 时，协程被挂起，而执行正在等待的操作，并且在等待的操作完成时恢复执行(可能在不同的线程上)。</p><p>标准库通过 <code>yield</code> 和 <code>yieldAll</code> 函数使用协程来支持 <code>lazily generated sequences</code> 惰性生成序列。在这样的序列中，在取回每个元素之后挂起返回序列元素的代码块， 并在请求下一个元素时恢复。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> seq <span class="token operator">=</span> buildSequence <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span>i <span class="token keyword">in</span> <span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 产生一个 i 的平方</span>        <span class="token function">yield</span><span class="token punctuation">(</span>i <span class="token operator">*</span> i<span class="token punctuation">)</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 产生一个区间</span>    <span class="token function">yieldAll</span><span class="token punctuation">(</span><span class="token number">26</span><span class="token operator">..</span><span class="token number">28</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 输出该序列</span><span class="token function">println</span><span class="token punctuation">(</span>seq<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>更多信息请参考 <a href="https://kotlinlang.org/docs/reference/coroutines.html" target="_blank" rel="noopener">Coroutines</a> 和 <a href="https://kotlinlang.org/docs/tutorials/coroutines-basic-jvm.html" target="_blank" rel="noopener">Tutorials</a>。</p><blockquote><p>请注意，协程目前还是一个<strong><code>实验性的特性</code></strong>，这意味着 Kotlin 团队不承诺在最终的 1.1 版本时保持该功能的向后兼容性。</p></blockquote><h2 id="其它语言特性"><a href="#其它语言特性" class="headerlink" title="其它语言特性"></a>其它语言特性</h2><h3 id="类型别名"><a href="#类型别名" class="headerlink" title="类型别名"></a>类型别名</h3><p>类型别名允许给现有的类型定义别名。主要在泛型类型（如集合）以及函数类型中很常用。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin">typealias OscarWinners <span class="token operator">=</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token keyword">fun</span> <span class="token function">countLaLaLand</span><span class="token punctuation">(</span>oscarWinners<span class="token operator">:</span> OscarWinners<span class="token punctuation">)</span> <span class="token operator">=</span>        oscarWinners<span class="token punctuation">.</span><span class="token function">count</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">contains</span><span class="token punctuation">(</span><span class="token string">"La La Land"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token comment" spellcheck="true">// 请注意，类型名称（初始名和类型别名）是可互换的：</span><span class="token keyword">fun</span> <span class="token function">checkLaLaLandIsTheBestMovie</span><span class="token punctuation">(</span>oscarWinners<span class="token operator">:</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token operator">=</span>        oscarWinners<span class="token punctuation">[</span><span class="token string">"Best picture"</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token string">"La La Land"</span></code></pre><p>更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/type-aliases.md" target="_blank" rel="noopener">KEEP</a> 或 <a href="https://kotlinlang.org/docs/reference/type-aliases.html" target="_blank" rel="noopener">Type aliases</a>。</p><h3 id="已绑定的可调用引用"><a href="#已绑定的可调用引用" class="headerlink" title="已绑定的可调用引用"></a>已绑定的可调用引用</h3><p>使用 <code>::</code> 操作符可以获取一个指向特定对象实例的方法或属性的成员引用。之前这只能用在 lambda 表达式上。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> numberRegex <span class="token operator">=</span> <span class="token string">"\\d+"</span><span class="token punctuation">.</span><span class="token function">toRegex</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">val</span> numbers <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">,</span> <span class="token string">"123"</span><span class="token punctuation">,</span> <span class="token string">"456"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>numberRegex<span class="token operator">::</span>matches<span class="token punctuation">)</span></code></pre><p>更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/bound-callable-references.md" target="_blank" rel="noopener">KEEP</a> 或 <a href="https://kotlinlang.org/docs/reference/reflection.html#bound-function-and-property-references-since-11" target="_blank" rel="noopener">Bound Function and Property References</a>。</p><h3 id="密封类和数据类"><a href="#密封类和数据类" class="headerlink" title="密封类和数据类"></a>密封类和数据类</h3><p>Kotlin 1.1 移除了一些对 Kotlin 1.0 中已存在的密封类和数据类的限制。现在可以在同一个文件中的任何地方定义一个密封类的子类，而不只是以作为密封类嵌套类的方式。数据类现在可以扩展其它类，这样可以更优雅简洁的定义表达式类的层次结构。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">sealed</span> <span class="token keyword">class</span> Expr<span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Const</span><span class="token punctuation">(</span><span class="token keyword">val</span> number<span class="token operator">:</span> Double<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Sum</span><span class="token punctuation">(</span><span class="token keyword">val</span> e1<span class="token operator">:</span> Expr<span class="token punctuation">,</span> <span class="token keyword">val</span> e2<span class="token operator">:</span> Expr<span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">object</span> NotANumber <span class="token operator">:</span> <span class="token function">Expr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">fun</span> <span class="token function">eval</span><span class="token punctuation">(</span>expr<span class="token operator">:</span> Expr<span class="token punctuation">)</span><span class="token operator">:</span> Double <span class="token operator">=</span> <span class="token keyword">when</span> <span class="token punctuation">(</span>expr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">is</span> Const <span class="token operator">-></span> expr<span class="token punctuation">.</span>number    <span class="token keyword">is</span> Sum <span class="token operator">-></span> <span class="token function">eval</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>e1<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">eval</span><span class="token punctuation">(</span>expr<span class="token punctuation">.</span>e2<span class="token punctuation">)</span>    NotANumber <span class="token operator">-></span> Double<span class="token punctuation">.</span>NaN<span class="token punctuation">}</span><span class="token keyword">val</span> e <span class="token operator">=</span> <span class="token function">eval</span><span class="token punctuation">(</span><span class="token function">Sum</span><span class="token punctuation">(</span><span class="token function">Const</span><span class="token punctuation">(</span><span class="token number">1.0</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">Const</span><span class="token punctuation">(</span><span class="token number">2.0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code></pre><p>密封类更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/sealed-class-inheritance.md" target="_blank" rel="noopener">KEEP</a>、<a href="https://kotlinlang.org/docs/reference/sealed-classes.html#relaxed-rules-for-sealed-classes-since-11" target="_blank" rel="noopener">Sealed Classes</a>。<br>数据类更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/data-class-inheritance.md" target="_blank" rel="noopener">KEEP</a> 或 <a href="https://kotlinlang.org/docs/reference/data-classes.html" target="_blank" rel="noopener">Data Classes</a>。</p><h3 id="lambda-表达式中的解构"><a href="#lambda-表达式中的解构" class="headerlink" title="lambda 表达式中的解构"></a>lambda 表达式中的解构</h3><p>现在可以使用 <a href="https://kotlinlang.org/docs/reference/multi-declarations.html" target="_blank" rel="noopener">解构声明</a> 语法取出 lambda 中的参数。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> map <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token number">1</span> <span class="token keyword">to</span> <span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token number">2</span> <span class="token keyword">to</span> <span class="token string">"two"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 之前</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">mapValues</span> <span class="token punctuation">{</span> entry <span class="token operator">-></span>    <span class="token keyword">val</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">=</span> entry  <span class="token string">"<span class="token interpolation variable">$key</span> -> <span class="token interpolation variable">$value</span>!"</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 现在</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">mapValues</span> <span class="token punctuation">{</span> <span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span> <span class="token operator">-></span> <span class="token string">"<span class="token interpolation variable">$key</span> -> <span class="token interpolation variable">$value</span>!"</span> <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/destructuring-in-parameters.md" target="_blank" rel="noopener">KEEP</a> 或 <a href="https://kotlinlang.org/docs/reference/multi-declarations.html#destructuring-in-lambdas-since-11" target="_blank" rel="noopener">Destructuring in Lambdas</a>。</p><h3 id="用下划线表示未使用的参数"><a href="#用下划线表示未使用的参数" class="headerlink" title="用下划线表示未使用的参数"></a>用下划线表示未使用的参数</h3><p>对于具有多个参数的 lambda 表达式，可以使用 <code>_</code> 字符替换不使用的参数的名称。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin">map<span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> _<span class="token punctuation">,</span> value <span class="token operator">-></span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"<span class="token interpolation variable">$value</span>!"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><p>这也适用于 <a href="https://kotlinlang.org/docs/reference/multi-declarations.html" target="_blank" rel="noopener">解构声明</a>。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> <span class="token punctuation">(</span>_<span class="token punctuation">,</span> status<span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/underscore-for-unused-parameters.md" target="_blank" rel="noopener">KEEP</a>。</p><h3 id="数字字面值中的下划线"><a href="#数字字面值中的下划线" class="headerlink" title="数字字面值中的下划线"></a>数字字面值中的下划线</h3><p>正如在 Java 8 中一样，Kotlin 现在支持在数字字面值中使用下划线来划分组。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> oneMillion <span class="token operator">=</span> 1_000_000<span class="token keyword">val</span> hexBytes <span class="token operator">=</span> 0xFF_EC_DE_5E<span class="token keyword">val</span> bytes <span class="token operator">=</span> 0b11010010_01101001_10010100_10010010</code></pre><p>更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/underscores-in-numeric-literals.md" target="_blank" rel="noopener">KEEP</a>。</p><h3 id="属性简写"><a href="#属性简写" class="headerlink" title="属性简写"></a>属性简写</h3><p>对于没有自定义访问器、或者将 getter 定义为表达式主体的属性，现在可以省略属性的类型。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> age<span class="token operator">:</span> Int<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">val</span> isAdult <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> age <span class="token operator">>=</span> <span class="token number">20</span> <span class="token comment" spellcheck="true">// 属性类型推断为 “Boolean”</span><span class="token punctuation">}</span></code></pre><h3 id="内联属性访问器"><a href="#内联属性访问器" class="headerlink" title="内联属性访问器"></a>内联属性访问器</h3><p>如果属性没有幕后字段，可以使用 inline 修饰符来标记该属性访问器。这些属性访问器的编译方式与<a href="http://kotlinlang.org/docs/reference/inline-functions.html" target="_blank" rel="noopener">内联函数</a>相同。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">public</span> <span class="token keyword">val</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> List<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">.</span>lastIndex<span class="token operator">:</span> Int    <span class="token keyword">inline</span> <span class="token keyword">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">-</span> <span class="token number">1</span></code></pre><p>更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/inline-properties.md" target="_blank" rel="noopener">KEEP</a> 或 <a href="http://kotlinlang.org/docs/reference/inline-functions.html#inline-properties-since-11" target="_blank" rel="noopener">Inline properties</a>。</p><h3 id="局部委托属性"><a href="#局部委托属性" class="headerlink" title="局部委托属性"></a>局部委托属性</h3><p>现在可以对局部变量使用<a href="http://kotlinlang.org/docs/reference/delegated-properties.html" target="_blank" rel="noopener">委托属性</a>语法。一个应用场景就是定义一个延迟求值的局部变量。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> answer <span class="token keyword">by</span> lazy <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Calculating the answer..."</span><span class="token punctuation">)</span>    <span class="token number">42</span><span class="token punctuation">}</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">needAnswer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                     <span class="token comment" spellcheck="true">// 返回随机值</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The answer is <span class="token interpolation variable">$answer</span>."</span><span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// 此时计算出答案</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>    <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sometimes no answer is the answer..."</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p>更多信息请参考 <a href="https://github.com/Kotlin/KEEP/blob/master/proposals/local-delegated-properties.md" target="_blank" rel="noopener">KEEP</a> 或 <a href="http://kotlinlang.org/docs/reference/delegated-properties.html#local-delegated-properties-since-11" target="_blank" rel="noopener">Local Delegated Properties</a>。</p><h3 id="拦截委托属性的绑定"><a href="#拦截委托属性的绑定" class="headerlink" title="拦截委托属性的绑定"></a>拦截委托属性的绑定</h3><p>对于<a href="http://kotlinlang.org/docs/reference/delegated-properties.html" target="_blank" rel="noopener">委托属性</a>，现在可以使用 <code>provideDelegate</code> 操作符拦截委托到属性之间的绑定。例如，如果我们想要在绑定之前检查属性名称，我们可以这样写：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> ResourceLoader<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span>id<span class="token operator">:</span> ResourceID<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    operator <span class="token keyword">fun</span> <span class="token function">provideDelegate</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> MyUI<span class="token punctuation">,</span> property<span class="token operator">:</span> KProperty<span class="token operator">&lt;</span><span class="token operator">*</span><span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> ReadOnlyProperty<span class="token operator">&lt;</span>MyUI<span class="token punctuation">,</span> T<span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token function">checkProperty</span><span class="token punctuation">(</span>thisRef<span class="token punctuation">,</span> property<span class="token punctuation">.</span>name<span class="token punctuation">)</span>        …… <span class="token comment" spellcheck="true">// 属性创建</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">fun</span> <span class="token function">checkProperty</span><span class="token punctuation">(</span>thisRef<span class="token operator">:</span> MyUI<span class="token punctuation">,</span> name<span class="token operator">:</span> String<span class="token punctuation">)</span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">bindResource</span><span class="token punctuation">(</span>id<span class="token operator">:</span> ResourceID<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">)</span><span class="token operator">:</span> ResourceLoader<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span> …… <span class="token punctuation">}</span><span class="token keyword">class</span> MyUI <span class="token punctuation">{</span>    <span class="token keyword">val</span> image <span class="token keyword">by</span> <span class="token function">bindResource</span><span class="token punctuation">(</span>ResourceID<span class="token punctuation">.</span>image_id<span class="token punctuation">)</span>    <span class="token keyword">val</span> text <span class="token keyword">by</span> <span class="token function">bindResource</span><span class="token punctuation">(</span>ResourceID<span class="token punctuation">.</span>text_id<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><code>provideDelegate</code> 方法可以可以在创建 MyUI 实例的每个属性时调用，并做相应的验证检查。</p><p>更多信息请参考 <a href="http://kotlinlang.org/docs/reference/delegated-properties.html#providing-a-delegate-since-11" target="_blank" rel="noopener">Providing a delegate</a>。</p><h3 id="泛型枚举值的访问"><a href="#泛型枚举值的访问" class="headerlink" title="泛型枚举值的访问"></a>泛型枚举值的访问</h3><p>现在可以用泛型的方式来对枚举类的值进行枚举。代码示例如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">enum</span> <span class="token keyword">class</span> RGB <span class="token punctuation">{</span> RED<span class="token punctuation">,</span> GREEN<span class="token punctuation">,</span> BLUE <span class="token punctuation">}</span><span class="token keyword">inline</span> <span class="token keyword">fun</span> <span class="token operator">&lt;</span><span class="token keyword">reified</span> T <span class="token operator">:</span> Enum<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token operator">></span> <span class="token function">printAllValues</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">print</span><span class="token punctuation">(</span>enumValues<span class="token operator">&lt;</span>T<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">joinToString</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>name <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="对于-DSL-中隐式接收者的作用域控制"><a href="#对于-DSL-中隐式接收者的作用域控制" class="headerlink" title="对于 DSL 中隐式接收者的作用域控制"></a>对于 DSL 中隐式接收者的作用域控制</h3><p><code>@DslMarker</code> 注解允许限制来自 DSL 上下文中的外部作用域的接收者的使用。考虑那个典型的 <a href="http://kotlinlang.org/docs/reference/type-safe-builders.html" target="_blank" rel="noopener">HTML 构建器示例</a>：</p><pre class=" language-kotlin"><code class="language-kotlin">table <span class="token punctuation">{</span>    tr <span class="token punctuation">{</span>        td <span class="token punctuation">{</span> <span class="token operator">+</span> <span class="token string">"Text"</span> <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 Kotlin 1.0 中，传递给 <code>td</code> 的 lambda 表达式中的代码可以访问三个隐式接收者：传递给 <code>table</code>、<code>tr</code> 和 <code>td</code> 的。这允许调用在上下文中没有意义的方法——例如在 <code>td</code> 里面调用 <code>tr</code>，从而在 <code>&lt;td&gt;</code> 中放置一个 <code>&lt;tr&gt;</code> 标签。</p><p>在 Kotlin 1.1 中，可以限制这种情况，以使只有在 <code>td</code> 的隐式接收者上定义的方法会在传给 <code>td</code> 的 lambda 表达式中可用。可以通过定义标记有 <code>@DslMarker</code> 元注解的注解并将其应用于标记类的基类。</p><h3 id="rem-操作符"><a href="#rem-操作符" class="headerlink" title="rem 操作符"></a>rem 操作符</h3><p><code>mod</code> 操作符现已弃用，而使用 <code>rem</code> 取代。动机参见这个 <a href="https://youtrack.jetbrains.com/issue/KT-14650" target="_blank" rel="noopener">issue</a>。</p><h2 id="标准库"><a href="#标准库" class="headerlink" title="标准库"></a>标准库</h2><h3 id="字符串到数字的转换"><a href="#字符串到数字的转换" class="headerlink" title="字符串到数字的转换"></a>字符串到数字的转换</h3><p>在 String 类中有一些新的扩展，用来将它转换为数字，而不会在无效数字上抛出异常： <code>String.toIntOrNull(): Int?</code>、 <code>String.toDoubleOrNull(): Double?</code> 等。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> port <span class="token operator">=</span> System<span class="token punctuation">.</span><span class="token function">getenv</span><span class="token punctuation">(</span><span class="token string">"PORT"</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">toIntOrNull</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?:</span> <span class="token number">80</span></code></pre><p>还有整数转换函数，如 <code>Int.toString()</code>、<code>String.toInt()</code>、<code>String.toIntOrNull()</code>，每个都有一个带有 <code>radix</code> 参数的重载，它允许指定转换的基数(2~36)。</p><h3 id="onEach"><a href="#onEach" class="headerlink" title="onEach()"></a>onEach()</h3><p><code>onEach</code> 是一个小、但对于集合和序列很有用的扩展函数，它允许对操作链中的集合/序列的每个元素执行一些操作，可能带有副作用。对于迭代其行为像 <code>forEach</code> 但是也进一步返回可迭代实例。对于序列它返回一个包装序列，它在元素迭代时延迟应用给定的动作。</p><pre class=" language-kotlin"><code class="language-kotlin">inputDir<span class="token punctuation">.</span><span class="token function">walk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span>isFile <span class="token operator">&amp;&amp;</span> it<span class="token punctuation">.</span>name<span class="token punctuation">.</span><span class="token function">endsWith</span><span class="token punctuation">(</span><span class="token string">".txt"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token function">onEach</span> <span class="token punctuation">{</span> <span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Moving <span class="token interpolation variable">$it</span> to <span class="token interpolation variable">$outputDir</span>"</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>        <span class="token punctuation">.</span><span class="token function">forEach</span> <span class="token punctuation">{</span> <span class="token function">moveFile</span><span class="token punctuation">(</span>it<span class="token punctuation">,</span> <span class="token function">File</span><span class="token punctuation">(</span>outputDir<span class="token punctuation">,</span> it<span class="token punctuation">.</span><span class="token function">toRelativeString</span><span class="token punctuation">(</span>inputDir<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">}</span></code></pre><h3 id="also-、takeIf-和-takeUnless"><a href="#also-、takeIf-和-takeUnless" class="headerlink" title="also()、takeIf() 和 takeUnless()"></a>also()、takeIf() 和 takeUnless()</h3><p><code>also()</code>、<code>takeIf()</code> 和 <code>takeUnless()</code> 是适用于任何接收者的三个通用扩展函数。</p><p><code>also</code> 就像 <code>apply</code>：它接受接收者、做一些动作、并返回该接收者。二者区别是在 <code>apply</code> 内部的代码块中接收者是 <code>this</code>， 而在 <code>also</code> 内部的代码块中是 <code>it</code> (并且如果你想的话，你可以给它另一个名字)。当你不想掩盖来自外部作用域的 <code>this</code> 时这很方便：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> Block<span class="token punctuation">.</span><span class="token function">copy</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token function">Block</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">also</span> <span class="token punctuation">{</span>    it<span class="token punctuation">.</span>content <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">}</span></code></pre><p><code>takeIf</code> 就像单个值的 <code>filter</code>。它检查接收者是否满足该谓词，并在满足时返回该接收者否则不满足时返回 <code>null</code>。结合 elvis-操作符和及早返回，它允许编写如下结构：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> outDirFile <span class="token operator">=</span> <span class="token function">File</span><span class="token punctuation">(</span>outputDir<span class="token punctuation">.</span>path<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">exists</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span> <span class="token operator">?:</span> <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true">// 对现有的 outDirFile 做些事情</span></code></pre><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> index <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">takeIf</span> <span class="token punctuation">{</span> it <span class="token operator">>=</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">?:</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"keyword not found"</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">// 对输入字符串中的关键字索引做些事情，鉴于它已找到</span></code></pre><p><code>takeUnless</code> 与 <code>takeIf</code> 相同，只是它采用了反向谓词。当它不满足谓词时返回接收者，否则返回 <code>null</code>。因此，上面的示例之一可以用 <code>takeUnless</code> 重写如下：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> index <span class="token operator">=</span> input<span class="token punctuation">.</span><span class="token function">indexOf</span><span class="token punctuation">(</span>keyword<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">takeUnless</span> <span class="token punctuation">{</span> it <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token punctuation">}</span> <span class="token operator">?:</span> <span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"keyword not found"</span><span class="token punctuation">)</span></code></pre><p>当你有一个可调用的引用而不是 lambda 时，使用也很方便：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> result <span class="token operator">=</span> string<span class="token punctuation">.</span><span class="token function">takeUnless</span><span class="token punctuation">(</span>String<span class="token operator">::</span>isEmpty<span class="token punctuation">)</span></code></pre><h3 id="groupingBy"><a href="#groupingBy" class="headerlink" title="groupingBy()"></a>groupingBy()</h3><p>此 API 可以用于按照键对集合进行分组，并同时折叠每个组。例如，它可以用于计算文本中字符的频率：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> frequencies <span class="token operator">=</span> words<span class="token punctuation">.</span><span class="token function">groupingBy</span> <span class="token punctuation">{</span> it<span class="token punctuation">.</span><span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token function">eachCount</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><h3 id="Map-toMap-和-Map-toMutableMap"><a href="#Map-toMap-和-Map-toMutableMap" class="headerlink" title="Map.toMap() 和 Map.toMutableMap()"></a>Map.toMap() 和 Map.toMutableMap()</h3><p><code>Map.toMap()</code> 和 <code>Map.toMutableMap()</code> 函数可以用来简易复制映射：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">class</span> <span class="token function">ImmutablePropertyBag</span><span class="token punctuation">(</span>map<span class="token operator">:</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Any<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">val</span> mapCopy <span class="token operator">=</span> map<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="Map-minus-key"><a href="#Map-minus-key" class="headerlink" title="Map.minus(key)"></a>Map.minus(key)</h3><p>运算符 <code>plus</code> 提供了一种将键值对添加到只读映射中以生成新映射的方法，但是没有一种简单的方法来做相反的操作：从映射中删除一个键采用不那么直接的方式如 <code>Map.filter()</code> 或 <code>Map.filterKeys()</code>。现在运算符 <code>minus</code> 填补了这个空白。有 4 个可用的重载：用于删除单个键、键的集合、键的序列和键的数组。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> map <span class="token operator">=</span> <span class="token function">mapOf</span><span class="token punctuation">(</span><span class="token string">"key"</span> <span class="token keyword">to</span> <span class="token number">42</span><span class="token punctuation">)</span><span class="token keyword">val</span> emptyMap <span class="token operator">=</span> map <span class="token operator">-</span> <span class="token string">"key"</span></code></pre><h3 id="Map-getValue"><a href="#Map-getValue" class="headerlink" title="Map.getValue()"></a>Map.getValue()</h3><p><code>Map</code> 上的这个扩展函数返回一个与给定键相对应的现有值，或者抛出一个异常，提示找不到该键。如果该映射是用 <code>withDefault</code> 生成的，这个函数将返回默认值，而不是抛异常。</p><pre class=" language-kotlin​"><code class="language-kotlin​">val map = mapOf("key" to 42)// 返回不可空 Int 值 42val value: Int = map.getValue("key")​val mapWithDefault = map.withDefault { k -> k.length }// 返回 4val value2 = mapWithDefault.getValue("key2")​// map.getValue("anotherKey") // <- 这将抛出 NoSuchElementException</code></pre><h3 id="minOf-和-maxOf"><a href="#minOf-和-maxOf" class="headerlink" title="minOf() 和 maxOf()"></a>minOf() 和 maxOf()</h3><p><code>minOf()</code> 和 <code>maxOf()</code> 函数可用于查找两个或三个给定值中的最小和最大值，其中值是原生数字或 <code>Comparable</code> 对象。每个函数还有一个重载，它接受一个额外的 <code>Comparator</code> 实例，如果你想比较自身不可比的对象的话。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> list1 <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">)</span><span class="token keyword">val</span> list2 <span class="token operator">=</span> <span class="token function">listOf</span><span class="token punctuation">(</span><span class="token string">"x"</span><span class="token punctuation">,</span> <span class="token string">"y"</span><span class="token punctuation">,</span> <span class="token string">"z"</span><span class="token punctuation">)</span><span class="token keyword">val</span> minSize <span class="token operator">=</span> <span class="token function">minOf</span><span class="token punctuation">(</span>list1<span class="token punctuation">.</span>size<span class="token punctuation">,</span> list2<span class="token punctuation">.</span>size<span class="token punctuation">)</span><span class="token keyword">val</span> longestList <span class="token operator">=</span> <span class="token function">maxOf</span><span class="token punctuation">(</span>list1<span class="token punctuation">,</span> list2<span class="token punctuation">,</span> compareBy <span class="token punctuation">{</span> it<span class="token punctuation">.</span>size <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><h3 id="类似数组的列表实例化函数"><a href="#类似数组的列表实例化函数" class="headerlink" title="类似数组的列表实例化函数"></a>类似数组的列表实例化函数</h3><p>类似于 <code>Array</code> 构造函数，现在有创建 <code>List</code> 和 <code>MutableList</code> 实例的函数，并通过调用 lambda 表达式来初始化每个元素：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> squares <span class="token operator">=</span> <span class="token function">List</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> index <span class="token operator">-></span> index <span class="token operator">*</span> index <span class="token punctuation">}</span><span class="token keyword">val</span> mutable <span class="token operator">=</span> <span class="token function">MutableList</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token number">0</span> <span class="token punctuation">}</span></code></pre><h3 id="抽象集合"><a href="#抽象集合" class="headerlink" title="抽象集合"></a>抽象集合</h3><p>这些抽象类可以在实现 Kotlin 集合类时用作基类。对于实现只读集合，有 <code>AbstractCollection</code>、<code>AbstractList</code>、<code>AbstractSet</code> 和 <code>AbstractMap</code>，而对于可变集合，有 <code>AbstractMutableCollection</code>、<code>AbstractMutableList</code>、<code>AbstractMutableSet</code> 和 <code>AbstractMutableMap</code>。在 JVM 上，这些抽象可变集合从 JDK 的抽象集合继承了大部分的功能。</p><h3 id="数组处理函数"><a href="#数组处理函数" class="headerlink" title="数组处理函数"></a>数组处理函数</h3><p>标准库现在提供了一组用于逐个元素操作数组的函数：比较(<code>contentEquals</code> 和 <code>contentDeepEquals</code>)、哈希码计算(<code>contentHashCode</code> 和 <code>contentDeepHashCode</code>)、以及转换成一个字符串(<code>contentToString</code> 和 <code>contentDeepToString</code>)。它们都支持 JVM(它们作为 <code>java.util.Arrays</code> 中的相应函数的别名)和 JS(在 Kotlin 标准库中提供实现)。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> array <span class="token operator">=</span> <span class="token function">arrayOf</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"c"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// JVM 实现：类型及哈希乱码</span><span class="token function">println</span><span class="token punctuation">(</span>array<span class="token punctuation">.</span><span class="token function">contentToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 良好格式化为列表</span></code></pre><h2 id="JVM-后端"><a href="#JVM-后端" class="headerlink" title="JVM 后端"></a>JVM 后端</h2><h3 id="Java-8-字节码支持"><a href="#Java-8-字节码支持" class="headerlink" title="Java 8 字节码支持"></a>Java 8 字节码支持</h3><p>Kotlin 现在可以选择生成 Java 8 字节码(命令行选项 <code>-jvm-target 1.8</code> 或者 Ant/Maven/Gradle 中的相应选项)。目前这并不改变字节码的语义(特别是，接口和 lambda 表达式中的默认方法的生成与 Kotlin 1.0 中完全一样)，但我们计划在以后进一步使用它。</p><h3 id="Java-8-标准库支持"><a href="#Java-8-标准库支持" class="headerlink" title="Java 8 标准库支持"></a>Java 8 标准库支持</h3><p>现在有支持在 Java 7 和 8 中新添加的 JDK API 的标准库的独立版本。如果你需要访问新的 API，请使用 <code>kotlin-stdlib-jre7</code> 和 <code>kotlin-stdlib-jre8</code> Maven 构件，而不是标准的 <code>kotlin-stdlib</code>。这些构件是在 <code>kotlin-stdlib</code> 之上的微小扩展，它们将它作为传递依赖项带到项目中。</p><h3 id="字节码中的参数名"><a href="#字节码中的参数名" class="headerlink" title="字节码中的参数名"></a>字节码中的参数名</h3><p>Kotlin 现在支持在字节码中存储参数名。这可以使用命令行选项 <code>-java-parameters</code> 启用。</p><h3 id="常量内联"><a href="#常量内联" class="headerlink" title="常量内联"></a>常量内联</h3><p>编译器现在将 <code>const val</code> 属性的值内联到使用它们的位置。</p><h3 id="可变闭包变量"><a href="#可变闭包变量" class="headerlink" title="可变闭包变量"></a>可变闭包变量</h3><p>用于在 lambda 表达式中捕获可变闭包变量的装箱类不再具有 <code>volatile</code> 字段。此更改提高了性能，但在一些罕见的使用情况下可能导致新的竞争条件。如果受此影响，你需要提供自己的同步机制来访问变量。</p><h3 id="javax-scripting-支持"><a href="#javax-scripting-支持" class="headerlink" title="javax.scripting 支持"></a>javax.scripting 支持</h3><p>Kotlin 现在与 <a href="https://docs.oracle.com/javase/8/docs/api/javax/script/package-summary.html" target="_blank" rel="noopener"><code>javax.script</code></a> API(JSR-223)集成。其 API 允许在运行时求值代码段：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> engine <span class="token operator">=</span> <span class="token function">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getEngineByExtension</span><span class="token punctuation">(</span><span class="token string">"kts"</span><span class="token punctuation">)</span><span class="token operator">!!</span>engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"val x = 3"</span><span class="token punctuation">)</span><span class="token function">println</span><span class="token punctuation">(</span>engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"x + 2"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment" spellcheck="true">// 输出 5</span></code></pre><p>关于使用 API 的示例项目参见 <a href="https://github.com/JetBrains/kotlin/tree/master/libraries/examples/kotlin-jsr223-local-example" target="_blank" rel="noopener">kotlin-jsr223-local-example</a> 。</p><h3 id="kotlin-reflect-full"><a href="#kotlin-reflect-full" class="headerlink" title="kotlin.reflect.full"></a>kotlin.reflect.full</h3><p><a href="https://blog.jetbrains.com/kotlin/2017/01/kotlin-1-1-whats-coming-in-the-standard-library/" target="_blank" rel="noopener">为 Java 9 支持准备</a>，在 <code>kotlin-reflect.jar</code> 库中的扩展函数和属性已移动到 <code>kotlin.reflect.full</code> 包中。旧包(<code>kotlin.reflect</code>)中的名称已弃用，将在 Kotlin 1.2 中删除。请注意，核心反射接口(如 <code>KClass</code>)是 Kotlin 标准库(而不是 <code>kotlin-reflect</code>)的一部分，不受移动影响。</p><h2 id="JavaScript-后端"><a href="#JavaScript-后端" class="headerlink" title="JavaScript 后端"></a>JavaScript 后端</h2><p>从 Kotlin 1.1 开始，JavaScript 目标平台不再当是实验性的。所有语言功能都支持， 并且有许多新的工具用于与前端开发环境集成。</p><h3 id="统一的标准库"><a href="#统一的标准库" class="headerlink" title="统一的标准库"></a>统一的标准库</h3><p>Kotlin 标准库的大部分目前可以从代码编译成 JavaScript 来使用。 特别是，关键类如集合(<code>ArrayList</code>、<code>HashMap</code> 等)、异常(<code>IllegalArgumentException</code> 等)以及其他几个关键类(<code>StringBuilder</code>、<code>Comparator</code>)现在都定义在 <code>kotlin</code> 包下。在 JVM 平台上，一些名称是相应 JDK 类的类型别名，而在 JS 平台上，这些类在 Kotlin 标准库中实现。</p><h3 id="更好的代码生成"><a href="#更好的代码生成" class="headerlink" title="更好的代码生成"></a>更好的代码生成</h3><p>JavaScript 后端现在生成更加可静态检查的代码，这对 JS 代码处理工具(如 minifiers、optimisers、linters 等)更加友好。</p><h3 id="external-修饰符"><a href="#external-修饰符" class="headerlink" title="external 修饰符"></a>external 修饰符</h3><p>如果你需要以类型安全的方式在 Kotlin 中访问 JavaScript 实现的类， 你可以使用 <code>external</code> 修饰符写一个 Kotlin 声明。在 Kotlin 1.0 中，使用了 <code>@native</code> 注解。与 JVM 目标平台不同，JS 平台允许对类和属性使用 <code>external</code> 修饰符。例如，可以按以下方式声明 DOM Node 类：</p><pre class=" language-kotlin"><code class="language-kotlin">external <span class="token keyword">class</span> Node <span class="token punctuation">{</span>    <span class="token keyword">val</span> firstChild<span class="token operator">:</span> Node​    <span class="token keyword">fun</span> <span class="token function">appendChild</span><span class="token punctuation">(</span>child<span class="token operator">:</span> Node<span class="token punctuation">)</span><span class="token operator">:</span> Node​    <span class="token keyword">fun</span> <span class="token function">removeChild</span><span class="token punctuation">(</span>child<span class="token operator">:</span> Node<span class="token punctuation">)</span><span class="token operator">:</span> Node​    <span class="token comment" spellcheck="true">// 等等</span><span class="token punctuation">}</span></code></pre><h3 id="改进的导入处理"><a href="#改进的导入处理" class="headerlink" title="改进的导入处理"></a>改进的导入处理</h3><p>现在可以更精确地描述应该从 JavaScript 模块导入的声明。 如果在外部声明上添加 <code>@JsModule(&quot;＜模块名＞&quot;)</code> 注解，它会在编译期间正确导入到模块系统(CommonJS 或 AMD)。例如，使用 CommonJS，该声明会通过 <code>require(……)</code> 函数导入。 此外，如果要将声明作为模块或全局 JavaScript 对象导入， 可以使用 <code>@JsNonModule</code> 注解。</p><p>例如，以下是将 JQuery 导入 Kotlin 模块的方法：</p><pre class=" language-kotlin"><code class="language-kotlin">external <span class="token keyword">interface</span> JQuery <span class="token punctuation">{</span>    <span class="token keyword">fun</span> <span class="token function">toggle</span><span class="token punctuation">(</span>duration<span class="token operator">:</span> Int <span class="token operator">=</span> definedExternally<span class="token punctuation">)</span><span class="token operator">:</span> JQuery    <span class="token keyword">fun</span> <span class="token function">click</span><span class="token punctuation">(</span>handler<span class="token operator">:</span> <span class="token punctuation">(</span>Event<span class="token punctuation">)</span> <span class="token operator">-></span> Unit<span class="token punctuation">)</span><span class="token operator">:</span> JQuery<span class="token punctuation">}</span>​<span class="token annotation builtin">@JsModule</span><span class="token punctuation">(</span><span class="token string">"jquery"</span><span class="token punctuation">)</span><span class="token annotation builtin">@JsNonModule</span><span class="token annotation builtin">@JsName</span><span class="token punctuation">(</span><span class="token string">"$"</span><span class="token punctuation">)</span>external <span class="token keyword">fun</span> <span class="token function">jquery</span><span class="token punctuation">(</span>selector<span class="token operator">:</span> String<span class="token punctuation">)</span><span class="token operator">:</span> JQuery</code></pre><p>在这种情况下，JQuery 将作为名为 <code>jquery</code> 的模块导入。或者，它可以用作 $-对象， 这取决于Kotlin编译器配置使用哪个模块系统。</p><p>你可以在应用程序中使用如下所示的这些声明：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">jquery</span><span class="token punctuation">(</span><span class="token string">".toggle-button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span> <span class="token punctuation">{</span>        <span class="token function">jquery</span><span class="token punctuation">(</span><span class="token string">".toggle-panel"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toggle</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token keyword">fun</span> <span class="token function">main</span><span class="token punctuation">(</span>args<span class="token operator">:</span> Array<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">jquery</span><span class="token punctuation">(</span><span class="token string">".toggle-button"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">click</span> <span class="token punctuation">{</span>        <span class="token function">jquery</span><span class="token punctuation">(</span><span class="token string">".toggle-panel"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toggle</span><span class="token punctuation">(</span><span class="token number">300</span><span class="token punctuation">)</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://kotlinlang.org/docs/reference/whatsnew11.html" target="_blank" rel="noopener">What’s New in Kotlin 1.1</a></p>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 8 之 Stream</title>
      <link href="/posts/2018/7ebad28b.html"/>
      <url>/posts/2018/7ebad28b.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 8 引入了全新的 <code>Stream API</code>，此 <code>Stream</code> 与 java I/O 包里的 <code>InputStream</code> 和 <code>OutputStream</code> 是完全不同的概念，它不同于 StAX 对 XML 解析的 Stream，也不同于 Amazon Kinesis 对大数据实时处理的 Stream。<code>Stream API</code> 更像具有 <code>Iterable</code> 的集合类，但行为和集合类又有所不同，它是对集合对象功能的增强，专注于对集合对象进行各种非常便捷、高效的聚合操作或大批量数据操作。</p><p><code>Stream API</code> 引入的目的在于弥补 <code>Java 函数式编程</code>的缺陷。对于很多支持函数式编程的语言，<code>map()</code>、<code>reduce()</code>基本上都内置到语言的标准库中了。不过，Java 8 的 <code>Stream API</code> 总体来讲仍然是非常完善和强大，足以用很少的代码完成许多复杂的功能。</p><p>Java 8 的 <code>Stream API</code> 充分利用 <code>Lambda 表达式</code>的特性，极大的提高编程效率和程序可读性。同时它提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势，使用 <code>fork/join</code>并行方式来拆分任务和加速处理过程。通常编写并行代码很难而且容易出错，但使用 <code>Stream API</code> 无需编写一行多线程的代码，就可以很方便地写出高性能的并发程序。</p><p>在 <code>Stream API</code> 中，一个流基本上代表一个元素序列，<code>Stream API</code> 提供了丰富的操作函数来计算这些元素。以前我们在开发业务应用时，通常很多操作的实现是这样做的:我们使用循环对集合做遍历，针对集合中的元素实现各种操作，定义各种变量来实现目的，这样我们就得到了一大堆丑陋的顺序代码。</p><p>如果开发过程中使用 <code>Stream API</code> 做同样的事情，使用 Lambda 表达式和其它函数进行抽象，可以使得代码更易于理解、更为干净。有了这些抽象，还可以做一些优化，比如实现并行等。</p><h2 id="什么是-Stream"><a href="#什么是-Stream" class="headerlink" title="什么是 Stream"></a>什么是 Stream</h2><p><strong><code>Stream(流)</code></strong>是一个来自数据源的元素队列并支持聚合操作。</p><blockquote><p>元素：特定类型的对象，形成一个队列。Stream 并不会存储元素，而是按需计算。<br>数据源：流的来源。可以是集合，数组，I/O channel，产生器 generator 等。<br>聚合操作：类似 SQL 语句一样的操作，比如 filter、map、reduce、find、match、sorted 等。</p></blockquote><p><code>Stream</code> 不是集合元素，它不是数据结构并不保存数据，它是有关算法和计算的，它更像一个高级版本的 <code>Iterator</code>。原始版本的 <code>Iterator</code>，用户只能显式地一个一个遍历元素并对其执行某些操作；高级版本的 <code>Stream</code>，用户只要给出需要对其包含的元素执行什么操作，<code>Stream</code> 会隐式地在内部进行遍历，做出相应的数据转换。<br><code>Stream</code> 就如同一个迭代器(Iterator)，单向，不可往复，数据只能遍历一次，遍历过一次后即用尽了，就好比流水从面前流过，一去不复返。<br><code>Stream</code> 和迭代器又不同的是，<code>Stream</code> 可以并行化操作，迭代器只能命令式地、串行化操作。顾名思义，当使用串行方式去遍历时，每个 item 读完后再读下一个 item。而使用并行去遍历时，数据会被分成多个段，其中每一个都在不同的线程中处理，然后将结果一起输出。<code>Stream</code> 的并行操作依赖于 Java7 中引入的 <code>Fork/Join</code> 框架(JSR166y)来拆分任务和加速处理过程。</p><p><code>Stream</code> 和 <code>Collection</code> 的区别主要有：</p><ul><li><code>Stream</code> 本身并不存储数据，数据是存储在对应的 <code>Collection</code> 里，或者在需要的时候才生成的；</li><li><code>Stream</code> 不会修改数据源，总是返回新的 <code>Stream</code>；</li><li><code>Stream</code> 的操作是懒执行(lazy)的，仅当最终的结果需要的时候才会执行。</li></ul><p><code>Stream</code> 和 <code>Collection</code> 相比，<code>Stream</code> 操作还有两个基础的特征：</p><ul><li><code>Pipelining：</code>中间操作都会返回流对象本身。这样多个操作可以串联成一个管道， 如同流式风格(fluent style)。这样做可以对操作进行优化，比如延迟执行(laziness)和短路(short-circuiting)。</li><li><code>内部迭代：</code>以前对集合遍历都是通过 Iterator 或者 forEach 的方式，显式的在集合外部进行迭代，这叫做外部迭代。Stream 提供了内部迭代的方式，通过访问者模式(Visitor)实现。</li></ul><p><code>Stream</code> 的使用步骤如下：</p><ul><li>创建 Stream。</li><li>通过一个或多个中间操作(intermediate operations)将初始 Stream 转换为另一个 Stream。</li><li>通过中止操作(terminal operation)获取结果；该操作触发之前的懒操作的执行，中止操作后，该 Stream 关闭，不能再使用了。</li></ul><h2 id="Stream-的创建"><a href="#Stream-的创建" class="headerlink" title="Stream 的创建"></a>Stream 的创建</h2><p>最常用的 Stream 的创建方式有以下几种途径：</p><ul><li>通过 Stream 接口的<code>静态工厂方法</code>；</li><li>通过 Collection 接口的默认方法– <code>stream()</code>，把一个 Collection 对象转换成 Stream。</li><li>通过 Arrays 类的<code>静态工厂方法</code>。</li></ul><blockquote><p>需要注意的是，对于基本数值型，目前有三种对应的包装类型 Stream：<code>IntStream</code>、<code>LongStream</code>、<code>DoubleStream</code>。当然我们也可以用 <code>Stream&lt;Integer&gt;</code>、<code>Stream&lt;Long&gt;</code>、<code>Stream&lt;Double&gt;</code>，但是 <code>boxing</code> 和 <code>unboxing</code> 会很耗时，所以特别为这三种基本数值型提供了对应的 Stream。<br>Java 8 中还没有提供其它数值型 Stream，因为这将导致扩增的内容较多。而常规的数值型聚合运算可以通过上面三种 Stream 进行。</p></blockquote><h3 id="通过-Stream-的静态方法来创建-Stream"><a href="#通过-Stream-的静态方法来创建-Stream" class="headerlink" title="通过 Stream 的静态方法来创建 Stream"></a>通过 Stream 的静态方法来创建 Stream</h3><p><code>Stream</code> 接口提供了几个静态工厂方法用来创建 <code>Stream</code> 对象：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Builder&lt;T&gt; builder()</code></td><td>返回一个 Stream 的可变构建器，可通过 Builder 的 build() 方法返回一个 Stream 实例</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; empty()</code></td><td>返回一个空的 Stream 实例</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; of(T t)</code></td><td>返回一个包含单一元素的 Stream 实例</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; of(T... values)</code></td><td>返回一个包含指定元素并且按顺序排列的 Stream 实例</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; iterate(T seed, UnaryOperator&lt;T&gt; f)</code></td><td>返回一个无限元素有序的 Stream 实例，其元素的生成是重复对给定的种子值(seed)调用指定函数来生成的，其中包含的元素可以认为是：seed，f(seed)，f(f(seed))无限循环</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; generate(Supplier&lt;T&gt; s)</code></td><td>返回一个无限元素无序的 Stream 实例，其中每个元素由提供的 Supplier 生成，这适用于生成常量流、随机元素流等</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; concat(Stream&lt;? extends T&gt; a, Stream&lt;? extends T&gt; b)</code></td><td>创建一个延迟连接的 Stream 实例，其元素是第一个流的所有元素，然后是第二个流的所有元素</td></tr></tbody></table><blockquote><p><code>Stream</code> 的 <code>iterate()</code> 和 <code>generate()</code> 方法都用于生成无限元素的流，所以一般这种无限长度的 <code>Stream</code> 都会配合 <code>Stream</code> 的 <code>limit()</code> 方法来用。</p></blockquote><h3 id="通过-Collection-子类创建-Stream"><a href="#通过-Collection-子类创建-Stream" class="headerlink" title="通过 Collection 子类创建 Stream"></a>通过 Collection 子类创建 Stream</h3><p><code>Collection</code> 接口提供了2个默认方法用来创建 <code>Stream</code> 对象：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>default Stream&lt;E&gt; stream()</code></td><td>返回一个指定该集合为源的有序的 Stream 实例</td></tr><tr><td><code>default Stream&lt;E&gt; parallelStream()</code></td><td>返回一个指定该集合为源的并行的 Stream 实例</td></tr></tbody></table><h3 id="通过-Arrays-的静态方法来创建-Stream"><a href="#通过-Arrays-的静态方法来创建-Stream" class="headerlink" title="通过 Arrays 的静态方法来创建 Stream"></a>通过 Arrays 的静态方法来创建 Stream</h3><p><code>Arrays</code> 类提供了几个个静态工厂方法用来创建 <code>Stream</code> 对象：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array)</code></td><td>返回一个以指定数组为源的有序的 Stream 实例</td></tr><tr><td><code>static &lt;T&gt; Stream&lt;T&gt; stream(T[] array, int startInclusive, int endExclusive)</code></td><td>返回一个以指定数组的指定范围为源的有序的 Stream 实例</td></tr><tr><td><code>static IntStream stream(int[] array)</code></td><td>返回一个以指定数组为源的有序的 IntStream 实例</td></tr><tr><td><code>static IntStream stream(int[] array, int startInclusive, int endExclusive)</code></td><td>返回一个以指定数组的指定范围为源的有序的 IntStream 实例</td></tr><tr><td><code>static LongStream stream(long[] array)</code></td><td>返回一个以指定数组为源的有序的 LongStream 实例</td></tr><tr><td><code>static static LongStream stream(long[] array, int startInclusive, int endExclusive)</code></td><td>返回一个以指定数组的指定范围为源的有序的 LongStream 实例</td></tr><tr><td><code>static DoubleStream stream(double[] array)</code></td><td>返回一个以指定数组为源的有序的 DoubleStream 实例</td></tr><tr><td><code>static DoubleStream stream(double[] array, int startInclusive, int endExclusive)</code></td><td>返回一个以指定数组的指定范围为源的有序的 DoubleStream 实例</td></tr></tbody></table><h2 id="Stream-的转换"><a href="#Stream-的转换" class="headerlink" title="Stream 的转换"></a>Stream 的转换</h2><p>当把一个数据结构包装成 Stream 后，就要开始对里面的元素进行各类操作了。常见的操作可以归类如下。</p><ul><li><strong><code>中间操作(Intermediate)：</code></strong>一个流可以后面跟随零个或多个 Intermediate 操作。其目的主要是打开流，做出某种程度的数据映射/过滤，然后返回一个新的流，交给下一个操作使用，这种操作也叫做惰性求值方法。如：map (mapToInt, flatMap 等)、filter、distinct、sorted、peek、limit、skip、parallel、sequential、unordered</li><li><strong><code>终止操作(Terminal)：</code></strong>一个流只能有一个 Terminal 操作，当这个操作执行后，流就被使用“光”了，无法再被操作。如：forEach、forEachOrdered、toArray、reduce、collect、min、max、count、anyMatch、allMatch、noneMatch、findFirst、findAny、iterator</li></ul><p>我们下面看一下 Stream 的比较典型用法。</p><h3 id="distinct"><a href="#distinct" class="headerlink" title="distinct()"></a>distinct()</h3><p><strong><code>distinct()</code></strong> 方法对于 Stream 中包含的元素进行去重操作(去重逻辑依赖元素的 <code>equals()</code> 方法)，新生成的 Stream 中没有重复的元素。</p><p><img src="https://henleylee.github.io/medias/java/stream_distinct.jpg" alt="distinct 方法示意图"></p><p>以下代码片段使用 distinct 方法去除重复的元素并排序后输出：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Character<span class="token operator">></span> letters <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">'A'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'C'</span><span class="token punctuation">,</span> <span class="token string">'B'</span><span class="token punctuation">,</span> <span class="token string">'D'</span><span class="token punctuation">,</span> <span class="token string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>letters<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sorted</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="filter"><a href="#filter" class="headerlink" title="filter()"></a>filter()</h3><p><strong><code>filter()</code></strong> 方法对于 Stream 中包含的元素使用给定的过滤函数进行过滤操作，新生成的 Stream 只包含符合条件的元素。</p><p><img src="https://henleylee.github.io/medias/java/stream_filter.jpg" alt="filter 方法示意图"></p><p>以下代码片段使用 filter 方法过滤出长度小于5的语言个数：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> languages <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"java"</span><span class="token punctuation">,</span> <span class="token string">"scala"</span><span class="token punctuation">,</span> <span class="token string">"python"</span><span class="token punctuation">,</span> <span class="token string">"shell"</span><span class="token punctuation">,</span> <span class="token string">"ruby"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">long</span> num <span class="token operator">=</span> languages<span class="token punctuation">.</span><span class="token function">parallelStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">count</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>num<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="map"><a href="#map" class="headerlink" title="map()"></a>map()</h3><p><strong><code>map()</code></strong> 方法对于 Stream 中包含的元素使用给定的转换函数进行转换操作，新生成的 Stream 只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：<code>mapToInt</code>，<code>mapToLong</code> 和 <code>mapToDouble</code>。这三个方法也比较好理解，比如 <code>mapToInt</code> 就是把原始 Stream 转换成一个新的 Stream，这个新生成的 Stream 中的元素都是 int 类型。之所以会有这样三个变种方法，可以免除自动装箱/拆箱的额外消耗。</p><p><img src="https://henleylee.github.io/medias/java/stream_map.jpg" alt="map 方法示意图"></p><p>以下代码片段使用 map 得到元素对应的平方数并去除重复元素后转换为集合：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> squaresList <span class="token operator">=</span> numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>i <span class="token operator">-</span><span class="token operator">></span> i <span class="token operator">*</span> i<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">distinct</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="flatMap"><a href="#flatMap" class="headerlink" title="flatMap()"></a>flatMap()</h3><p><strong><code>flatMap()</code></strong> 方法和 map 类似，不同的是其每个元素转换得到的是 Stream 对象，会把子 Stream 中的元素压缩到重新生成的集合中。</p><p><img src="https://henleylee.github.io/medias/java/stream_flatMap.jpg" alt="flatMap 方法示意图"></p><p>以下代码片段使用 flatMap 将多个 Stream 连接成一个 Stream 并转换为集合后输出：</p><pre class=" language-java"><code class="language-java">Stream<span class="token operator">&lt;</span>List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> numbersStream <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>        Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbersStream        <span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>Collection<span class="token operator">:</span><span class="token operator">:</span>stream<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="peek"><a href="#peek" class="headerlink" title="peek()"></a>peek()</h3><p><strong><code>peek()</code></strong> 方法生成一个包含原 Stream 的所有元素的新 Stream，同时会提供一个消费函数(Consumer 实例)，新 Stream 每个元素被消费的时候都会执行给定的消费函数。</p><p><img src="https://henleylee.github.io/medias/java/stream_peek.jpg" alt="peek 方法示意图"></p><p>以下代码片段使用 peek 消费了过滤后的元素和转换后的元素：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>String<span class="token operator">></span> peeks <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> s<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Filtered value: "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>String<span class="token operator">:</span><span class="token operator">:</span>toUpperCase<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Mapped value: "</span> <span class="token operator">+</span> s<span class="token punctuation">)</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result value: "</span> <span class="token operator">+</span> peeks<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="limit"><a href="#limit" class="headerlink" title="limit()"></a>limit()</h3><p><strong><code>limit()</code></strong> 方法对一个 Stream 进行截断操作，获取其前 N 个元素，如果原 Stream 中包含的元素个数小于 N，那就获取其所有的元素。</p><p><img src="https://henleylee.github.io/medias/java/stream_limit.jpg" alt="limit 方法示意图"></p><p>以下代码片段使用 limit 得到前2个元素并输出：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"limit:"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="skip"><a href="#skip" class="headerlink" title="skip()"></a>skip()</h3><p><strong><code>skip()</code></strong> 方法返回一个丢弃原 Stream 的前 N 个元素后剩下元素组成的新 Stream，如果原 Stream 中包含的元素个数小于 N，那么返回空 Stream。</p><p><img src="https://henleylee.github.io/medias/java/stream_skip.jpg" alt="skip 方法示意图"></p><p>以下代码片段使用 skip 得到前2个元素后剩下的元素并输出：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> numbers <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>numbers<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">skip</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="reduce"><a href="#reduce" class="headerlink" title="reduce()"></a>reduce()</h3><p><strong><code>reduce()</code></strong> 方法用于从 Stream 中生成一个值，其生成的值不是随意的，而是根据指定的计算模型。比如，<code>count</code>、<code>min</code> 和 <code>max</code> 方法，因为常用而被纳入标准库中。事实上，这些方法都是 <code>reduce</code> 操作。</p><p><img src="https://henleylee.github.io/medias/java/stream_reduce.jpg" alt="reduce 方法示意图"></p><p><code>reduce()</code> 方法有三种变形：</p><pre class=" language-java"><code class="language-java">T <span class="token function">reduce</span><span class="token punctuation">(</span>T identity<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span>Optional<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">reduce</span><span class="token punctuation">(</span>BinaryOperator<span class="token operator">&lt;</span>T<span class="token operator">></span> accumulator<span class="token punctuation">)</span><span class="token operator">&lt;</span>U<span class="token operator">></span> U <span class="token function">reduce</span><span class="token punctuation">(</span>U identity<span class="token punctuation">,</span> BiFunction<span class="token operator">&lt;</span>U<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> U<span class="token operator">></span> accumulator<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>U<span class="token operator">></span> combiner<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>以下代码片段使用 reduce 得到所有元素的和并输出：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> reduce1 <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span>identity<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> identity <span class="token operator">+</span> item<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"reduce1: identity = "</span> <span class="token operator">+</span> identity <span class="token operator">+</span> <span class="token string">",item = "</span> <span class="token operator">+</span> item <span class="token operator">+</span> <span class="token string">",result = "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"reduce1: "</span> <span class="token operator">+</span> reduce1<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">int</span> reduce2 <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">(</span>identity<span class="token punctuation">,</span> item<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> identity <span class="token operator">+</span> item<span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"reduce2: identity = "</span> <span class="token operator">+</span> identity <span class="token operator">+</span> <span class="token string">",item = "</span> <span class="token operator">+</span> item <span class="token operator">+</span> <span class="token string">",result = "</span> <span class="token operator">+</span> result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"reduce2: "</span> <span class="token operator">+</span> reduce2<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>从打印结果可以看出，reduce前两种变形，因为接受参数不同，其执行的操作也有相应变化：</p><ul><li>变形1：未定义初始值，从而第一次执行的时候第一个参数的值是 Stream 的第一个元素，第二个参数是 Stream 的第二个元素</li><li>变形2：定义了初始值，从而第一次执行的时候第一个参数的值是初始值，第二个参数是 Stream 的第一个元素</li></ul><h2 id="Collector"><a href="#Collector" class="headerlink" title="Collector"></a>Collector</h2><p><code>Collector</code> 是 <code>Stream</code> 中对于 <code>Reduce</code> 操作的抽象，此接口中定义了常用的 <code>Reduce</code> 操作，包括：将元素累积到集合中，使用 StringBuilder连接字符串；计算元素相关的统计信息，例如 sum，min，max 或 average 等。<code>Collectors(类收集器)</code>提供了许多常见的可变减少操作的实现。</p><p><code>Collector</code> 中定义的 <code>Reduce</code> 操作可以通过串行或者并行的方式进行实现。BaseStream 接口中的 <code>parallel()</code>、<code>sequential()</code>、<code>unordered()</code> 方法提供的高层 API 使并发程序设计变得非常简洁。</p><p><code>Collector&lt;T, A, R&gt;</code> 接受三个泛型参数，对可变减少操作的数据类型作相应限制：</p><ul><li><code>T：</code>输入元素类型</li><li><code>A：</code>缩减操作的可变累积类型（通常隐藏为实现细节）</li><li><code>R：</code>可变减少操作的结果类型</li></ul><p><code>Collector</code> 接口声明了4个函数，这四个函数一起协调执行以将元素目累积到可变结果容器中，并且可以选择地对结果进行最终的变换。</p><ul><li><code>Supplier&lt;A&gt; supplier()：</code>创建并返回一个新的可变结果容器。</li><li><code>BiConsumer&lt;A, T&gt; accumulator()：</code>将元素添加到可变结果容器中。</li><li><code>BinaryOperator&lt;A&gt; combiner()：</code>接收两个结果容器将合并为一个结果容器。</li><li><code>Function&lt;A, R&gt; finisher()：</code>对结果容器作相应的变换。</li></ul><p>在 <code>Collector</code> 接口的 <code>characteristics()</code> 方法内，可以对 <code>Collector</code> 声明相关约束：</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Characteristics<span class="token operator">></span> <span class="token function">characteristics</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>而 <code>Characteristics</code> 是 <code>Collector</code> 内的一个枚举类，声明了以下三个属性，用来约束Collector的属性：</p><ul><li><code>CONCURRENT：</code>表示此收集器支持并发，意味着允许在多个线程中，累加器可以调用结果容器</li><li><code>UNORDERED：</code>表示收集器并不按照 Stream 中的元素输入顺序执行</li><li><code>IDENTITY_FINISH：</code>表示 finisher 实现的是识别功能，可以省略。</li></ul><blockquote><p>注意：如果一个容器仅声明 <code>CONCURRENT</code> 属性，而不是 <code>UNORDERED</code> 属性，那么该容器仅仅支持无序的 Stream 在多线程中执行。</p></blockquote><h2 id="Collectors"><a href="#Collectors" class="headerlink" title="Collectors"></a>Collectors</h2><p><code>Collectors</code> 是 <code>Collector</code> 的实现，它实现了各种有用的 <code>Reduce</code> 操作，例如将元素累积到集合中，根据各种标准汇总元素等等。</p><h3 id="转换成其他集合"><a href="#转换成其他集合" class="headerlink" title="转换成其他集合"></a>转换成其他集合</h3><p>很多 Stream 的链式操作可以转成集合，比如 <code>toList()</code>，生成了 <code>java.util.List</code> 类的实例。当然了，还有还有 <code>toSet()</code> 和 <code>toCollection(Supplier&lt;C&gt; collectionFactory)</code>，分别生成 <code>java.util.Set</code> 和 <code>java.util.Collection</code> 类的实例。</p><h4 id="toList"><a href="#toList" class="headerlink" title="toList()"></a>toList()</h4><p><code>toList()</code> 方法用于返回一个将输入元素累积到一个新的 <code>java.util.List</code> 中的 <code>Collector</code> 实例。代码示例如下：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Integer<span class="token operator">></span> list <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>list<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="toSet"><a href="#toSet" class="headerlink" title="toSet()"></a>toSet()</h4><p><code>toSet()</code> 方法用于返回一个将输入元素累积到一个新的 <code>java.util.Set</code> 中的 <code>Collector</code> 实例。代码示例如下：</p><pre class=" language-java"><code class="language-java">Set<span class="token operator">&lt;</span>Integer<span class="token operator">></span> set <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>set<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="toCollection"><a href="#toCollection" class="headerlink" title="toCollection()"></a>toCollection()</h4><p><code>toCollection()</code> 方法用于返回一个将输入元素按照遇到的顺序累积到一个新的 <code>java.util.Collection</code> 中的 <code>Collector</code> 实例，<code>java.util.Collection</code> 由提供的工厂创建。</p><p>通常情况下，创建集合时需要调用适当的构造函数指明集合的具体类型，但是调用 <code>toList()</code> 或者 <code>toSet()</code> 方法时，不需要指定具体的类型，Stream 类库会自动推断并生成合适的类型。当然，有时候对转换生成的集合有特定要求，比如，希望生成一个 TreeSet，而不是由 Stream 类库自动指定的一种类型。此时使用 <code>toCollection()</code>，它接受一个函数作为参数，来创建集合。代码示例如下：</p><pre class=" language-java"><code class="language-java">TreeSet<span class="token operator">&lt;</span>Integer<span class="token operator">></span> treeSet <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toCollection</span><span class="token punctuation">(</span>TreeSet<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>treeSet<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h4 id="toMap"><a href="#toMap" class="headerlink" title="toMap()"></a>toMap()</h4><p><code>toMap()</code> 方法用于返回一个通过提供的映射函数将输入元素生成的键和值累积到一个新的 <code>java.util.Map</code> 中的 <code>Collector</code> 实例。<br>由于 <code>Map</code> 中有 <code>Key</code> 和 <code>Value</code> 这两个值，故该方法与 <code>toList()</code>、<code>toSet()</code> 等方法的处理方式是不一样的。<code>toMap()</code> 方法最少应接受两个参数，一个用来生成 <code>key</code>，另外一个用来生成 <code>value</code>。<code>toMap()</code> 方法有三种变形：</p><pre class=" language-java"><code class="language-java">Collector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>U<span class="token operator">>></span> <span class="token function">toMap</span><span class="token punctuation">(</span>Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token operator">></span> keyMapper<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token operator">></span> valueMapper<span class="token punctuation">)</span>Collector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>U<span class="token operator">>></span> <span class="token function">toMap</span><span class="token punctuation">(</span>Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token operator">></span> keyMapper<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token operator">></span> valueMapper<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>U<span class="token operator">></span> mergeFunction<span class="token punctuation">)</span>Collector<span class="token operator">&lt;</span>T<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">,</span> M<span class="token operator">></span> <span class="token function">toMap</span><span class="token punctuation">(</span>Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token operator">></span> keyMapper<span class="token punctuation">,</span> Function<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">super</span> T<span class="token punctuation">,</span> <span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">U</span><span class="token operator">></span> valueMapper<span class="token punctuation">,</span> BinaryOperator<span class="token operator">&lt;</span>U<span class="token operator">></span> mergeFunction<span class="token punctuation">,</span> Supplier<span class="token operator">&lt;</span>M<span class="token operator">></span> mapSupplier<span class="token punctuation">)</span></code></pre><ul><li>类型参数：<ul><li>T：输入元素的类型</li><li>K：Key 映射函数的输出类型</li><li>U：Value 映射函数的输出类型</li><li>M：生成的 Map 类型</li></ul></li><li>参数：<ul><li>keyMapper：用于生成 Key 的映射函数</li><li>valueMapper：用于生成 Value 的映射函数</li><li>mergeFunction：合并函数，用于解决与相同 Key 关联的 Value 之间的冲突</li><li>mapSupplier：返回一个用于存储结果的新的空 Map 实例</li></ul></li></ul><p>代码示例如下：</p><pre class=" language-java"><code class="language-java">List<span class="token operator">&lt;</span>Person<span class="token operator">></span> persons <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Aaron"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Cherry"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>persons<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Jim"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>Integer<span class="token punctuation">,</span> String<span class="token operator">></span> map <span class="token operator">=</span> persons<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toMap</span><span class="token punctuation">(</span>Person<span class="token operator">:</span><span class="token operator">:</span>getId<span class="token punctuation">,</span> Person<span class="token operator">:</span><span class="token operator">:</span>getName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="转换成值"><a href="#转换成值" class="headerlink" title="转换成值"></a>转换成值</h3><p>使用 <code>collect()</code> 可以将 Stream 转换成值。</p><ul><li>averagingDouble：求平均值，Stream 的元素类型为 double</li><li>averagingInt：求平均值，Stream 的元素类型为 int</li><li>averagingLong：求平均值，Stream 的元素类型为 long</li><li>counting：Stream 的元素个数</li><li>maxBy：在指定条件下的，Stream 的最大元素</li><li>minBy：在指定条件下的，Stream 的最小元素</li><li>reducing：reduce 操作</li><li>summarizingDouble：统计 Stream 的数据(double)状态，其中包括 count，min，max，sum 和平均。</li><li>summarizingInt：统计 Stream 的数据(int)状态，其中包括 count，min，max，sum 和平均。</li><li>summarizingLong：统计 Stream 的数据(long)状态，其中包括 count，min，max，sum 和平均。</li><li>summingDouble：求和，Stream 的元素类型为 double</li><li>summingInt：求和，Stream 的元素类型为 int</li><li>summingLong：求和，Stream 的元素类型为 long</li></ul><p>代码示例如下：</p><pre class=" language-java"><code class="language-java">Double collectAveragingDouble <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">averagingDouble</span><span class="token punctuation">(</span>value <span class="token operator">-</span><span class="token operator">></span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"collectAveragingDouble : "</span> <span class="token operator">+</span> collectAveragingDouble<span class="token punctuation">)</span><span class="token punctuation">;</span>Optional<span class="token operator">&lt;</span>Integer<span class="token operator">></span> collectMaxBy <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">maxBy</span><span class="token punctuation">(</span>Comparator<span class="token punctuation">.</span><span class="token function">comparingInt</span><span class="token punctuation">(</span>o <span class="token operator">-</span><span class="token operator">></span> o<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"collectMaxBy : "</span> <span class="token operator">+</span> collectMaxBy<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>DoubleSummaryStatistics collectSummarizingDouble <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">summarizingDouble</span><span class="token punctuation">(</span>value <span class="token operator">-</span><span class="token operator">></span> value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"collectSummarizingDouble : "</span> <span class="token operator">+</span> collectSummarizingDouble<span class="token punctuation">.</span><span class="token function">getSum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="分割数据块"><a href="#分割数据块" class="headerlink" title="分割数据块"></a>分割数据块</h3><p><code>collect()</code> 方法的一个常用操作将 Stream 分解成两个集合。</p><p>假如一个数字的 Stream，我们可能希望将其分割成两个集合，一个是偶数集合，另外一个是奇数集合。我们首先想到的就是过滤操作，通过两次过滤操作，很简单的就完成了我们的需求。但是这样操作起来有问题。首先，为了执行两次过滤操作，需要有两个流。其次，如果过滤操作复杂，每个流上都要执行这样的操作， 代码也会变得冗余。</p><p>这里就不得不说 <code>Collectors</code> 库中的 <code>partitioningBy()</code> 方法，它接受一个流，并将其分成两部分：使用 <code>Predicate</code> 对象，指定条件并判断一个元素应该属于哪个部分，并根据布尔值返回一个 <code>Map&lt;Boolean, List&lt;T&gt;&gt;</code>。因此对于 <code>key</code> 为 <code>true</code> 所对应的 <code>List</code> 中的元素，满足 <code>Predicate</code> 对象中指定的条件；同样，<code>key</code> 为 <code>false</code> 所对应的 <code>List</code> 中的元素，不满足 <code>Predicate</code> 对象中指定的条件。</p><p>代码示例如下：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> collectPartitioningBy <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">partitioningBy</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it <span class="token operator">%</span> <span class="token number">2</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"collectPartitioningBy : "</span> <span class="token operator">+</span> collectPartitioningBy<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="数据分组"><a href="#数据分组" class="headerlink" title="数据分组"></a>数据分组</h3><p>数据分组是一种更自然的分割数据操作，与将数据分成 true 和 false 两部分不同，可以使用任意值对数据分组。</p><p>调用 <code>Stream</code> 的 <code>collect()</code> 方法，传入一个收集器，<code>groupingBy()</code> 方法接受一个分类函数，用来对数据分组，就像 <code>partitioningBy()</code> 方法一样，接受一个 <code>Predicate</code> 对象将数据分成 true 和 false 两部分。使用到的分类器是一个 <code>Function</code> 对象，和 <code>map</code> 操作用到的一样。</p><p>代码示例如下：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Integer<span class="token operator">>></span> collectGroupingBy <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"collectGroupingBy : "</span> <span class="token operator">+</span> collectGroupingBy<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>有时候，需要将 Stream 的元素(String 类型)最后生成一组字符串，可以使用 <code>Collectors.joining()</code> 收集 Stream 中的值，该方法可以方便地将 Stream 得到一个字符串。<code>joining()</code> 函数接受三个参数，分别表示分隔符(用以分隔元素)、前缀和后缀。</p><p>代码示例如下：</p><pre class=" language-java"><code class="language-java">String joining <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">,</span> <span class="token string">"2"</span><span class="token punctuation">,</span> <span class="token string">"3"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">joining</span><span class="token punctuation">(</span><span class="token string">","</span><span class="token punctuation">,</span> <span class="token string">"["</span><span class="token punctuation">,</span> <span class="token string">"]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"joining: "</span> <span class="token operator">+</span> joining<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="组合-Collector"><a href="#组合-Collector" class="headerlink" title="组合 Collector"></a>组合 Collector</h3><p><code>Collectors</code> 库中的 <code>partitioningBy()</code> 和 <code>groupingBy()</code> 方法还可以接收一个 <code>Collector</code>，用以收集最终结果的一个子集，这些 <code>Collector</code> 叫作下游收集器。收集器是生成最终结果的一剂配方，下游收集器则是生成部分结果的配方，主收集器中会用到下游收集器。这种组合使用收集器的方式， 使得它们在 Stream 类库中的作用更加强大。</p><p>那些为基本类型特殊定制的函数，如 <code>averagingInt</code>、<code>summarizingLong</code> 等，事实上和调用特殊 Stream 上的方法是等价的，加上它们是为了将它们当作下游收集器来使用的。</p><p>比如要收集各个分组的列表中的元素个数，代码示例如下：</p><pre class=" language-java"><code class="language-java">Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> Long<span class="token operator">></span> collectPartitioningBy <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">,</span> Collectors<span class="token punctuation">.</span><span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"collectPartitioningBy : "</span> <span class="token operator">+</span> collectPartitioningBy<span class="token punctuation">)</span><span class="token punctuation">;</span>Map<span class="token operator">&lt;</span>Boolean<span class="token punctuation">,</span> Long<span class="token operator">></span> collectGroupingBy <span class="token operator">=</span> Stream<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>it <span class="token operator">-</span><span class="token operator">></span> it <span class="token operator">></span> <span class="token number">3</span><span class="token punctuation">,</span> Collectors<span class="token punctuation">.</span><span class="token function">counting</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"collectGroupingBy : "</span> <span class="token operator">+</span> collectGroupingBy<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p><code>Stream</code> 的特性可以归纳为：</p><ul><li>Stream 不是数据结构</li><li>Stream 没有内部存储，它只是用操作管道从 source（数据结构、数组、generator function、IO channel）抓取数据。</li><li>Stream 绝不修改自己所封装的底层数据结构的数据。例如 Stream 的 filter 操作会产生一个不包含被过滤元素的新 Stream，而不是从 source 删除那些元素。</li><li>Stream 的所有操作必须以 lambda 表达式为参数</li><li>Stream 不支持索引访问</li><li>Stream 可以请求第一个元素，但无法请求第二个，第三个，或最后一个。不过请参阅下一项。</li><li>Stream 很容易生成数组或者 List</li><li>Stream 的惰性化<ul><li>Stream 的很多操作是向后延迟的，一直到它弄清楚了最后需要多少数据才会开始。</li><li>Stream 的Intermediate 操作永远是惰性化的。</li></ul></li><li>并行能力<ul><li>当一个 Stream 是并行化的，就不需要再写多线程代码，所有对它的操作会自动并行进行的。</li></ul></li><li>Stream 可以是无限的，集合有固定大小，Stream 则不必。limit(n) 和 findFirst() 这类的 short-circuiting 操作可以对无限的 Stream 进行运算并很快完成。</li></ul><h2 id="相关文档"><a href="#相关文档" class="headerlink" title="相关文档"></a>相关文档</h2><ul><li>Oracle Java 8 官方文档对 <a href="http://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html" target="_blank" rel="noopener">java.util.stream package</a> 的说明。</li><li><a href="http://javarevisited.blogspot.sg/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">Java 8 Tutorials, Resources, Books and Examples to learn Lambdas, Stream API and Functional Interfaces</a>。</li><li>关于 <a href="http://www.drdobbs.com/jvm/lambdas-and-streams-in-java-8-libraries/240166818" target="_blank" rel="noopener">Lambda 和 Stream</a> 更多介绍的教程。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 8 之 Optional</title>
      <link href="/posts/2018/e7fa2ea9.html"/>
      <url>/posts/2018/e7fa2ea9.html</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>Java 应用中最常见的 bug 就是<a href="https://examples.javacodegeeks.com/java-basics/exceptions/java-lang-nullpointerexception-how-to-handle-null-pointer-exception/" target="_blank" rel="noopener">空值异常</a>。在 Java 8 之前，<a href="https://github.com/google/guava" target="_blank" rel="noopener">Google Guava</a> 引入了 <code>Optionals</code> 类来解决 <code>NullPointerException</code>，从而避免源码被各种 <code>null</code> 检查污染，以便开发者写出更加整洁的代码。Java 8 也将 <code>Optional</code> 加入了官方库。</p><p><code>Optional</code> 仅仅是一个容器：存放 <code>T</code> 类型的值或者 <code>null</code>，它提供了一些有用的方法来避免显式的 <code>null</code> 检查，可以参考 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java 8 官方文档</a>了解更多细节。</p><h2 id="Optional-的方法"><a href="#Optional-的方法" class="headerlink" title="Optional 的方法"></a>Optional 的方法</h2><p><code>java.util.Optional</code> 类提供了很多有用的方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>static &lt;T&gt; Optional&lt;T&gt; empty()</code></td><td>返回空的 Optional 实例</td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt; of(T value)</code></td><td>返回一个描述指定非 null 值的 Optional 实例</td></tr><tr><td><code>static &lt;T&gt; Optional&lt;T&gt; ofNullable(T value)</code></td><td>如果指定的值为非空，则返回具有指定值的 Optional 实例，返回空的 Optional 实例</td></tr><tr><td><code>T get()</code></td><td>如果在这个 Optional 中存在一个非 null 值，则返回该值，否则抛出 NoSuchElementException</td></tr><tr><td><code>boolean isPresent()</code></td><td>如果存在值，则返回true，否则返回false</td></tr><tr><td><code>void ifPresent(Consumer&lt;? super T&gt; consumer)</code></td><td>如果值存在，则使用该值调用指定的 consumer，否则不做任何事情</td></tr><tr><td><code>Optional&lt;T&gt; filter(Predicate&lt;? super T&gt; predicate)</code></td><td>如果值存在，并且这个值匹配给定的 predicate，则返回描述该值的 Optional 实例，否则返回一个空的 Optional 实例</td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt; map(Function&lt;? super T, ? extends U&gt; mapper)</code></td><td>如果值存在，则使用该值调用指定的 mapper；如果返回值不为 null，则返回描述返回值的 Optional 实例，否则返回一个空的 Optional 实例</td></tr><tr><td><code>&lt;U&gt; Optional&lt;U&gt; flatMap(Function&lt;? super T, Optional&lt;U&gt;&gt; mapper)</code></td><td>如果值存在，则使用该值调用指定的 mapper；如果返回值不为 null，则返回基于 Optional 的描述返回值的 Optional 实例，否则返回一个空的 Optional 实例</td></tr><tr><td><code>T orElse(T other)</code></td><td>如果值存在，则返回该值，否则返回 other</td></tr><tr><td><code>T orElseGet(Supplier&lt;? extends T&gt; other)</code></td><td>如果值存在，则返回该值，调用 other 并返回该调用的结果</td></tr><tr><td><code>&lt;X extends Throwable&gt; T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)</code></td><td>如果值存在，则返回该值，否则抛出由 Supplier 提供的异常</td></tr><tr><td><code>boolean equals(Object obj)</code></td><td>判断其他对象是否等于 Optional</td></tr><tr><td><code>int hashCode()</code></td><td>如果值存在，则返回该值的哈希值；如果值不存在，则返回 0</td></tr><tr><td><code>String toString()</code></td><td>返回此 Optional 的非空字符串表示形式，适用于调试</td></tr></tbody></table><blockquote><p>Java 8 除了提供了 <code>Optional</code> 类之外，还提供了 <code>OptionalInt</code>、<code>OptionalLong</code>、<code>OptionalDouble</code>，他们的使用方法和 <code>Optional</code> 类似。</p></blockquote><h2 id="Optional-示例"><a href="#Optional-示例" class="headerlink" title="Optional 示例"></a>Optional 示例</h2><p>可以通过以下实例来更好的了解 <code>Optional</code> 类的使用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">OptionalTest</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        User user1 <span class="token operator">=</span> null<span class="token punctuation">;</span>        User user2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"Aaron"</span><span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        User user3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span><span class="token string">"Cherry"</span><span class="token punctuation">,</span> <span class="token number">18</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>User<span class="token operator">></span> optional1 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>user1<span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>User<span class="token operator">></span> optional2 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>user2<span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>User<span class="token operator">></span> optional3 <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Whether the value of optional1 exists : "</span> <span class="token operator">+</span> optional1<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Whether the value of optional2 exists : "</span> <span class="token operator">+</span> optional2<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        optional3<span class="token punctuation">.</span><span class="token function">ifPresent</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The name of one is "</span><span class="token operator">+</span> user3<span class="token punctuation">.</span>name<span class="token operator">+</span> <span class="token string">", and the age is "</span> <span class="token operator">+</span> user3<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The value of user2 : "</span> <span class="token operator">+</span> optional2<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The value of user1 or user3 : "</span> <span class="token operator">+</span> optional1<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The value of user2 or user3 : "</span> <span class="token operator">+</span> optional2<span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span>user3<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The name of user3 : "</span> <span class="token operator">+</span> optional3<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> user<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Optional<span class="token operator">&lt;</span>User<span class="token operator">></span> optional4 <span class="token operator">=</span> optional3<span class="token punctuation">.</span><span class="token function">flatMap</span><span class="token punctuation">(</span>user <span class="token operator">-</span><span class="token operator">></span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">User</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span>name<span class="token punctuation">,</span> user<span class="token punctuation">.</span>age<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"The value of optional4 : "</span> <span class="token operator">+</span> optional4<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Whether optional3 and optional4 are equal : "</span> <span class="token operator">+</span> optional3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>optional4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> String name<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token function">User</span><span class="token punctuation">(</span>String name<span class="token punctuation">,</span> <span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"User{"</span> <span class="token operator">+</span> <span class="token string">"name='"</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">'\''</span> <span class="token operator">+</span> <span class="token string">", age="</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">'}'</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 8 之日期和时间</title>
      <link href="/posts/2018/5b66a8.html"/>
      <url>/posts/2018/5b66a8.html</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>随着<a href="http://javarevisited.blogspot.sg/2014/02/10-example-of-lambda-expressions-in-java8.html" target="_blank" rel="noopener"><code>lambda</code></a>表达式、<a href="http://java67.blogspot.sg/2014/04/java-8-stream-api-examples-filter-map.html" target="_blank" rel="noopener"><code>streams</code></a>以及一系列小优化，Java8 推出了全新的日期时间 API。</p><p>Java 处理日期、日历和时间的方式一直为社区所诟病，将 <code>java.util.Date</code> 设定为可变类型，以及<a href="http://javarevisited.blogspot.sg/2012/03/simpledateformat-in-java-is-not-thread.html" target="_blank" rel="noopener">SimpleDateFormat 的非线程安全</a>使其应用非常受限。Java 也意识到需要一个更好的 API 来满足社区中已经习惯了使用 <code>JodaTime API</code> 的人们。</p><p>全新 API 的众多好处之一就是，明确了日期时间概念，例如：<code>瞬时(instant)</code>、<code>期间(duration)</code>、<code>日期</code>、<code>时间</code>、<code>时区</code>和<code>周期</code>。同时继承了 <code>Joda</code> 库按人类语言和计算机各自解析的时间处理方式。不同于老版本，新 API 基于 ISO 标准日历系统，<code>java.time</code> 包下的所有类都是不可变类型而且线程安全。</p><h2 id="java-time-的关键类"><a href="#java-time-的关键类" class="headerlink" title="java.time 的关键类"></a>java.time 的关键类</h2><p>新版 API 中 <code>java.time</code> 包含以下关键类：</p><ul><li><strong><code>Instant：</code></strong>瞬时实例。</li><li><strong><code>LocalDate：</code></strong>本地日期，不包含具体时间。例如：<code>2014-01-14</code> 可以用来记录生日、纪念日、加盟日等。</li><li><strong><code>LocalTime：</code></strong>本地时间，不包含日期。</li><li><strong><code>LocalDateTime：</code></strong>组合了日期和时间，但不包含时差和时区信息。</li><li><strong><code>ZonedDateTime：</code></strong>最完整的日期时间，包含时区和相对 UTC 或格林威治的时差。</li></ul><p>新 API 还引入了 <code>ZoneOffSet</code> 和 <code>ZoneId</code> 类，使得解决时区问题更为简便。<a href="http://javarevisited.blogspot.sg/2011/09/step-by-step-guide-to-convert-string-to.html" target="_blank" rel="noopener">解析和格式化时间</a>的 <code>DateTimeFormatter</code> 类也全部重新设计。</p><h2 id="日期和时间-API-的使用"><a href="#日期和时间-API-的使用" class="headerlink" title="日期和时间 API 的使用"></a>日期和时间 API 的使用</h2><p>常有人问我学习一个新库的最好方式是什么？我的答案是在实际项目中使用它。项目中有很多真正的需求驱使开发者去发掘并学习新库。简单得说就是任务驱动学习探索。这对Java8新日期时间<code>API</code>也不例外。我创建了20个基于任务的实例来学习Java8的新特性。从最简单创建当天的日期开始，然后创建时间及时区，接着模拟一个日期提醒应用中的任务——计算重要日期的到期天数，例如生日、纪念日、账单日、保费到期日、信用卡过期日等。</p><h3 id="1-获取当前日期"><a href="#1-获取当前日期" class="headerlink" title="1. 获取当前日期"></a>1. 获取当前日期</h3><p>Java8 中的 <code>LocalDate</code> 用于表示当天日期。和 <code>java.util.Date</code> 不同，它只有日期，不包含时间。当仅需要表示日期时就用这个类。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getCurrentDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Today's Local date : "</span> <span class="token operator">+</span> today<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 这个是作为对比</span>    Date date <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Today's Local date : "</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>上面的代码创建了当天的日期，不含时间信息。打印出的日期格式非常友好，不像老的 <code>Date</code> 类打印出一堆没有格式化的信息。</p><h3 id="2-获取当前的年、月、日信息"><a href="#2-获取当前的年、月、日信息" class="headerlink" title="2. 获取当前的年、月、日信息"></a>2. 获取当前的年、月、日信息</h3><p><code>LocalDate</code> 类提供了获取年、月、日的快捷方法，其实例还包含很多其它的日期属性。通过调用这些方法就可以很方便的得到需要的日期信息，不用像以前一样需要依赖 <code>java.util.Calendar</code> 类了。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getCurrentDetailDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> year <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> month <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getMonthValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> day <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Year : %d  Month : %d  day : %d %n"</span><span class="token punctuation">,</span> year<span class="token punctuation">,</span> month<span class="token punctuation">,</span> day<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行后可以看到，在 Java8 中得到年、月、日信息是这么简单直观，想用就用，没什么需要记的。对比看看以前 Java 是怎么处理年月日信息的吧。</p><h3 id="3-处理特定日期"><a href="#3-处理特定日期" class="headerlink" title="3. 处理特定日期"></a>3. 处理特定日期</h3><p>在第一个例子里，我们通过静态工厂方法 <code>now()</code> 非常容易地创建了当天日期，还可以调用另一个有用的工厂方法 <code>LocalDate.of()</code> 创建任意日期，该方法需要传入年、月、日做参数，返回对应的 <code>LocalDate</code> 实例。这个方法的好处是没再犯老 API 的设计错误，比如年度起始于1900，月份是从0开始等等。日期所见即所得，就像下面这个例子表示了1月14日，没有任何隐藏机关。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">handleSpecilDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate dateOfBirth <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Your Date of birth is : "</span> <span class="token operator">+</span> dateOfBirth<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行后可以看到创建的日期完全符合预期，与写入的2010年1月14日完全一致。</p><h3 id="4-判断两个日期是否相等"><a href="#4-判断两个日期是否相等" class="headerlink" title="4. 判断两个日期是否相等"></a>4. 判断两个日期是否相等</h3><p>现实生活中有一类时间处理就是判断两个日期是否相等。常常会检查今天是不是个特殊的日子，比如生日、纪念日或非交易日。这时就需要把指定的日期与某个特定日期做比较，例如判断这一天是否是假期。下面这个例子会用 Java8 的方式去解决，<code>LocalDate</code> 重载了 <code>equal</code> 方法，请看下面的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">compareDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate date1 <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>date1<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Today %s and date1 %s are same date %n"</span><span class="token punctuation">,</span> today<span class="token punctuation">,</span> date1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个例子中我们比较的两个日期相同。注意，如果比较的日期是字符型的，需要先解析成日期对象再作判断。对比<a href="http://javarevisited.blogspot.sg/2012/02/3-example-to-compare-two-dates-in-java.html" target="_blank" rel="noopener">Java 老的日期比较方式</a>，你会感到清风拂面。</p><h3 id="5-检查像生日这种周期性事件"><a href="#5-检查像生日这种周期性事件" class="headerlink" title="5. 检查像生日这种周期性事件"></a>5. 检查像生日这种周期性事件</h3><p>Java 中另一个日期时间的处理就是检查类似每月账单、结婚纪念日、EMI 日或保险缴费日这些周期性事件，比如在类似生日、纪念日、法定假日(国庆以及春节)、或者每个月固定时间发送邮件给客户这些周期性事件。Java 中如何检查这些节日或其它周期性事件呢？答案就是 <code>MonthDay</code> 类。这个类组合了月份和日，去掉了年，这意味着你可以用它判断每年都会发生事件。和这个类相似的还有一个 <code>YearMonth</code> 类。这些类也都是不可变并且线程安全的值类型。下面我们通过 <code>MonthDay</code> 来检查周期性事件：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">recurringDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate dateOfBirth <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2010</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MonthDay birthday <span class="token operator">=</span> MonthDay<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>dateOfBirth<span class="token punctuation">.</span><span class="token function">getMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> dateOfBirth<span class="token punctuation">.</span><span class="token function">getDayOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    MonthDay currentMonthDay <span class="token operator">=</span> MonthDay<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>currentMonthDay<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>birthday<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Many Many happy returns of the day"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Sorry, today is not your birthday"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>只要当天的日期和生日匹配，无论是哪一年都会打印出祝贺信息。可以把程序整合进系统时钟，看看生日时是否会受到提醒，或者写一个单元测试来检测代码是否运行正确。</p><h3 id="6-获取当前时间"><a href="#6-获取当前时间" class="headerlink" title="6. 获取当前时间"></a>6. 获取当前时间</h3><p>与 Java8 获取日期的例子很像，获取时间使用的是 <code>LocalTime</code> 类，一个只有时间没有日期的 <code>LocalDate</code> 的近亲。可以调用静态工厂方法 <code>now()</code> 来获取当前时间。默认的格式是 <code>hh:mm:ss:nnn</code>。对比一下<a href="http://javarevisited.blogspot.sg/2012/01/get-current-date-timestamps-java.html" target="_blank" rel="noopener">Java8 之前获取当前时间的方式</a>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getCurrentTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local time now : "</span> <span class="token operator">+</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行后可以看到当前时间就只包含时间信息，没有日期。</p><h3 id="7-在现有的时间上增加小时"><a href="#7-在现有的时间上增加小时" class="headerlink" title="7. 在现有的时间上增加小时"></a>7. 在现有的时间上增加小时</h3><p>通过增加小时、分、秒来计算将来的时间很常见。Java8 除了不变类型和线程安全的好处之外，还提供了更好的 <code>plusHours()</code> 方法替换 <code>add()</code>，并且是兼容的。注意，这些方法返回一个全新的 <code>LocalTime</code> 实例，由于其不可变性，返回后一定要用变量赋值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">plusHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalTime newTime <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">plusHours</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// adding two hours</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Local time now : "</span> <span class="token operator">+</span> time<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Time after 2 hours : "</span> <span class="token operator">+</span>  newTime<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行后可以看到，新的时间在当前时间的基础上增加了2个小时。和<a href="http://javarevisited.blogspot.sg/2012/12/how-to-add-subtract-days-months-years-to-date-time-java.html" target="_blank" rel="noopener">旧版 Java 的增减时间的处理方式</a>对比一下，看看哪种更好。</p><h3 id="8-计算一周后的日期"><a href="#8-计算一周后的日期" class="headerlink" title="8. 计算一周后的日期"></a>8. 计算一周后的日期</h3><p>和上个例子计算两小时以后的时间类似，这个例子会计算一周后的日期。<code>LocalDate</code> 日期不包含时间信息，它的 <code>plus()</code> 方法用来增加天、周、月，<code>ChronoUnit</code> 类声明了这些时间单位。由于 <code>LocalDate</code> 也是不变类型，返回后一定要用变量赋值。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">nextWeek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate nextWeek <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>WEEKS<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Today is : "</span> <span class="token operator">+</span> today<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Date after 1 week : "</span> <span class="token operator">+</span> nextWeek<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>运行后可以看到新日期离当天日期是7天，也就是一周。你可以用同样的方法增加1个月、1年、1小时、1分钟甚至一个世纪，更多选项可以查看 <code>Java 8 API</code> 中的 <code>ChronoUnit</code>类。</p><h3 id="9-计算一年前或一年后的日期"><a href="#9-计算一年前或一年后的日期" class="headerlink" title="9. 计算一年前或一年后的日期"></a>9. 计算一年前或一年后的日期</h3><p>继续上面的例子，上个例子中我们通过 <code>LocalDate</code> 的 <code>plus()</code> 方法增加天数、周数或月数，这个例子我们利用 <code>minus()</code> 方法计算一年前的日期。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">minusDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Today's Local date : "</span> <span class="token operator">+</span> today<span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate previousYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>YEARS<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Date before 1 year : "</span> <span class="token operator">+</span> previousYear<span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate nextYear <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">plus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>YEARS<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Date after 1 year : "</span> <span class="token operator">+</span> nextYear<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h3 id="10-使用-Clock-时钟类"><a href="#10-使用-Clock-时钟类" class="headerlink" title="10. 使用 Clock 时钟类"></a>10. 使用 Clock 时钟类</h3><p>Java8 增加了一个 <code>Clock</code> 时钟类用于获取当时的时间戳，或当前时区下的日期时间信息。以前用到 <code>System.currentTimeInMillis()</code> 和 <code>TimeZone.getDefault()</code> 的地方都可用 <code>Clock</code> 替换。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">clock</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Returns the current time based on your system clock and set to UTC.</span>    Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemUTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Clock : "</span> <span class="token operator">+</span> clock<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// Returns time based on system clock zone</span>    Clock defaultClock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemDefaultZone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Clock : "</span> <span class="token operator">+</span> clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>还可以针对 <code>Clock</code> 时钟做比较，像下面这个例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyClass</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Clock clock<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// dependency inject</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">process</span><span class="token punctuation">(</span>LocalDate eventDate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>eventDate<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这种方式处理<a href="http://java67.blogspot.sg/2012/12/how-to-display-date-in-multiple-timezone-java.html" target="_blank" rel="noopener">在不同时区下的日期</a>时会非常管用。</p><h3 id="11-判断日期是早于还是晚于另一个日期"><a href="#11-判断日期是早于还是晚于另一个日期" class="headerlink" title="11. 判断日期是早于还是晚于另一个日期"></a>11. 判断日期是早于还是晚于另一个日期</h3><p>另一个工作中常见的操作就是如何判断给定的一个日期是大于某天还是小于某天？在 Java8 中，<code>LocalDate</code> 类有两类方法 <code>isBefore()</code> 和 <code>isAfter()</code> 用于比较日期。调用 <code>isBefore()</code> 方法时，如果给定日期小于当前日期则返回<code>true</code>。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">isBeforeOrIsAfter</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate tomorrow <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>tomorrow<span class="token punctuation">.</span><span class="token function">isAfter</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Tomorrow comes after today"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    LocalDate yesterday <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">minus</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> ChronoUnit<span class="token punctuation">.</span>DAYS<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>yesterday<span class="token punctuation">.</span><span class="token function">isBefore</span><span class="token punctuation">(</span>today<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Yesterday is day before today"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 Java8 中比较日期非常方便，不需要使用额外的 <code>Calendar</code> 类来做这些基础工作了。</p><h3 id="12-处理时区"><a href="#12-处理时区" class="headerlink" title="12. 处理时区"></a>12. 处理时区</h3><p>Java8 不仅分离了日期和时间，也把时区分离出来了。现在有一系列单独的类如 <code>ZoneId</code> 来处理特定时区，<code>ZoneDateTime</code> 类来表示某时区下的时间。这在 Java8 以前都是 <a href="http://javarevisited.blogspot.sg/2013/02/convert-xmlgregoriancalendar-to-date-xmlgregoriancalendar-java-example-tutorial.html" target="_blank" rel="noopener">GregorianCalendar 类</a>来做的。下面这个例子展示了如何把本时区的时间转换成另一个时区的时间。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getZoneTime</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Date and time with timezone in Java 8</span>    ZoneId america <span class="token operator">=</span> ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"America/New_York"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDateTime localtDateAndTime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ZonedDateTime dateAndTimeInNewYork <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>localtDateAndTime<span class="token punctuation">,</span> america<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Current date and time in a particular timezone : "</span> <span class="token operator">+</span> dateAndTimeInNewYork<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>和以前<a href="http://javarevisited.blogspot.sg/2012/04/how-to-convert-local-time-to-gmt-in.html" target="_blank" rel="noopener">使用 GMT 的方式转换本地时间</a>对比一下。注意，在 Java8 以前，一定要牢牢记住时区的名称，不然就会抛出下面的异常：</p><pre class=" language-java"><code class="language-java">Exception in thread <span class="token string">"main"</span> java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesException<span class="token operator">:</span> Unknown time<span class="token operator">-</span>zone ID<span class="token operator">:</span> ASIA<span class="token operator">/</span>Tokyo        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesProvider<span class="token punctuation">.</span><span class="token function">getProvider</span><span class="token punctuation">(</span>ZoneRulesProvider<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">272</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>zone<span class="token punctuation">.</span>ZoneRulesProvider<span class="token punctuation">.</span><span class="token function">getRules</span><span class="token punctuation">(</span>ZoneRulesProvider<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">227</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneRegion<span class="token punctuation">.</span><span class="token function">ofId</span><span class="token punctuation">(</span>ZoneRegion<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">120</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">403</span><span class="token punctuation">)</span>        at java<span class="token punctuation">.</span>time<span class="token punctuation">.</span>ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span>java<span class="token operator">:</span><span class="token number">351</span><span class="token punctuation">)</span></code></pre><h3 id="13-表示固定日期"><a href="#13-表示固定日期" class="headerlink" title="13. 表示固定日期"></a>13. 表示固定日期</h3><p>与 <code>MonthDay</code> 检查重复事件的例子相似，<code>YearMonth</code> 是另一个组合类，用于表示信用卡到期日、FD 到期日、期货期权到期日等。还可以用这个类得到当月共有多少天，<code>YearMonth</code> 实例的 <code>lengthOfMonth()</code> 方法可以返回当月的天数，在判断2月有28天还是29天时非常有用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">checkCardExpiry</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    YearMonth currentYearMonth <span class="token operator">=</span> YearMonth<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Days in month year %s: %d%n"</span><span class="token punctuation">,</span> currentYearMonth<span class="token punctuation">,</span> currentYearMonth<span class="token punctuation">.</span><span class="token function">lengthOfMonth</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    YearMonth creditCardExpiry <span class="token operator">=</span> YearMonth<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2018</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>FEBRUARY<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Your credit card expires on %s %n"</span><span class="token punctuation">,</span> creditCardExpiry<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>根据上述数据，你可以提醒客户信用卡快要到期了，个人认为这个类非常有用。</p><h3 id="14-检查闰年"><a href="#14-检查闰年" class="headerlink" title="14. 检查闰年"></a>14. 检查闰年</h3><p><code>LocalDate</code> 类有一个很实用的方法 <code>isLeapYear()</code> 判断该实例是否是一个闰年，如果你还是想重新发明轮子，这有一个代码示例，<a href="http://java67.blogspot.sg/2012/12/how-to-check-leap-year-in-java-program.html" target="_blank" rel="noopener">纯 Java 逻辑编写的判断闰年</a>的程序。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> year <span class="token operator">=</span> today<span class="token punctuation">.</span><span class="token function">getYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>today<span class="token punctuation">.</span><span class="token function">isLeapYear</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Year %d is a Leap year %n"</span><span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Year %d is not a Leap year %n"</span><span class="token punctuation">,</span> year<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>你可以多写几个日期来验证是否是闰年，最好是写 <code>JUnit</code> 单元测试做判断。</p><h3 id="15-计算两个日期之间的天数和月数"><a href="#15-计算两个日期之间的天数和月数" class="headerlink" title="15. 计算两个日期之间的天数和月数"></a>15. 计算两个日期之间的天数和月数</h3><p>有一个常见日期操作是计算两个日期之间的天数、周数或月数。在 Java8 中可以用 <code>java.time.Period</code> 类来做计算。下面这个例子中，我们计算了当天和将来某一天之间的月数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">calcDateBetweenDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDate today <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    LocalDate java8Release <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>DECEMBER<span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Period periodToNextJavaRelease <span class="token operator">=</span> Period<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>java8Release<span class="token punctuation">,</span> today<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Months left between today and Java 8 release : "</span> <span class="token operator">+</span> periodToNextJavaRelease<span class="token punctuation">.</span><span class="token function">getMonths</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>从上面可以看到现在是一月，Java8 的中计算的当前日期是4月18日，中间相隔3天。</p><h3 id="16-包含时差信息的日期和时间"><a href="#16-包含时差信息的日期和时间" class="headerlink" title="16. 包含时差信息的日期和时间"></a>16. 包含时差信息的日期和时间</h3><p>在 Java8 中，<code>ZoneOffset</code> 类用来表示时区，举例来说印度与 GMT 或 UTC 标准时区相差<code>+05:30</code>，可以通过 <code>ZoneOffset.of()</code> 静态方法来获取对应的时区。一旦得到了时差就可以通过传入 <code>LocalDateTime</code> 和 <code>ZoneOffset</code> 来创建一个 <code>OffSetDateTime</code> 对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">zoneOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDateTime datetime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>JANUARY<span class="token punctuation">,</span> <span class="token number">14</span><span class="token punctuation">,</span> <span class="token number">19</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    ZoneOffset offset <span class="token operator">=</span> ZoneOffset<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"+05:30"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    OffsetDateTime date <span class="token operator">=</span> OffsetDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>datetime<span class="token punctuation">,</span> offset<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Date and Time with timezone offset in Java : "</span> <span class="token operator">+</span> date<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>现在的时间信息里已经包含了时区信息了。注意：<code>OffSetDateTime</code> 是对计算机友好的，<code>ZoneDateTime</code> 则对人更友好。</p><h3 id="17-获取当前时间戳"><a href="#17-获取当前时间戳" class="headerlink" title="17. 获取当前时间戳"></a>17. 获取当前时间戳</h3><p>如果你还记得 Java8 以前是如何获得当前时间戳，那么现在你终于解脱了。<code>Instant</code> 类有一个静态工厂方法 <code>now()</code> 会返回当前的时间戳，如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">getTimestamp</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    Instant timestamp <span class="token operator">=</span> Instant<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"What is value of this instant "</span> <span class="token operator">+</span> timestamp<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>时间戳信息里同时包含了日期和时间，这和 <code>java.util.Date</code> 很像。实际上 <code>Instant</code> 类确实等同于 Java8 之前的 <code>Date</code> 类，你可以使用 <code>Date</code> 类和 <code>Instant</code> 类各自的转换方法互相转换，例如：<code>Date.from(Instant)</code> 将 <code>Instant</code> 转换成 <code>java.util.Date</code>，<code>Date.toInstant()</code> 则是将 <code>Date</code> 类转换成 <code>Instant</code> 类。</p><h3 id="18-使用预定义的格式化工具去解析或格式化日期"><a href="#18-使用预定义的格式化工具去解析或格式化日期" class="headerlink" title="18. 使用预定义的格式化工具去解析或格式化日期"></a>18. 使用预定义的格式化工具去解析或格式化日期</h3><p>在 Java8 以前的世界里，日期和时间的格式化非常诡异，唯一的帮助类 <code>SimpleDateFormat</code> 也是非线程安全的，而且用作局部变量解析和格式化日期时显得很笨重。幸好线程局部变量能使它在多线程环境中变得可用，不过这都是过去时了。Java8 引入了全新的日期时间格式工具，线程安全而且使用方便。它自带了一些常用的内置格式化工具。下面这个例子使用了 <code>BASIC_ISO_DATE</code> 格式化工具将2016年4月18日格式化成20160418。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formateDateWithPredefined</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String dayAfterTommorrow <span class="token operator">=</span> <span class="token string">"20140116"</span><span class="token punctuation">;</span>    LocalDate formatted <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>dayAfterTommorrow<span class="token punctuation">,</span> DateTimeFormatter<span class="token punctuation">.</span>BASIC_ISO_DATE<span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Date generated from String %s is %s %n"</span><span class="token punctuation">,</span> dayAfterTommorrow<span class="token punctuation">,</span> formatted<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>很明显的看出得到的日期和给出的日期是同一天，但是格式不同。</p><h3 id="19-使用自定义格式化工具解析日期"><a href="#19-使用自定义格式化工具解析日期" class="headerlink" title="19. 使用自定义格式化工具解析日期"></a>19. 使用自定义格式化工具解析日期</h3><p>上个例子使用了<a href="http://java67.blogspot.sg/2014/12/string-to-date-example-in-java-multithreading.html" target="_blank" rel="noopener">Java 内置的格式化工具</a>去解析日期字符串。尽管内置格式化工具很好用，有时还是需要定义特定的日期格式，下面这个例子展示了如何创建自定义日期格式化工具。例子中的日期格式是“MMM dd yyyy”。可以调用<code>DateTimeFormatter</code>的<code>ofPattern()</code>静态方法并传入任意格式返回其实例，格式中的字符和以前代表的一样，<code>M</code> 代表月，<code>m</code> 代表分。如果格式不规范会抛出 <code>DateTimeParseException</code> 异常，不过如果只是把M写成m这种逻辑错误是不会抛异常的。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">formateDateWithCustom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String goodFriday <span class="token operator">=</span> <span class="token string">"Apr 18 2014"</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        DateTimeFormatter formatter <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd yyyy"</span><span class="token punctuation">,</span> Locale<span class="token punctuation">.</span>US<span class="token punctuation">)</span><span class="token punctuation">;</span>        LocalDate holiday <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>goodFriday<span class="token punctuation">,</span> formatter<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Successfully parsed String %s, date is %s%n"</span><span class="token punctuation">,</span> goodFriday<span class="token punctuation">,</span> holiday<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DateTimeParseException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s is not parsable!%n"</span><span class="token punctuation">,</span> goodFriday<span class="token punctuation">)</span><span class="token punctuation">;</span>        ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>日期值与传入的字符串是匹配的，只是格式不同而已。</p><h3 id="20-把日期转换成字符串"><a href="#20-把日期转换成字符串" class="headerlink" title="20. 把日期转换成字符串"></a>20. 把日期转换成字符串</h3><p>上两个例子都用到了 <code>DateTimeFormatter</code> 类，主要是从字符串解析日期。现在我们反过来，把 <code>LocalDateTime</code> 日期实例转换成特定格式的字符串。这是迄今为止<a href="http://java67.blogspot.sg/2013/01/how-to-format-date-in-java-simpledateformat-example.html" target="_blank" rel="noopener">Java 日期转字符串最为简单的方式</a>了。下面的例子将返回一个代表日期的格式化字符串。和前面类似，还是需要创建 <code>DateTimeFormatter</code> 实例并传入格式，但这回调用的是 <code>format()</code> 方法，而非 <code>parse()</code> 方法。这个方法会把传入的日期转化成指定格式的字符串。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">convertDateToString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    LocalDateTime arrivalDate <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        DateTimeFormatter format <span class="token operator">=</span> DateTimeFormatter<span class="token punctuation">.</span><span class="token function">ofPattern</span><span class="token punctuation">(</span><span class="token string">"MMM dd yyyy  hh:mm a"</span><span class="token punctuation">,</span> Locale<span class="token punctuation">.</span>US<span class="token punctuation">)</span><span class="token punctuation">;</span>        String landing <span class="token operator">=</span> arrivalDate<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span>format<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"Arriving at :  %s %n"</span><span class="token punctuation">,</span> landing<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">DateTimeException</span> ex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%s can't be formatted!%n"</span><span class="token punctuation">,</span> arrivalDate<span class="token punctuation">)</span><span class="token punctuation">;</span>        ex<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>当前时间被指定的“MMM dd yyyy hh:mm a”格式格式化，格式包含3个代表月的字符串，时间后面带有AM和PM标记。</p><h2 id="Java8-日期时间-API-总结"><a href="#Java8-日期时间-API-总结" class="headerlink" title="Java8 日期时间 API 总结"></a>Java8 日期时间 API 总结</h2><p>通过这些例子，你肯定已经掌握了 Java8 日期时间 API 的新知识点。现在我们来回顾一下这个优雅 API 的使用要点：</p><ol><li>提供了 <code>javax.time.ZoneId</code> 获取时区。</li><li>提供了 <code>LocalDate</code> 和 <code>LocalTime</code> 类。</li><li>Java8 的所有日期和时间 <code>API</code> 都是不可变类并且线程安全，而现有的 <code>Date</code> 和 <code>Calendar</code> API中的 <code>java.util.Date</code> 和 <code>SimpleDateFormat</code> 是非线程安全的。</li><li>主包是 <code>java.time</code>，包含了表示日期、时间、时间间隔的一些类。里面有两个子包<code>java.time.format</code>用于格式化， <code>java.time.temporal</code>用于更底层的操作。</li><li>时区代表了地球上某个区域内普遍使用的标准时间。每个时区都有一个代号，格式通常由区域/城市构成(Asia/Tokyo)，在加上与格林威治或 <code>UTC</code> 的时差。例如：东京的时差是+09:00。</li><li><code>OffsetDateTime</code> 类实际上组合了 <code>LocalDateTime</code> 类和 <code>ZoneOffset</code> 类。用来表示包含和格林威治或 UTC 时差的完整日期（年、月、日）和时间（时、分、秒、纳秒）信息。</li><li><code>DateTimeFormatter</code> 类用来格式化和解析时间。与 <code>SimpleDateFormat</code> 不同，这个类不可变并且线程安全，需要时可以给静态常量赋值。<code>DateTimeFormatter</code> 类提供了大量的内置格式化工具，同时也允许你自定义。在转换方面也提供了 <code>parse()</code> 将字符串解析成日期，如果解析出错会抛出 <code>DateTimeParseException</code>。<code>DateTimeFormatter</code> 类同时还有 <code>format()</code> 用来格式化日期，如果出错会抛出 <code>DateTimeException</code> 异常。</li><li>再补充一点，日期格式“MMM d yyyy”和“MMM dd yyyy”有一些微妙的不同，第一个格式可以解析“Jan 2 2014”和“Jan 14 2014”，而第二个在解析“Jan 2 2014”就会抛异常，因为第二个格式里要求日必须是两位的。如果想修正，你必须在日期只有个位数时在前面补零，就是说“Jan 2 2014”应该写成 “Jan 02 2014”。</li></ol><p>如何使用 Java8 的全新日期时间 API 就介绍到这了。这些简单的例子对帮助理解新 API 非常有用。由于这些例子都基于真实任务，在做 Java 日期编程时就不用再东张西望了。我们学会了如何创建并操作日期实例，学习了纯日期、以及包含时间信息和时差信息的日期、学会了怎样计算两个日期的间隔，这些在计算当天与某个特定日期间隔的例子中都有所展示。 我们还学到了在Java8中如何线程安全地解析和格式化日期，不用再使用蹩脚的线程局部变量技巧，也不用依赖<code>Joda Time</code>第三方库。新<code>API</code>可以作为处理日期时间操作的标准。</p><h2 id="Java8-其它教程"><a href="#Java8-其它教程" class="headerlink" title="Java8 其它教程"></a>Java8 其它教程</h2><p>如果你喜欢这个教程并希望看到更多关于 Java 8 的教程，下面这些精彩的文章都值得一看：</p><ul><li>如何在 Java8 中用一行代码搞定文件读取？(<a href="http://javarevisited.blogspot.sg/2015/02/how-to-read-file-in-one-line-java-8.html" target="_blank" rel="noopener">示例</a>)</li><li>学习 Java8 的十大教程（<a href="http://java67.blogspot.sg/2014/09/top-10-java-8-tutorials-best-of-lot.html" target="_blank" rel="noopener">教程</a>）</li><li>免费的 Java8 教程和图书 （<a href="http://javarevisited.blogspot.sg/2013/11/java-8-tutorials-resources-and-examples-lambda-expression-stream-api-functional-interfaces.html" target="_blank" rel="noopener">资源</a>）</li><li>Java 8 <code>Comparator</code> 例子 （<a href="http://java67.blogspot.com/2014/11/java-8-comparator-example-using-lambda-expression.html" target="_blank" rel="noopener">示例</a>）</li><li>如何使用 Java8 的 <code>Map</code> 函数（<a href="http://java67.blogspot.sg/2015/01/java-8-map-function-examples.html" target="_blank" rel="noopener">示例</a>）</li><li>你准备好学习 Java8 的认证了吗 （<a href="http://javarevisited.blogspot.sg/2014/09/latest-OCPJP-exam-java-8-certification-oracle-java-se-8.html" target="_blank" rel="noopener">更多</a>）</li><li>如何使用 Java8 的默认方法。（<a href="http://javarevisited.blogspot.sg/2014/07/default-defender-or-extension-method-of-Java8-example-tutorial.html" target="_blank" rel="noopener">看这里</a>）</li><li>开始 Java8 之前需要温习的十个<code>Java 7</code> 特性（<a href="http://javarevisited.blogspot.sg/2014/04/10-jdk-7-features-to-revisit-before-you.html" target="_blank" rel="noopener">更多</a>）</li><li>Java8 学习 <code>Stream API</code> 十例（<a href="http://javarevisited.blogspot.sg/2014/03/2-examples-of-streams-with-Java8-collections.html" target="_blank" rel="noopener">示例</a>）</li><li>如何在匿名类中使用 <code>Lambda</code> 表达式（<a href="http://javarevisited.blogspot.sg/2015/01/how-to-use-lambda-expression-in-place-anonymous-class-java8.html" target="_blank" rel="noopener">答案</a>）</li><li>如何使用 Java8 的 <code>Predicates</code> 类过滤 <code>Collection</code>？（<a href="http://javarevisited.blogspot.sg/2015/02/how-to-filter-collections-in-java-8.html" target="_blank" rel="noopener">答案</a>）</li><li>Java 中如何随即访问文件？（<a href="http://javarevisited.blogspot.sg/2015/02/randomaccessfile-example-in-java-read-write-String.html" target="_blank" rel="noopener">答案</a>）</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="http://javarevisited.blogspot.sg/2015/03/20-examples-of-date-and-time-api-from-Java8.html" target="_blank" rel="noopener">Java 8 - 20 Examples of Date and Time API</a></p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 反射详解</title>
      <link href="/posts/2018/23741915.html"/>
      <url>/posts/2018/23741915.html</url>
      
        <content type="html"><![CDATA[<h2 id="反射的概述"><a href="#反射的概述" class="headerlink" title="反射的概述"></a>反射的概述</h2><h3 id="什么是反射？"><a href="#什么是反射？" class="headerlink" title="什么是反射？"></a>什么是反射？</h3><p>Java 反射(<code>Reflection</code>)机制就是在运行状态中，对于<code>任意</code>一个类，都能够获取到这个类的所有属性和方法。对于<code>任意</code>一个对象，都能够调用它的<code>任意</code>一个方法和属性(包括私有的方法和属性)。这种动态获取的信息以及动态调用对象的方法的功能就称为 Java 语言的反射机制。通俗点讲，通过反射，该类对我们来说是完全透明的，想要获取任何东西都可以。Java 程序中一般的对象的类型都是在编译期就确定下来的，而 Java 反射机制可以动态地创建对象并调用其属性，这样的对象的类型在编译期是未知的。所以我们可以通过反射机制直接创建对象，即使这个对象的类型在编译期是未知的。</p><p>反射的核心是 JVM 在<strong><code>运行时</code></strong>才动态加载类或调用方法/访问属性，它不需要事先(写代码的时候或编译期)知道运行对象是谁。反射机制就是通过 <code>java.lang.Class</code> 类来实现的，在 Java 中，<code>Object</code> 类是所有类的根类，而 <code>Class</code> 类就是描述 Java 类的类。</p><blockquote><p><strong>注</strong>：<code>Class</code> 本身就是一个类，<code>Class</code> 就是这个类的名称(注意首字母是大写)，所以 <code>Object</code> 也包括 <code>Class</code> 类。<code>public class Demo {}</code>，这里的 <code>class</code> 是作为关键字，来表明 <code>Demo</code> 是一个类。</p></blockquote><h3 id="反射的主要功能"><a href="#反射的主要功能" class="headerlink" title="反射的主要功能"></a>反射的主要功能</h3><p>Java 反射框架主要提供以下功能：</p><ul><li>在运行时判断任意一个对象所属的类；</li><li>在运行时构造任意一个类的对象；</li><li>在运行时判断任意一个类所具有的成员变量和方法(通过反射甚至可以调用 private 方法)；</li><li>在运行时调用任意一个对象的方法；</li><li>修改构造函数、方法、属性的可见性。</li></ul><h3 id="反射的主要用途"><a href="#反射的主要用途" class="headerlink" title="反射的主要用途"></a>反射的主要用途</h3><p><strong>反射最重要的用途就是开发各种通用框架</strong>。很多框架(比如 Spring)都是配置化的(比如通过 XML 文件配置 JavaBean、Action 之类的)，为了保证框架的通用性，它们可能需要根据配置文件加载不同的对象或类，调用不同的方法，这个时候就必须用到反射——运行时动态加载需要加载的对象。对与框架开发人员来说，反射虽小但作用非常大，它是各种容器实现的核心。</p><h2 id="反射的使用"><a href="#反射的使用" class="headerlink" title="反射的使用"></a>反射的使用</h2><p>反射机制中会用到一些类，在了解反射是如何使用之前，先介绍一下这些类。</p><table><thead><tr><th>类</th><th>说明</th></tr></thead><tbody><tr><td>Class</td><td>在反射中表示内存中的一个 Java 类，Class 可以代表的实例类型包括，类和接口、基本数据类型、数组</td></tr><tr><td>Object</td><td>Java 中所有类的超类</td></tr><tr><td>Constructor</td><td>封装了类的构造函数的属性信息，包括访问权限和动态调用信息</td></tr><tr><td>Field</td><td>提供类或接口的成员变量属性信息，包括访问权限和动态修改</td></tr><tr><td>Method</td><td>提供类或接口的方法属性信息，包括访问权限和动态调用信息</td></tr><tr><td>Modifier</td><td>封装了修饰属性，public、protected、static、final、synchronized、abstract 等</td></tr></tbody></table><p>声明一个接口和一个简单的具体类作为示例代码：<br>声明一个接口：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IAddress</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>具体的类，注意类各个方法的修饰属性。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Person</span> <span class="token keyword">implements</span> <span class="token class-name">IAddress</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> age<span class="token punctuation">;</span>    <span class="token keyword">public</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getAge</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setAge</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Person <span class="token function">setData</span><span class="token punctuation">(</span><span class="token keyword">int</span> age<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>age <span class="token operator">=</span> age<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">address</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"I am from China."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Person [age="</span> <span class="token operator">+</span> age <span class="token operator">+</span> <span class="token string">", name="</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">"]"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="获取-Class-对象"><a href="#获取-Class-对象" class="headerlink" title="获取 Class 对象"></a>获取 Class 对象</h3><p>想要使用反射机制，就必须要先获取到该类的字节码文件对象(.class)，通过字节码文件对象，就能够通过该类中的方法获取到我们想要的所有信息(方法，属性，类名，父类名，实现的所有接口等等)，每一个类对应着一个字节码文件也就对应着一个 <code>Class</code> 类型的对象，也就是字节码文件对象。</p><p>反射的各种功能都需要通过 <code>Class</code> 对象来实现，因此，需要知道如何获取 <code>Class</code>对象，主要有以下三种方式：</p><ul><li><strong><code>调用某个对象的 getClass() 方法：</code></strong>通过类的实例获取该类的字节码文件对象，该类处于<code>创建对象阶段</code>。</li><li><strong><code>直接获取某个类的 class：</code></strong>当类被加载成 <code>.class</code> 文件时，此时该类变成了 <code>.class</code>，在获取该字节码文件对象，也就是获取自己，该类处于<code>字节码阶段</code>。</li><li><strong><code>使用 Class.forName() 的静态方法：</code></strong>通过 <code>Class</code> 类中的静态方法 <code>forName()</code>，可以通过类或接口的名称(一个字符串或完全限定名)来获取对应的的字节码文件对象。此时该类还是<code>源文件阶段</code>，并没有变为字节码文件。</li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 调用某个对象的 getClass() 方法</span>        Person person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Person</span><span class="token operator">></span> clazz1 <span class="token operator">=</span> person<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 直接获取某个类的 class</span>        Class<span class="token operator">&lt;</span>Person<span class="token operator">></span> clazz2 <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 使用 Class.forName() 的静态方法</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz3 <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.custom.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>注意：在运行期间，一个类，只有一个 <code>Class</code> 对象产生。</p></blockquote><h3 id="判断是否为某个类的实例"><a href="#判断是否为某个类的实例" class="headerlink" title="判断是否为某个类的实例"></a>判断是否为某个类的实例</h3><p>一般地，可以使用 <code>instanceof</code> 关键字来判断是否为某个类的实例。同时也可以借助反射中 <code>Class</code> 对象的 <code>isInstance()</code> 方法来判断是否为某个类的实例，它是一个 <code>Native</code> 方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">boolean</span> <span class="token function">isInstance</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="基类或者接口"><a href="#基类或者接口" class="headerlink" title="基类或者接口"></a>基类或者接口</h3><p>可以通过反射，来获取一个类的基类或者实现的接口，使用 <code>getSuperclass()</code> 获取该类的基类，使用 <code>getInterfaces()</code> 获取该类实现的接口。</p><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        Class <span class="token class-name">clazz</span> <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"com.custom.Person"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class <span class="token class-name">superClazz</span> <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getSuperclass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该类的父类："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>superClazz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"该类实现的接口："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Class<span class="token punctuation">[</span><span class="token punctuation">]</span> interfaces <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Class <span class="token class-name">clz</span> <span class="token operator">:</span> interfaces<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clz<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="创建实例"><a href="#创建实例" class="headerlink" title="创建实例"></a>创建实例</h3><p>通过反射来生成对象主要有两种方式：</p><ul><li>使用 Class 对象的 newInstance() 方法</li><li>通过 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法</li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Constructor<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> InstantiationException<span class="token punctuation">,</span> IllegalAccessException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> SecurityException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用 Class 对象的 newInstance() 方法</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz1 <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Object obj1 <span class="token operator">=</span> clazz1<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Person<span class="token punctuation">)</span> obj1<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"Shelly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj1<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 通过 Class 对象获取指定的 Constructor 对象，再调用 Constructor 对象的 newInstance() 方法</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz2 <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        Constructor<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> constructor <span class="token operator">=</span> clazz2<span class="token punctuation">.</span><span class="token function">getConstructor</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object obj2 <span class="token operator">=</span> constructor<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token number">18</span><span class="token punctuation">,</span> <span class="token string">"Shirley"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：第二种方法可以用指定的构造器构造类的实例。</p></blockquote><h3 id="获取方法"><a href="#获取方法" class="headerlink" title="获取方法"></a>获取方法</h3><p>获取某个 Class 对象的方法集合，主要有以下几个方法：</p><ul><li><strong><code>Method[] getMethods()：</code></strong>返回一个包含此 Class 对象所表示的类或接口的所有公共方法所反映 Method 对象的数组，包括由类或接口声明的那些从超类和超接口继承的那些方法。</li><li><strong><code>Method[] getDeclaredMethods()：</code></strong>返回一个包含此 Class 对象所表示的类或接口的所有已声明方法所反映 Method 对象的数组，包括 public、protected、default(包)访问和 private 方法，但不包括继承的方法。</li><li><strong><code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)：</code></strong>返回一个此 Class 对象所表示的类或接口的指定公共成员方法所反映的 Method 对象。</li><li><strong><code>Method getDeclaredMethod(String name, Class&lt;?&gt;... parameterTypes)：</code></strong>返回一个此 Class 对象表示的类或接口的指定声明方法所反映的 Method 对象。</li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Modifier<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过getMethods()方法获取该类的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> methods <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method method <span class="token operator">:</span> methods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过getDeclaredMethods()方法获取该类的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method<span class="token punctuation">[</span><span class="token punctuation">]</span> declaredMethods <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Method declaredMethod <span class="token operator">:</span> declaredMethods<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>declaredMethod<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> declaredMethod<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> declaredMethod<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过getMethod()方法获取该类的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"toString"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>method<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> method<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"通过getDeclaredMethod()方法获取该类的方法："</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Method declaredMethod <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getDeclaredMethod</span><span class="token punctuation">(</span><span class="token string">"address"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Modifier<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>declaredMethod<span class="token punctuation">.</span><span class="token function">getModifiers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> declaredMethod<span class="token punctuation">.</span><span class="token function">getReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" "</span> <span class="token operator">+</span> declaredMethod<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p><strong>注</strong>：通过<code>getMethods()</code>获取的方法可以获取到父类的方法,比如<code>java.lang.Object</code>下定义的各个方法。</p></blockquote><h3 id="获取构造方法"><a href="#获取构造方法" class="headerlink" title="获取构造方法"></a>获取构造方法</h3><p>获取某个 Class 对象的构造方法，主要有以下几个方法：</p><ul><li><strong><code>Constructor&lt;?&gt;[] getConstructors()：</code></strong>返回一个包含此 Class 对象所表示的类的所有公共构造函数的所反映的 Constructor 对象的数组。</li><li><strong><code>Constructor&lt;?&gt;[] getDeclaredConstructors()：</code></strong>返回一个包含此 Class 对象表示的类声明的所有构造函数所反映的 Constructor 对象的数组。</li><li><strong><code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)：</code></strong>返回一个此 Class 对象所表示的类的指定公共构造函数所反映的 Constructor 对象。</li><li><strong><code>Constructor&lt;T&gt; getDeclaredConstructor(Class&lt;?&gt;... parameterTypes)：</code></strong>返回一个此 Class 对象表示的类或接口的指定构造函数所反映的 Constructor 对象。</li></ul><p>通过 <code>Constructor</code> 对象创建一个对象实例，主要是通过 <code>Class</code> 类的 <code>getConstructor</code> 方法得到 <code>Constructor</code> 类的一个实例，而 <code>Constructor</code> 类有一个 <code>newInstance</code> 方法可以创建一个对象实例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> T <span class="token function">newInstance</span><span class="token punctuation">(</span>Object <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> initargs<span class="token punctuation">)</span></code></pre><blockquote><p><strong>注</strong>：此方法可以根据传入的参数来调用对应的 <code>Constructor</code> 创建对象实例。</p></blockquote><h3 id="获取成员变量"><a href="#获取成员变量" class="headerlink" title="获取成员变量"></a>获取成员变量</h3><p>获取某个 Class 对象的成员变量，主要有以下几个方法：</p><ul><li><strong><code>Field[] getFields()：</code></strong>返回一个包含此 Class 对象所表示的类或接口的所有可访问公共字段所反映的 Field 对象的数组。</li><li><strong><code>Field[] getDeclaredFields()：</code></strong>返回一个包含此 Class 对象所表示的类或接口声明的所有字段所反映的 Field 对象的数组。</li><li><strong><code>Field getField(String name)：</code></strong>返回一个此 Class 对象表示的类或接口的指定公共成员字段所反映的 Field 对象。</li><li><strong><code>Field getDeclaredField(String name)：</code></strong>返回一个此 Class 对象表示的类或接口的指定声明字段所反映的 Field 对象。</li></ul><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>当我们从类中获取了一个方法后，我们就可以用 <code>invoke()</code> 方法来调用这个方法。<code>invoke()</code> 方法的原型为:</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> Object <span class="token function">invoke</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> IllegalArgumentException<span class="token punctuation">,</span> InvocationTargetException</code></pre><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>InvocationTargetException<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> IllegalAccessException<span class="token punctuation">,</span> InstantiationException<span class="token punctuation">,</span> NoSuchMethodException<span class="token punctuation">,</span> InvocationTargetException <span class="token punctuation">{</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> Person<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建 Person 的实例</span>        Object obj <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取 Person 类的 setData 方法</span>        Method method <span class="token operator">=</span> clazz<span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"setData"</span><span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 调用 method 对应的方法 => setData(16, "Shelly")</span>        Object result <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token string">"Shelly"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="利用反射创建数组"><a href="#利用反射创建数组" class="headerlink" title="利用反射创建数组"></a>利用反射创建数组</h3><p>数组在 Java 里是比较特殊的一种类型，它可以赋值给一个 <code>Object Reference</code>。下面我们看一看利用反射创建数组的例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Array<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Test</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> ClassNotFoundException <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 使用`java.lang.reflect.Array`反射创建长度为25的字符串数组.</span>        Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> clazz <span class="token operator">=</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span><span class="token string">"java.lang.String"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Object array <span class="token operator">=</span> Array<span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span>clazz<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 往数组里添加内容</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token string">"Java"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"Kotlin"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Array<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Android"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 获取某一项的内容</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其中的 <code>Array</code> 类为 <code>java.lang.reflect.Array</code> 类。我们通过 <code>Array.newInstance()</code> 创建数组对象，而 <code>newArray</code> 方法是一个 <code>native</code> 方法，它的原型是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> Object <span class="token function">newInstance</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> componentType<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token keyword">throws</span> NegativeArraySizeException <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">newArray</span><span class="token punctuation">(</span>componentType<span class="token punctuation">,</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">native</span> Object <span class="token function">newArray</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span><span class="token operator">?</span><span class="token operator">></span> componentType<span class="token punctuation">,</span> <span class="token keyword">int</span> length<span class="token punctuation">)</span> <span class="token keyword">throws</span> NegativeArraySizeException<span class="token punctuation">;</span></code></pre><h2 id="使用反射获取信息"><a href="#使用反射获取信息" class="headerlink" title="使用反射获取信息"></a>使用反射获取信息</h2><p>Class 类提供了大量的实例方法来获取该 Class 对象所对应的详细信息，Class 类大致包含如下方法，其中每个方法都包含多个重载版本，因此我们只是做简单的介绍，详细请参考<a href="https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html" target="_blank" rel="noopener">JDK 文档</a>。</p><h3 id="获取类内信息"><a href="#获取类内信息" class="headerlink" title="获取类内信息"></a>获取类内信息</h3><ul><li>构造器: <code>Constructor&lt;T&gt; getConstructor(Class&lt;?&gt;... parameterTypes)</code></li><li>包含的方法: <code>Method getMethod(String name, Class&lt;?&gt;... parameterTypes)</code></li><li>包含的属性: <code>Field getField(String name)</code></li><li>包含的Annotation: <code>&lt;A extends Annotation&gt; A getAnnotation(Class&lt;A&gt; annotationClass)</code></li><li>内部类: <code>Class&lt;?&gt;[] getDeclaredClasses()</code></li><li>外部类: <code>Class&lt;?&gt; getDeclaringClass()</code></li><li>所实现的接口: <code>Class&lt;?&gt;[] getInterfaces()</code></li><li>修饰符: <code>int getModifiers()</code></li><li>所在包: <code>Package getPackage()</code></li><li>类名: <code>String getName()</code></li><li>简称: <code>String getSimpleName()</code></li></ul><h3 id="判断类本身信息的方法"><a href="#判断类本身信息的方法" class="headerlink" title="判断类本身信息的方法"></a>判断类本身信息的方法</h3><ul><li>是否注解类型: <code>boolean isAnnotation()</code></li><li>是否使用了该Annotation修饰: <code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationClass)</code></li><li>是否匿名类: <code>boolean isAnonymousClass()</code></li><li>是否数组: <code>boolean isArray()</code></li><li>是否枚举: <code>boolean isEnum()</code></li><li>是否原始类型: <code>boolean isPrimitive()</code></li><li>是否接口: <code>boolean isInterface()</code></li><li>obj 是否是该 Class 的实例: <code>boolean isInstance(Object obj)</code></li></ul><h3 id="使用反射获取泛型信息"><a href="#使用反射获取泛型信息" class="headerlink" title="使用反射获取泛型信息"></a>使用反射获取泛型信息</h3><p>为了通过反射操作泛型以迎合实际开发的需要，Java 新增了 <code>java.lang.reflect.ParameterizedType</code>、<code>java.lang.reflect.GenericArrayType</code>、<code>java.lang.reflect.TypeVariable</code>、<code>java.lang.reflect.WildcardType</code> 几种类型来代表不能归一到 Class 类型但是又和原始类型同样重要的类型。</p><ul><li><code>ParameterizedType</code>: 一种参数化类型，比如Collection<string></string></li><li><code>GenericArrayType</code>: 一种元素类型是参数化类型或者类型变量的数组类型</li><li><code>TypeVariable</code>: 各种类型变量的公共接口</li><li><code>WildcardType</code>: 一种通配符类型表达式，如<code>?</code>、<code>? extends Number</code>、<code>? super Integer</code></li></ul><p>代码示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Object<span class="token operator">></span> objectMap<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">test</span><span class="token punctuation">(</span>Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> User<span class="token operator">></span> map<span class="token punctuation">,</span> String string<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Map<span class="token operator">&lt;</span>User<span class="token punctuation">,</span> Bean<span class="token operator">></span> <span class="token function">test</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试属性类型     *     * @throws NoSuchFieldException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testFieldType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchFieldException <span class="token punctuation">{</span>        Field field <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getDeclaredField</span><span class="token punctuation">(</span><span class="token string">"objectMap"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type gType <span class="token operator">=</span> field<span class="token punctuation">.</span><span class="token function">getGenericType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 打印type与generic type的区别</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>field<span class="token punctuation">.</span><span class="token function">getType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>gType<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"**************"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>gType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            ParameterizedType pType <span class="token operator">=</span> <span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> gType<span class="token punctuation">;</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> types <span class="token operator">=</span> pType<span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> types<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>type<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试参数类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testParamType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">,</span> Map<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">,</span> String<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type<span class="token punctuation">[</span><span class="token punctuation">]</span> parameterTypes <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericParameterTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Type type <span class="token operator">:</span> parameterTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"type -> "</span> <span class="token operator">+</span> type<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>type <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> type<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 测试返回值类型     *     * @throws NoSuchMethodException     */</span>    <span class="token annotation punctuation">@Test</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">testReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> NoSuchMethodException <span class="token punctuation">{</span>        Method testMethod <span class="token operator">=</span> Client<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"test"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Type returnType <span class="token operator">=</span> testMethod<span class="token punctuation">.</span><span class="token function">getGenericReturnType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"return type -> "</span> <span class="token operator">+</span> returnType<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>returnType <span class="token keyword">instanceof</span> <span class="token class-name">ParameterizedType</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            Type<span class="token punctuation">[</span><span class="token punctuation">]</span> actualTypes <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>ParameterizedType<span class="token punctuation">)</span> returnType<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getActualTypeArguments</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span>Type actualType <span class="token operator">:</span> actualTypes<span class="token punctuation">)</span> <span class="token punctuation">{</span>                System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"\tactual type -> "</span> <span class="token operator">+</span> actualType<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="反射的一些注意事项"><a href="#反射的一些注意事项" class="headerlink" title="反射的一些注意事项"></a>反射的一些注意事项</h2><p>由于反射会额外消耗一定的系统资源，因此如果不需要动态地创建一个对象，那么就不需要用反射。</p><p>另外，反射调用方法时可以忽略权限检查，因此可能会破坏封装性而导致安全问题。</p>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 反射 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 注解(Annotation)详解</title>
      <link href="/posts/2018/52b68731.html"/>
      <url>/posts/2018/52b68731.html</url>
      
        <content type="html"><![CDATA[<h2 id="什么叫注解"><a href="#什么叫注解" class="headerlink" title="什么叫注解"></a>什么叫注解</h2><p><strong><code>注解(Annotation)</code></strong>就是 Java 提供了一种元程序中的元素关联任何信息和着任何元数据(metadata)的途径和方法。<code>Annotation</code> 是一个接口，程序可以通过反射来获取指定程序元素的 <code>Annotation</code> 对象，然后通过 <code>Annotation</code> 对象来获取注解里面的元数据。</p><p><code>Annotation</code> 是 <code>JDK 5.0</code> 及以后版本引入的。它可以用于创建文档，跟踪代码中的依赖性，甚至执行基本编译时检查。<code>Annotation</code> 是一种应用于<code>包</code>、<code>类型</code>、<code>构造方法</code>、<code>方法</code>、<code>成员变量</code>、<code>参数</code>、<code>本地变量</code>的声明中的<code>特殊修饰符</code>。这些信息被存储在 <code>Annotation</code> 的 <code>“name=value”</code> 结构对中。</p><p>在注解出现之前，程序的元数据只是通过 java 注释和 javadoc，但是注解提供的功能要远远超过这些。注解不仅包含了元数据，它还可以作用于程序运行过程中、注解解释器可以通过注解决定程序的执行顺序。</p><p>比如，下面这段代码：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token string">"This is a string representation of the current object."</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="什么是-metadata-元数据"><a href="#什么是-metadata-元数据" class="headerlink" title="什么是 metadata 元数据"></a>什么是 metadata 元数据</h2><p>元数据从 metadata 一词译来，就是“关于数据的数据”的意思。</p><p>元数据的功能作用有很多，比如：你可能用过 Javadoc 的注释自动生成文档。这就是元数据功能的一种。总的来说，元数据可以用来创建文档，跟踪代码的依赖性，执行编译时格式检查，代替已有的配置文件。如果要对于元数据的作用进行分类，目前还没有明确的定义，不过可以根据它所起的作用，大致可分为三类： </p><ul><li><strong><code>编写文档：</code></strong>通过代码里标识的元数据生成文档。</li><li><strong><code>代码分析：</code></strong>通过代码里标识的元数据对代码进行分析。</li><li><strong><code>编译检查：</code></strong>通过代码里标识的元数据让编译器能实现基本的编译检查。</li></ul><h2 id="为什么要使用注解"><a href="#为什么要使用注解" class="headerlink" title="为什么要使用注解"></a>为什么要使用注解</h2><p>使用 Annotation 之前(甚至在使用之后)，XML 被广泛的应用于描述元数据。不知何时开始一些应用开发人员和架构师发现 XML 的维护越来越糟糕了。他们希望使用一些和代码紧耦合的东西，而不是像XML那样和代码是松耦合的(在某些情况下甚至是完全分离的)代码描述。如果你在 Google 中搜索 <code>XML vs. annotations</code>，会看到许多关于这个问题的辩论。最有趣的是 XML 配置其实就是为了分离代码和配置而引入的。上述两种观点可能会让你很疑惑，两者观点似乎构成了一种循环，但各有利弊。下面我们通过一个例子来理解这两者的区别。</p><p>假如你想为应用设置很多的常量或参数，这种情况下，XML 是一个很好的选择，因为它不会同特定的代码相连。如果你想把某个方法声明为服务，那么使用 Annotation 会更好一些，因为这种情况下需要注解和方法紧密耦合起来，开发人员也必须认识到这点。</p><p>另一个很重要的因素是 Annotation 定义了一种标准的描述元数据的方式。在这之前，开发人员通常使用他们自己的方式定义元数据。例如，使用标记 <code>interfaces</code>，注释，<code>transient</code> 关键字等等。每个程序员按照自己的方式定义元数据，而不像 Annotation 这种标准的方式。</p><p>目前，许多框架将 <code>XML</code> 和 <code>Annotation</code> 两种方式结合使用，平衡两者之间的利弊。</p><h2 id="Annotation-和-Annotation-类型"><a href="#Annotation-和-Annotation-类型" class="headerlink" title="Annotation 和 Annotation 类型"></a>Annotation 和 Annotation 类型</h2><p>Annotation 使用了在 Java5 所带来的新语法，它的行为十分类似 <code>public</code>、<code>final</code> 这样的修饰符。每个 <code>Annotation</code> 具有一个名字和零个或多个成员。每个 <code>Annotation</code> 的成员具有被称为 <code>name=value</code> 对的名字和值（就像 JavaBean 一样），<code>name=value</code> 装载了 <code>Annotation</code> 的信息。</p><p>Annotation 类型定义了 Annotation 的<code>名字</code>、<code>类型</code>、<code>成员默认值</code>。一个 Annotation 类型可以说是一个特殊的 Java 接口，它的成员变量是受限制的，而声明 Annotation 类型时需要使用新语法。当我们通过 Java <strong><code>反射</code></strong> API 访问 Annotation 时，返回值将是一个实现了该 <code>Annotation</code> 类型接口的对象，通过访问这个对象能方便的访问到其 <code>Annotation</code> 成员。</p><h2 id="注解的分类"><a href="#注解的分类" class="headerlink" title="注解的分类"></a>注解的分类</h2><h3 id="按照运行机制划分"><a href="#按照运行机制划分" class="headerlink" title="按照运行机制划分"></a>按照运行机制划分</h3><p>按照注解的参数个数划分，注解可以分为以下三种：</p><ul><li><strong><code>标记注解：</code></strong>没有变量，只有名称标识。这种类型仅仅使用自身的存在与否来为开发者提供信息，如 @annotation</li><li><strong><code>单值注解：</code></strong>在标记注解的基础上提供一段数据。如 @annotation(“data”)</li><li><strong><code>完整注解：</code></strong>可以包括多个数据成员，每个数据成员由名称和值构成。如 @annotation(value1 = “data1”, value2 = “data2”)</li></ul><p>按照运行机制划分，注解可以分为以下三种：</p><ul><li><strong><code>源码注解：</code></strong>只在源码中存在，编译成 class 文件就不存在了。</li><li><strong><code>编译时注解：</code></strong>在源码和 class 文件中都存在。例如 @Override、@Deprecated、@SuppressWarnings，他们都属于编译时注解。</li><li><strong><code>运行时注解：</code></strong>在运行阶段还起作用，甚至会影响运行逻辑的注解。像 @Autowired 自动注入的这样一种注解就属于运行时注解，它会在程序运行的时候把你的成员变量自动的注入进来。</li></ul><h3 id="按照来源划分"><a href="#按照来源划分" class="headerlink" title="按照来源划分"></a>按照来源划分</h3><p>按照使用方法和用途划分，注解可以分为以下三种：</p><ul><li><strong><code>JDK 内置注解：</code></strong>Java 目前只内置了五种标准注解和五种元注解。</li><li><strong><code>第三方的注解：</code></strong>这一类注解是我们接触最多和作用最大的一类。</li><li><strong><code>自定义注解：</code></strong>可以看作是开发者自己编写的注解。</li></ul><h3 id="元注解"><a href="#元注解" class="headerlink" title="元注解"></a>元注解</h3><p><strong><code>元注解</code></strong>是给注解进行注解，可以理解为注解的注解就是元注解。</p><h2 id="JDK-内置注解"><a href="#JDK-内置注解" class="headerlink" title="JDK 内置注解"></a>JDK 内置注解</h2><p>在 <code>java.lang</code> 包下，JDK 提供了 <code>5</code> 个基本注解：<code>@Override</code>、<code>@Deprecated</code>、<code>@SuppressWarnings</code>、<code>@SafeVarargs</code>、<code>@FunctionalInterface</code>。</p><h3 id="Override"><a href="#Override" class="headerlink" title="@Override"></a>@Override</h3><p><strong><code>@Override</code></strong> 用于标注重写了父类的方法。</p><p>当我们想要复写父类中的方法时，我们需要使用该注解去告知编译器我们想要复写这个方法，这样一来当父类中的方法移除或者发生更改时编译器将提示错误信息。对于子类中被 <code>@Override</code> 修饰的方法，如果存在对应的被重写的父类方法，则正确；如果不存在，则报错。<code>@Override</code> 只能作用于方法，不能作用于其他程序元素。</p><h3 id="Deprecated"><a href="#Deprecated" class="headerlink" title="@Deprecated"></a>@Deprecated</h3><p><strong><code>@Deprecated</code></strong> 用于表示某个程序元素（类、方法等）已过时。</p><p>当我们希望编译器知道某一方法不建议使用时，我们应该使用这个注解。Java 在 javadoc 中推荐使用该注解，我们应该提供为什么该方法不推荐使用以及替代的方法。如果使用了被 <code>@Deprecated</code> 修饰的类或方法等，编译器会发出警告。</p><h3 id="SuppressWarnings"><a href="#SuppressWarnings" class="headerlink" title="@SuppressWarnings"></a>@SuppressWarnings</h3><p><strong><code>@SuppressWarnings</code></strong> 用于抑制编译器的警告。</p><p>这个仅仅是告诉编译器忽略特定的警告信息，例如在泛型中使用原生数据类型。指示被 <code>@SuppressWarnings</code> 修饰的程序元素（以及该程序元素中的所有子元素，例如类以及该类中的方法）取消显示指定的编译器警告。例如，常见的 <code>@SuppressWarnings(&quot;unchecked&quot;)</code>。</p><p><strong><code>@SuppressWarnings</code></strong> 注解的常见参数值主要有以下几种：</p><ul><li><code>deprecation：</code>使用了不赞成使用的类或方法时的警告(使用 <code>@Deprecated</code> 使得编译器产生的警告)；</li><li><code>unchecked：</code>执行了未检查的转换时的警告，例如当使用集合时没有用泛型 (Generics) 来指定集合保存的类型; 关闭编译器警告</li><li><code>fallthrough：</code>当 switch 程序块直接通往下一种情况而没有 break 语句时的警告;</li><li><code>path：</code>在类路径、源文件路径等中有不存在的路径时的警告;</li><li><code>serial：</code>当在可序列化的类上缺少 serialVersionUID 定义时的警告;</li><li><code>finally：</code>任何 finally 子句不能正常完成时的警告;</li><li><code>all：</code>关于以上所有情况的警告。</li></ul><h3 id="SafeVarargs"><a href="#SafeVarargs" class="headerlink" title="@SafeVarargs"></a>@SafeVarargs</h3><p><strong><code>@SafeVarargs</code></strong> 是 JDK 7 专门为抑制<code>堆污染</code>警告提供的。</p><h3 id="FunctionalInterface-Java8新增"><a href="#FunctionalInterface-Java8新增" class="headerlink" title="@FunctionalInterface (Java8新增)"></a>@FunctionalInterface (Java8新增)</h3><p><strong><code>@FunctionalInterface</code></strong> 是 Java8 中新增的函数式接口。Java8 规定：如果接口中只有一个抽象方法(可以包含多个 <code>default</code> 方法或多个 <code>static</code> 方法)，该接口称为函数式接口。</p><blockquote><p><strong>注意：</strong></p><ol><li><strong><code>value 特权：</code></strong>如果使用注解时只需要为 <code>value</code> 成员变量指定值，则使用注解时可以直接在该注解的括号中指定 <code>value</code> 值，而无需使用 <code>name=value</code> 的形式(如<code>@SuppressWarnings(&quot;unchecked&quot;)</code>)。</li><li><strong><code>坚持使用 @Override 注解：</code></strong>如果在每个方法中使用 <code>@Override</code> 注解来声明要覆盖父类声明，编译器就可以替你防止大量的错误。</li></ol></blockquote><h2 id="JDK-元注解"><a href="#JDK-元注解" class="headerlink" title="JDK 元注解"></a>JDK 元注解</h2><p>元注解(meta-annotation)是指注解的注解。元注解是 Java 定义的用于创建注解的工具，它们本身也是注解。在 <code>java.lang.annotation</code> 包下，JDK 提供了 <code>5</code> 个标准的元注解类型：<code>@Retention</code>、<code>@Target</code>、<code>@Inherited</code>、<code>@Documented</code>、<code>@Repeatable</code>。</p><h3 id="Retention"><a href="#Retention" class="headerlink" title="@Retention"></a>@Retention</h3><p><strong><code>@Retention：</code></strong>注解的保留策略。该注解指明了被它所注解的注解被保留的时间长短。</p><p><strong><code>@Retention</code></strong> 包含一个名为 <code>value</code> 的成员变量，该 <code>value</code> 成员变量是 <code>RetentionPolicy</code>，<code>RetentionPolicy</code> 是枚举类型，值有如下几个：</p><ul><li><strong><code>RetentionPolicy.SOURCE：</code></strong>注解只在源码阶段保留，在编译器进行编译时它将被丢弃忽视，不记录在 class 文件中。</li><li><strong><code>RetentionPolicy.CLASS：</code></strong>注解只被保留到编译进行的时候，它并不会被加载到 JVM 中。这是默认行为，所有没有用 @Retention 注解的注解，都会采用这种策略。</li><li><strong><code>RetentionPolicy.RUNTIME：</code></strong>注解可以保留到程序运行的时候，它会被加载进入到 JVM 中，程序可以通过反射获取该注解的信息。</li></ul><h3 id="Target"><a href="#Target" class="headerlink" title="@Target"></a>@Target</h3><p><strong><code>@Target：</code></strong>注解的作用目标。该注解指定注解用于修饰哪些程序元素。</p><p><strong><code>@Target</code></strong> 也包含一个名为 <code>value</code> 的成员变量，该 <code>value</code> 成员变量类型为 <code>ElementType[]</code>，<code>ElementType</code> 也为枚举类型，值有如下几个：</p><ul><li><strong><code>ElementType.TYPE：</code></strong> 修饰类型，比如接口、类、枚举、注解</li><li><strong><code>ElementType.FIELD：</code></strong> 修饰属性，比如成员变量、枚举常量</li><li><strong><code>ElementType.METHOD：</code></strong> 修饰方法</li><li><strong><code>ElementType.PARAMETER：</code></strong>修饰方法内的参数</li><li><strong><code>ElementType.CONSTRUCTOR：</code></strong>修饰构造方法</li><li><strong><code>ElementType.LOCAL_VARIABLE：</code></strong>修饰局部变量</li><li><strong><code>ElementType.ANNOTATION_TYPE：</code></strong>修饰注解</li><li><strong><code>ElementType.PACKAGE：</code></strong>修饰包</li><li><strong><code>ElementType.TYPE_PARAMETER：</code></strong>修饰类型参数(Java8 新增)</li><li><strong><code>ElementType.TYPE_USE：</code></strong>修饰任何类型(Java8 新增)</li></ul><h3 id="Inherited"><a href="#Inherited" class="headerlink" title="@Inherited"></a>@Inherited</h3><p><strong><code>@Inherited：</code></strong>指定注解具有继承性。但是它并不是说注解本身可以继承，而是说如果一个超类被 @Inherited 注解过的注解进行注解的话，那么如果它的子类没有被任何注解应用的话，那么这个子类就继承了超类的注解。</p><h3 id="Documented"><a href="#Documented" class="headerlink" title="@Documented"></a>@Documented</h3><p><strong><code>@Documented：</code></strong>注解将被包含在 Javadoc 中。该注解的作用是在用 Javadoc 命令生成 API 文档时能够将注解中的元素包含到 Javadoc 中去。</p><h3 id="Repeatable-Java8新增"><a href="#Repeatable-Java8新增" class="headerlink" title="@Repeatable (Java8新增)"></a>@Repeatable (Java8新增)</h3><p><strong><code>@Repeatable：</code></strong> 表示可重复注解。<code>@Repeatable</code> 是 Java 8 才加进来的，所以算是一个新的特性。</p><p>在实际应用中，可能会出现需要对同一个声明式或者类型加上相同的注解（包含不同的属性值）的情况。例如系统中除了管理员之外，还添加了超级管理员这一权限，对于某些只能由这两种角色调用的特定方法，可以使用可重复注解。</p><h2 id="自定义注解"><a href="#自定义注解" class="headerlink" title="自定义注解"></a>自定义注解</h2><p>使用 <strong><code>@interface</code></strong> 自定义注解时，自动继承了 <strong><code>java.lang.annotation.Annotation</code></strong> 接口，由编译程序自动完成其他细节。在定义注解时，不能继承其他的注解或接口。 <code>@interface</code> 用来声明一个注解，其中的每一个方法实际上是声明了一个配置参数。方法的名称就是参数的名称，返回值类型就是参数的类型(返回值类型只能是<code>基本类型</code>、<code>Class</code>、<code>String</code>、<code>Enum</code>)。可以通过 <code>default</code> 来声明参数的默认值。</p><p>定义注解格式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> @<span class="token keyword">interface</span> 注解名 <span class="token punctuation">{</span>    定义体<span class="token punctuation">}</span></code></pre><p>自定义注解就需要用到上面所介绍到的几种元注解，可以看出元注解就是用来注解其它注解。自定义注解和接口类似，只能定义方法。注解参数的可支持数据类型：</p><ul><li>所有基本数据类型(int、float、boolean、byte、double、char、long、short)</li><li>String 类型</li><li>Class 类型</li><li>Enum 类型</li><li>Annotation 类型</li><li>以上所有类型的数组</li></ul><p>定义新注解使用 <strong><code>@interface</code></strong> 关键字，其定义过程与定义接口非常类似，需要注意的是：Annotation 的成员变量在 Annotation 定义中是以无参的方法形式来声明的，其方法名和返回值类型定义了该成员变量的名字和类型，而且还可以使用 <code>default</code> 关键字为这个成员变量设定默认值。</p><p>自定义注解的示例如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> annotation<span class="token punctuation">.</span>custom<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Inherited<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token annotation punctuation">@Inherited</span><span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span><span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>METHOD<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Tag</span> <span class="token punctuation">{</span>    String <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">"undefined"</span><span class="token punctuation">;</span>    String <span class="token function">description</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Java 使用 Annotation 接口来代表程序元素前面的注解，该接口是所有 Annotation 类型的父接口。自定义的注解继承了 <code>Annotation</code> 这个接口，因此自定义注解中包含了 <code>Annotation</code> 接口中所有的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Annotation</span> <span class="token punctuation">{</span>    <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span>Object obj<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    Class<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Annotation</span><span class="token operator">></span> <span class="token function">annotationType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="注解的提取"><a href="#注解的提取" class="headerlink" title="注解的提取"></a>注解的提取</h2><p>Java 在 <code>java.lang.reflect</code> 包下新增了 <code>AnnotatedElement</code> 接口，该接口代表程序中可以接受注解的程序元素，该接口主要有如下几个实现类：</p><ul><li><code>AccessibleObject：</code>是 Field、Method 和 Constructor 对象的基类。它提供了将反射的对象标记为在使用时取消默认 Java 语言访问控制检查的能力。<ul><li><code>Executable：</code>是 Method 和 Constructor 对象的基类，提供了 Method 和 Constructor 的常用功能。<ul><li><code>Method：</code>提供关于类或接口上单独某个方法（以及如何访问该方法）的信息。所反映的方法可能是类方法或实例方法（包括抽象方法）。</li><li><code>Constructor：</code>提供关于类的单个构造方法的信息以及对它的访问权限。</li></ul></li><li><code>Field：</code>提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。</li></ul></li><li><code>Class：</code>表示正在运行的 Java 应用程序中的类和接口。枚举是一种类，注释是一种接口。每个数组属于被映射为 Class 对象的一个类，所有具有相同元素类型和维数的数组都共享该 Class 对象。基本的 Java 类型(boolean、byte、char、short、int、long、float 和 double)和关键字 void 也表示为 Class 对象。</li><li><code>Package：</code>包含有关 Java 包的实现和规范的版本信息。通过用于加载类的 ClassLoader 实例，可以获取并获得此版本信息。通常，此信息存储在与类一起分发的清单中。</li><li><code>Parameter：</code>提供有关方法参数的信息，包括其名称和修饰符(Java8 新增)。</li></ul><p><code>java.lang.reflect</code> 包下主要包含一些实现反射功能的工具类，实际上，<code>java.lang.reflect</code> 包所有提供的反射 API 扩充了读取运行时 Annotation 信息的能力。当一个 Annotation 类型被定义为运行时的 Annotation 后，该注解才能是运行时可见，当 class 文件被装载时被保存在 class 文件中的 Annotation 才会被虚拟机读取。</p><p>AnnotatedElement 接口是所有程序元素(Class、Method、Constructor、Field、Parameter、Package)的父接口，所以程序通过反射获取了某个类的 <code>AnnotatedElement</code> 对象之后，程序就可以调用该对象的如下方法来访问 <code>Annotation</code> 信息：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean isAnnotationPresent(Class&lt;? extends Annotation&gt; annotationType)</code></td><td>判断指定对象是否应用了某个注解，此方法主要用于方便地访问标记注释</td></tr><tr><td><code>Annotation[] getAnnotations()</code></td><td>返回作用于指定对象的所有注解，不存在则返回长度为 0 的数组</td></tr><tr><td><code>Annotation[] getDeclaredAnnotations()</code></td><td>返回直接作用于指定对象的所有注解，不存在则返回长度为 0 的数组(此方法忽略继承的注解)</td></tr><tr><td><code>&lt;T extends Annotation&gt; T getAnnotation(Class&lt;T&gt; annotationClass)</code></td><td>返回指定类型的注解，不存在则返回 null</td></tr><tr><td><code>&lt;T extends Annotation&gt; T getDeclaredAnnotation(Class&lt;T&gt; annotationClass)</code></td><td>返回直接作用于指定对象的指定类型的注解，不存在则返回 null(此方法忽略继承的注解)</td></tr><tr><td><code>&lt;T extends Annotation&gt; T[] getAnnotationsByType(Class&lt;T&gt; annotationClass)</code></td><td>返回指定类型的注解，不存在则返回长度为 0 的数组，此方法检测其参数是否为可重复的注解类型</td></tr><tr><td><code>&lt;T extends Annotation&gt; T[] getDeclaredAnnotationsByType(Class&lt;T&gt; annotationClass)</code></td><td>返回直接作用于指定对象的指定类型的注解，不存在则返回长度为 0 的数组，此方法检测其参数是否为可重复的注解类型(此方法忽略继承的注解)</td></tr></tbody></table><blockquote><p>只有当定义 Annotation 时使用了 @Retention(RetentionPolicy.RUNTIME) 修饰，JVM 才会在装载 class 文件时提取保存在 class 文件中的 Annotation，该 Annotation 才会在运行时可见。否则 class 文件的注解信息在执行过程中将不可用，从而也就不能从中得到任何和注解有关的数据。</p></blockquote><h2 id="注解处理器"><a href="#注解处理器" class="headerlink" title="注解处理器"></a>注解处理器</h2><p>注解处理器是(Annotation Processor)是 javac 内置的一个用于在编译时扫描、编译和处理注解(Annotation)的工具。简单的说，在源代码编译阶段，通过注解处理器，我们可以获取源文件内注解(Annotation)相关内容。</p><p>在 Java 5 首次引入注解的时候，注解处理器的 API 还没有成熟，也没有标准化。处理注解需要一个名为 <code>apt(Annotation Processor Tool，注解处理器工具)</code>的独立的工具，以及包含在 <code>com.sum.mirror</code> 包中的 Mirror API。<code>apt</code> 需要使用 Mirror API 来自定义处理器。</p><p>从 Java 6 开始，注解处理器通过 JSR 269 已经标准化并被纳入到标准库中，APT 工具也被无缝集成到 Java 编译工具 javac 里面。Java 6 提供了一个已经实现通用功能的抽象类 <code>javax.annotation.processing.AbstractProcessor</code>，同时还提供了 <code>javax.lang.model</code>包。</p><h3 id="注解处理器的用途"><a href="#注解处理器的用途" class="headerlink" title="注解处理器的用途"></a>注解处理器的用途</h3><p>由于注解处理器可以在程序编译阶段工作，所以开发者可以在编译期间通过注解处理器进行开发者需要的操作。比较常用的用法就是在编译期间获取相关注解数据，然后动态生成 <code>.java</code> 源文件(让机器帮开发者写代码)，通常是自动产生一些有规律性的重复代码，解决了手工编写重复代码的问题，大大提升编码效率。</p><h3 id="注解处理器的介绍"><a href="#注解处理器的介绍" class="headerlink" title="注解处理器的介绍"></a>注解处理器的介绍</h3><p><code>AbstractProcessor</code> 是一个抽象类，该类实现了 <code>Processor</code> 接口。抽象类 <code>AbstractProcessor</code> 以及接口 <code>Processor</code> 都是位于包 <a href="http://tool.oschina.net/apidocs/apidoc?api=jdk-zh" target="_blank" rel="noopener"><code>javax.annotation.processing</code></a> 中。该包中定义的所有类、接口都是与实现注解处理器相关的。如下表所示： </p><table><thead><tr><th>类/接口</th><th>描述</th></tr></thead><tbody><tr><td><code>Completion</code></td><td>某一注释的建议 completion</td></tr><tr><td><code>Filer</code></td><td>此接口支持通过注释处理器创建新文件</td></tr><tr><td><code>Messager</code></td><td>Messager 提供注释处理器用来报告错误消息、警告和其他通知的方式</td></tr><tr><td><code>ProcessingEnvironment</code></td><td>注释处理工具框架将提供一个具有实现此接口的对象的注释 processor，因此 processor 可以使用该框架提供的设施来编写新文件、报告错误消息并查找其他实用工具</td></tr><tr><td><code>Processor</code></td><td>注释 Processor 的接口</td></tr><tr><td><code>RoundEnvironment</code></td><td>注释处理工具框架将提供一个注释处理器和一个实现此接口的对象，这样处理器可以查询有关注释处理的 round 的信息</td></tr><tr><td><code>AbstractProcessor</code></td><td>旨在用作最具体注释 processor 的便捷超类的抽象注释 processor</td></tr><tr><td><code>Completions</code></td><td>用来组合 Completion 对象的实用工具类</td></tr><tr><td><code>FilerException</code></td><td>指示一个检测到试图打开某一文件的 Filer，该文件违反 Filer 提供的保证</td></tr><tr><td><code>SupportedAnnotationTypes</code></td><td>用来指示注释处理器支持哪些注释类型的注释</td></tr></tbody></table><h3 id="自定义注解处理器"><a href="#自定义注解处理器" class="headerlink" title="自定义注解处理器"></a>自定义注解处理器</h3><p>实现一个自定义注解处理器需要有两个步骤，第一是实现 <code>Processor</code> 接口处理注解，第二是注册注解处理器。</p><h4 id="实现-Processor-接口"><a href="#实现-Processor-接口" class="headerlink" title="实现 Processor 接口"></a>实现 Processor 接口</h4><p>通过实现 <code>Processor</code> 接口可以自定义注解处理器，可以采用更简单的方法通过继承 <code>AbstractProcessor</code> 类实现自定义注解处理器，并实现抽象方法 <code>process</code> 处理想要的功能。</p><p><code>AbstractProcessor</code> 具有如下方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void init(ProcessingEnvironment processingEnv)</code></td><td>用处理环境初始化 processor，方法是将 processingEnv 字段设置为 processingEnv 参数的值</td></tr><tr><td><code>boolean isInitialized()</code></td><td>如果此对象已被初始化，则返回 true，否则返回 false</td></tr><tr><td><code>Iterable&lt;? extends Completion&gt; getCompletions(Element element, AnnotationMirror annotation, ExecutableElement member, String userText)</code></td><td>返回一个空的 completion 迭代</td></tr><tr><td><code>Set&lt;String&gt; getSupportedAnnotationTypes()</code></td><td>如果 processor 类是使用 SupportedAnnotationTypes 注释的，则返回一个不可修改的集合，该集合具有与注释相同的字符串集</td></tr><tr><td><code>Set&lt;String&gt; getSupportedOptions()</code></td><td>如果 processor 类是使用 SupportedOptions 注释的，则返回一个不可修改的集合，该集合具有与注释相同的字符串集</td></tr><tr><td><code>SourceVersion getSupportedSourceVersion()</code></td><td>如果 processor 类是使用 SupportedSourceVersion 注释的，则返回注释中的源版本</td></tr><tr><td><code>boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv)</code></td><td>处理先前 round 产生的类型元素上的注释类型集，并返回这些注释是否由此 Processor 声明</td></tr></tbody></table><blockquote><p><strong>注意：</strong>在 Java 6 及以上版本中，<code>getSupportedAnnotationTypes()</code> 方法和 <code>getSupportedSourceVersion()</code> 方法分别可以通过 <code>@SupportedAnnotationTypes</code> 注解和 <code>@SupportedSourceVersion</code> 注解来替换。</p></blockquote><p>自定义注解处理器都需要继承于 <code>AbstractProcessor</code>，如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 自定义注解处理器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CustomProcessor</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractProcessor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Filer mFiler<span class="token punctuation">;</span>    <span class="token keyword">private</span> Messager mMessager<span class="token punctuation">;</span>    <span class="token keyword">private</span> Elements mElementUtils<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">init</span><span class="token punctuation">(</span>ProcessingEnvironment processingEnvironment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">init</span><span class="token punctuation">(</span>processingEnvironment<span class="token punctuation">)</span><span class="token punctuation">;</span>        mFiler <span class="token operator">=</span> processingEnvironment<span class="token punctuation">.</span><span class="token function">getFiler</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mMessager <span class="token operator">=</span> processingEnvironment<span class="token punctuation">.</span><span class="token function">getMessager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mElementUtils <span class="token operator">=</span> processingEnvironment<span class="token punctuation">.</span><span class="token function">getElementUtils</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> <span class="token function">getSupportedAnnotationTypes</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span>String<span class="token operator">></span> annotataions <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LinkedHashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        annotataions<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>Tag<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getCanonicalName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> annotataions<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> SourceVersion <span class="token function">getSupportedSourceVersion</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SourceVersion<span class="token punctuation">.</span><span class="token function">latestSupported</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">process</span><span class="token punctuation">(</span>Set<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">TypeElement</span><span class="token operator">></span> annotations<span class="token punctuation">,</span> RoundEnvironment roundEnvironment<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Set<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Element</span><span class="token operator">></span> tagElements <span class="token operator">=</span> roundEnvironment<span class="token punctuation">.</span><span class="token function">getElementsAnnotatedWith</span><span class="token punctuation">(</span>Tag<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Element element <span class="token operator">:</span> tagElements<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 1.获取包名</span>            PackageElement packageElement <span class="token operator">=</span> mElementUtils<span class="token punctuation">.</span><span class="token function">getPackageOf</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>            String pkName <span class="token operator">=</span> packageElement<span class="token punctuation">.</span><span class="token function">getQualifiedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printMessage</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"package = %s"</span><span class="token punctuation">,</span> pkName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 2.获取包装类类型</span>            TypeElement enclosingElement <span class="token operator">=</span> <span class="token punctuation">(</span>TypeElement<span class="token punctuation">)</span> element<span class="token punctuation">.</span><span class="token function">getEnclosingElement</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String enclosingName <span class="token operator">=</span> enclosingElement<span class="token punctuation">.</span><span class="token function">getQualifiedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printMessage</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"enclosindClass = %s"</span><span class="token punctuation">,</span> enclosingName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 3.获取注解的成员变量名</span>            String tagFiledName <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">getSimpleName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 4.获取注解的成员变量类型</span>            String tagFiledClassType <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">asType</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 5.获取注解元数据</span>            Tag tag <span class="token operator">=</span> element<span class="token punctuation">.</span><span class="token function">getAnnotation</span><span class="token punctuation">(</span>Tag<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            String name <span class="token operator">=</span> tag<span class="token punctuation">.</span><span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token function">printMessage</span><span class="token punctuation">(</span>String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s %s = %s"</span><span class="token punctuation">,</span> tagFiledClassType<span class="token punctuation">,</span> tagFiledName<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 6.生成文件</span>            <span class="token function">createFile</span><span class="token punctuation">(</span>enclosingElement<span class="token punctuation">,</span> tagFiledClassType<span class="token punctuation">,</span> tagFiledName<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">createFile</span><span class="token punctuation">(</span>TypeElement enclosingElement<span class="token punctuation">,</span> String tagFiledClassType<span class="token punctuation">,</span> String tagFiledName<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        String pkName <span class="token operator">=</span> mElementUtils<span class="token punctuation">.</span><span class="token function">getPackageOf</span><span class="token punctuation">(</span>enclosingElement<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getQualifiedName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            JavaFileObject javaFileObject <span class="token operator">=</span> mFiler<span class="token punctuation">.</span><span class="token function">createSourceFile</span><span class="token punctuation">(</span>pkName <span class="token operator">+</span> <span class="token string">".Tag"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            Writer writer <span class="token operator">=</span> javaFileObject<span class="token punctuation">.</span><span class="token function">openWriter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            writer<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span><span class="token function">generateCode</span><span class="token punctuation">(</span>pkName<span class="token punctuation">,</span> tagFiledClassType<span class="token punctuation">,</span> tagFiledName<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            writer<span class="token punctuation">.</span><span class="token function">flush</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            writer<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">printMessage</span><span class="token punctuation">(</span>String msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>        mMessager<span class="token punctuation">.</span><span class="token function">printMessage</span><span class="token punctuation">(</span>Diagnostic<span class="token punctuation">.</span>Kind<span class="token punctuation">.</span>NOTE<span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">generateCode</span><span class="token punctuation">(</span>String pkName<span class="token punctuation">,</span> String tagFiledClassType<span class="token punctuation">,</span> String tagFiledName<span class="token punctuation">,</span> String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        StringBuilder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"package "</span> <span class="token operator">+</span> pkName <span class="token operator">+</span> <span class="token string">";\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"//Auto generated by apt,do not modify!!\n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"public class Tag { \n\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"public static void main(String[] args){ \n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String info <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"%s %s = %s"</span><span class="token punctuation">,</span> tagFiledClassType<span class="token punctuation">,</span> tagFiledName<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"System.out.println(\""</span> <span class="token operator">+</span> info <span class="token operator">+</span> <span class="token string">"\");\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"}\n"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">append</span><span class="token punctuation">(</span><span class="token string">"}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 <code>init()</code> 中可以获得如下引用：</p><ul><li><strong><code>Elements：</code></strong>一个用来处理 <code>Element</code> 的工具类。</li><li><strong><code>Types：</code></strong>一个用来处理 <code>TypeMirror</code> 的工具类。</li><li><strong><code>Filer：</code></strong>正如这个名字所示，使用 <code>Filer</code> 可以创建文件。</li></ul><p>在注解处理过程中，扫描所有的 Java 源文件。源代码的每一个部分都是一个特定类型的 <code>Element</code>。换句话说：<code>Element</code> 代表程序的元素，例如包、类或者方法。每个 <code>Element</code> 代表一个静态的、语言级别的构件。</p><p><code>Element</code> 代表的是源代码，它的子类有这些：</p><ul><li>PackageElement：表示一个包程序元素。提供对有关包及其成员的信息的访问。</li><li>TypeElement：表示一个类或接口程序元素。提供对有关类型及其成员的信息的访问。注意，枚举类型是一种类，而注解类型是一种接口。</li><li>VariableElement：表示一个成员变量、枚举常量、方法或构造方法参数、局部变量或异常参数。</li><li>ExecutableElement：表示某个类或接口的方法、构造方法或初始化程序（静态或实例），包括注释类型元素。</li><li>TypeParameterElement：表示一般类、接口、方法或构造方法元素的形式类型参数。类型参数声明一个 TypeVariable。</li></ul><h4 id="注册注解处理器"><a href="#注册注解处理器" class="headerlink" title="注册注解处理器"></a>注册注解处理器</h4><p>注册注解处理器有两种方法：</p><ul><li>在当前项目中的 <code>resources/META-INF/services</code> 目录需要新建一个特殊的文件 <code>javax.annotation.processing.Processor</code>，文件里的内容就是声明你的处理器。 <code>javax.annotation.processing.Processor</code> 文件的内容是合法全称，多个处理器之间换行。</li><li>Google 提供了一个注册处理器的库，添加 <a href="https://github.com/google/auto/tree/master/service" target="_blank" rel="noopener"><code>com.google.auto.service:auto-service</code></a> 依赖并在自定义注解处理器上添加 <code>@AutoService(Processor.class)</code>， <code>AutoService</code> 注解会自动在 <code>META-INF</code> 文件夹下生成 <code>javax.annotation.processing.Processor</code> 配置信息文件，该文件里就是实现该服务接口的具体实现类。</li></ul><h2 id="注解的使用场景"><a href="#注解的使用场景" class="headerlink" title="注解的使用场景"></a>注解的使用场景</h2><p>注解是一系列元数据，它提供数据用来解释程序代码，但是注解并非是所解释的代码本身的一部分。注解对于代码的运行效果没有直接影响。</p><p>注解有许多使用场景：</p><ul><li>类属性自动赋值。</li><li>验证对象属性完整性。</li><li>代替配置文件功能，像 Spring 基于注解的配置。</li><li>可以生成文档，像 Java 代码注释中的 @see、@param 等</li></ul><p>注解有许多用处，主要如下：</p><ul><li>提供信息给编译器： 编译器可以利用注解来探测错误和警告信息</li><li>编译阶段时的处理： 软件工具可以用来利用注解信息来生成代码、Html 文档或者做其它相应处理。</li><li>运行时的处理： 某些注解可以在程序运行的时候接受代码的提取</li></ul><blockquote><p>使用 Annotation 修饰了类、方法、成员变量等之后，这些 Annotation 不会自己生效，必须由开发者提供相应的代码来提取并处理 Annotation 信息。这些处理提取和处理 Annotation 的代码统称为 APT(Annotation Processing Tool)。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 注解 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java IO 知识整理</title>
      <link href="/posts/2018/5feeeebf.html"/>
      <url>/posts/2018/5feeeebf.html</url>
      
        <content type="html"><![CDATA[<p>Java IO 是一套 Java 用来读写数据（输入和输出）的 API。大部分程序都要处理一些输入，并由输入产生一些输出。Java 为此提供了 <code>java.io</code> 包。<code>java.io</code> 包几乎包含了所有操作输入、输出需要的类。所有这些流类代表了输入源和输出目标。<code>java.io</code> 包中的流支持很多种格式，比如：基本类型、对象、文件、网络数据流、内存缓冲等等。</p><p>一个流可以理解为一个数据的序列。输入流表示从一个源读取数据，输出流表示向一个目标写数据。Java 为 I/O 提供了强大的而灵活的支持，使其更广泛地应用到文件传输和网络编程中。</p><h2 id="Java-IO-的用途"><a href="#Java-IO-的用途" class="headerlink" title="Java IO 的用途"></a>Java IO 的用途</h2><p>Java IO 中包含了许多 <code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code>、<code>Writer</code>的子类。这样设计的原因是让每一个类都负责不同的功能。这也就是为什么 IO 包中有这么多不同的类的缘故。各类用途汇总如下：</p><ul><li>文件访问</li><li>网络访问</li><li>内存缓存访问</li><li>线程内部通信(管道)</li><li>缓冲</li><li>过滤</li><li>解析</li><li>读写文本(Readers / Writers)</li><li>读写基本类型数据(long, int etc.)</li><li>读写对象</li></ul><blockquote><p>当通读过 Java IO 类的源代码之后，我们很容易就能了解这些用途。这些用途或多或少让我们更加容易地理解，不同的类用于针对不同业务场景。</p></blockquote><h2 id="Java-IO-关系图"><a href="#Java-IO-关系图" class="headerlink" title="Java IO 关系图"></a>Java IO 关系图</h2><p>Java InputStream UML 类关系图如下：<br><img src="https://henleylee.github.io/medias/java/io_inputstream_uml.png" alt="Java InputStream UML"></p><p>Java OutputStream UML 类关系图如下：<br><img src="https://henleylee.github.io/medias/java/io_outputstream_uml.png" alt="Java OutputStream UML"></p><p>Java Reader UML 类关系图如下：<br><img src="https://henleylee.github.io/medias/java/io_reader_uml.png" alt="Java Reader UML"></p><p>Java Writer UML 类关系图如下：<br><img src="https://henleylee.github.io/medias/java/io_writer_uml.png" alt="Java Writer UML"></p><h2 id="Java-IO-类的关系"><a href="#Java-IO-类的关系" class="headerlink" title="Java IO 类的关系"></a>Java IO 类的关系</h2><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><p>InputStream：Java IO 中的顶级的字节输入流的抽象类，定义了最基础的输入、读取的相关方法。实现了 <code>Closeable</code> 接口。</p><ul><li>FileInputStream：继承自 <code>InputStream</code> 的文件输入流类，用于从本地文件中读取字节数据。</li><li>ByteArrayInputStream：继承自 <code>InputStream</code> 的字节数组输入流类，它包含一个内部缓冲区，该缓冲区包含从流中读取的字节；通俗点说，它的内部缓冲区就是一个字节数组，而 <code>ByteArrayInputStream</code> 本质就是通过字节数组来实现的。<code>InputStream</code> 通过 <code>read()</code> 向外提供接口，供它们来读取字节数据；而 <code>ByteArrayInputStream</code> 的内部额外的定义了一个计数器，它被用来跟踪 <code>read()</code> 方法要读取的下一个字节。</li><li>StringBufferInputStream：继承自 <code>InputStream</code> 的字节输入流类，其中读取的字节由字符串的内容提供的输入流。该类已过时，不推荐使用，由 <code>StringReader</code> 代替。</li><li>PipedInputStream：继承自 <code>InputStream</code> 的管道输入流类，在使用管道通信时，必须与 <code>PipedOutputStream</code> 配合使用。让多线程可以通过管道进行线程间的通讯。</li><li>ObjectInputStream：继承自 <code>InputStream</code> 的对象输入流类，实现了 <code>ObjectInput</code> 和 <code>ObjectStreamConstants</code> 接口。作用是从输入流中读取 Java 对象和基本数据。只有支持 <code>Serializable</code>  或 <code>Externalizable</code> 接口的对象才能被 <code>ObjectInputStream/ObjectOutputStream</code> 所操作！</li><li>SequenceInputStream：继承自 <code>InputStream</code> 的输入合并流类。<code>SequenceInputStream</code> 会将与之相连接的流集组合成一个输入流并从第一个输入流开始读取，直到到达文件末尾，接着从第二个输入流读取，依次类推，直到到达包含的最后一个输入流的文件末 尾为止。合并流的作用是将多个源合并合一个源。</li><li>AudioInputStream：继承自 <code>InputStream</code> 的音频输入流类。音频输入流是具有指定音频格式和长度的输入流。长度用示例帧表示，不用字节表示。提供几种方法，用于从流读取一定数量的字节，或未指定数量的字节。音频输入流跟踪所读取的最后一个字节。可以跳过任意数量的字节以到达稍后的读取位置。音频输入流可支持标记。设置标记时，会记住当前位置，以便可以稍后返回到该位置。</li><li>FilterInputStream：继承自 <code>InputStream</code> 的过滤输入流类（装饰器超类），是用来“封装其它的输入流，并为它们提供额外的功能”。<ul><li>BufferedInputStream：继承自 <code>FilterInputStream</code> 的带缓冲区功能的输入流类（装饰器子类），默认缓冲区大小是8K，能够减少访问磁盘的次数，提高文件读取性能。</li><li>DataInputStream：继承自 <code>FilterInputStream</code> 的数据输入流类，实现了 <code>DataInput</code> 接口。它允许应用程序以与机器无关方式从底层输入流中读取基本 Java 数据类型。</li><li>PushbackInputStream：继承自 <code>FilterInputStream</code> 的回退输入流类。允许试探性的读取数据流，如果不是我们想要的则返还回去。</li><li>LineNumberInputStream：继承自 <code>FilterInputStream</code> 的行号输入流类。可以获取当前的行号或设置当前行号，已过时，已经被 <code>LineNumberReader</code> 替代。</li><li>CheckedInputStream：继承自 <code>FilterInputStream</code> 的校验输入流类。</li><li>CipherInputStream：继承自 <code>FilterInputStream</code> 的密钥输入流类。</li><li>DigestInputStream：继承自 <code>FilterInputStream</code> 的摘要处理输入流类。</li><li>InflaterInputStream：继承自 <code>FilterInputStream</code> 的解压缩处理输入流类。<ul><li>GZIPInputStream：继承自 <code>InflaterInputStream</code> 的 gzip 文件处理输入流类。</li><li>ZipInputStream：继承自 <code>InflaterInputStream</code> 的解压缩处理输入流类。<ul><li>JarInputStream：继承自<code>ZipInputStream</code> 的解压缩处理输入流类。</li></ul></li></ul></li><li>DeflaterInputStream：继承自 <code>FilterInputStream</code> 的压缩数据输入流类。</li><li>ProgressMonitorInputStream：继承自 <code>FilterInputStream</code> 的进度监控输入流类。</li></ul></li></ul><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>OutputStream：Java IO 中的顶级的字节输出流的抽象类，定义了最基础的输出、写入的相关方法。实现了 <code>Closeable</code> 和 <code>Flushable</code> 接口。</p><ul><li>FileOutputStream：继承自 <code>OutputStream</code> 的文件输出流类，用于向本地文件中写入字节数据。</li><li>ByteArrayOutputStream：继承自 <code>OutputStream</code> 的字节数组输出流类，<code>ByteArrayOutputStream</code> 中的数据会被写入一个 <code>byte</code> 数组。缓冲区会随着数据的不断写入而自动增长。可使用 <code>toByteArray()</code> 和 <code>toString()</code> 获取数据。</li><li>PipedOutputStream：继承自 <code>OutputStream</code> 的管道输出流类，在使用管道通信时，必须与 <code>PipedInputStream</code> 配合使用。让多线程可以通过管道进行线程间的通讯。</li><li>ObjectOutputStream：继承自 <code>OutputStream</code> 的对象输出流类，实现了 <code>ObjectOutput</code> 和 <code>ObjectStreamConstants</code> 接口。作用是把 Java 对象和基本数据写入到对象输出流中。只有支持 <code>Serializable</code> 或 <code>Externalizable</code> 接口的对象才能被 <code>ObjectInputStream/ObjectOutputStream</code> 所操作！</li><li>FilterOutputStream：继承自 <code>OutputStream</code> 的过滤输出流类，是用来“封装其它的输出流，并为它们提供额外的功能”。<ul><li>BufferedOutputStream：继承自 <code>FilterOutputStream</code> 的带缓冲区功能的输出流类，默认缓冲区大小是8K，能够提高文件的写入效率。</li><li>DataOutputStream：继承自 <code>FilterOutputStream</code> 的数据输出流类，实现了 <code>DataOutput</code> 接口。它允许应用程序以与机器无关方式向底层输入流中写入基本 Java 数据类型。</li><li>PrintStream：继承自 <code>FilterOutputStream</code> 的打印输出流类，实现了 <code>Appendable</code> 和 <code>Closeable</code> 接口。使它们能够方便地打印各种数据值表示形式。<code>PrintStream</code> 永远不会抛出 IOException。<code>PrintStream</code> 提供了自动flush 和 字符集设置功能。所谓自动 <code>flush</code>，就是往 <code>PrintStream</code> 写入的数据会立刻调用 <code>flush()</code> 函数。</li><li>CheckedOutputStream：继承自 <code>FilterOutputStream</code> 的校验输出流类。</li><li>CipherOutputStream：继承自 <code>FilterOutputStream</code> 的密钥输出流类。</li><li>DigestOutputStream：继承自 <code>FilterOutputStream</code> 的摘要处理输出流类。</li><li>InflaterOutputStream：继承自 <code>FilterOutputStream</code> 的解压缩处理输出流类。</li><li>DeflaterOutputStream：继承自 <code>FilterOutputStream</code> 的解压缩数据输出流类。<ul><li>GZIPOutputStream：继承自 <code>DeflaterOutputStream</code> 的 gzip 文件解压缩输出流类。</li><li>ZipOutputStream：继承自 <code>DeflaterOutputStream</code> 的 zip 文件解压缩输出流类。<ul><li>JarOutputStream：继承自 <code>ZipOutputStream</code> 的 zip 文件解压缩输出流类。</li></ul></li></ul></li></ul></li></ul><h3 id="Reader"><a href="#Reader" class="headerlink" title="Reader"></a>Reader</h3><ul><li>Reader：Java IO 中的顶级的字符读取的抽象类，定义了最基础的读取方法。实现了 <code>Readable</code> 和 <code>Closeable</code> 接口。<ul><li>BufferedReader：继承自 <code>Reader</code> 的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输入流中读取文本，缓冲各个字符，从而实现字符、数组和行的高效读取。创建 <code>BufferReader</code> 时，我们会通过它的构造函数指定某个 <code>Reader</code> 为参数。<code>BufferReader</code> 会将该 <code>Reader</code> 中的数据分批读取，每次读取一部分到缓冲中；操作完缓冲中的这部分数据之后，再从 <code>Reader</code> 中读取下一部分的数据。<ul><li>LineNumberReader：继承自 <code>BufferedReader</code>，可以获取当前的行号或设置当前行号。</li></ul></li><li>InputStreamReader：继承自 <code>Reader</code>，用于将从字节流转换成字符流的 <code>Reader</code>。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。<ul><li>FileReader：继承自 <code>InputStreamReader</code>，用来读取字符文件的便捷类。</li></ul></li><li>StringReader：继承自 <code>Reader</code>，用于字符串读取的字符流。</li><li>CharArrayReader：继承自 <code>Reader</code> 的字符数组输入流类。</li><li>FilterReader：继承自 <code>Reader</code> 的字符过滤输入流抽象类。<ul><li>PushbackReader：继承自 <code>FilterReader</code> 的字符回退输入流类。</li></ul></li><li>PipedReader：继承自 <code>Reader</code> 的字符管道输入流类。作用是可以通过管道进行线程间的通讯。必须和 <code>PipedWriter</code> 配合使用。</li></ul></li></ul><h3 id="Writer"><a href="#Writer" class="headerlink" title="Writer"></a>Writer</h3><ul><li>Writer：Java IO 中的顶级的字符写入的抽象类，定义了最基础的写入方法。实现了 <code>Appendable</code>、<code>Closeable</code> 和 <code>Flushable</code> 接口。<ul><li>BufferedWriter：继承自<code>Writer</code>的带缓冲功能的字符流类，默认缓冲区大小是8K，从字符输出流中写入字符到文本中，缓冲各个字符，从而实现字符、数组和行的高效写入。</li><li>OutputStreamWriter：继承自 <code>Reader</code>，用于将从字节流转换成字符流的 <code>Writer</code>。是字节流通向字符流的桥梁。如果不指定字符集编码，该解码过程将使用平台默认的字符编码。<ul><li>FileWriter：继承自 <code>OutputStreamWriter</code>，用来向文件中写入字符的便捷类。</li></ul></li><li>FilterWriter：继承自 <code>Writer</code> 的字符过滤输出流抽象类。与 <code>FilterOutputStream</code> 功能一样、只是简单重写了父类的方法、目的是为所有装饰类提供标准和基本的方法、要求子类必须实现核心方法、和拥有自己的特色。这里 <code>FilterWriter</code> 没有子类、可能其意义只是提供一个接口、留着以后的扩展，本身是一个抽象类。</li><li>StringWriter：继承自 <code>Writer</code>，用于字符串写入的字符流。</li><li>PipedWriter：继承自 <code>Writer</code> 的字符管道输出流类。作用是可以通过管道进行线程间的通讯。必须和 <code>PipedReader</code> 配合使用。</li><li>CharArrayWriter：继承自 <code>Writer</code> 的字符数组输出流类。</li><li>PrintWriter：继承自 <code>Writer</code> 的打印写入类，提供了 <code>PrintStream</code> 的所有打印方法，其方法也从不抛出 IOException。与 <code>PrintStream</code> 的区别：作为处理流使用时，<code>PrintStream</code> 只能封装 <code>OutputStream</code> 类型的字节流，而 <code>PrintWriter</code> 既可以封装 <code>OutputStream</code> 类型的字节流，还能够封装 <code>Writer</code> 类型的字符输出流并增强其功能。</li></ul></li></ul><p><img src="https://henleylee.github.io/medias/java/io_mind_all.png" alt="Java IO Mind"></p><h2 id="Java-IO-的分类"><a href="#Java-IO-的分类" class="headerlink" title="Java IO 的分类"></a>Java IO 的分类</h2><ul><li><strong><code>字节流和字符流</code></strong>：<ul><li><code>字节流：</code>以字节为单位，每次次读入或读出是8位数据。可以读任何类型数据。</li><li><code>字符流：</code>以字符为单位，每次次读入或读出是16位数据。其只能读取字符类型数据。</li></ul></li><li><strong><code>输出流和输入流</code></strong>：<ul><li><code>输入流：</code>从文件读入到内存。只能进行读操作。</li><li><code>输出流：</code>从内存读出到文件。只能进行写操作。</li></ul></li><li><strong><code>节点流和处理流</code></strong>：<ul><li><code>节点流：</code>直接与数据源相连，读入或读出。</li><li><code>处理流：</code>与节点流一块使用，在节点流的基础上，再套接一层，套接在节点流上的就是处理流。处理流的构造方法总是要带一个其他的流对象做参数。一个流对象经过其他流的多次包装，称为流的链接。</li></ul></li></ul><blockquote><p><strong>注</strong>：输入输出流中的入和出，都是相对于系统内存而言的。为什么要有处理流？直接使用节点流，读写不方便，为了更快的读写文件，才有了处理流。</p></blockquote><p>流按类型分类的结构图如下：<br><img src="https://henleylee.github.io/medias/java/io_mind_optype.png" alt="流按类型分类"></p><p>流按用途分类的结构图如下：<br><img src="https://henleylee.github.io/medias/java/io_mind_object.png" alt="流按用途分类"></p><h2 id="Java-IO-的主要方法"><a href="#Java-IO-的主要方法" class="headerlink" title="Java IO 的主要方法"></a>Java IO 的主要方法</h2><h3 id="InputStream-中的主要方法"><a href="#InputStream-中的主要方法" class="headerlink" title="InputStream 中的主要方法"></a>InputStream 中的主要方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>abstract int read()</code></td><td>从流中读取数据，读取一个字节，返回值为所读得字节</td></tr><tr><td><code>int read(byte b[])</code></td><td>从流中读取数据，读取多个字节，放置到字节数组 b 中，通常读取的字节数量为 b 的长度，返回值为实际独取的字节的数量</td></tr><tr><td><code>int read(byte b[], int off, int len)</code></td><td>从流中读取数据，读取 len 个字节，放置到以下标 off 开始字节数组 b 中，返回值为实际读取的字节的数量</td></tr><tr><td><code>long skip(long n)</code></td><td>读指针跳过 n 个字节不读，返回值为实际跳过的字节数量</td></tr><tr><td><code>int available()</code></td><td>返回值为流中尚未读取的字节的数量</td></tr><tr><td><code>void close()</code></td><td>关闭输入流</td></tr><tr><td><code>synchronized void mark(int readlimit)</code></td><td>记录当前指针的所在位置，<code>readlimit</code> 表示读指针读出的 <code>readlimit</code> 个字节后，所标记的指针位置才实效</td></tr><tr><td><code>synchronized void reset()</code></td><td>把读指针重新指向用 <code>mark</code> 方法所记录的位置</td></tr><tr><td><code>boolean markSupported()</code></td><td>当前的流是否支持读指针的记录功能</td></tr></tbody></table><blockquote><p><strong>注</strong>：其中<code>read()</code>返回的是读入的一个字节所对应的 int 值(0-255),而<code>read(byte[] b)</code>和<code>read(byte[] b, int off, int len)</code>返回的是读入的字节数。</p></blockquote><h3 id="OutputStream-中的主要方法"><a href="#OutputStream-中的主要方法" class="headerlink" title="OutputStream 中的主要方法"></a>OutputStream 中的主要方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>abstract void write(int b)</code></td><td>输出数据，往流中写一个字节 b</td></tr><tr><td><code>void write(byte b[])</code></td><td>输出数据，往流中写一个字节数组 b</td></tr><tr><td><code>void write(byte b[], int off, int len)</code></td><td>输出数据，把字节数组 b 中从下标 off 开始，长度为 len 的字节写入到流中</td></tr><tr><td><code>void flush()</code></td><td>刷空输出流，并输出所有被缓存的字节。由于某些流支持缓存功能，该方法将把缓存中所有内容强制输出到流中</td></tr><tr><td><code>void close()</code></td><td>关闭输出流</td></tr></tbody></table><h3 id="Reader-中的主要方法"><a href="#Reader-中的主要方法" class="headerlink" title="Reader 中的主要方法"></a>Reader 中的主要方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>int read(java.nio.CharBuffer target)</code></td><td>试图读取字符入指定的字符缓冲区</td></tr><tr><td><code>int read()</code></td><td>读取单个字符</td></tr><tr><td><code>int read(char cbuf[])</code></td><td>读取字符到一个数组中</td></tr><tr><td><code>int read(char cbuf[], int off, int len)</code></td><td>读取字符到一个数组中的一部分</td></tr><tr><td><code>long skip(long n)</code></td><td>跳过 n 个字符</td></tr><tr><td><code>boolean ready()</code></td><td>通知此流是否已准备好被读取</td></tr><tr><td><code>boolean markSupported()</code></td><td>告诉此流是否支持 <code>mark()</code> 操作</td></tr><tr><td><code>void mark(int readAheadLimit)</code></td><td>标记流中的当前位置</td></tr><tr><td><code>void reset()</code></td><td>重置流</td></tr><tr><td><code>void close()</code></td><td>关闭该流并释放与之关联的所有系统资源</td></tr></tbody></table><h3 id="Writer-中的主要方法"><a href="#Writer-中的主要方法" class="headerlink" title="Writer 中的主要方法"></a>Writer 中的主要方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void write(int c)</code></td><td>写入单个字符</td></tr><tr><td><code>void write(char cbuf[])</code></td><td>写入字符数组</td></tr><tr><td><code>abstract void write(char cbuf[], int off, int len)</code></td><td>写入字符数组的一部分</td></tr><tr><td><code>void write(String str)</code></td><td>写入一个字符串</td></tr><tr><td><code>void write(String str, int off, int len)</code></td><td>写入一个字符串的一部分</td></tr><tr><td><code>Writer append(CharSequence csq)</code></td><td>将指定的字符序列追加写到 writer 中</td></tr><tr><td><code>Writer append(CharSequence csq, int start, int end)</code></td><td>将指定的字符序列的子序列追加写入此 writer</td></tr><tr><td><code>Writer append(char c)</code></td><td>将指定字符追加到这个 writer</td></tr><tr><td><code>abstract void flush()</code></td><td>刷新流</td></tr><tr><td><code>abstract void close()</code></td><td>关闭流，但要先刷新它</td></tr></tbody></table><h2 id="Java-IO-的使用示例"><a href="#Java-IO-的使用示例" class="headerlink" title="Java IO 的使用示例"></a>Java IO 的使用示例</h2><h3 id="FileInputStream-和-FileOutputStream"><a href="#FileInputStream-和-FileOutputStream" class="headerlink" title="FileInputStream 和 FileOutputStream"></a>FileInputStream 和 FileOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试复制文件 a.txt 中的内容到 b.txt 文件中 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testCopyByFileStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>            InputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/b.txt"</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"文件读取写入失败!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="BufferedInputStream-和-BufferedOutputStream"><a href="#BufferedInputStream-和-BufferedOutputStream" class="headerlink" title="BufferedInputStream 和 BufferedOutputStream"></a>BufferedInputStream 和 BufferedOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试通过 BufferedInputStream 和 BufferedOutputStream 来复制文件 a.txt 中的内容到 b.txt 文件中 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testCopyByBufferedStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>            InputStream in <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedInputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedOutputStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> bytes <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">1024</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> in<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>bytes<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>bytes<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"通过缓冲区的方式来做文件读取写入失败!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="ByteArrayOutputStream"><a href="#ByteArrayOutputStream" class="headerlink" title="ByteArrayOutputStream"></a>ByteArrayOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试将内容写入到 ByteArrayOutputStream 中并打印出来，不需要关闭流 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testByByteArrayStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    String text <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>    ByteArrayOutputStream byteOut <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ByteArrayOutputStream</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        byteOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"写入字节数据出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buffer <span class="token operator">=</span> byteOut<span class="token punctuation">.</span><span class="token function">toByteArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">byte</span> b <span class="token operator">:</span> buffer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token keyword">char</span><span class="token punctuation">)</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="PipedInputStream-和-PipedOutputStream"><a href="#PipedInputStream-和-PipedOutputStream" class="headerlink" title="PipedInputStream 和 PipedOutputStream"></a>PipedInputStream 和 PipedOutputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 发送消息的线程 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Sender</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Sender<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 管道输出流对象，它和管道输入流(PipedInputStream)对象绑定，从而可以将数据发送给“管道输入流” */</span>    <span class="token keyword">private</span> PipedOutputStream pipedOut<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Sender</span><span class="token punctuation">(</span>PipedOutputStream pipedOut<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pipedOut <span class="token operator">=</span> pipedOut<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> PipedOutputStream <span class="token function">getPipedOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> pipedOut<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String strInfo <span class="token operator">=</span> <span class="token string">"Hello World!"</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            pipedOut<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>strInfo<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pipedOut<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"向管道中写入数据出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 接收消息的线程 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token keyword">extends</span> <span class="token class-name">Thread</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>Test<span class="token punctuation">.</span>Receiver<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 管道输入流对象，它和管道输出流(PipedOutputStream)对象绑定，从而可以接收“管道输出流”的数据 */</span>    <span class="token keyword">private</span> PipedInputStream pipedIn<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Receiver</span><span class="token punctuation">(</span>PipedInputStream pipedIn<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>pipedIn <span class="token operator">=</span> pipedIn<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> PipedInputStream <span class="token function">getPipedIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> pipedIn<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">byte</span><span class="token punctuation">[</span><span class="token punctuation">]</span> buf <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">byte</span><span class="token punctuation">[</span><span class="token number">2048</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> len <span class="token operator">=</span> pipedIn<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span>buf<span class="token punctuation">)</span><span class="token punctuation">;</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"{}"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>buf<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            pipedIn<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"从管道中读取数据出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * PipedInputStream 和 PipedOutputStream 的测试类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PipedStreamTest</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Logger log <span class="token operator">=</span> LoggerFactory<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>PipedStreamTest<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Sender sender <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Sender</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PipedOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Receiver</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PipedInputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// 将管道输入流和管道的输出流进行连接.</span>            receiver<span class="token punctuation">.</span><span class="token function">getPipedIn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">connect</span><span class="token punctuation">(</span>sender<span class="token punctuation">.</span><span class="token function">getPipedOut</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 启动线程</span>            sender<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            receiver<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            log<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"发送接收消息出错!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="SequenceInputStream"><a href="#SequenceInputStream" class="headerlink" title="SequenceInputStream"></a>SequenceInputStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试使用 testBySequenceStream 合并输入流来统一读取写入 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testBySequenceStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>            InputStream in1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/a.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            InputStream in2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileInputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/b.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            OutputStream out <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span><span class="token string">"D:/test/c.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            SequenceInputStream seqIn <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SequenceInputStream</span><span class="token punctuation">(</span>in1<span class="token punctuation">,</span> in2<span class="token punctuation">)</span>    <span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> len<span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>len <span class="token operator">=</span> seqIn<span class="token punctuation">.</span><span class="token function">read</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            out<span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>len<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"合并输入流写入失败!"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="PrintStream"><a href="#PrintStream" class="headerlink" title="PrintStream"></a>PrintStream</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 测试使用 PrintStream 将数据输出到指定的文件 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">testOutputByPrintStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Hello World!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    File file <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span><span class="token string">"D:/test/d.txt"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span><span class="token function">setOut</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">PrintStream</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">FileOutputStream</span><span class="token punctuation">(</span>file<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">FileNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"这些内容在文件中才能看到哦！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><h2 id="Java-IO-具有的对称性"><a href="#Java-IO-具有的对称性" class="headerlink" title="Java IO 具有的对称性"></a>Java IO 具有的对称性</h2><p>Java I/O库具有两个对称性，它们分别是：</p><ul><li><strong><code>输入-输出对称性：</code></strong> <code>InputStream</code> 和 <code>OutputStream</code> 各自占据 <code>Byte</code> 流的输入与输出的两个平行的等级结构的根部。而 <code>Reader</code> 和 <code>Writer</code> 各自占据 <code>Char</code> 流的输入与输出的两个平行的等级结构的根部。</li><li><strong><code>byte-char 对称：</code></strong> <code>InputStream</code> 和 <code>Reader</code> 的子类分别负责 <code>Byte</code> 和 <code>Char</code> 流的输入；<code>OutputStream</code> 和 <code>Writer</code> 的子类分别负责 <code>Byte</code> 和 <code>Char</code> 流的输出，它们分别形成平行的等级结构。</li></ul><h2 id="Java-IO-遵循的设计原则"><a href="#Java-IO-遵循的设计原则" class="headerlink" title="Java IO 遵循的设计原则"></a>Java IO 遵循的设计原则</h2><ul><li><strong><code>单一职责原则：</code></strong>每一个 IO 类的都具有单独的功能和职责，需要对某种类型的流做修改时，只需要修改具体对应的 IO 流类即可。</li><li><strong><code>里氏替换原则：</code></strong>子类完全实现了父类的方法，且有自己的个性，子类覆盖或实现父类的方法时输入参数和返回结果的范围没有变化。</li><li><strong><code>接口隔离原则：</code></strong>输入输出流所实现的接口有所不同，而且接口比较细化，接口中的方法少。</li><li><strong><code>依赖倒置原则：</code></strong>Java IO 中的各个具体的功能类，都继承或聚合了 <code>InputStream/OutputStream</code> 的抽象类，都共同依赖了抽象，而不是依赖了某个具体的功能的IO类。</li><li><strong><code>开闭原则：</code></strong>当用户需要新增一种新特征、新方式的IO流时，可以直接新增一种类的流，让其继承或聚合 <code>InputStream/OutputStream/FilterInputStream/FilterOutputStream</code> 等类，从而来书写其特有的功能，减少。</li><li><strong><code>聚合/组合复用原则：</code></strong>就比如 <code>FileInputStream</code> 中对 <code>FileDescriptor</code> 和 <code>FileChannel</code> 的使用，都是采用了聚合的方式，而非继承的方式，从而使类之间的耦合度降低，提高了灵活性。</li></ul><h2 id="Java-IO-使用到的设计模式"><a href="#Java-IO-使用到的设计模式" class="headerlink" title="Java IO 使用到的设计模式"></a>Java IO 使用到的设计模式</h2><p>Java 的 I/O 库总体设计是符合装饰者模式(Decorator)跟适配器模式(Adapter)的。这个库中处理流的类叫做流类，比如 FileInputStream、FileOutputStream、DataInputStream 及 DataOutputStream 都是流处理器的例子。</p><h3 id="装饰者模式-Decorator"><a href="#装饰者模式-Decorator" class="headerlink" title="装饰者模式(Decorator)"></a>装饰者模式(Decorator)</h3><p>由于 Java I/O 库需要很多性能的各种组合，如果这些性能都是用继承来实现，那么每一种组合都需要一个类，这样就会造成大量行重复的类出现。如果采用装饰模式，那么类的数目就会大大减少，性能的重复也可以减至最少。因此装饰模式是 Java I/O 库基本模式。装饰模式的引进，造成灵活性和复杂性的提高。因此在使用 Java I/O 库时，必须理解 Java I/O 库是由一些基本的原始流处理器和围绕它们的装饰流处理器所组成的。</p><p>在由 <code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code> 和 <code>Writer</code> 代表的等级结构内部，有一些流处理器可以对另一些流处理器起到装饰作用，形成新的，具有改善了的功能的流处理器。装饰者模式是 Java I/O 库的整体设计模式。以字节输入流为例，<code>InputStream</code> 是需要被装饰的抽象构件，而其下的 <code>FileInputStream</code>、<code>ByteArrayInputStream</code> 等是被装饰的具体构件；<code>FilterInputStream</code> 是装饰器的父类，<code>BufferedInputStream</code>、<code>DataInputStream</code> 则是具体的装饰器类。</p><h3 id="适配器模式-Adapter"><a href="#适配器模式-Adapter" class="headerlink" title="适配器模式(Adapter)"></a>适配器模式(Adapter)</h3><p>适配器模式是 Java I/O 库中第二个重要的设计模式。适配器模式应用到了原始流处理器的设计上面，构成了 I/O 库所有流处理器的起点。</p><p>在由 <code>InputStream</code>、<code>OutputStream</code>、<code>Reader</code> 和 <code>Writer</code> 代表的等级结构内部，有一些流处理器是对其它类型的流源的适配。如：<code>StringBufferInputStream</code> 就是一个适配器类。它继承了 <code>InputStream</code> 类型，同时持有一个对 <code>String</code> 类型的引用。这是将 <code>String</code> 对象适配成 <code>InputStream</code> 类型的对象形式的适配器模式。<code>PipedOutputStream</code> 也是一个适配器类。<code>PipedOutputStream</code> 总是和 <code>PipedInputStream</code> 一起使用，它接收一个类型为 <code>PipedInputStream</code> 的输入类型，并将之转换成 <code>OutputStream</code> 类型的输出流，这是一个对象形式的适配器模式应用。</p><h2 id="Java-IO-中的流处理器"><a href="#Java-IO-中的流处理器" class="headerlink" title="Java IO 中的流处理器"></a>Java IO 中的流处理器</h2><p>根据输入流的源的类型，可以将这些流类分成两种，即原始流类(Original Stream)和链接流处理器(Wrapper Stream)。</p><h3 id="原始流处理器"><a href="#原始流处理器" class="headerlink" title="原始流处理器"></a>原始流处理器</h3><p>原始流处理器接收一个 Byte 数组对象、String 对象、FileDiscriptor 对象或者不同类型的流源对象。原始流处理器包括：</p><ul><li>ByteArrayInputStream：为多线程的通信提供缓冲区操作功能，接收一个 Byte 数组作为流的源。</li><li>FileInputStream：建立一个与文件有关的输入流。接收一个 File 对象作为流的源。</li><li>PipedInputStream：可以与 PipedOutputStream 配合使用，用于读入一个数据管道的数据，接收一个 PipedOutputStream 作为源。</li><li>StringBufferInputStream：将一个字符串缓冲区转换为一个输入流。接收一个 String 对象作为流的源(JDK 帮助文档上说明：已过时。此类未能正确地将字符转换为字节。从 JDK 1.1 开始，从字符串创建流的首选方法是通过 StringReader 类进行创建。只有字符串中每个字符的低八位可以由此类使用)。</li></ul><h3 id="链接流处理器"><a href="#链接流处理器" class="headerlink" title="链接流处理器"></a>链接流处理器</h3><p>链接流处理器就是可以接收另一个流对象作为源，并对之进行功能扩展的类。InputStream类型的链接处理器包括以下几种，它们都接收另一个 InputStream 对象作为流源：</p><ul><li>FilterInputStream：称为过滤输入流，它将另一个输入流作为流源。这个类的子类包括以下几种：<ul><li>BufferedInputStream：用来从硬盘将数据读入到一个内存缓冲区中，并从缓冲区提供数据。</li><li>DataInputStream：提供基于多字节的读取方法，可以读取原始类型的数据。</li><li>LineNumberInputStream：提供带有行计数功能的过滤输入流。</li><li>PushbackInputStream：提供特殊的功能，可以将已经读取的字节“推回”到输入流中。</li></ul></li><li>ObjectInputStream：可以将使用 ObjectInputStream 串行化的原始数据类型和对象重新并行化。</li><li>SeqcueneInputStream：可以将两个已有的输入流连接起来，形成一个输入流，从而将多个输入流排列构成一个输入流序列。</li></ul><h2 id="Java-IO-设计的优缺点"><a href="#Java-IO-设计的优缺点" class="headerlink" title="Java IO 设计的优缺点"></a>Java IO 设计的优缺点</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><ul><li>功能全面、强大和灵活，同时还防止了过多的类膨胀。</li><li>符合开闭原则，开发可以通过各种装配能实现各种功能。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><ul><li>复杂难记，API 使用繁琐。如：<code>JDK 1.6</code>中，从文本文件中读取数据转换为字符串，就得至少10行代码。</li><li>IO 流中的绝大多数方法都有 <code>IOException</code> 的检查异常，导致开发人员不得不在各个使用到的地方捕捉或再抛出异常，代码繁琐，不符合当前的主流设计思路。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> IO </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 集合框架综述</title>
      <link href="/posts/2018/83599db7.html"/>
      <url>/posts/2018/83599db7.html</url>
      
        <content type="html"><![CDATA[<p>早在 Java 2 中之前，Java 就提供了特设类。比如：Dictionary、Vector、Stack 和 Properties 这些类用来存储和操作对象组。虽然这些类都非常有用，但是它们缺少一个核心的，统一的主题。由于这个原因，使用 Vector 类的方式和使用 Properties 类的方式有着很大不同。</p><p>集合框架被设计成要满足以下几个目标：</p><ul><li>该框架必须是高性能的，基本集合（动态数组，链表，树，哈希表）的实现也必须是高效的。</li><li>该框架允许不同类型的集合，以类似的方式工作，具有高度的互操作性。</li><li>对一个集合的扩展和适应必须是简单的。</li></ul><p>为此，整个集合框架就围绕一组标准接口而设计。</p><h2 id="集合框架图"><a href="#集合框架图" class="headerlink" title="集合框架图"></a>集合框架图</h2><p>Java 集合框架图如下：<br><img src="https://henleylee.github.io/medias/java/java_collections_framework.png" alt="Java 集合框架图"></p><p>从上面的集合框架图可以看到，Java 集合框架主要包括两种类型的容器：</p><ul><li><strong><code>集合(Collection)：</code></strong>存储一个<code>元素集合</code>。Collection 接口又有 3 种子类型，List、Set 和 Queue，再下面是一些抽象类，最后是具体实现类，常用的有 ArrayList、LinkedList、HashSet、LinkedHashSet、TreeSet 等。</li><li><strong><code>图(Map)：</code></strong>存储<code>键/值对</code>映射。Map 接口又有 3 种子类型，ConcurrentMap、ObservableMap、SortedMap，再下面是一些抽象类，最后是具体实现类，常用的有 HashMap、LinkedHashMap、TreeMap、Hashtable、Properties 等等。</li></ul><p>集合框架是一个用来代表和操纵集合的统一架构。所有的集合框架都包含如下内容：</p><ul><li><strong><code>接口：</code></strong>是代表集合的抽象数据类型。例如 Collection、List、Set、Map 等。之所以定义多个接口，是为了以不同的方式操作集合对象</li><li><strong><code>实现(类)：</code></strong>是集合接口的具体实现。从本质上讲，它们是可重复使用的数据结构，例如：ArrayList、LinkedList、HashSet、HashMap、LinkedHashMap。</li><li><strong><code>算法：</code></strong>是实现集合接口的对象里的方法执行的一些有用的计算，例如：搜索和排序。这些算法被称为多态，那是因为相同的方法可以在相似的接口上有着不同的实现。</li></ul><p>除了集合，该框架也定义了几个 Map 接口和类。Map 里存储的是键/值对。尽管 Map 不是集合，但是它们完全整合在集合中。</p><h2 id="集合关系图"><a href="#集合关系图" class="headerlink" title="集合关系图"></a>集合关系图</h2><p>Java Collection UML 类关系图如下：<br><img src="https://henleylee.github.io/medias/java/java_collection_uml.png" alt="Java Collection UML类关系图"></p><p>Java Map UML 类关系图如下：<br><img src="https://henleylee.github.io/medias/java/java_map_uml.png" alt="Java Map UML类关系图"></p><h2 id="集合接口、类的关系"><a href="#集合接口、类的关系" class="headerlink" title="集合接口、类的关系"></a>集合接口、类的关系</h2><h3 id="Collection"><a href="#Collection" class="headerlink" title="Collection"></a>Collection</h3><p><code>Collection</code> 接口继承了 <code>Iterable</code> 接口，依赖了 <code>Predicate</code>、<code>Spliterator</code>、<code>Stream</code> 接口（这些均为 <code>Java8</code> 新增），<code>Iterable</code> 接口依赖了 <code>Iterator</code> 接口。</p><ul><li><code>List</code> 接口继承自 <code>Collection</code> 接口，依赖了 <code>UnaryOperator</code> 接口(<code>Java8</code>新增)、<code>ListIterator</code>、<code>Comparator</code> 接口。</li><li><code>Set</code> 接口继承自 <code>Collection</code>接口。<ul><li><code>AbstractSet</code> 抽象类继承了 <code>AbstractCollection</code> 抽象类，实现了 <code>Set</code> 接口。<ul><li><code>HashSet</code> 类继承了 <code>AbstractSet</code> 抽象类，实现了 <code>Set</code>、<code>Cloneable</code>、<code>Serializable</code> 接口，聚合了 <code>HashMap</code> 类。<ul><li><code>LinkedHashSet</code> 类继承了 <code>HashSet</code> 类，实现了 <code>Set</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。</li></ul></li><li><code>TreeSet</code> 类继承了 <code>AbstractSet</code> 抽象类，实现了 <code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code> 接口，聚合了 <code>NavigableMap</code>，依赖了 <code>Comparator</code>、<code>SortedSet</code> 接口。</li><li><code>EnumSet</code> 抽象类继承了 <code>AbstractSet</code> 抽象类，实现了 <code>Cloneable</code>、<code>Serializable</code> 接口，依赖了 <code>Comparator</code>、<code>SortedSet</code> 接口。<ul><li><code>RegularEnumSet</code>类继承了<code>EnumSet</code>抽象类。</li><li><code>JumboEnumSet</code>类继承了<code>EnumSet</code>抽象类。</li></ul></li><li><code>CopyOnWriteArraySet</code> 类继承了 <code>AbstractSet</code> 抽象类，实现了 <code>Serializable</code> 接口，聚合了 <code>CopyOnWriteArrayList</code> 类，依赖了 <code>Predicate</code>、<code>Consumer</code> 接口。</li><li><code>ConcurrentSkipListSet</code> 类继承了 <code>AbstractSet</code> 抽象类，实现了 <code>NavigableSet</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。</li></ul></li><li><code>SortedSet</code> 接口继承自 <code>Set</code> 接口，依赖了 <code>Comparator</code> 接口。<ul><li><code>NavigableSet</code> 接口继承自 <code>SortedSet</code> 接口(<code>Java6</code>新增)。</li></ul></li></ul></li><li><code>Queue</code> 接口继承了 <code>Collection</code> 接口。<ul><li><code>Deque</code> 接口继承了 <code>Queue</code> 接口。</li><li><code>BlockingQueue</code> 接口继承了 <code>Queue</code> 接口。<ul><li><code>BlockingDeque</code> 接口继承了 <code>BlockingQueue</code>、<code>Deque</code> 接口。</li><li><code>TransferQueue</code> 接口继承了 <code>BlockingQueue</code> 接口。</li></ul></li></ul></li><li><code>AbstractCollection</code> 抽象类实现了 <code>Collection</code> 接口。<ul><li><code>AbstractList</code> 抽象类继承了 <code>AbstractCollection</code> 抽象类，实现了 <code>List</code> 接口，依赖了 <code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。<ul><li><code>ArrayList</code> 类继承了 <code>AbstractList</code> 抽象类，实现了 <code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。</li><li><code>AbstractSequentialList</code> 抽象类继承了 <code>AbstractList</code> 抽象类。</li><li><code>LinkedList</code> 类继承了 <code>AbstractSequentialList</code> 抽象类，实现了 <code>List</code>、<code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。<ul><li><code>CopyOnWriteArrayList</code> 实现了 <code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。</li><li><code>Vector</code> 类继承了 <code>AbstractList</code> 抽象类，实现了 <code>List</code>、<code>RandomAccess</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。</li></ul></li><li><code>Stack</code> 类继承了 <code>Vector</code> 类。</li></ul></li><li><code>AbstractQueue</code> 抽象类继承了 <code>AbstractCollection</code> 接口，实现了 <code>Queue</code> 接口。<ul><li><code>SynchronousQueue</code> 类继承了 <code>AbstractQueue</code> 接口，实现了 <code>BlockingQueue</code>、<code>Serializable</code> 接口，依赖了 <code>Collection</code>、<code>Spliterator</code> 接口。</li><li><code>ArrayBlockingQueue</code> 类继承了 <code>AbstractQueue</code> 接口，实现了 <code>BlockingQueue</code>、<code>Serializable</code> 接口。</li><li><code>LinkedBlockingQueue</code> 类继承了 <code>AbstractQueue</code> 接口，实现了 <code>BlockingQueue</code>、<code>Serializable</code> 接口。</li><li><code>PriorityBlockingQueue</code> 类继承了 <code>AbstractQueue</code> 接口，实现了 <code>BlockingQueue</code>、<code>Serializable</code> 接口，聚合了 <code>Comparator</code> 接口，依赖了 <code>Collection</code>、<code>Comparator</code>、<code>Comparable</code> 接口。</li><li><code>DelayQueue</code>类继承了 <code>AbstractQueue</code> 接口，实现了 <code>BlockingQueue</code> 接口。</li><li><code>LinkedBlockingDeque</code> 类继承了 <code>AbstractQueue</code> 接口，实现了 <code>BlockingDeque</code>、<code>Serializable</code> 接口。</li><li><code>PriorityQueue</code> 类继承了<code>AbstractQueue</code>接口。</li><li><code>LinkedTransferQueue</code> 类继承了 <code>AbstractQueue</code> 接口，实现了 <code>TransferQueue</code>、<code>Serializable</code> 接口(<code>Java7</code>新增)。</li></ul></li><li><code>ConcurrentLinkedDeque</code> 类继承了 <code>AbstractCollection</code> 抽象类，实现了 <code>Deque</code>、<code>Cloneable</code>、<code>Serializable</code> 接口。</li><li><code>ArrayDeque</code> 类继承了 <code>AbstractCollection</code> 抽象类，实现了 <code>Deque</code>、<code>Serializable</code> 接口。</li></ul></li></ul><h3 id="Map"><a href="#Map" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code> 接口依赖了 <code>Set</code>、<code>Collection</code>、<code>BiConsumer</code>、<code>Function</code>、<code>BiFunction</code> 接口，<code>Map.Entry</code> 是 <code>Map</code> 中的内部接口。</p><ul><li><code>AbstractMap</code> 抽象类实现了 <code>Map</code> 接口，聚合了 <code>Collection</code>、<code>Set</code> 接口。<ul><li><code>HashMap</code> 类继承了 <code>AbstractMap</code> 抽象类，实现了 <code>Map</code>、<code>Cloneable</code>、<code>Serializable</code> 接口，依赖了 <code>Collection</code>、<code>Set</code> 接口。<ul><li><code>LinkedHashMap</code> 继承了 <code>HashMap</code> 类，实现了 <code>Map</code> 接口，依赖了 <code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code> 接口。</li></ul></li><li><code>TreeMap</code> 类继承了 <code>AbstractMap</code> 抽象类，实现了 <code>NavigableMap</code>、<code>Cloneable</code>、<code>Serializable</code> 接口，依赖了 <code>Comparator</code>、<code>SortedMap</code>、<code>Collection</code>、<code>Set</code>、<code>BiConsumer</code>、<code>BiFunction</code> 接口。</li><li><code>EnumMap</code> 类继承了 <code>AbstractMap</code> 抽象类，实现了 <code>Cloneable</code>、<code>Serializable</code> 接口，依赖了 <code>AbstractSet</code> 类，<code>Collection</code>、<code>Set</code> 接口。</li><li><code>WeakHashMap</code> 类继承了<code>AbstractMap</code> 抽象类，实现了 <code>Map</code> 接口，依赖了 <code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code> 接口。</li><li><code>IdentityHashMap</code> 类继承了 <code>AbstractMap</code> 抽象类，实现了 <code>Map</code>、<code>Serializable</code>、<code>Cloneable</code> 接口，依赖了 <code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code> 接口。</li><li><code>ConcurrentHashMap</code> 类继承了 <code>AbstractMap</code> 抽象类，实现了 <code>ConcurrentMap</code>、<code>Serializable</code> 接口，依赖了 <code>Comparable</code>、<code>ParameterizedType</code>、<code>Collection</code>、<code>Set</code>、<code>Spliterator</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>Function</code>、<code>BiFunction</code>、<code>ToDoubleFunction</code>、<code>DoubleBinaryOperator</code> 等接口。</li><li><code>ConcurrentSkipListMap</code> 类继承了 <code>AbstractMap</code> 抽象类，实现了 <code>ConcurrentNavigableMap</code>、<code>Cloneable</code>、<code>Serializable</code> 接口，聚合了 <code>Comparator</code> 接口，依赖了 <code>Collection</code>、<code>Set</code>、<code>Consumer</code>、<code>BiConsumer</code>、<code>BiFunction</code>、<code>NavigableSet</code> 接口。</li></ul></li><li><code>SortedMap</code> 接口继承自 <code>Map</code> 接口，依赖了 <code>Set</code>、<code>Collection</code>、<code>Comparator</code> 接口。<ul><li><code>NavigableMap</code>接口继承了<code>SortedMap</code>接口，依赖了 <code>NavigableSet</code> 接口。</li><li><code>ConcurrentNavigableMap</code> 接口继承了 <code>ConcurrentMap</code>、<code>NavigableMap</code> 接口，聚合了 <code>NavigableSet</code> 接口。</li></ul></li><li><code>ConcurrentMap</code> 接口继承了 <code>Map</code> 接口，依赖了 <code>BiConsumer</code>、<code>BiFunction</code> 接口。</li><li><code>Hashtable</code> 类继承了 <code>Dictionary</code> 抽象类，实现了 <code>Map</code>、<code>Cloneable</code>、<code>Serializable</code> 接口，聚合了 <code>Collection</code>、<code>Set</code> 接口，依赖了 <code>Enumeration</code>、<code>BiConsumer</code>、<code>BiFunction</code> 接口。<ul><li><code>Properties</code> 类继承了 <code>Hashtable</code> 类。</li></ul></li></ul><h3 id="工具类"><a href="#工具类" class="headerlink" title="工具类"></a>工具类</h3><ul><li><code>Collections</code> 是 <code>Collection</code> 的辅助工具类，依赖了上述大多数接口和类。</li><li><code>Arrays</code> 是数组的辅助工具类，依赖了上述一些接口和类。</li></ul><h2 id="集合接口、类的功能"><a href="#集合接口、类的功能" class="headerlink" title="集合接口、类的功能"></a>集合接口、类的功能</h2><h3 id="Collection-1"><a href="#Collection-1" class="headerlink" title="Collection"></a>Collection</h3><p><code>Collection</code>：<code>Collection</code> 是最基本集合接口，它定义了一组允许重复的对象。<code>Collection</code> 接口派生了三个子接口 <code>List</code>、<code>Set</code>和<code>Queue</code>。<code>Collection</code> 所有实现类的遍历都可以使用 <code>Iterator</code> 接口或者是 <code>foreach</code> 来循环。</p><ul><li><code>List</code>：<code>List</code>代表有序、可重复的集合。<ul><li><code>ArrayList</code>：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程不安全，效率高。<code>ArrayList</code> 创建时的大小为<code>0</code>；当加入第一个元素时，进行第一次扩容时，默认容量大小为<code>10</code>，每次扩容都以当前数组大小的1.5倍去扩容。</li><li><code>Vector</code>：底层使用数组的形式来实现，排列有序可重复，查询速度快、增删数据慢，线程安全，效率低。<code>Vector</code> 创建时的默认大小为<code>10</code>；<code>Vector</code> 每次扩容都以当前数组大小的<code>2</code>倍去扩容。当指定了 <code>capacityIncrement</code> 之后，每次扩容仅在原先基础上增加 <code>capacityIncrement</code> 个单位空间。<code>ArrayList</code> 和 <code>Vector</code> 的 <code>add</code>、<code>get</code>、<code>size</code> 方法的复杂度都为 <code>O(1)</code>，<code>remove</code> 方法的复杂度为 <code>O(n)</code>。<ul><li><code>Stack</code>：<code>Vector</code> 的一个子类，是标准的<strong>先进后出</strong>(FILO, First In Last Out)的栈。底层通过数组实现的，线程安全。</li></ul></li><li><code>LinkedList</code>：底层使用双向循环链表的数据结构来实现，排列有序可重复，查询速度慢、增删数据快，线程不安全。</li><li><code>CopyOnWriteArrayList</code>：底层使用 <code>Copy-On-Write</code> 的优化策略实现，适用于<strong>读多写少</strong>的场景，同 <code>ArrayList</code> 功能相似，线程安全。<code>CopyOnWriteArrayList</code> 在某些情况下比 <code>Collections.synchronizedList(List list)</code> 有更好的性能。缺点是：内存占用大和数据一致性问题，只能保证最终一致性。</li></ul></li><li><code>Set</code>：<code>Set</code>代表无序、不可重复的集合。<ul><li><code>HastSet</code>：底层使用<code>Hash</code>表来实现，内部使用了<code>HashMap</code>，排列无序不可重复，存取速度快，线程不安全。<ul><li><code>LinkedHashSet</code>：底层采用<code>Hash</code>表存储，并用双向链表记录插入顺序，排列有序不可重复，存取速度较<code>HashSet</code>略慢，比<code>TreeSet</code>快，线程不安全。</li></ul></li><li><code>TreeSet</code>：底层使用红黑树来实现，内部使用了<code>NavigableMap</code>，按自然顺序或者自定义顺序存放、不可重复，线程不安全。</li><li><code>CopyOnWriteArraySet</code>：底层使用<code>Copy-On-Write</code>的优化策略实现，适用于<strong>读多写少</strong>的场景，内部使用了<code>CopyOnWriteArrayList</code>，同<code>HastSet</code>功能相似，线程安全。</li><li><code>ConcurrentSkipListSet</code>：底层使用<strong>跳跃列表</strong>来实现，适用于<strong>高并发</strong>的场景，内部使用了<code>ConcurrentNavigableMap</code>，同<code>TreeSet</code>功能相似，线程安全。</li><li><code>EnumSet</code>：是抽象类，只能用来存储Enum常量或其子类，不能存储其它类型，<code>EnumSet</code>有两种实现方式，<code>RegularEnumSet</code>和<code>JumboEnumSet</code>，但是这两种实现方式是包<strong>私有</strong>的，不能在包外访问，因此必须使用工厂方法来创建并返回 <code>EnumSet</code> 实例，不能通过构造函数来创建。<code>EnumSet</code> 中提供了多种创建 <code>EnumSet</code> 实例的静态工厂方法，例如 <code>of</code> 方法（进行了函数重载），<code>copyOf</code>方法，<code>noneOf</code> 方法等。存储效率快，线程不安全。存储枚举常量时使用 <code>EnumSet</code> 而不要用 <code>HashSet</code>。</li></ul></li><li><code>Queue</code>：<code>Queue</code>是Java 5之后增加的集合体系，表示<strong>队列</strong>集合的相关实现，大多遵循<strong>先进先出</strong>(FIFO, First-In-First-Out)的模式。<ul><li><code>PriorityQueue</code>：即优先队列，底层基于<strong>优先堆的一个无界队列</strong>来实现，无界但可选容量界限。这个优先队列中的元素可以默认自然排序或者通过提供的<code>Comparator</code>（比较器）在队列实例化的时排序，而不是先进先出。不允许空值、不支持 <code>non-comparable</code>（不可比较）的对象，每次从队列中取出的是具有最高优先权的元素，线程不安全。</li><li><code>ArrayBlockingQueue</code>：底层基于<strong>定长数组</strong>的阻塞队列实现，即是线程安全的有界阻塞队列。<code>ArrayBlockingQueue</code>内部通过<strong>互斥锁</strong>保护竞争资源，实现了多线程对竞争资源的互斥访问。队列中的锁是没有分离的，所以在添加的同时就不能读取，读取的同时就不能添加，所以锁方面性能不如 <code>LinkedBlockingQueue</code>。</li><li><code>LinkedBlockingQueue</code>：即链接队列，底层基于<strong>单向链表</strong>的阻塞队列实现，无界但可选容量界限，线程安全。队列中的锁是分离的，即添加用的是 <code>putLock</code>，获取是 <code>takeLock</code>，所以在添加获取方面理论上性能会高于 <code>ArrayBlockingQueue</code>。所以 <code>LinkedBlockingQueue</code> 更适合实现生产者-消费者队列。</li><li><code>PriorityBlockingQueue</code>：即优先阻塞队列，底层基于<strong>优先堆的一个无界队列</strong>来实现，无界但可选容量界限的阻塞队列，线程安全，功能同 <code>PriorityQueue</code>、<code>LinkedBlockQueue</code> 相似。其所含对象的排序不是先进先出，而是依据对象的自然排序顺序或者是构造函数的 <code>Comparator</code> 决定的顺序。</li><li><code>SynchronousQueue</code>：即同步队列，是一种线程安全无缓冲的无界阻塞队列。其操作必须是放和取交替完成的，即每个 <code>put</code> 必须等待一个 <code>take</code>，反之亦然。</li><li><code>DelayQueue</code>：即延迟队列，是一种有序无界阻塞队列，只有在延迟期满时才能从中提取元素，线程安全。</li><li><code>ArrayDeque</code>：底层采用了循环数组的方式来完成双端队列的实现，无限扩展且可选容量。Java 已不推荐使用 <code>Stack</code>，而是推荐使用更高效的 <code>ArrayDeque</code> 来实现栈的功能，非线程安全。</li><li><code>LinkedBlockingDeque</code>：底层采用了<strong>双向链表</strong>实现的<strong>双端阻塞并发</strong>队列，无限扩展且可选容量。该阻塞队列同时支持 <code>FIFO</code> 和 <code>FILO</code> 两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>ConcurrentLinkedDeque</code>：底层采用了<strong>双向链表</strong>实现的<strong>双端非阻塞并发</strong>队列，无限扩展且可选容量。该队列同时支持 <code>FIFO</code> 和 <code>FILO</code> 两种操作方式，即可以从队列的头和尾同时操作(插入/删除)，且线程安全。</li><li><code>LinkedTransferQueue</code>：底层采用了<strong>单向链表</strong>实现的<strong>无界传输阻塞</strong>队列，先进先出，无限扩展且可选容量线程安全。</li></ul></li></ul><h3 id="Map-1"><a href="#Map-1" class="headerlink" title="Map"></a>Map</h3><p><code>Map</code>：<code>Map</code> 代表具有映射关系的集合。</p><ul><li><code>HashMap</code>：底层是用<strong>链表数组</strong>，<code>Java8</code> 后又加了<strong>红黑树</strong>来实现，键无序不可重复可为 null、值可重复可为 null，存取速度快，线程不安全。<ul><li><code>LinkedHashMap</code>：底层是用<strong>链表数组</strong>存储，并用双向链表记录插入顺序，键有序不可重复可为 null、值可重复可为 null，存取速度快较 <code>HashMap</code> 略慢，比 <code>TreeMap</code> 快，线程不安全。</li></ul></li><li><code>HashTable</code>：底层是用<strong>链表数组</strong>，键无序不可重复可为 null、值可重复可为 null，存取速度较 <code>HashMap</code> 慢，线程安全。<ul><li><code>Properties</code>：是 <code>HashTable</code> 的子类，是 &lt;String,String&gt; 的映射，比 <code>HashTable</code> 多了 <code>load</code>、<code>store</code> 两个方法，线程安全。</li></ul></li><li><code>TreeMap</code>：底层使用红黑树来实现，内部使用了 <code>Comparator</code>，按自然顺序或自定义顺序存放键，键不可重复不可为 null、值可重复可为 null，存取速度较 <code>HashMap</code> 慢，线程不安全。</li><li><code>EnumMap</code>：底层使用数组来实现，是专门为枚举类型量身定做的 Map，性能更好。只能接收同一枚举类型的实例作为键值，并且由于枚举类型实例的数量相对固定并且有限，所以 <code>EnumMap</code> 使用数组来存放与枚举类型对应的值，线程不安全。</li><li><code>WeakHashMap</code>：同 <code>HashMap</code> 基本相似。区别在于，<code>HashMap</code> 的 <code>key</code> 保留对象的强引用，这意味着只要该 <code>HashMap</code> 对象不被销毁，该 <code>HashMap</code> 对象所有 key 所引用的对象不会被垃圾回收，<code>HashMap</code> 也不会自动删除这些 <code>key</code> 所对应的 <code>key-value</code> 对象；但 <code>WeakHashMap</code> 的 <code>key</code> 只保留对实际对象的弱引用，这意味着当垃圾回收了该 <code>key</code> 所对应的实际对象后，<code>WeakHashMap</code> 会自动删除该 <code>key</code> 对应的 <code>key-value</code> 对象。</li><li><code>IdentityHashMap</code>：同 <code>HashMap</code> 基本相似。区别在于，在处理两个 <code>key</code> 相等时，对于普通 <code>HashMap</code> 而言，只要 <code>key1</code> 和 <code>key2</code> 通过 <code>equals</code> 比较返回 <code>true</code> 时就认为 key 相同；在 <code>IdentityHashMap</code> 中，当且仅当两个 <code>key</code> 严格相等时(<code>key1 = key2</code>)时才认为两个 <code>key</code> 相同。</li><li><code>ConcurrentHashMap</code>：底层使用<strong>锁分段</strong>技术来实现线程安全，首先将数据分成一段一段的存储，然后给每一段数据配一把锁，当一个线程占用锁访问其中一个段数据的时候，其他段的数据也能被其他线程访问。<code>ConcurrentHashMap</code> 是由 <code>Segment</code> 数组结构和 <code>HashEntry</code> 数组结构组成。<code>Segment</code> 是一种可重入锁 <code>ReentrantLock</code>，在 <code>ConcurrentHashMap</code> 里扮演锁的角色，<code>HashEntry</code> 则用于存储键值对数据。一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构， 一个 <code>Segment</code> 里包含一个 <code>HashEntry</code> 数组，每个 <code>HashEntry</code> 是一个链表结构的元素， 每个 <code>Segment</code> 守护者一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得它对应的 <code>Segment</code> 锁。</li><li><code>ConcurrentSkipListMap</code>：底层使用<strong>跳跃列表</strong>来实现，适用于<strong>高并发</strong>的场景，内部使用了 <code>ConcurrentNavigableMap</code>，同 <code>TreeMap</code> 功能相似，是一个并发的、可排序的 Map，线程安全。因此它可以在多线程环境中弥补 <code>ConcurrentHashMap</code> 不支持排序的问题。</li></ul><h3 id="思维导图"><a href="#思维导图" class="headerlink" title="思维导图"></a>思维导图</h3><p>Java 集合框架功能介绍思维导图如下：<br><img src="https://henleylee.github.io/medias/java/java_collections_mind.png" alt="Java 集合框架功能介绍思维导图"></p><h2 id="集合接口、类的方法"><a href="#集合接口、类的方法" class="headerlink" title="集合接口、类的方法"></a>集合接口、类的方法</h2><h3 id="Collection-接口中的抽象方法"><a href="#Collection-接口中的抽象方法" class="headerlink" title="Collection 接口中的抽象方法"></a>Collection 接口中的抽象方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>int size()</code></td><td>返回集合的大小</td></tr><tr><td><code>boolean isEmpty()</code></td><td>返回集合是否为空的布尔值</td></tr><tr><td><code>boolean contains(Object o)</code></td><td>返回集合是否包含元素 <code>o</code> 的布尔值</td></tr><tr><td><code>Iterator&lt;E&gt; iterator()</code></td><td>返回该集合中元素的迭代器，继承自 <code>Iterable</code> 接口</td></tr><tr><td><code>Object[] toArray()</code></td><td>返回一个包含此集合中所有元素的数组</td></tr><tr><td><code>&lt;T&gt; T[] toArray(T[] a)</code></td><td>返回一个包含此集合中所有元素的数组，返回类型由传入数组参数的类型决定</td></tr><tr><td><code>boolean add(E e)</code></td><td>返回向集合中插入元素 <code>e</code> 是否成功的布尔值</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>返回从集合中删除元素 <code>o</code> 是否成功的布尔值</td></tr><tr><td><code>boolean containsAll(Collection&lt;?&gt; c)</code></td><td>返回本集合中是否完全包含集合 <code>c</code> 的布尔值，即判断集合 <code>c</code> 是否是本集合子集</td></tr><tr><td><code>boolean addAll(Collection&lt;? extends E&gt; c)</code></td><td>将集合 <code>c</code> 中的所有元素添加到本集合中并返回</td></tr><tr><td><code>boolean removeAll(Collection&lt;?&gt; c)</code></td><td>移除本集合中所有包含集合 <code>c</code> 的所有元素</td></tr><tr><td><code>default boolean removeIf(Predicate&lt;? super E&gt; filter)</code></td><td>Java8 新增的接口默认方法。将会批量删除符合 filter 条件的所有元素，该方法需要一个 Predicate 对象作为作为参数，Predicate 也是函数式接口，因此可使用 Lambda 表达式作为参数</td></tr><tr><td><code>boolean retainAll(Collection&lt;?&gt; c)</code></td><td>返回本集合和集合 <code>c</code> 中相同的元素并存到本集合中，集合 <code>c</code> 保持不变，返回值表示的是本集合是否发生过改变。即该方法是用来求两个集合的交集，交集的结果存到本集合中，如果本集合没发生变化则返回 <code>true</code></td></tr><tr><td><code>void clear()</code></td><td>清空本集合中的所有元素</td></tr><tr><td><code>boolean equals(Object o)</code></td><td>返回本集合是否和对象 <code>o</code> 相等的布尔值</td></tr><tr><td><code>int hashCode()</code></td><td>返回此集合的 <code>Hash</code> 码值</td></tr><tr><td><code>default Spliterator&lt;E&gt; spliterator()</code></td><td>在集合中创建 <code>Spliterator</code> 对象</td></tr><tr><td><code>default Stream&lt;E&gt; stream()</code></td><td>返回一个顺序的 <code>Stream</code> 对象。Java8 引入了 Stream 以实现对集合更方便地进行函数式编程。</td></tr><tr><td><code>default Stream&lt;E&gt; parallelStream()</code></td><td>返回一个可能并行的 <code>Stream</code> 对象。Java8 新增的方法。流可以是顺序的也可以是并行的。顺序流的操作是在单线程上执行的，而并行流的操作是在多线程上并发执行的。</td></tr></tbody></table><h3 id="List-接口中的额外抽象方法"><a href="#List-接口中的额外抽象方法" class="headerlink" title="List 接口中的额外抽象方法"></a>List 接口中的额外抽象方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean addAll(int index, Collection&lt;? extends E&gt; c)</code></td><td>将指定集合 <code>c</code> 中的所有元素插入到指定索引位置处</td></tr><tr><td><code>default void replaceAll(UnaryOperator&lt;E&gt; operator)</code></td><td>Java8 新增的使用 <code>Lambda</code> 的方式，通过应用 <code>UnaryOperator</code> 获得的结果来替换列表中的每个元素</td></tr><tr><td><code>default void sort(Comparator&lt;? super E&gt; c)</code></td><td>在比较器的基础上将本列表排序</td></tr><tr><td><code>E get(int index)</code></td><td>获取本集合中指定索引位置处的元素</td></tr><tr><td><code>E set(int index, E element)</code></td><td>设置或替换本集合中指定索引位置处的元素</td></tr><tr><td><code>void add(int index, E element)</code></td><td>在本集合中的指定索引位置处插入指定的元素</td></tr><tr><td><code>E remove(int index)</code></td><td>移除本集合中指定索引位置处的元素</td></tr><tr><td><code>int indexOf(Object o)</code></td><td>返回指定元素第一次出现的索引位置</td></tr><tr><td><code>int lastIndexOf(Object o)</code></td><td>返回指定元素最后出现的索引位置</td></tr><tr><td><code>ListIterator&lt;E&gt; listIterator()</code></td><td>返回本集合中的 <code>ListIterator</code> 迭代器</td></tr><tr><td><code>ListIterator&lt;E&gt; listIterator(int index)</code></td><td>返回本集合中从指定索引位置开始的 <code>ListIterator</code> 迭代器</td></tr><tr><td><code>List&lt;E&gt; subList(int fromIndex, int toIndex)</code></td><td>返回指定开始和结束索引位置的子集合</td></tr></tbody></table><h3 id="Set-接口中的额外抽象方法"><a href="#Set-接口中的额外抽象方法" class="headerlink" title="Set 接口中的额外抽象方法"></a>Set 接口中的额外抽象方法</h3><p>Set 除了继承自 Collection 的方法之外，没有额外抽象方法。</p><h3 id="Map-接口中的抽象方法"><a href="#Map-接口中的抽象方法" class="headerlink" title="Map 接口中的抽象方法"></a>Map 接口中的抽象方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean containsKey</code></td><td>判断本 Map 集合中是否包含指定的 key 键</td></tr><tr><td><code>boolean containsValue</code></td><td>判断本 Map 集合中是否包含指定的 value 值</td></tr><tr><td><code>V get(Object key)</code></td><td>根据 key 获取本 Map 集合中的 value 值</td></tr><tr><td><code>V put(K key, V value)</code></td><td>向本 Map 集合中存放 key 键和 value 值，返回 value 值</td></tr><tr><td><code>V remove(Object key)</code></td><td>根据 key 删除本 Map 集合中的 key 和 value 值，并返回删除的 value值</td></tr><tr><td><code>void putAll(Map&lt;? extends K, ? extends V&gt; m)</code></td><td>将指定的 Map 集合添加到本的 Map 集合当中</td></tr><tr><td><code>Set&lt;K&gt; keySet()</code></td><td>获取本 Map 集合中的所有 key 值，并以 Set 接口的结果作为返回</td></tr><tr><td><code>Collection&lt;V&gt; values()</code></td><td>获取本 Map 集合中的所有 value 值，并以 Collection 接口的结果作为返回</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td>获取本 Map 集合中的所有 key 和 value 值，并以 <code>Set&lt;Map.Entry&lt;K, V&gt;&gt;</code> 的结果作为返回</td></tr><tr><td><code>default V getOrDefault(Object key, V defaultValue)</code></td><td>根据 key 获取本 Map 集合中的 value 值，如果没找到对应的值或者 value 值是 null，则返回 <code>defaultValue</code> 的值</td></tr><tr><td><code>default void forEach(BiConsumer&lt;? super K, ? super V&gt; action)</code></td><td>Java8 新增的使用 <code>Lambda</code> 的方式遍历操作 Map 中的元素的默认接口方法</td></tr><tr><td><code>default void replaceAll(BiFunction&lt;? super K, ? super V, ? extends V&gt; function)</code></td><td>Java8 新增的使用 <code>Lambda</code>的方式遍历替换 Map 中的元素的默认接口方法</td></tr><tr><td><code>default V putIfAbsent(K key, V value)</code></td><td>Java8 新增的不用写是否为 null 值的检测语句向 Map 中保存 key 和 value 的元素的默认接口方法，即如果通过 key 获取到的 value 是空的，则在调用 <code>put(key, value)</code> 方法并返回 value 值</td></tr><tr><td><code>default boolean remove(Object key, Object value)</code></td><td>Java8 新增的默认接口方法，删除给定 key 所对应的元素，如果 value 不存在、为 null 或者与参数中的 value 不等，则不能删除。即删除操作需要满足给定的值需要和 map 中的值相等的条件</td></tr><tr><td><code>default boolean replace(K key, V oldValue, V newValue)</code></td><td>Java8 新增的默认接口方法，替换给定 key 所对应的元素，如果 value 不存在、为 null 或者与参数中的 oldValue 不等，则不能替换。即替换操作需要满足给定的值需要和 map 中的值相等的条件</td></tr><tr><td><code>default V replace(K key, V value)</code></td><td>Java8 新增的默认接口方法，替换给定 key 所对应的元素，如果 value 不为 null，则 value 值与参数中的 value 值做替换</td></tr><tr><td><code>default V computeIfAbsent(K key, Function&lt;? super K, ? extends V&gt; mappingFunction)</code></td><td>Java8 新增的默认接口方法，根据key获取到的 value 如果不为 null，则直接返回 value 值，否则将 <code>Lambda</code> 表达式中的结果值存放到 Map 中</td></tr><tr><td><code>default V computeIfPresent(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code></td><td>Java8 新增的默认接口方法，根据 key获取到的 value 和新计算的值如果不为 null，则直接新计算的值，否则移除该 key，且返回 null</td></tr><tr><td><code>default V compute(K key, BiFunction&lt;? super K, ? super V, ? extends V&gt; remappingFunction)</code></td><td>Java8 新增的默认接口方法，将 <code>Lambda</code> 表达式中的结果值存放到Map中，如果计算的新值为 null 则返回 null，且移除以前有的 key 和 value 值</td></tr><tr><td><code>default V merge(K key, V value, BiFunction&lt;? super V, ? super V, ? extends V&gt; remappingFunction)</code></td><td>Java8 新增的默认接口方法，将新计算的值覆盖 Map 中原 key 对应的 value 值</td></tr></tbody></table><h3 id="SortedSet接口中的额外抽象方法"><a href="#SortedSet接口中的额外抽象方法" class="headerlink" title="SortedSet接口中的额外抽象方法"></a>SortedSet接口中的额外抽象方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Comparator&lt;? super E&gt; comparator()</code></td><td>返回本 SortedSet 集合中的 <code>Comparator</code> 比较器</td></tr><tr><td><code>SortedSet&lt;E&gt; subSet(E fromElement, E toElement)</code></td><td>获取开始元素和结束元素之间的子 SortedSet 集合</td></tr><tr><td><code>SortedSet&lt;E&gt; headSet(E toElement)</code></td><td>获取开始元素和 <code>toElement</code> 元素之间的子 SortedSet 集合</td></tr><tr><td><code>SortedSet&lt;E&gt; tailSet(E fromElement)</code></td><td>获取 <code>fromElement</code> 元素和结束元素之间的子 SortedSet 集合</td></tr><tr><td><code>E first()</code></td><td>获取本 SortedSet 集合中的第一个元素</td></tr><tr><td><code>E last()</code></td><td>获取本 SortedSet 集合中的最后一个元素</td></tr></tbody></table><h3 id="SortedMap接口中的额外抽象方法"><a href="#SortedMap接口中的额外抽象方法" class="headerlink" title="SortedMap接口中的额外抽象方法"></a>SortedMap接口中的额外抽象方法</h3><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Comparator&lt;? super K&gt; comparator()</code></td><td>返回本 SortedMap 集合中的 <code>Comparator</code> 比较器</td></tr><tr><td><code>SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey)</code></td><td>获取开始 key 和结束 key 之间的子 SortedMap 集合</td></tr><tr><td><code>SortedMap&lt;K,V&gt; headMap(K toKey)</code></td><td>获取开始 key 和 <code>toKey</code> 元素之间的子 SortedMap 集合</td></tr><tr><td><code>SortedMap&lt;K,V&gt; tailMap(K fromKey)</code></td><td>获取 <code>fromKey</code> 元素和结束key之间的子 SortedMap 集合</td></tr><tr><td><code>K firstKey()</code></td><td>获取本 SortedMap 集合中的第一个 key</td></tr><tr><td><code>K lastKey()</code></td><td>获取本 SortedMap 集合中的最后一个 key</td></tr><tr><td><code>Set&lt;K&gt; keySet()</code></td><td>获取本 SortedMap 集合中所有 key 的 Set 集合</td></tr><tr><td><code>Collection&lt;V&gt; values()</code></td><td>获取本 SortedMap 集合中所有 value 的 Collection 集合</td></tr><tr><td><code>Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet()</code></td><td>获取本 SortedMap 集合中所有 key 和 value 的 Map 集合</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 集合 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 数据结构与算法概述</title>
      <link href="/posts/2018/8359917f.html"/>
      <url>/posts/2018/8359917f.html</url>
      
        <content type="html"><![CDATA[<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><p>数据结构是计算机存储、组织数据的方式。数据结构是指相互之间存在一种或多种特定关系的数据元素的集合。通常情况下，精心选择的数据结构可以带来更高的运行或者存储效率。数据结构往往同高效的检索算法和索引技术有关。</p><h3 id="数据结构的基本功能"><a href="#数据结构的基本功能" class="headerlink" title="数据结构的基本功能"></a>数据结构的基本功能</h3><p>不同的数据结构其操作集不同，但下列基本功能必不可缺：</p><ul><li>如何插入一条新的数据项；</li><li>如何寻找某一特定的数据项；</li><li>如何删除某一特定的数据项；</li><li>如何迭代的访问各个数据项，以便进行显示或其他操作。</li></ul><h3 id="常见的数据结构"><a href="#常见的数据结构" class="headerlink" title="常见的数据结构"></a>常见的数据结构</h3><p>常见的数据结构包含：数组(Array)、栈(Stack)、队列(Queue)、链表(Linked List)、树(Tree)、哈希表(Hash)、堆(Heap)、图(Graph)。</p><p>下表示常见的几种数据结构的特性：</p><table><thead><tr><th>数据结构</th><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>数组</td><td>插入快，如果知道下标，可以非常快地存取</td><td>查找慢，删除慢，大小固定，只能存储单一元素</td></tr><tr><td>有序数组</td><td>比无序的数据查找快</td><td>插入慢，删除慢，大小固定，只能存储单一元素</td></tr><tr><td>栈</td><td>提供后进先出方式的存取</td><td>存取其他项很慢</td></tr><tr><td>队列</td><td>提供先进先出方式的存取</td><td>存取其他项很慢</td></tr><tr><td>链表</td><td>插入快，删除快</td><td>查找慢</td></tr><tr><td>二叉树</td><td>如果树是平衡的，查找、插入、删除都快</td><td>删除算法复杂</td></tr><tr><td>红黑树</td><td>查找、插入、删除都快。树总是平衡的</td><td>算法复杂</td></tr><tr><td>2-3-4树</td><td>查找、插入、删除都快。树总是平衡的。类似的树对磁盘存储有用</td><td>算法复杂</td></tr><tr><td>哈希表</td><td>如果关键字已知则存取极快。插入快</td><td>删除慢，如果不知道关键字则存取很慢，对存储空间使用不充分</td></tr><tr><td>堆</td><td>插入、删除快，对最大数据项的存取很快</td><td>对其他数据项存取慢</td></tr><tr><td>图</td><td>对现实世界建模</td><td>有些算法且复杂</td></tr></tbody></table><h2 id="算法"><a href="#算法" class="headerlink" title="算法"></a>算法</h2><p>算法(Algorithm)是指解题方案的准确而完整的描述，是一系列解决问题的清晰指令，算法代表着用系统的方法描述解决问题的策略机制。也就是说，能够对一定规范的输入，在有限时间内获得所要求的输出。如果一个算法有缺陷，或不适合于某个问题，执行这个算法将不会解决这个问题。不同的算法可能用不同的时间、空间或效率来完成同样的任务。一个算法的优劣可以用空间复杂度与时间复杂度来衡量。</p><p>在 Java 中，算法通常都是由类的方法来实现的。前面的数据结构，比如链表为啥插入、删除快，而查找慢，平衡的二叉树插入、删除、查找都快，这都是实现这些数据结构的算法所造成的。后面我们讲的各种排序实现也是算法范畴的重要领域。</p><h3 id="算法的五个特征"><a href="#算法的五个特征" class="headerlink" title="算法的五个特征"></a>算法的五个特征</h3><p>一个算法应该具有以下五个重要的特征：</p><ul><li><strong><code>有穷性(Finiteness)：</code></strong>算法的有穷性是指算法必须能在执行有限个步骤之后终止。</li><li><strong><code>确定性(Definiteness)：</code></strong>在每种情况下所应执行的操作，在算法中都有确切的规定，使算法的执行者或阅读者都能明确其含义及如何执行，并且在任何条件下，算法都只有一条执行路径。</li><li><strong><code>可行性(Effectiveness)：</code></strong>算法中执行的任何计算步骤都是可以被分解为基本的可执行的操作步，即每个计算步都可以在有限时间内完成(也称之为有效性)。</li><li><strong><code>有输入(Input)：</code></strong>一个算法有0个或多个输入，以刻画运算对象的初始情况，所谓0个输入是指算法本身定出了初始条件。</li><li><strong><code>有输出(Output)：</code></strong>个算法有一个或多个输出，以反映对输入数据加工后的结果，没有输出的算法是毫无意义的。</li></ul><h3 id="算法的设计原则"><a href="#算法的设计原则" class="headerlink" title="算法的设计原则"></a>算法的设计原则</h3><p>一个算法应该具有以下四个重要的设计原则：</p><ul><li>正确性：算法至少应该具有输入、输出和加工处理无歧义性、能正确反映问题的需要、能够得到问题的正确答案。<blockquote><p>算法的“正确”通常在用法上有很大的差别，大体分为以下4个层次：<br>① 算法程序没有语法错误；<br>② 算法程序能够根据正确的输入的值得到满足要求的输出结果；<br>③ 算法程序能够根据错误的输出的值满足规格说明的输出结果；<br>④ 算法程序对于精心设计、极其刁难的测试数据都能满足要求的输出结果。<br>对于这4层含义，层次 <code>①</code> 要求最低，因为仅仅没有语法错误实在谈不上是好的算法。而层次 <code>④</code> 是最困难的，人们几乎不可能逐一验证所有的输入都得到正确的结果。<br>因此，算法的正确性在大部分情况下都不可能用程序来证明，而是用数学方法证明的。证明一个复杂算法在所有层次上都是正确的，代价非常昂贵。所以一般情况下，人们把层次 <code>③</code> 作为一个算法是否正确的标准。</p></blockquote></li><li>可读性：算法为了人的阅读与交流，其次才是计算机执行。因此算法应该易于人的理解；另一方面，晦涩难懂的程序易于隐藏较多的错误而难以调试。</li><li>健壮性：当输入的数据非法时，算法应当恰当的做出反应或进行相应处理，而不是产生莫名其妙的输出结果。并且，处理出错的方法不应是中断程序执行，而是应当返回一个表示错误或错误性质的值，以便在更高的抽象层次上进行处理。</li><li>高效与低存储：通常算法效率值得是算法执行时间；存储量是指算法执行过程中所需要的最大存储空间，两者都与问题的规模有关。<blockquote><p>在满足以上几点以后，还可以考虑对算法进程进一步优化，尽量满足时间效率高和空间存储量低的需求。</p></blockquote></li></ul><h3 id="算法的设计步骤"><a href="#算法的设计步骤" class="headerlink" title="算法的设计步骤"></a>算法的设计步骤</h3><p>算法设计的一般过程可以归纳为以下几个步骤：</p><ul><li>建立数学模型；</li><li>通过对问题进行详细的分析，抽象出相应的数学模型；</li><li>确定数据结构与算法；</li><li>确定使用的数据结构，并在此基础上设计对此数据结构实施各种操作的算法；</li><li>选用语言；</li><li>选用某种语言将算法转化成程序；</li><li>调试并运行；</li><li>调试并运行这些程序。</li></ul><h3 id="算法的基本思想"><a href="#算法的基本思想" class="headerlink" title="算法的基本思想"></a>算法的基本思想</h3><h4 id="穷举算法思想"><a href="#穷举算法思想" class="headerlink" title="穷举算法思想"></a>穷举算法思想</h4><p>穷举算法思想就是从所有的可能结果中一个一个的试验，知道试出正确的结果。具体的操作步骤如下：</p><ol><li>对每一种可能的结果，计算其结果；</li><li>判断结果是否符合题目要求，如果符合则该结果正确，如果不符合则继续进行第1步骤。</li></ol><blockquote><p>穷举算法思想的经典例子为鸡兔同笼为题（又称龟鹤同笼问题）。</p></blockquote><h4 id="递推算法思想"><a href="#递推算法思想" class="headerlink" title="递推算法思想"></a>递推算法思想</h4><p>递推算法算法就是根据已知条件，利用特定关系推导出中间推论，直到得到结果的算法。其执行过程如下：</p><ol><li>根据已知结果和关系，求解中间结果。</li><li>判断是否达到要求，如果没有达到，则继续根据已知结果和关系求解中间结果。如果满足要求，则表示寻找到一个正确答案。</li></ol><blockquote><p>递推算法思想最经典的例子是斐波那契数列 : 1,1,2,3,5,8,13……</p></blockquote><h4 id="递归算法思想"><a href="#递归算法思想" class="headerlink" title="递归算法思想"></a>递归算法思想</h4><p>递归算法思想是把大问题转换成同类问题的子问题，然后递归调用函数表示问题的解。在使用递归的时候一定要注意调回递归函数的终止条件。</p><p>递归算法的分类：</p><ul><li>直接递归：在函数中调用自身。</li><li>间接递归：在函数中调用另外一个函数，然后在另外一个函数中再调用该函数(用得不多)。</li></ul><blockquote><p>递归算法比较经典的例子是求阶乘。</p></blockquote><h4 id="分治算法思想"><a href="#分治算法思想" class="headerlink" title="分治算法思想"></a>分治算法思想</h4><p>分治算法思想就是把一个大问题分解成若干个规模较小的子问题，且这些子问题的都是相互独立的、与原问题性质一致。逐个求出这些子问题的解就能够得到原问题的解了。其执行过程如下：</p><ol><li>对于一个规模为 N 的问题，若该问题可以容易地解决（比如说规模 N 较小），则直接解决，否则执行下面的步骤。</li><li>将该问题分解为 M 个规模较小的子问题，这些子问题互相独立，并且与原问题形式相同。</li><li>递归的解子问题。</li><li>然后，将各子问题的解合并到原问题的解。</li></ol><blockquote><p>分治算法思想有一个比较经典的例子就是查找假币问题。</p></blockquote><h4 id="概率算法思想"><a href="#概率算法思想" class="headerlink" title="概率算法思想"></a>概率算法思想</h4><p>概率算法主要包括四种算法：</p><ul><li>数值概率算法：数值问题的求解，最优化问题的近似解。</li><li>蒙特卡罗算法：判定问题的准确解，不一定正确。</li><li>拉斯维加斯算法：不一定会得到解，但得到的解一定是正确解。</li><li>舍伍德算法：总能求得一个解，且一定是正确解。</li></ul><h2 id="Java-数据结构"><a href="#Java-数据结构" class="headerlink" title="Java 数据结构"></a>Java 数据结构</h2><p>Java 工具包提供了强大的数据结构。在 Java 中的数据结构主要包括以下几种接口和类：</p><ul><li><strong><code>枚举(Enumeration)：</code></strong>Enumeration 接口中定义了一些方法，通过这些方法可以枚举(一次获得一个)对象集合中的元素。</li><li><strong><code>位集合(BitSet)：</code></strong>BitSet 实现了一组可以单独设置和清除的位或标志。</li><li><strong><code>向量(Vector)：</code></strong>Vector 类实现了一个动态数组。</li><li><strong><code>栈(Stack)：</code></strong>Stack 实现了一个后进先出(LIFO)的数据结构。</li><li><strong><code>字典(Dictionary)：</code></strong>Dictionary 定义了键映射到值的数据结构。</li><li><strong><code>哈希表(Hashtable)：</code></strong>Hashtable 提供了一种在用户定义键结构的基础上来组织数据的手段。</li><li><strong><code>属性(Properties)：</code></strong>Properties 表示一个持久的属性集。</li></ul><h3 id="枚举-Enumeration"><a href="#枚举-Enumeration" class="headerlink" title="枚举(Enumeration)"></a>枚举(Enumeration)</h3><p><strong><code>枚举(Enumeration)</code></strong>接口虽然它本身不属于数据结构，但它在其他数据结构的范畴里应用很广。 枚举(Enumeration)接口中定义了一些方法，通过这些方法可以枚举(一次获得一个)对象集合中的元素。<br>这种传统接口已被迭代器取代，虽然 Enumeration 还未被遗弃，但在现代代码中已经被很少使用了。尽管如此，它还是使用在诸如 Vector 和 Properties 这些传统类所定义的方法中，除此之外，还用在一些 API 类，并且在应用程序中也广泛被使用。 下表总结了一些 Enumeration 声明的方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean hasMoreElements()</code></td><td>判断此枚举是否包含更多的元素</td></tr><tr><td><code>Object nextElement()</code></td><td>如果此枚举对象至少还有一个可提供的元素，则返回下一个元素的枚举</td></tr></tbody></table><blockquote><p>枚举可用作<code>常量</code>、<code>swicth 语句</code>，枚举中也可以<code>添加参数和方法</code>，每个枚举对象可以用作一个带方法和属性的实例对象。</p></blockquote><h3 id="位集合-BitSet"><a href="#位集合-BitSet" class="headerlink" title="位集合(BitSet)"></a>位集合(BitSet)</h3><p><strong><code>位集合(BitSet)</code></strong>实现了一组可以单独设置和清除的位或标志。该类在处理一组布尔值的时候非常有用，只需要给每个值赋值一”位”，然后对位进行适当的设置或清除，就可以对布尔值进行操作了。</p><p>一个 Bitset 类创建一种特殊类型的数组来保存位值。BitSet 中数组大小会随需要增加。</p><p>BitSet 定义了两个构造方法：</p><ul><li><p>第一个构造方法创建一个默认的对象：</p><pre class=" language-java"><code class="language-java"> <span class="token function">BitSet</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li><p>第二个方法允许用户指定初始大小，所有位初始化为0：</p><pre class=" language-java"><code class="language-java"> <span class="token function">BitSet</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span></code></pre></li></ul><p>BitSet 中实现了 Cloneable 接口中定义的方法如下表所列：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void and(BitSet set)</code></td><td>对此目标位 set 和参数位 set 执行逻辑与操作</td></tr><tr><td><code>void andNot(BitSet set)</code></td><td>清除此 BitSet 中所有的位，其相应的位在指定的 BitSet 中已设置</td></tr><tr><td><code>int cardinality()</code></td><td>返回此 BitSet 中设置为 true 的位数</td></tr><tr><td><code>void clear()</code></td><td>将此 BitSet 中的所有位设置为 false</td></tr><tr><td><code>void clear(int index)</code></td><td>将索引指定处的位设置为 false</td></tr><tr><td><code>void clear(int startIndex, int endIndex)</code></td><td>将指定的 fromIndex(包括)到指定的 toIndex(不包括)范围内的位设置为 false</td></tr><tr><td><code>Object clone()</code></td><td>复制此 BitSet，生成一个与之相等的新 BitSet</td></tr><tr><td><code>boolean equals(Object bitSet)</code></td><td>将此对象与指定的对象进行比较</td></tr><tr><td><code>void flip(int index)</code></td><td>将指定索引处的位设置为其当前值的补码</td></tr><tr><td><code>void flip(int startIndex, int endIndex)</code></td><td>将指定的 fromIndex(包括)到指定的 toIndex(不包括)范围内的每个位设置为其当前值的补码</td></tr><tr><td><code>boolean get(int index)</code></td><td>返回指定索引处的位值</td></tr><tr><td><code>BitSet get(int startIndex, int endIndex)</code></td><td>返回一个新的 BitSet，它由此 BitSet 中从 fromIndex(包括)到 toIndex(不包括)范围内的位组成</td></tr><tr><td><code>boolean intersects(BitSet bitSet)</code></td><td>如果指定的 BitSet 中有设置为 true 的位，并且在此 BitSet 中也将其设置为 true，则返回 true</td></tr><tr><td><code>boolean isEmpty()</code></td><td>如果此 BitSet 中没有包含任何设置为 true 的位，则返回 true</td></tr><tr><td><code>int length()</code></td><td>返回此 BitSet 的”逻辑大小”：BitSet 中最高设置位的索引加 1</td></tr><tr><td><code>int nextClearBit(int startIndex)</code></td><td>返回第一个设置为 false 的位的索引，这发生在指定的起始索引或之后的索引上</td></tr><tr><td><code>int nextSetBit(int startIndex)</code></td><td>返回第一个设置为 true 的位的索引，这发生在指定的起始索引或之后的索引上</td></tr><tr><td><code>void or(BitSet bitSet)</code></td><td>对此位 set 和位 set 参数执行逻辑或操作</td></tr><tr><td><code>void set(int index)</code></td><td>将指定索引处的位设置为 true</td></tr><tr><td><code>void set(int index, boolean v)</code></td><td>将指定索引处的位设置为指定的值</td></tr><tr><td><code>void set(int startIndex, int endIndex)</code></td><td>将指定的 fromIndex(包括)到指定的 toIndex(不包括)范围内的位设置为 true</td></tr><tr><td><code>void set(int startIndex, int endIndex, boolean v)</code></td><td>将指定的 fromIndex(包括)到指定的 toIndex(不包括)范围内的位设置为指定的值</td></tr><tr><td><code>int size()</code></td><td>返回此 BitSet 表示位值时实际使用空间的位数</td></tr><tr><td><code>void xor(BitSet bitSet)</code></td><td>对此位 set 和位 set 参数执行逻辑异或操作</td></tr><tr><td><code>void xor(BitSet bitSet)</code></td><td>对此位 set 和位 set 参数执行逻辑异或操作</td></tr><tr><td><code>String toString()</code></td><td>返回此位 set 的字符串表示形式</td></tr></tbody></table><h3 id="向量-Vector"><a href="#向量-Vector" class="headerlink" title="向量(Vector)"></a>向量(Vector)</h3><p><strong><code>向量(Vector)</code></strong>类实现了一个动态数组。和ArrayList和相似，但是两者是不同的：</p><ul><li>Vector 是同步访问的。</li><li>Vector 包含了许多传统的方法，这些方法不属于集合框架。</li></ul><p>Vector 主要用在事先不知道数组的大小，或者只是需要一个可以改变大小的数组的情况。</p><p>Vector 类支持4种构造方法：</p><ul><li><p>第一种构造方法创建一个默认的向量，默认大小为10：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li><p>第二种构造方法创建指定大小的向量：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span></code></pre></li><li><p>第三种构造方法创建指定大小的向量，并且增量用 incr 指定. 增量表示向量每次增加的元素数目：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Vector</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span><span class="token keyword">int</span> incr<span class="token punctuation">)</span></code></pre></li><li><p>第四种构造方法创建一个包含集合 c 元素的向量：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Vector</span><span class="token punctuation">(</span>Collection c<span class="token punctuation">)</span></code></pre></li></ul><p>除了从父类继承的方法外 Vector 还定义了以下方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void add(int index, Object element)</code></td><td>在此向量的指定位置插入指定的元素</td></tr><tr><td><code>boolean add(Object o)</code></td><td>将指定元素添加到此向量的末尾</td></tr><tr><td><code>boolean addAll(Collection c)</code></td><td>将指定 Collection 中的所有元素添加到此向量的末尾，按照指定 collection 的迭代器所返回的顺序添加这些元素</td></tr><tr><td><code>boolean addAll(int index, Collection c)</code></td><td>在指定位置将指定 Collection 中的所有元素插入到此向量中</td></tr><tr><td><code>void addElement(Object obj)</code></td><td>将指定的组件添加到此向量的末尾，将其大小增加 1</td></tr><tr><td><code>int capacity()</code></td><td>返回此向量的当前容量</td></tr><tr><td><code>void clear()</code></td><td>从此向量中移除所有元素</td></tr><tr><td><code>Object clone()</code></td><td>返回向量的一个副本</td></tr><tr><td><code>boolean contains(Object elem)</code></td><td>如果此向量包含指定的元素，则返回 true</td></tr><tr><td><code>boolean containsAll(Collection c)</code></td><td>如果此向量包含指定 Collection 中的所有元素，则返回 true</td></tr><tr><td><code>void copyInto(Object[] anArray)</code></td><td>将此向量的组件复制到指定的数组中</td></tr><tr><td><code>Object elementAt(int index)</code></td><td>返回指定索引处的组件</td></tr><tr><td><code>Enumeration elements()</code></td><td>返回此向量的组件的枚举</td></tr><tr><td><code>void ensureCapacity(int minCapacity)</code></td><td>增加此向量的容量(如有必要)，以确保其至少能够保存最小容量参数指定的组件数</td></tr><tr><td><code>boolean equals(Object o)</code></td><td>比较指定对象与此向量的相等性</td></tr><tr><td><code>Object firstElement()</code></td><td>返回此向量的第一个组件(位于索引 0) 处的项)</td></tr><tr><td><code>Object get(int index)</code></td><td>返回向量中指定位置的元素</td></tr><tr><td><code>int hashCode()</code></td><td>返回此向量的哈希码值</td></tr><tr><td><code>int indexOf(Object elem)</code></td><td>返回此向量中第一次出现的指定元素的索引，如果此向量不包含该元素，则返回 -1</td></tr><tr><td><code>int indexOf(Object elem, int index)</code></td><td>返回此向量中第一次出现的指定元素的索引，从 index 处正向搜索，如果未找到该元素，则返回 -1</td></tr><tr><td><code>void insertElementAt(Object obj, int index)</code></td><td>将指定对象作为此向量中的组件插入到指定的 index 处</td></tr><tr><td><code>boolean isEmpty()</code></td><td>测试此向量是否不包含组件</td></tr><tr><td><code>Object lastElement()</code></td><td>返回此向量的最后一个组件</td></tr><tr><td><code>int lastIndexOf(Object elem)</code></td><td>返回此向量中最后一次出现的指定元素的索引；如果此向量不包含该元素，则返回 -1</td></tr><tr><td><code>int lastIndexOf(Object elem, int index)</code></td><td>返回此向量中最后一次出现的指定元素的索引，从 index 处逆向搜索，如果未找到该元素，则返回 -1</td></tr><tr><td><code>Object remove(int index)</code></td><td>移除此向量中指定位置的元素</td></tr><tr><td><code>boolean remove(Object o)</code></td><td>移除此向量中指定元素的第一个匹配项，如果向量不包含该元素，则元素保持不变</td></tr><tr><td><code>boolean removeAll(Collection c)</code></td><td>从此向量中移除包含在指定 Collection 中的所有元素</td></tr><tr><td><code>void removeAllElements()</code></td><td>从此向量中移除全部组件，并将其大小设置为零</td></tr><tr><td><code>boolean removeElement(Object obj)</code></td><td>从此向量中移除变量的第一个(索引最小的)匹配项</td></tr><tr><td><code>void removeElementAt(int index)</code></td><td>删除指定索引处的组件</td></tr><tr><td><code>protected void removeRange(int fromIndex, int toIndex)</code></td><td>从此 List 中移除其索引位于 fromIndex(包括)与 toIndex(不包括)之间的所有元素</td></tr><tr><td><code>boolean retainAll(Collection c)</code></td><td>在此向量中仅保留包含在指定 Collection 中的元素</td></tr><tr><td><code>Object set(int index, Object element)</code></td><td>用指定的元素替换此向量中指定位置处的元素</td></tr><tr><td><code>void setElementAt(Object obj, int index)</code></td><td>将此向量指定 index 处的组件设置为指定的对象</td></tr><tr><td><code>void setSize(int newSize)</code></td><td>设置此向量的大小</td></tr><tr><td><code>int size()</code></td><td>返回此向量中的组件数</td></tr><tr><td><code>List subList(int fromIndex, int toIndex)</code></td><td>返回此 List 的部分视图，元素范围为从 fromIndex(包括)到 toIndex(不包括)</td></tr><tr><td><code>Object[] toArray()</code></td><td>返回一个数组，包含此向量中以恰当顺序存放的所有元素</td></tr><tr><td><code>Object[] toArray(Object[] a)</code></td><td>返回一个数组，包含此向量中以恰当顺序存放的所有元素；返回数组的运行时类型为指定数组的类型</td></tr><tr><td><code>String toString()</code></td><td>返回此向量的字符串表示形式，其中包含每个元素的 String 表示形式</td></tr><tr><td><code>void trimToSize()</code></td><td>对此向量的容量进行微调，使其等于向量的当前大小</td></tr></tbody></table><h3 id="栈-Stack"><a href="#栈-Stack" class="headerlink" title="栈(Stack)"></a>栈(Stack)</h3><p><strong><code>栈(Stack)</code></strong>是 Vector 的一个子类，实现了一个后进先出(LIFO)的数据结构。</p><p>可以把栈理解为对象的垂直分布的栈，当添加一个新元素时，就将新元素放在其他元素的顶部。当从栈中取元素的时候，就从栈顶取一个元素。换句话说，最后进栈的元素最先被取出。</p><p>堆栈只定义了默认构造函数，用来创建一个空栈：</p><pre class=" language-java"><code class="language-java"><span class="token function">Stack</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p>除了由 Vector 定义的所有方法，Stack 还定义了以下方法：：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>boolean empty()</code></td><td>测试堆栈是否为空</td></tr><tr><td><code>Object peek()</code></td><td>查看堆栈顶部的对象，但不从堆栈中移除它</td></tr><tr><td><code>Object pop()</code></td><td>移除堆栈顶部的对象，并作为此函数的值返回该对象</td></tr><tr><td><code>Object push(Object element)</code></td><td>把项压入堆栈顶部</td></tr><tr><td><code>int search(Object element)</code></td><td>返回对象在堆栈中的位置，以 1 为基数</td></tr></tbody></table><h3 id="字典-Dictionary"><a href="#字典-Dictionary" class="headerlink" title="字典(Dictionary)"></a>字典(Dictionary)</h3><p><strong><code>字典(Dictionary)</code></strong>类是一个抽象类，用来存储键/值对，作用和 Map 类相似。</p><p>Dictionary 定义的抽象方法如下表所示：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>Enumeration elements()</code></td><td>返回此 dictionary 中值的枚举</td></tr><tr><td><code>Object get(Object key)</code></td><td>返回此 dictionary 中该键所映射到的值</td></tr><tr><td><code>boolean isEmpty()</code></td><td>测试此 dictionary 是否不存在从键到值的映射</td></tr><tr><td><code>Enumeration keys()</code></td><td>返回此 dictionary 中的键的枚举</td></tr><tr><td><code>Object put(Object key, Object value)</code></td><td>将指定 key 映射到此 dictionary 中指定 value</td></tr><tr><td><code>Object remove(Object key)</code></td><td>从此 dictionary 中移除 key (及其相应的 value)</td></tr><tr><td><code>int size()</code></td><td>返回此 dictionary 中条目(不同键)的数量</td></tr></tbody></table><blockquote><p>Dictionary 类已经过时了。在实际开发中，你可以实现 Map 接口来获取键/值的存储功能。</p></blockquote><h3 id="哈希表-Hashtable"><a href="#哈希表-Hashtable" class="headerlink" title="哈希表(Hashtable)"></a>哈希表(Hashtable)</h3><p><strong><code>哈希表(Hashtable)</code></strong>类提供了一种在用户定义键结构的基础上来组织数据的手段。Hashtable 是原始的 java.util 的一部分，是一个 Dictionary 具体的实现。</p><p>哈希表键的具体含义完全取决于哈希表的使用情景和它包含的数据。Hashtable 现在集成到了集合框架中。它和 HashMap 类很相似，但是它支持同步。</p><p>像 HashMap 一样，Hashtable 在哈希表中存储键/值对。当使用一个哈希表，要指定用作键的对象，以及要链接到该键的值。然后，该键经过哈希处理，所得到的散列码被用作存储在该表中值的索引。</p><p>Hashtable 定义了四个构造方法：</p><ul><li><p>第一个是默认构造方法：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Hashtable</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li><p>第二个构造函数创建指定大小的哈希表：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Hashtable</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">)</span></code></pre></li><li><p>第三个构造方法创建了一个指定大小的哈希表，并且通过 fillRatio 指定填充比例(填充比例必须介于0.0和1.0之间，它决定了哈希表在重新调整大小之前的充满程度)：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Hashtable</span><span class="token punctuation">(</span><span class="token keyword">int</span> size<span class="token punctuation">,</span><span class="token keyword">float</span> fillRatio<span class="token punctuation">)</span></code></pre></li><li><p>第四个构造方法创建了一个以M中元素为初始化元素的哈希表(哈希表的容量被设置为M的两倍)：</p><pre class=" language-java"><code class="language-java"> <span class="token function">Hashtable</span><span class="token punctuation">(</span>Map m<span class="token punctuation">)</span></code></pre></li></ul><p>Hashtable 中除了从 Map 接口中定义的方法外，还定义了以下方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>void clear()</code></td><td>将此哈希表清空，使其不包含任何键</td></tr><tr><td><code>Object clone()</code></td><td>创建此哈希表的浅表副本</td></tr><tr><td><code>boolean contains(Object value)</code></td><td>测试此映射表中是否存在与指定值关联的键</td></tr><tr><td><code>boolean containsKey(Object key)</code></td><td>测试指定对象是否为此哈希表中的键</td></tr><tr><td><code>boolean containsValue(Object value)</code></td><td>如果此 Hashtable 将一个或多个键映射到此值，则返回 true</td></tr><tr><td><code>Enumeration elements()</code></td><td>返回此哈希表中的值的枚举</td></tr><tr><td><code>Object get(Object key)</code></td><td>返回指定键所映射到的值，如果此映射不包含此键的映射，则返回 null</td></tr><tr><td><code>boolean isEmpty()</code></td><td>测试此哈希表是否没有键映射到值</td></tr><tr><td><code>Enumeration keys()</code></td><td>返回此哈希表中的键的枚举</td></tr><tr><td><code>Object put(Object key, Object value)</code></td><td>将指定 key 映射到此哈希表中的指定 value</td></tr><tr><td><code>void rehash()</code></td><td>增加此哈希表的容量并在内部对其进行重组，以便更有效地容纳和访问其元素</td></tr><tr><td><code>Object remove(Object key)</code></td><td>从哈希表中移除该键及其相应的值</td></tr><tr><td><code>int size()</code></td><td>返回此哈希表中的键的数量</td></tr></tbody></table><h3 id="属性-Properties"><a href="#属性-Properties" class="headerlink" title="属性(Properties)"></a>属性(Properties)</h3><p><strong><code>属性(Properties)</code></strong>继承于 Hashtable。Properties 类表示了一个持久的属性集。属性列表中每个键及其对应值都是一个字符串。</p><p>Properties 类被许多 Java 类使用。例如，在获取环境变量时它就作为 System.getProperties() 方法的返回值。</p><p>Properties 定义如下实例变量，这个变量持有一个 Properties 对象相关的默认属性列表：</p><pre class=" language-java"><code class="language-java">Properties defaults<span class="token punctuation">;</span></code></pre><p>Properties 类定义了两个构造方法：</p><ul><li>第一个构造方法没有默认值：<pre class=" language-java"><code class="language-java"> <span class="token function">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li>第二个构造方法使用propDefault 作为默认值：<pre class=" language-java"><code class="language-java"> <span class="token function">Properties</span><span class="token punctuation">(</span>Properties propDefault<span class="token punctuation">)</span></code></pre></li></ul><p>除了从 Hashtable 中所定义的方法，Properties 定义了以下方法：</p><table><thead><tr><th>方法</th><th>描述</th></tr></thead><tbody><tr><td><code>String getProperty(String key)</code></td><td>用指定的键在此属性列表中搜索属性</td></tr><tr><td><code>String getProperty(String key, String defaultProperty)</code></td><td>用指定的键在属性列表中搜索属性</td></tr><tr><td><code>void list(PrintStream streamOut)</code></td><td>将属性列表输出到指定的输出流</td></tr><tr><td><code>void list(PrintWriter streamOut)</code></td><td>将属性列表输出到指定的输出流</td></tr><tr><td><code>void load(InputStream streamIn)</code></td><td>从输入流中读取属性列表(键和元素对)</td></tr><tr><td><code>Enumeration propertyNames()</code></td><td>按简单的面向行的格式从输入字符流中读取属性列表(键和元素对)</td></tr><tr><td><code>Object setProperty(String key, String value)</code></td><td>调用 Hashtable 的方法 put</td></tr><tr><td><code>void store(OutputStream streamOut, String description)</code></td><td>以适合使用  load(InputStream)方法加载到 Properties 表中的格式，将此 Properties 表中的属性列表(键和元素对)写入输出流</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 数据结构 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 11 新特性</title>
      <link href="/posts/2018/17b661f9.html"/>
      <url>/posts/2018/17b661f9.html</url>
      
        <content type="html"><![CDATA[<p>自从 2017 年 9 月 21 日 Java 9 正式发布之时，Oracle 就宣布今后会按照每六个月一次的节奏进行更新，JDK 11 已于 2018 年 9 月发布。与 JDK 10 不同，JDK 11 将提供长期支持，还将作为 Java 平台的参考实现以及标准版（Java SE）11。Oracle 直到 2023 年 9 月都会为 JDK 11 提供一级支持，而补丁和安全警告等扩展支持将延续到 2026 年。新的长期支持版本每三年发布一次，根据后续的发行计划，JDK 17 将于 2021 年发布。</p><h2 id="Java-11-的新特性"><a href="#Java-11-的新特性" class="headerlink" title="Java 11 的新特性"></a>Java 11 的新特性</h2><p>Java 11 新增了非常多的特性，主要特性包含以下几个：</p><ul><li><strong><code>基于嵌套的访问控制</code></strong> − 嵌套是一种访问控制上下文，与 Java 编程语言中现有的嵌套类型概念一致。 嵌套允许逻辑上属于同一代码实体，但被编译为不同类文件的类，无需编译器插入可访问性扩展桥接方法，即可访问彼此的私有成员。</li><li><strong><code>动态类文件常量</code></strong> − 扩展 Java 类文件格式以支持新的常量池形式，CONSTANT_Dynamic。 加载CONSTANT_Dynamic 会将创建委托给 bootstrap 方法，就像链接 invokedynamic 调用站点将链接委托给 bootstrap 方法一样。</li><li><strong><code>改进 Aarch64 内联函数</code></strong> − 改进现有的字符串和数组内联函数，并在 AArch64 处理器上为 java.lang.Math sin，cos 和 log 函数实现新的内联函数。</li><li><strong><code>Epsilon：No-Op 垃圾回收器</code></strong> − 开发一个处理内存分配但不实现任何实际内存回收机制的 GC。 一旦可用的 Java 堆耗尽，JVM 将关闭。</li><li><strong><code>HTTP 客户端（标准）</code></strong> − 通过 JEP 110 标准化 JDK 9 中引入的孵化 HTTP 客户端 API，并在 JDK 10 中进行更新。</li><li><strong><code>Lambda 参数的局部变量语法</code></strong> − 在声明隐式类型的 lambda 表达式的形式参数时允许使用 var。</li><li><strong><code>采用 Curve25519 和 Curve448 加密的密钥协议</code></strong> − 使用 RFC 7748 中描述的 Curve25519 和 Curve448 实现密钥协议。</li><li><strong><code>支持 Unicode 10.0</code></strong> − 升级现有平台 API 以支持 Unicode 标准 v10.0。</li><li><strong><code>飞行记录仪</code></strong> − 提供低开销的数据收集框架，用于对 Java 应用程序和 HotSpot JVM 进行故障排除。</li><li><strong><code>实现 ChaCha20 和 Poly1305 加密算法</code></strong> − 实现 RFC 7539 中指定的 ChaCha20 和 ChaCha20-Poly1305 加密。ChaCha20 是一种相对较新的流加密，可以替代旧的、不安全的 RC4 流加密。</li><li><strong><code>增强 Java 启动器</code></strong> − 增强 java 启动程序以运行作为 Java 源代码的单个文件提供的程序，包括通过“shebang”文件和相关技术从脚本中使用。</li><li><strong><code>低开销堆分析</code></strong> − 提供一种低开销的 Java 堆分配采样方法，可通过 JVMTI 访问。</li><li><strong><code>传输层安全性(TLS) 1.3</code></strong> − 实现传输层安全性（TLS）协议 RFC 8446 的 1.3 版。</li><li><strong><code>ZGC：可扩展的低延迟垃圾收集器</code></strong> − Z 垃圾收集器，也称为 ZGC，是一个可扩展的低延迟垃圾收集器。</li><li><strong><code>弃用 Nashorn JavaScript 引擎</code></strong> − 弃用 Nashorn JavaScript 脚本引擎和 API 以及 jjs 工具，意图在将来的版本中删除它们。</li><li><strong><code>弃用 Pack200 工具和 API</code></strong> − 在 java.util.jar 中弃用 pack200 和 unpack200 工具以及 Pack200 API。</li><li><strong><code>删除 Java EE 和 CORBA 模块</code></strong> − 从 Java SE Platform 和 JDK 中删除 Java EE 和 CORBA 模块。这些模块在 Java SE 9 中已弃用，声明的目的是为了在将来的版本中删除它们。</li><li><strong><code>删除 JavaFX</code></strong> − JavaFX 模块已从 JDK 11 发行版中删除。这些模块包含在早期版本的 Oracle JDK 中，但不包含在 OpenJDK 版本中。JavaFX 模块将作为 JDK 之外的单独模块集提供。</li></ul><p>更多的新特性可以参阅官网：<a href="https://www.oracle.com/technetwork/java/javase/11-relnote-issues-5012449.html#NewFeature" target="_blank" rel="noopener">What’s New in JDK 11</a><br>JDK 11 下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk11-downloads-5066655.html" target="_blank" rel="noopener">Java 11 Downloads</a></p><h3 id="HTTP客户端（标准）"><a href="#HTTP客户端（标准）" class="headerlink" title="HTTP客户端（标准）"></a>HTTP客户端（标准）</h3><p>这个功能于 JDK 9 中引入并在 JDK 10 中得到了更新，现在终于转正了。该 API 通过 <code>CompleteableFutures</code> 提供非阻塞请求和响应语义，可以联合使用以触发相应的动作。自从 JDK 9 和 10 中引入该功能后，JDK 11 完全重写了该功能，现在其实现完全是异步的。<code>RX Flow</code> 的概念也得到了实现，这样就无需为了支持 HTTP/2 而创造许多概念了。现在，在用户层请求发布者和响应发布者与底层套接字之间追踪数据流更容易了。这降低了复杂性，并最大程度上提高了 HTTP/1 和 HTTP/2 之间的重用的可能性。</p><h3 id="Epsilon-垃圾回收器"><a href="#Epsilon-垃圾回收器" class="headerlink" title="Epsilon 垃圾回收器"></a>Epsilon 垃圾回收器</h3><p>Epsilon 垃圾回收器又被称为 <code>no-op</code> 回收器，它是新的实验性无操作垃圾收集器。Epsilon GC 仅处理内存分配，并且不实现任何内存回收机制。它对性能测试非常有用，可以与其他 GC 的成本/收益进行对比。它可用于在测试中方便地断言内存占用和内存压力。在极端情况下，它可能对非常短暂的作业很有用，其中内存回收将在 JVM 终止时发生，或者在低垃圾应用程序中获得最后一次延迟改进。</p><h3 id="Lambda-参数的局部变量语法"><a href="#Lambda-参数的局部变量语法" class="headerlink" title="Lambda 参数的局部变量语法"></a>Lambda 参数的局部变量语法</h3><p>可以消除隐含类型表达式中正式参数定义的语法与局部变量定义语法的不一致。这样就能在隐含类型的 <code>lambda</code> 表达式中定义正式参数时使用 <code>var</code> 了。</p><h3 id="Java的类文件格式将被扩展"><a href="#Java的类文件格式将被扩展" class="headerlink" title="Java的类文件格式将被扩展"></a>Java的类文件格式将被扩展</h3><p>以支持新的常量池，<code>CONSTANT_Dynamic</code>。其目标是降低开发新形式的可实现类文件约束带来的成本和干扰。</p><h3 id="采用-Curve25519-和-Curve448-加密的密钥协议"><a href="#采用-Curve25519-和-Curve448-加密的密钥协议" class="headerlink" title="采用 Curve25519 和 Curve448 加密的密钥协议"></a>采用 Curve25519 和 Curve448 加密的密钥协议</h3><p>比现有的 <code>Diffie-Hellman</code> 椭圆曲线密钥交换方式更有效、更安全。根据 IETF 的资料，<code>Curve25519</code> 和 <code>Curve448</code> 两种椭圆曲线采用常量时间的实现方式，以及不会发生异常的数乘实现，能更好地抵抗各种旁路，包括时序、缓存等。该提案的目标是为密钥交换方法提供一个 API 和实现，同时开发一个平台无关、纯 Java 的的实现。由于该提案采用了复杂且精密的模算数，因此还是有风险的。</p><h3 id="飞行记录仪（Flight-Recorder）"><a href="#飞行记录仪（Flight-Recorder）" class="headerlink" title="飞行记录仪（Flight Recorder）"></a>飞行记录仪（Flight Recorder）</h3><p>将提供<code>低开销</code>的数据收集框架，用来调试 <code>Java 应用程序</code>和 <code>HotSpot JVM</code>。飞行记录仪是 Oracle 的商业版 JDK 的功能，但在 JDK 11 中，其代码将移动到公开代码库中，这样所有人都能使用该功能了。<code>Iclouded</code> 将作为 API，以事件的形式产生或消耗数据，同时提供缓存机制、二进制数据工具，同时支持配置和事件过滤。该提案还提议为 OS、HotSpot 和 JDK 库提供事件。</p><h3 id="支持-Unicode-10-0"><a href="#支持-Unicode-10-0" class="headerlink" title="支持 Unicode 10.0"></a>支持 Unicode 10.0</h3><p>升级现有平台 API 以支持 <code>Unicode</code> 标准 <code>v10.0</code>，从而使 Java 跟上潮流。<br>JDK 11 版本包括对 <code>Unicode 10.0.0</code> 的支持。自从支持 Unicode 8.0.0 的 JDK 10 发布以来，JDK 11 结合了 Unicode 9.0.0 和 10.0.0 版本，包括：</p><ul><li>16018 个新字符</li><li>18 个新区块</li><li>10 个新脚本</li></ul><h3 id="实现-ChaCha20-和-Poly1305-加密算法"><a href="#实现-ChaCha20-和-Poly1305-加密算法" class="headerlink" title="实现 ChaCha20 和 Poly1305 加密算法"></a>实现 ChaCha20 和 Poly1305 加密算法</h3><p><code>ChaCha20</code> 是种相对较新的流加密算法，能代替旧的、不安全的R4流加密。<code>ChaCha20</code> 将与 <code>Poly1305</code> 认证算法配对使用。<code>ChaCha20</code> 和 <code>ChaCha20-Poly1305</code> 加密实现将通过 <code>crypto.CipherSpi</code> API 于 SunJCE（Java加密扩展）中提供。</p><h3 id="增强Java启动器"><a href="#增强Java启动器" class="headerlink" title="增强Java启动器"></a>增强Java启动器</h3><p>使之能够运行单一文件的 Java 源代码，使得应用程序可以直接从源代码运行。单文件程序常见于小型工具，或开发者初学 Java 时使用。而且，单一源代码文件有可能会编译成多个类文件，这会增加打包开销。由于这些原因，在运行程序之前进行编译，已成为了不必要的步骤。</p><h3 id="低开销堆分析"><a href="#低开销堆分析" class="headerlink" title="低开销堆分析"></a>低开销堆分析</h3><p>提供一种<code>低开销</code>的 Java 堆分配采样方法，可通过 <code>JVMTI</code> 访问。它旨在实现以下目标：</p><ul><li>低开销足以在默认情况下持续启用；</li><li>可通过定义明确的编程接口（JVMTI）访问；</li><li>可以对所有分配进行采样（即，不限于在一个特定堆区域中的分配或以特定方式分配的分配）；</li><li>可以以独立于实现的方式定义（即，不依赖于任何特定的 GC 算法或 VM 实现）；</li><li>可以提供有关实时和死 Java 对象的信息。</li></ul><h3 id="ZGC：可扩展的低延迟垃圾收集器-试验"><a href="#ZGC：可扩展的低延迟垃圾收集器-试验" class="headerlink" title="ZGC：可扩展的低延迟垃圾收集器(试验)"></a>ZGC：可扩展的低延迟垃圾收集器(试验)</h3><p><code>Z 垃圾收集器</code>，也称为 <code>ZGC</code>，是一个可扩展的低延迟垃圾收集器（JEP 333）。它旨在实现以下目标：</p><ul><li>暂停时间不超过10毫秒；</li><li>暂停时间不会随堆或实时设置大小而增加；</li><li>处理大小从几百兆到几千兆字节不等的堆；</li><li>ZGC 的核心是并发垃圾收集器，这意味着在 Java 线程继续执行时，所有繁重的工作（标记，压缩，引用处理，字符串表清理等）都已完成。这极大地限制了垃圾收集对应用程序响应时间的负面影响。</li></ul><p>ZGC 作为实验性功能包含在内。要启用它，需要 <code>-XX:+UnlockExperimentalVMOptions</code> 选项与 <code>-XX:+UseZGC</code> 选项结合使用。ZGC 的这个实验版具有以下限制：</p><ul><li>它仅适用于Linux / x64。</li><li>不支持使用压缩的 oops 和/或压缩的类点。在 -XX:+UseCompressedOops 和 -XX:+UseCompressedClassPointers 选项默认情况下禁用。启用它们将不起作用。</li><li>不支持类卸载。在 -XX:+ClassUnloading 和 -XX:+ClassUnloadingWithConcurrentMark 选项默认情况下禁用。启用它们将不起作用。</li><li>不支持将 ZGC 与 Graal 结合使用。</li></ul><h3 id="传输层安全-TLS-1-3"><a href="#传输层安全-TLS-1-3" class="headerlink" title="传输层安全(TLS) 1.3"></a>传输层安全(TLS) 1.3</h3><p>JDK 11 版本包括传输层安全性(TLS) 1.3规范（RFC 8446）的实现。对于 <code>TLS 1.3</code>，定义了以下新标准算法名称：</p><ul><li>TLS 协议版本名称：TLSv1.3 </li><li>SSLContext 算法名称：TLSv1.3 </li><li>TLS 1.3 的 TLS 密码套件名称：TLS_AES_128_GCM_SHA256，TLS_AES_256_GCM_SHA384 </li><li>X509KeyManager 的密钥类型：RSASSA-PSS </li><li>X509TrustManager 的 authType：RSASSA-PSS</li></ul><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>参考 <a href="https://docs.oracle.com/javase/11/" target="_blank" rel="noopener">Java 11 官方文档</a>，了解 Java 11 的更多内容。</li><li>参考 <a href="https://docs.oracle.com/en/java/javase/11/docs/api/index.html" target="_blank" rel="noopener">Java 11 API 文档</a>，了解 Java 11 API 的细节。 </li><li>参考 <a href="https://www.oracle.com/technetwork/java/javase/11-relnote-issues-5012449.html#NewFeature" target="_blank" rel="noopener">What’s New in JDK 11</a>，了解 Java 11 的新特性。</li><li>参考 <a href="https://www.oracle.com/technetwork/java/javase/11u-relnotes-5093844.html" target="_blank" rel="noopener">Java 11 Release Notes</a>，了解 Java 11 的更新说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 9 新特性</title>
      <link href="/posts/2018/81153f7d.html"/>
      <url>/posts/2018/81153f7d.html</url>
      
        <content type="html"><![CDATA[<p>Java 9 正式发布于 2017 年 9 月 21 日。作为 Java 8 之后 3 年半才发布的新版本，Java 9 带来了很多重大的变化。其中最主要的变化是 Java 平台模块系统的引入。除此之外，还有一些新的特性。</p><h2 id="Java-9-的新特性"><a href="#Java-9-的新特性" class="headerlink" title="Java 9 的新特性"></a>Java 9 的新特性</h2><p>Java 9 新增了非常多的特性，主要特性包含以下几个：</p><ul><li><strong><code>模块系统</code></strong> - 模块是一个包的容器，Java 9 最大的变化之一是引入了模块系统(Jigsaw 项目)。</li><li><strong><code>REPL (JShell)</code></strong> - 交互式编程环境。</li><li><strong><code>HTTP/2 客户端</code></strong> - HTTP/2 标准是 HTTP 协议的最新版本，新的 HTTPClient API 支持 WebSocket 和 HTTP2 流以及服务器推送特性。</li><li><strong><code>多版本兼容 JAR 包</code></strong> - 多版本兼容 JAR 功能能让你创建仅在特定版本的 Java 环境中运行库程序时选择使用的 class 版本。</li><li><strong><code>集合工厂方法</code></strong> - List，Set 和 Map 接口中，新的静态工厂方法可以创建这些集合的不可变实例。</li><li><strong><code>私有接口方法</code></strong> - 在接口中使用 private 私有方法。我们可以使用 private 访问修饰符在接口中编写私有方法。</li><li><strong><code>改进的 Javadoc</code></strong> - Javadoc 现在支持在 API 文档中的进行搜索。另外，Javadoc 的输出现在符合兼容 HTML5 标准。</li><li><strong><code>改进的 Optional 类</code></strong> - java.util.Optional 添加了很多新的有用方法，Optional 可以直接转为 stream。</li><li><strong><code>改进的 Stream API</code></strong> - 改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。</li><li><strong><code>改进的 try-with-resources</code></strong> - 如果你已经有一个资源是 final 或等效于 final 变量，您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</li><li><strong><code>改进的进程 API</code></strong> - 改进的 API 来控制和管理操作系统进程。引进 java.lang.ProcessHandle 及其嵌套接口 Info 来让开发者逃离时常因为要获取一个本地进程的 PID 而不得不使用本地代码的窘境。</li><li><strong><code>改进的弃用注解 @Deprecated</code></strong> - 注解 @Deprecated 可以标记 Java API 状态，可以表示被标记的 API 将会被移除，或者已经破坏。</li><li><strong><code>改进钻石操作符(Diamond Operator)</code></strong> - 匿名类可以使用钻石操作符(Diamond Operator)。</li><li><strong><code>改进的 CompletableFuture API</code></strong> - CompletableFuture 类的异步机制可以在 ProcessHandle.onExit 方法退出时执行操作。</li><li><strong><code>轻量级的 JSON API</code></strong> - 内置了一个轻量级的 JSON API。</li><li><strong><code>多分辨率图像 API</code></strong> - 定义多分辨率图像API，开发者可以很容易的操作和展示不同分辨率的图像了。</li><li><strong><code>响应式流(Reactive Streams) API</code></strong> - Java 9 中引入了新的响应式流 API 来支持 Java 9 中的响应式编程。</li></ul><p>更多的新特性可以参阅官网：<a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm" target="_blank" rel="noopener">What’s New in JDK 9</a><br>JDK 9 下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk9-doc-downloads-3850606.html" target="_blank" rel="noopener">Java 9 Downloads</a></p><h3 id="模块系统"><a href="#模块系统" class="headerlink" title="模块系统"></a>模块系统</h3><p>Java 9 最大的变化之一是引入了模块系统（Jigsaw 项目）。</p><p>Java 平台模块系统(Modular System)，把模块化开发实践引入到了 Java 平台中。在引入了模块系统之后，JDK 被重新组织成 94 个模块。Java 应用可以通过新增的 jlink 工具，创建出只包含所依赖的 JDK 模块的自定义运行时镜像。这样可以极大的减少 Java 运行时环境的大小。这对于目前流行的不可变基础设施的实践来说，镜像的大小的减少可以节省很多存储空间和带宽资源 。 </p><p> 模块化开发的实践在软件开发领域并不是一个新的概念。Java 开发社区已经使用这样的模块化实践有相当长的一段时间。主流的构建工具，包括 Apache Maven 和 Gradle 都支持把一个大的项目划分成若干个子项目。子项目之间通过不同的依赖关系组织在一起。每个子项目在构建之后都会产生对应的 JAR 文件。 在 Java9 中 ，已有的这些项目可以很容易的升级转换为 Java 9 模块 ，并保持原有的组织结构不变。</p><p>Java 9 模块的重要特征是在其工件（artifact）的根目录中包含了一个描述模块的 <code>module-info.class</code> 文件。工件的格式可以是传统的 JAR 文件或是 Java 9 新增的 JMOD 文件。这个文件由根目录中的源代码文件 <code>module-info.java</code> 编译而来。该模块声明文件可以描述模块的不同特征。模块声明文件中可以包含的内容如下：</p><ul><li><code>模块导出的包：</code>使用 <code>exports</code> 可以声明模块对其他模块所导出的包。包中的 <code>public</code> 和 <code>protected</code> 类型，以及这些类型的 <code>public</code> 和 <code>protected</code> 成员可以被其他模块所访问。没有声明为导出的包相当于模块中的私有成员，不能被其他模块使用。</li><li><code>模块的依赖关系：</code>使用 <code>requires</code> 可以声明模块对其他模块的依赖关系。使用 requires transitive 可 以把一个模块依赖声明为传递的。传递的模块依赖可以被依赖当前模块的其他模块所读取。如果一个模块所导出的类型的型构中包含了来自它所依赖的模块的类型，那么对该模块的依赖应该声明为传递的。</li><li><code>服务的提供和使用：</code>如果一个模块中包含了可以被 <code>ServiceLocator</code> 发现的服务接口的实现，需要使用 provides with 语句来声明具体的实现类；如果一个模块需要使用服务接口，可以使用 <code>uses</code> 语句来声明。 </li></ul><p>下面给出了一个模块 com.mycompany.sample 的最基本的模块声明：</p><pre class=" language-java"><code class="language-java">module com<span class="token punctuation">.</span>mycompany<span class="token punctuation">.</span>sample <span class="token punctuation">{</span>     exports com<span class="token punctuation">.</span>mycompany<span class="token punctuation">.</span>sample<span class="token punctuation">;</span>     requires com<span class="token punctuation">.</span>mycompany<span class="token punctuation">.</span>common<span class="token punctuation">;</span>     provides com<span class="token punctuation">.</span>mycompany<span class="token punctuation">.</span>common<span class="token punctuation">.</span>DemoService with        com<span class="token punctuation">.</span>mycompany<span class="token punctuation">.</span>sample<span class="token punctuation">.</span>DemoServiceImpl<span class="token punctuation">;</span> <span class="token punctuation">}</span></code></pre><p>模块系统中增加了模块路径的概念。模块系统在解析模块时，会从模块路径中进行查找。为了保持与之前 Java 版本的兼容性，CLASSPATH 依然被保留。所有的类型在运行时都属于某个特定的模块。对于从 CLASSPATH 中加载的类型，它们属于加载它们的类加载器对应的未命名模块。可以通过 Class 的 getModule()方法来获取到表示其所在模块的 Module 对象。</p><p>在 JVM 启动时，会从应用的根模块开始，根据依赖关系递归的进行解析，直到得到一个表示依赖关系的图。如果解析过程中出现找不到模块的情况，或是在模块路径的同一个地方找到了名称相同的模块，模块解析过程会终止，JVM 也会退出。Java 也提供了相应的 API 与模块系统进行交互。</p><p>如果想了解和学习更详细的内容，可以参考<a href="http://openjdk.java.net/projects/jigsaw/quick-start" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="REPL-JShell"><a href="#REPL-JShell" class="headerlink" title="REPL (JShell)"></a>REPL (JShell)</h3><p>REPL(Read Eval Print Loop)意为交互式的编程环境。</p><p>JShell 是 Java 9 新增的一个<code>交互式的编程环境工具</code>。JShell 为 Java 增加了类似 NodeJS 和 Python 中的读取-求值-打印循环(Read-Evaluation-Print Loop)。在 JShell 中可以<code>直接输入表达式并查看其执行结果</code>。当需要测试一个方法的运行效果，或是快速的对表达式进行求值时，JShell 都非常实用。只需要通过 JShell 命令启动 jshell，然后直接输入表达式即可。</p><p>执行 JShell：</p><pre class=" language-shell"><code class="language-shell">$ jshell|  Welcome to JShell -- Version 9-ea|  For an introduction type: /help introjshell></code></pre><p>执行 JShell 简单计算：</p><pre class=" language-shell"><code class="language-shell">jshell> 3+1$1 ==> 4jshell> 13%7$2 ==> 6jshell> $2$2 ==> 6jshell></code></pre><p>JShell 创建与使用函数：</p><pre class=" language-shell"><code class="language-shell">jshell> int doubled(int i){ return i*2;}|  created method doubled(int)jshell> doubled(6)$3 ==> 12jshell></code></pre><p>退出 JShell：</p><pre class=" language-shell"><code class="language-shell">jshell> /exit| Goodbye </code></pre><h3 id="HTTP-2-客户端"><a href="#HTTP-2-客户端" class="headerlink" title="HTTP/2 客户端"></a>HTTP/2 客户端</h3><p>在此之前，JDK 提供的 Http 访问功能，几乎都需要依赖于 HttpURLConnection，但是这个类大家在写代码的时候很少使用，此次在Java 9的版本中引入了一个新的 package：<code>java.net.http</code>，里面提供了对 Http 访问很好的支持，不仅支持 Http/1.1 而且还支持 HTTP/2，以及 WebSocket，据说性能可以超过 Apache HttpClient，Netty，Jetty。<br>下面是一个简单的使用例子：</p><pre class=" language-java"><code class="language-java">URI httpURI <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">URI</span><span class="token punctuation">(</span><span class="token string">"http://www.baidu.com"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>HttpRequest request <span class="token operator">=</span> HttpRequest<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>httpURI<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">GET</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>HttpResponse response <span class="token operator">=</span> request<span class="token punctuation">.</span><span class="token function">response</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>String responseBody <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">body</span><span class="token punctuation">(</span>HttpResponse<span class="token punctuation">.</span><span class="token function">asString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="集合工厂方法"><a href="#集合工厂方法" class="headerlink" title="集合工厂方法"></a>集合工厂方法</h3><p>Java 9 在 <code>List</code>，<code>Set</code> 和 <code>Map</code> 接口中，添加了可以创建这些集合的不可变实例新的静态工厂方法。</p><p>在 Java 9 之前，Java 只能利用一些实用方法（例如：Collections.unmodifiableCollection(Collection&lt;? extends T&gt; c)）创建一个不可修改视图的集合。现在，Java 9 引入了一些有用的工厂方法来创建不可修改的集合。</p><p>Java 9 中，以下方法被添加到 List、Set 和 Map 接口以及它们的重载对象。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> List<span class="token operator">&lt;</span>E<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>E e1<span class="token punctuation">,</span> E e2<span class="token punctuation">,</span> E e3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>E<span class="token operator">></span> Set<span class="token operator">&lt;</span>E<span class="token operator">></span>  <span class="token function">of</span><span class="token punctuation">(</span>E e1<span class="token punctuation">,</span> E e2<span class="token punctuation">,</span> E e3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">of</span><span class="token punctuation">(</span>K k1<span class="token punctuation">,</span> V v1<span class="token punctuation">,</span> K k2<span class="token punctuation">,</span> V v2<span class="token punctuation">,</span> K k3<span class="token punctuation">,</span> V v3<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">static</span> <span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> Map<span class="token operator">&lt;</span>K<span class="token punctuation">,</span>V<span class="token operator">></span> <span class="token function">ofEntries</span><span class="token punctuation">(</span>Map<span class="token punctuation">.</span>Entry<span class="token operator">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">K</span><span class="token punctuation">,</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">V</span><span class="token operator">></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> entries<span class="token punctuation">)</span></code></pre><ul><li>List 和 Set 接口：of(…) 方法重载了 0 ~ 10 个参数的不同方法。</li><li>Map 接口：of(…) 方法重载了 0 ~ 10 个参数的不同方法。</li><li>Map 接口：如果超过 10 个参数, 可以使用 ofEntries(…) 方法。</li></ul><h3 id="私有接口方法"><a href="#私有接口方法" class="headerlink" title="私有接口方法"></a>私有接口方法</h3><p>在 Java 8 之前，接口可以有<code>常量变量</code>和<code>抽象方法</code>。我们不能在接口中提供方法实现，如果我们要提供抽象方法和非抽象方法（方法与实现）的组合，那么我们就得使用抽象类。</p><p>在 Java 8 接口引入了<code>默认方法</code>和<code>静态方法</code>。我们可以在 Java 8 的接口中编写方法实现，仅仅需要使用 <code>default</code> 关键字来定义它们。在 Java 8 中，一个接口中能定义如下几种变量/方法：常量、抽象方法、默认方法、静态方法。</p><p>Java 9 不仅像 Java 8 一样支持接口默认方法，同时还支持<code>私有方法</code>。在 Java 9 中，一个接口中能定义如下几种变量/方法：常量、抽象方法、默认方法、静态方法、私有方法、私有静态方法</p><p>默认方法和静态方法可以共享接口中的私有方法，因此避免了代码冗余，这也使代码更加清晰。如果私有方法是静态的，那这个方法就属于这个接口的，并且没有 <code>static</code> 修饰的私有方法只能被在接口中的实例调用。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">InterfaceWithPrivateMethods</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> String <span class="token function">staticPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"static private"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> String <span class="token function">instancePrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"instance private"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">check</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        String result <span class="token operator">=</span> <span class="token function">staticPrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        InterfaceWithPrivateMethods methods <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterfaceWithPrivateMethods</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment" spellcheck="true">// anonymous class 匿名类</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>        result <span class="token operator">=</span> methods<span class="token punctuation">.</span><span class="token function">instancePrivate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h3 id="改进的-Javadoc"><a href="#改进的-Javadoc" class="headerlink" title="改进的 Javadoc"></a>改进的 Javadoc</h3><p>javadoc 工具可以生成 Java 文档。Javadoc 现在支持在 API 文档中的进行搜索。另外， Java 9 的 javadoc 的输出现在符合兼容 HTML5 标准。使用 Java 9 javadoc 命令中的 <code>-html5</code> 参数可以让生成的文档支持 HTML5 标准。</p><h3 id="改进-Optional-类"><a href="#改进-Optional-类" class="headerlink" title="改进 Optional 类"></a>改进 Optional 类</h3><p>Optional 类在 Java 8 中引入，Optional 类的引入很好的解决空指针异常。在 java 9 中, 添加了三个方法来改进它的功能：</p><ul><li><strong><code>stream()：</code></strong>将 Optional 转为一个 <code>Stream</code>，如果该 Optional 中包含值，那么就返回包含这个值的 Stream，否则返回一个空的 Stream（<code>Stream.empty()</code>）。</li><li><strong><code>ifPresentOrElse()：</code></strong>如果一个 Optional 包含值，则对其包含的值调用函数 <code>action</code>，即 <code>action.accept(value)</code>，这与 ifPresent 一致；与 ifPresent 方法的区别在于，ifPresentOrElse 还有第二个参数 <code>emptyAction</code> —— 如果 Optional 不包含值，那么 ifPresentOrElse 便会调用 <code>emptyAction</code>，即 <code>emptyAction.run()</code>。</li><li><strong><code>or()：</code></strong>如果值存在，返回 Optional 指定的值，否则返回一个预设的值。</li></ul><h3 id="改进的-Stream-API"><a href="#改进的-Stream-API" class="headerlink" title="改进的 Stream API"></a>改进的 Stream API</h3><p>Java 9 改进的 Stream API 添加了一些便利的方法，使流处理更容易，并使用收集器编写复杂的查询。Java 9 为 Stream 新增了几个方法：<code>dropWhile</code>、<code>takeWhile</code>、<code>ofNullable</code>，为 <code>iterate</code> 方法新增了一个重载方法。</p><ul><li><strong><code>takeWhile()：</code></strong>使用一个断言作为参数，返回给定 Stream 的子集直到断言语句第一次返回 false。如果第一个值不满足断言条件，将返回一个空的 Stream。</li><li><strong><code>dropWhile()：</code></strong>和 takeWhile 作用相反的，使用一个断言作为参数，直到断言语句第一次返回 true 才返回给定 Stream 的子集。</li><li><strong><code>ofNullable()：</code></strong>可以预防 NullPointerExceptions 异常， 可以通过检查流来避免 null 值。</li><li><strong><code>iterate()：</code></strong>允许使用初始种子值创建顺序（可能是无限）流，并迭代应用指定的下一个方法。 当指定的 hasNext 的 predicate 返回 false 时，迭代停止。</li></ul><h3 id="改进的-try-with-resources"><a href="#改进的-try-with-resources" class="headerlink" title="改进的 try-with-resources"></a>改进的 try-with-resources</h3><p>try-with-resources 是 JDK 7 中一个新的异常处理机制，它能够很容易地关闭在 try-catch 语句块中使用的资源。所谓的资源（resource）是指在程序完成后，必须关闭的对象。try-with-resources 语句确保了每个资源在语句结束时关闭。所有实现了 java.lang.AutoCloseable 接口（其中，它包括实现了 java.io.Closeable 的所有对象），可以使用作为资源。</p><p>try-with-resources 声明在 JDK 9 已得到改进。如果你已经有一个资源是 <code>final</code> 或<code>等效于 final 变量</code>，您可以在 try-with-resources 语句中使用该变量，而无需在 try-with-resources 语句中声明一个新变量。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> String <span class="token function">readData</span><span class="token punctuation">(</span>String message<span class="token punctuation">)</span> <span class="token keyword">throws</span> IOException <span class="token punctuation">{</span>    Reader inputString <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StringReader</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>    BufferedReader br <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BufferedReader</span><span class="token punctuation">(</span>inputString<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">(</span>br<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> br<span class="token punctuation">.</span><span class="token function">readLine</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在处理必须关闭的资源时，使用 try-with-resources 语句替代 try-finally 语句。 生成的代码更简洁，更清晰，并且生成的异常更有用。try-with-resources 语句在编写必须关闭资源的代码时会更容易，也不会出错，而使用 try-finally 语句实际上是不可能的。</p><h3 id="改进的进程-API"><a href="#改进的进程-API" class="headerlink" title="改进的进程 API"></a>改进的进程 API</h3><p>在 Java 9 之前，Process API 仍然缺乏对使用本地进程的基本支持，例如获取进程的 PID 和所有者，进程的开始时间，进程使用了多少 CPU 时间，多少本地进程正在运行等。</p><p>Java 9 向 Process API 添加了一个名为 <code>ProcessHandle</code> 的接口来增强 <code>java.lang.Process</code> 类，可以对原生进程进行管理，尤其适合于管理长时间运行的进程。</p><p>在使用 <code>ProcessBuilder</code> 来启动一个进程之后，可以通过 <code>Process.toHandle()</code> 方法来得到一个 <code>ProcessHandle</code> 对象的实例。通过 <code>ProcessHandle</code> 可以获取到由 <code>ProcessHandle.Info</code> 表示的进程的基本信息，如命令行参数、可执行文件路径和启动时间等。<code>ProcessHandle</code> 的 <code>onExit()</code> 方法返回一个 <code>CompletableFuture&lt;ProcessHandle&gt;</code> 对象，可以在进程结束时执行自定义的动作。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> ProcessBuilder processBuilder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ProcessBuilder</span><span class="token punctuation">(</span><span class="token string">"top"</span><span class="token punctuation">)</span>     <span class="token punctuation">.</span><span class="token function">inheritIO</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token keyword">final</span> ProcessHandle processHandle <span class="token operator">=</span> processBuilder<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toHandle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> processHandle<span class="token punctuation">.</span><span class="token function">onExit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">whenCompleteAsync</span><span class="token punctuation">(</span><span class="token punctuation">(</span>handle<span class="token punctuation">,</span> throwable<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>throwable <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>handle<span class="token punctuation">.</span><span class="token function">pid</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         throwable<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><h3 id="改进的弃用注解-Deprecated"><a href="#改进的弃用注解-Deprecated" class="headerlink" title="改进的弃用注解 @Deprecated"></a>改进的弃用注解 @Deprecated</h3><p>注解 <code>@Deprecated</code> 可以标记 Java API 状态，可以是以下几种：</p><ul><li>使用它存在风险，可能导致错误；</li><li>可能在未来版本中不兼容；</li><li>可能在未来版本中删除；</li><li>一个更好和更高效的方案已经取代它。</li></ul><p>Java 9 中注解增加了两个新元素：<code>since</code> 和 <code>forRemoval</code>。</p><ul><li><strong><code>since：</code></strong>元素指定已注解的 API 元素已被弃用的版本。</li><li><strong><code>forRemoval：</code></strong>元素表示注解的 API 元素在将来的版本中被删除，应该迁移 API。 </li></ul><p>Java 9 中也提供了扫描 jar 文件的工具 <code>jdeprscan</code>。这款工具也可以扫描一个聚合类，这个类使用了 Java SE 中的已废弃的 API 元素。这个工具将会对使用已经编译好的库的应用程序有帮助，这样使用者就不知道这个已经编译好的库中使用了那些已废弃的 API。</p><h3 id="改进钻石操作符-Diamond-Operator"><a href="#改进钻石操作符-Diamond-Operator" class="headerlink" title="改进钻石操作符(Diamond Operator)"></a>改进钻石操作符(Diamond Operator)</h3><p>钻石操作符是在 Java 7 中引入的，可以让代码更易读，但它不能用于匿名的内部类。</p><p>在 Java 9 中，它可以与匿名的内部类一起使用，从而提高代码的可读性。在 Java 9 中，我们可以在匿名类中使用 <code>&lt;&gt;</code> 操作符。</p><h3 id="轻量级的-JSON-API"><a href="#轻量级的-JSON-API" class="headerlink" title="轻量级的 JSON API"></a>轻量级的 JSON API</h3><p>Java 9 带来一个轻量级的 API，用于通过 JSON(JavaScriopt 对象符号) 数据交换格式处理和生成文件以及数据流，JSON 是基于 JavaScript 的子集，用来代替 XML。</p><p>这个 API 的主要目标如下：</p><ul><li>解析和生成 JSON。</li><li>满足 Java 开发者使用 JSON 的功能性需求。</li><li>解析 API 可以选择标记流，事件(包括文件层次结构)流，或不可变树的方式来呈现文档或数据流视图。</li><li>用于紧凑配置和 Java ME 的 API 子集。</li><li>使用创建者模式 API 构造不可变的树型结构。</li><li>生成器风格 API，用于输出 JSON 数组流和 JSON “文本”。</li><li>一个转换 API，将已有的树形值输入转换成另一个树形值输出。</li></ul><p>预计 JEP 会把它作为 java.util 的子包交付，至少包含 4 个模块：事件、流、树和生成器。预期不会修改现有的模块、包或类。预计 JSON API 不会依赖 Java 基础模块之外的模块。</p><h3 id="多分辨率图像-API"><a href="#多分辨率图像-API" class="headerlink" title="多分辨率图像 API"></a>多分辨率图像 API</h3><p>Java 9 定义了多分辨率图像 API，开发者可以很容易的操作和展示不同分辨率的图像。</p><p>以下是多分辨率图像的主要操作方法：</p><ul><li><strong><code>Image getResolutionVariant(double destImageWidth, double destImageHeight)：</code></strong>获取特定分辨率的图像变体-表示一张已知分辨率单位为DPI的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li><li><strong><code>List&lt;Image&gt; getResolutionVariants()：</code></strong>返回可读的分辨率的图像变体列表。</li></ul><p>基于当前屏幕分辨率大小和运用的图像转换算法，<code>java.awt.Graphics</code> 类可以从 <code>MultiResolutionImage</code> 接口获取所需的变体。<code>java.awt.image.AbstractMultiResolutionImage</code> 类提供了 <code>java.awt.image.AbstractMultiResolutionImage</code> 默认实现。<code>AbstractMultiResolutionImage</code> 的基础实现是 <code>java.awt.image.BaseMultiResolutionImage</code>。</p><h3 id="改进的-CompletableFuture-API"><a href="#改进的-CompletableFuture-API" class="headerlink" title="改进的 CompletableFuture API"></a>改进的 CompletableFuture API</h3><p>Java 8 引入了 <code>CompletableFuture&lt;T&gt;</code> 类，可能是 <code>java.util.concurrent.Future&lt;T&gt;</code> 明确的完成版（设置了它的值和状态），也可能被用作 <code>java.util.concurrent.CompleteStage</code>。支持 <code>future</code> 完成时触发一些依赖的函数和动作。Java 9 引入了一些 <code>CompletableFuture</code> 的改进：</p><p>Java 9 对 CompletableFuture 做了改进：</p><ol><li><p>支持 delays 和 timeouts</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> CompletableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">completeOnTimeout</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> <span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span></code></pre><p>在 <code>timeout</code> 前以给定的 <code>value</code> 完成这个 CompletableFutrue，并返回这个 CompletableFutrue。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> CompletableFuture<span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token function">orTimeout</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> TimeUnit unit<span class="token punctuation">)</span></code></pre><p>如果没有在给定的 <code>timeout</code> 内完成，就以 <code>java.util.concurrent.TimeoutException</code> 完成这个 CompletableFutrue，并返回这个 CompletableFutrue。</p></li><li><p>增强了对子类化的支持<br>做了许多改进使得 <code>CompletableFuture</code> 可以被更简单的继承。比如，你也许想重写新的 <code>public Executor defaultExecutor()</code> 方法来代替默认的 <code>executor</code>。<br>另一个新的使子类化更容易的方法是：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token operator">&lt;</span>U<span class="token operator">></span> CompletableFuture<span class="token operator">&lt;</span>U<span class="token operator">></span> <span class="token function">newIncompleteFuture</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre></li><li><p>新的工厂方法<br>Java 8 引入了 <code>&lt;U&gt; CompletableFuture&lt;U&gt; completedFuture(U value)</code> 工厂方法来返回一个已经以给定 value 完成了的 <code>CompletableFuture</code>。Java 9 以 一个新的 <code>&lt;U&gt; CompletableFuture&lt;U&gt; failedFuture(Throwable ex)</code> 来补充了这个方法，可以返回一个以给定异常完成的 <code>CompletableFuture</code>。<br>除此以外，Java 9 引入了下面这对 stage-oriented 工厂方法，返回完成的或异常完成的 completion stages:</p><ul><li><strong><code>&lt;U&gt; CompletionStage&lt;U&gt; completedStage(U value)：</code></strong>返回一个新的以指定 value 完成的 <code>CompletionStage</code>，并且只支持 <code>CompletionStage</code> 里的接口。</li><li><strong><code>&lt;U&gt; CompletionStage&lt;U&gt; failedStage(Throwable ex)：</code></strong>返回一个新的以指定异常完成的 <code>CompletionStage</code>，并且只支持 <code>CompletionStage</code> 里的接口。</li></ul></li></ol><h3 id="响应式流-Reactive-Streams-API"><a href="#响应式流-Reactive-Streams-API" class="headerlink" title="响应式流(Reactive Streams) API"></a>响应式流(Reactive Streams) API</h3><p>响应式编程的思想最近得到了广泛的流行。在 Java 平台上有流行的响应式库 <code>RxJava</code> 和 <code>Reactor</code>。反应式流规范的出发点是提供一个带非阻塞负压(non-blocking backpressure)的异步流处理规范。响应式流规范的核心接口已经添加到了 Java 9 中的 <code>java.util.concurrent.Flow</code> 类中。</p><p><code>java.util.concurrent.Flow</code> 中包含以下 4 个核心接口：</p><ul><li><strong><code>Flow.Publisher：</code></strong>发布者</li><li><strong><code>Flow.Subscriber：</code></strong>订阅者</li><li><strong><code>Flow.Subscription：</code></strong>订阅管理器</li><li><strong><code>Flow.Processor：</code></strong>处理器</li></ul><p>Java 9 还提供了 <code>SubmissionPublisher</code> 作为 <code>Flow.Publisher</code> 的一个实现。RxJava 2 和 Reactor 都可以很方便的与 Flow 类的核心接口进行互操作。 </p><h3 id="I-O-流新特性"><a href="#I-O-流新特性" class="headerlink" title="I/O 流新特性"></a>I/O 流新特性</h3><p>类 <code>java.io.InputStream</code> 中增加了新的方法来读取和复制 <code>InputStream</code> 中包含的数据：</p><ul><li><strong><code>readAllBytes()：</code></strong>读取 InputStream 中的所有剩余字节。</li><li><strong><code>readNBytes()：</code></strong>从 InputStream 中读取指定数量的字节到数组中。</li><li><p><strong><code>transferTo()：</code></strong>读取 InputStream 中的全部字节并写入到指定的 OutputStream 中 。 </p><p><code>ObjectInputFilter</code> 可以对 <code>ObjectInputStream</code> 中包含的内容进行检查，来确保其中包含的数据是合法的。可以使用 ObjectInputStream 的方法 <code>setObjectInputFilter</code> 来设置。<code>ObjectInputFilter</code> 在进行检查时，可以检查如对象图的最大深度、对象引用的最大数量、输入流中的最大字节数和数组的最大长度等限制，也可以对包含的类的名称进行限制。 </p></li></ul><h3 id="改进应用安全性能"><a href="#改进应用安全性能" class="headerlink" title="改进应用安全性能"></a>改进应用安全性能</h3><p>Java 9 新增了 4 个 <code>SHA-3</code> 哈希算法，<code>SHA3-224</code>、<code>SHA3-256</code>、<code>SHA3-384</code> 和 <code>SHA3-512</code>。另外也增加了通过 <code>java.security.SecureRandom</code> 生成使用 <code>DRBG</code> 算法的强随机数。</p><h3 id="变量句柄"><a href="#变量句柄" class="headerlink" title="变量句柄"></a>变量句柄</h3><p>变量句柄是一个变量或一组变量的引用，包括静态域，非静态域，数组元素和堆外数据结构中的组成部分等。变量句柄的含义类似于已有的方法句柄。变量句柄由 Java 类 <code>java.lang.invoke.VarHandle</code> 来表示。可以使用类 <code>java.lang.invoke.MethodHandles.Lookup</code> 中的静态工厂方法来创建 <code>VarHandle</code> 对象。通过变量句柄，可以在变量上进行各种操作。这些操作称为访问模式。不同的访问模式尤其在内存排序上的不同语义。目前一共有31种访问模式，而每种访问模式都在 <code>VarHandle</code> 中有对应的方法。这些方法可以对变量进行读取、写入、原子更新、数值原子更新和比特位原子操作等。<code>VarHandle</code> 还可以用来访问数组中的单个元素，以及把 <code>byte[]</code> 数组和 <code>ByteBuffer</code> 当成是不同原始类型的数组来访问。</p><h3 id="改进方法句柄-Method-Handle"><a href="#改进方法句柄-Method-Handle" class="headerlink" title="改进方法句柄(Method Handle)"></a>改进方法句柄(Method Handle)</h3><p>类 <code>java.lang.invoke.MethodHandles</code> 增加了更多的静态方法来创建不同类型的方法句柄：</p><ul><li><strong><code>arrayConstructor：</code></strong>创建指定类型的数组。</li><li><strong><code>arrayLength：</code></strong>获取指定类型的数组的大小。</li><li><strong><code>varHandleInvoker 和 varHandleExactInvoker：</code></strong>调用 VarHandle 中的访问模式方法。</li><li><strong><code>zero：</code></strong>返回一个类型的默认值。</li><li><strong><code>empty：</code></strong>返 回 MethodType 的返回值类型的默认值。</li><li><strong><code>loop、countedLoop、iteratedLoop、whileLoop 和 doWhileLoop：</code></strong>创建不同类型的循环，包括 for 循环、while 循环 和 do-while 循环。</li><li><strong><code>tryFinally：</code></strong>把对方法句柄的调用封装在 try-finally 语句中。 </li></ul><h3 id="用户界面"><a href="#用户界面" class="headerlink" title="用户界面"></a>用户界面</h3><p>类 <code>java.awt.Desktop</code> 增加了新的与桌面进行互动的能力。可以使用 <code>addAppEventListener</code> 方法来添加不同应用事件的监听器，包括应用变为前台应用、应用隐藏或显示、屏幕和系统进入休眠与唤醒、以及用户会话的开始和终止等。还可以在显示关于窗口和配置窗口时，添加自定义的逻辑。在用户要求退出应用时，可以通过自定义处理器来接受或拒绝退出请求。在 AWT 图像支持方面，可以在应用中使用多分辨率图像。</p><h3 id="统一-JVM-日志"><a href="#统一-JVM-日志" class="headerlink" title="统一 JVM 日志"></a>统一 JVM 日志</h3><p>Java 9 中，JVM 有了统一的日志记录系统，可以使用新的命令行选项 <code>-Xlog</code> 来控制 JVM 上 所有组件的日志记录。该日志记录系统可以设置输出的日志消息的标签、级别、修饰符和输出目标等。Java 9 移除了在 Java 8 中被废弃的垃圾回收器配置组合，同时把 G1 设为默认的垃圾回收器实现。另外，CMS 垃圾回收器已经被声明为废弃。Java 9 也增加了很多可以通过 <code>jcmd</code> 调用的诊断命令。 </p><h3 id="平台日志-API-和-服务"><a href="#平台日志-API-和-服务" class="headerlink" title="平台日志 API 和 服务"></a>平台日志 API 和 服务</h3><p>Java 9 允许为 JDK 和应用配置同样的日志实现。新增的 <code>System.LoggerFinder</code> 用来管理 JDK 使用的日志记录器实现。JVM 在运行时只有一个系统范围的 <code>LoggerFinder</code> 实例。<code>LoggerFinder</code> 通过服务查找机制来加载日志记录器实现。默认情况下，JDK 使用 <code>java.logging</code> 模块中的 <code>java.util.logging</code> 实现。通过 <code>LoggerFinder</code> 的 <code>getLogger()</code> 方法就可以获取到表示日志记录器的<code>System.Logger</code> 实现。应用同样可以使用 <code>System.Logger</code> 来记录日志。这样就保证了 JDK 和应用使用同样的日志实现。我们也可以通过添加自己的 <code>System.LoggerFinder</code> 实现来让 JDK 和应用使用 SLF4J 等其他日志记录框架。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>参考 <a href="https://docs.oracle.com/javase/9/" target="_blank" rel="noopener">Java 9 官方文档</a>，了解 Java 9 的更多内容。</li><li>参考 <a href="https://docs.oracle.com/javase/9/docs/api/index.html" target="_blank" rel="noopener">Java 9 API 文档</a>，了解 Java 9 API 的细节。 </li><li>参考 <a href="https://docs.oracle.com/javase/9/whatsnew/toc.htm" target="_blank" rel="noopener">What’s New in JDK 9</a>，了解 Java 9 的新特性。</li><li>参考 <a href="https://www.oracle.com/technetwork/java/javase/9-relnotes-3622618.html" target="_blank" rel="noopener">Java 9 Release Notes</a>，了解 Java 9 的更新说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 8 新特性</title>
      <link href="/posts/2018/409be0bd.html"/>
      <url>/posts/2018/409be0bd.html</url>
      
        <content type="html"><![CDATA[<p>Java 8 (又称为 jdk 1.8) 是 Java 语言开发的一个主要版本。Oracle 公司于 2014 年 3 月 18 日发布 Java 8 ，它支持函数式编程，新的 JavaScript 引擎，新的日期 API，新的 Stream API 等。</p><h2 id="Java-8-的新特性"><a href="#Java-8-的新特性" class="headerlink" title="Java 8 的新特性"></a>Java 8 的新特性</h2><p>Java 8 新增了非常多的特性，主要特性包含以下几个：</p><ul><li><strong><code>Lambda 表达式</code></strong> − Lambda允许把函数作为一个方法的参数（函数作为参数传递进方法中。</li><li><strong><code>方法引用</code></strong> − 方法引用提供了非常有用的语法，可以直接引用已有 Java 类或对象（实例）的方法或构造器。与 lambda 联合使用，方法引用可以使语言的构造更紧凑简洁，减少冗余代码。</li><li><strong><code>默认方法</code></strong> − 默认方法就是一个在接口里面有了一个实现的方法。</li><li><strong><code>新工具</code></strong> − 新的编译工具，如：Nashorn 引擎 jjs、 类依赖分析器 jdeps。</li><li><strong><code>Stream API</code></strong> −新添加的 Stream API（java.util.stream） 把真正的函数式编程风格引入到 Java 中。</li><li><strong><code>Date Time API</code></strong> − 加强对日期与时间的处理。</li><li><strong><code>Optional 类</code></strong> − Optional 类已经成为 Java 8 类库的一部分，用来解决空指针异常。</li><li><strong><code>Nashorn, JavaScript 引擎</code></strong> − Java 8 提供了一个新的 Nashorn javascript 引擎，它允许我们在 JVM 上运行特定的 javascript 应用。</li></ul><p>Java 8 包含语言、编译器、库、工具和JVM等方面的十多个新特性。</p><p>更多的新特性可以参阅官网：<a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">What’s New in JDK 8</a><br>JDK 8 下载地址：<a href="https://www.oracle.com/technetwork/java/javase/downloads/jdk8-downloads-2133151.html" target="_blank" rel="noopener">Java 8 Downloads</a></p><h3 id="Java语言的新特性"><a href="#Java语言的新特性" class="headerlink" title="Java语言的新特性"></a>Java语言的新特性</h3><h4 id="Lambda-表达式和函数式接口"><a href="#Lambda-表达式和函数式接口" class="headerlink" title="Lambda 表达式和函数式接口"></a>Lambda 表达式和函数式接口</h4><p>Lambda 表达式（也称为闭包）是 Java 8 中最大和最令人期待的语言改变。它允许我们将函数当成参数传递给某个方法，或者把代码本身当作数据处理：<a href="https://www.javacodegeeks.com/2014/03/functional-programming-with-java-8-lambda-expressions-monads.html" target="_blank" rel="noopener">函数式开发者</a>非常熟悉这些概念。</p><p>很多 JVM 平台上的语言（<a href="https://www.javacodegeeks.com/category/jvm-languages/groovy" target="_blank" rel="noopener">Groovy</a>、<a href="https://www.javacodegeeks.com/category/jvm-languages/scala" target="_blank" rel="noopener">Scala</a>等）从诞生之日就支持 Lambda 表达式，但是 Java 开发者没有选择，只能使用匿名内部类代替 Lambda 表达式。</p><p>Lambda 的设计耗费了很多时间和很大的社区力量，最终找到一种折中的实现方案，可以实现简洁而紧凑的语言结构。</p><p>最简单的 Lambda 表达式可由<code>逗号分隔的参数列表</code>、<code>-&gt;符号</code>和<code>语句块</code>组成，例如：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>在上面这个代码中的参数 e 的类型是由编译器推理得出的，你也可以显式指定该参数的类型，例如：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span>String e<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果 Lambda 表达式需要更复杂的语句块，则可以使用花括号将该语句块括起来，类似于 Java 中的函数体，例如：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>e <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Lambda 表达式可以引用类成员和局部变量（会将这些变量隐式得转换成 <code>final</code> 的），例如下列两个代码块的效果完全相同：</p><pre class=" language-java"><code class="language-java">String separator <span class="token operator">=</span> <span class="token string">","</span><span class="token punctuation">;</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span>String e<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>e <span class="token operator">+</span> separator<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>和</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> String separator <span class="token operator">=</span> <span class="token string">","</span><span class="token punctuation">;</span>Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>        <span class="token punctuation">(</span>String e<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>e <span class="token operator">+</span> separator<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Lambda 表达式有返回值，返回值的类型也由编译器推理得出。如果 Lambda 表达式中的语句块只有一行，则可以不用使用 <code>return</code> 语句，下列两个代码片段效果相同：</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> e1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>和</p><pre class=" language-java"><code class="language-java">Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span><span class="token string">"a"</span><span class="token punctuation">,</span> <span class="token string">"b"</span><span class="token punctuation">,</span> <span class="token string">"d"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token punctuation">(</span>e1<span class="token punctuation">,</span> e2<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> result <span class="token operator">=</span> e1<span class="token punctuation">.</span><span class="token function">compareTo</span><span class="token punctuation">(</span>e2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>Lambda 的设计者们为了让现有的功能与 Lambda 表达式良好兼容，考虑了很多方法，于是产生了<a href="https://www.javacodegeeks.com/2013/03/introduction-to-functional-interfaces-a-concept-recreated-in-java-8.html" target="_blank" rel="noopener">函数接口</a>这个概念。函数接口指的是只有一个函数的接口，这样的接口可以隐式转换为 Lambda 表达式。<code>java.lang.Runnable</code> 和 <code>java.util.concurrent.Callable</code> 是函数式接口的最佳例子。在实践中，函数式接口非常脆弱：只要某个开发者在该接口中添加一个函数，则该接口就不再是函数式接口进而导致编译失败。为了克服这种代码层面的脆弱性，并显式说明某个接口是函数式接口，Java 8 提供了一个特殊的注解 <code>@FunctionalInterface</code>（Java 库中的所有相关接口都已经带有这个注解了），举个简单的函数式接口的定义：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Functional</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>不过有一点需要注意，默认方法和静态方法不会破坏函数式接口的定义，因此如下的代码是合法的。</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@FunctionalInterface</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">FunctionalDefaultMethods</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">default</span> <span class="token keyword">void</span> <span class="token function">defaultMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Lambda 表达式作为 Java 8 的最大卖点，它有潜力吸引更多的开发者加入到 JVM 平台，并在纯 Java 编程中使用函数式编程的概念。如果你需要了解更多 Lambda 表达式的细节，可以参考<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/lambdaexpressions.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="接口的默认方法和静态方法"><a href="#接口的默认方法和静态方法" class="headerlink" title="接口的默认方法和静态方法"></a>接口的默认方法和静态方法</h4><p>Java 8 使用两个新概念扩展了接口的含义：默认方法和静态方法。默认方法使得接口有点类似 traits，不过要实现的目标不一样。默认方法使得开发者可以在 不破坏二进制兼容性的前提下，往现存接口中添加新的方法，即不强制那些实现了该接口的类也同时实现这个新加的方法。</p><p>默认方法和抽象方法之间的区别在于抽象方法需要实现，而默认方法不需要。接口提供的默认方法会被接口的实现类继承或者覆写，例子代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow default methods, the implementer may or</span>    <span class="token comment" spellcheck="true">// may not implement (override) them.</span>    <span class="token keyword">default</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Default implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">DefaultableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">OverridableImpl</span> <span class="token keyword">implements</span> <span class="token class-name">Defaulable</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> String <span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Overridden implementation"</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>Defaulable</code> 接口使用关键字 <code>default</code> 定义了一个默认方法 <code>notRequired()</code>。<code>DefaultableImpl</code> 类实现了这个接口，同时默认继承了这个接口中的默认方法；<code>OverridableImpl</code> 类也实现了这个接口，但覆写了该接口的默认方法，并提供了一个不同的实现。</p><p>Java 8 带来的另一个有趣的特性是在接口中可以定义静态方法，例子代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">interface</span> <span class="token class-name">DefaulableFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// Interfaces now allow static methods</span>    <span class="token keyword">static</span> Defaulable <span class="token function">create</span><span class="token punctuation">(</span>Supplier<span class="token operator">&lt;</span>Defaulable<span class="token operator">></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下面的代码片段整合了默认方法和静态方法的使用场景：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>    Defaulable defaulable <span class="token operator">=</span> DefaulableFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>DefaultableImpl<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>defaulable<span class="token punctuation">.</span><span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    defaulable <span class="token operator">=</span> DefaulableFactory<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>OverridableImpl<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>defaulable<span class="token punctuation">.</span><span class="token function">notRequired</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>这段代码的输出结果如下：</p><pre class=" language-shell"><code class="language-shell">Default implementationOverridden implementation</code></pre><p>由于 JVM 上的默认方法的实现在字节码层面提供了支持，因此效率非常高。默认方法允许在不打破现有继承体系的基础上改进接口。该特性在官方库中的应用是：给 <code>java.util.Collection</code> 接口添加新方法，如 <code>stream()</code>、<code>parallelStream()</code>、<code>forEach()</code> 和 <code>removeIf()</code> 等等。</p><p>尽管默认方法有这么多好处，但在实际开发中应该谨慎使用：在复杂的继承体系中，默认方法可能引起歧义和编译错误。如果你想了解更多细节，可以参考<a href="https://docs.oracle.com/javase/tutorial/java/IandI/defaultmethods.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="方法引用"><a href="#方法引用" class="headerlink" title="方法引用"></a>方法引用</h4><p>方法引用使得开发者可以直接引用现存的方法、Java 类的构造方法或者实例对象。方法引用和 Lambda 表达式配合使用，使得 Java 类的构造方法看起来紧凑而简洁，没有很多复杂的模板代码。</p><p>西门的例子中，<strong>Car</strong> 类是不同方法引用的例子，可以帮助读者区分四种类型的方法引用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Car</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Car <span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">final</span> Supplier<span class="token operator">&lt;</span>Car<span class="token operator">></span> supplier<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> supplier<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">collide</span><span class="token punctuation">(</span><span class="token keyword">final</span> Car car<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Collided "</span> <span class="token operator">+</span> car<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">follow</span><span class="token punctuation">(</span><span class="token keyword">final</span> Car another<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Following the "</span> <span class="token operator">+</span> another<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">repair</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Repaired "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>第一种方法引用的类型是构造器引用，语法是 <code>Class::new</code>，或者更一般的形式：<code>Class&lt;T&gt;::new</code>。注意：这个构造器没有参数。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Car car <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> List<span class="token operator">&lt;</span>Car<span class="token operator">></span> cars <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>car<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第二种方法引用的类型是静态方法引用，语法是 <code>Class::static_method</code>。注意：这个方法接受一个 Car 类型的参数。</p><pre class=" language-java"><code class="language-java">cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span>collide<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第三种方法引用的类型是某个类的成员方法的引用，语法是 <code>Class::method</code>，注意，这个方法没有定义入参：</p><pre class=" language-java"><code class="language-java">cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span>repair<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>第四种方法引用的类型是某个实例对象的成员方法的引用，语法是 <code>instance::method</code>。注意：这个方法接受一个 Car 类型的参数：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Car police <span class="token operator">=</span> Car<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Car<span class="token operator">:</span><span class="token operator">:</span><span class="token keyword">new</span><span class="token punctuation">)</span><span class="token punctuation">;</span>cars<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>police<span class="token operator">:</span><span class="token operator">:</span>follow<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行上述例子，可以在控制台看到如下输出（Car实例可能不同）：</p><pre class=" language-shell"><code class="language-shell">Collided com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197dRepaired com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197dFollowing the com.javacodegeeks.java8.method.references.MethodReferences$Car@7a81197d</code></pre><p>如果想了解和学习更详细的内容，可以参考<a href="https://docs.oracle.com/javase/tutorial/java/javaOO/methodreferences.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="重复注解"><a href="#重复注解" class="headerlink" title="重复注解"></a>重复注解</h4><p>自从 Java 5 中引入<a href="https://www.javacodegeeks.com/2012/08/java-annotations-explored-explained.html" target="_blank" rel="noopener">注解</a>以来，这个特性开始变得非常流行，并在各个框架和项目中被广泛使用。不过，注解有一个很大的限制是：在同一个地方不能多次使用同一个注解。Java 8 打破了这个限制，引入了重复注解的概念，允许在同一个地方多次使用同一个注解。</p><p>在 Java 8 中使用 <code>@Repeatable</code> 注解定义重复注解，实际上，这并不是语言层面的改进，而是编译器做的一个 trick，底层的技术仍然相同。可以利用下面的代码说明：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>repeatable<span class="token punctuation">.</span>annotations<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Repeatable<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RepeatingAnnotations</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filters</span> <span class="token punctuation">{</span>        Filter<span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span>ElementType<span class="token punctuation">.</span>TYPE<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Repeatable</span><span class="token punctuation">(</span>Filters<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">Filter</span> <span class="token punctuation">{</span>        String <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter1"</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Filter</span><span class="token punctuation">(</span><span class="token string">"filter2"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Filterable</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Filter filter <span class="token operator">:</span> Filterable<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getAnnotationsByType</span><span class="token punctuation">(</span>Filter<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>filter<span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>正如我们所见，这里的 <code>Filter</code> 类使用 <code>@Repeatable(Filters.class)</code> 注解修饰，而 <code>Filters</code> 是存放 <code>Filter</code> 注解的容器，编译器尽量对开发者屏蔽这些细节。这样，<code>Filterable</code> 接口可以用两个 <code>Filter</code> 注解注释（这里并没有提到任何关于Filters的信息）。</p><p>另外，反射 API 提供了一个新的方法：<code>getAnnotationsByType()</code>，可以返回某个类型的重复注解，例如 Filterable.class.getAnnoation(Filters.class) 将返回两个 Filter 实例，输出到控制台的内容如下所示：</p><pre class=" language-shell"><code class="language-shell">filter1filter2</code></pre><p>如果你希望了解更多内容，可以参考<a href="https://docs.oracle.com/javase/tutorial/java/annotations/repeating.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="更好的类型推断"><a href="#更好的类型推断" class="headerlink" title="更好的类型推断"></a>更好的类型推断</h4><p>Java 8 编译器在类型推断方面有很大的提升，在很多场景下编译器可以推导出某个参数的数据类型，从而使得代码更为简洁。例子代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>type<span class="token punctuation">.</span>inference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span>T<span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token operator">&lt;</span>T<span class="token operator">></span> T <span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> T <span class="token function">getOrDefault</span><span class="token punctuation">(</span>T value<span class="token punctuation">,</span> T defaultValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>value <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token operator">?</span> value <span class="token operator">:</span> defaultValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>下列代码是 <code>Value&lt;String&gt;</code> 类型的应用：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>type<span class="token punctuation">.</span>inference<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TypeInference</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Value<span class="token operator">&lt;</span>String<span class="token operator">></span> value <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Value</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        value<span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span><span class="token string">"22"</span><span class="token punctuation">,</span> Value<span class="token punctuation">.</span><span class="token function">defaultValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>参数 <code>Value.defaultValue()</code> 的类型由编译器推导得出，不需要显式指明。在 Java 7 中这段代码会有编译错误，除非使用 <code>Value.&lt;String&gt;defaultValue()</code>。</p><h4 id="拓宽注解的应用场景"><a href="#拓宽注解的应用场景" class="headerlink" title="拓宽注解的应用场景"></a>拓宽注解的应用场景</h4><p>Java 8 拓宽了注解的应用场景。现在，注解几乎可以使用在任何元素上：局部变量、接口类型、超类和接口实现类，甚至可以用在函数的异常定义上。下面是一些例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>annotations<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>ElementType<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Retention<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>RetentionPolicy<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>annotation<span class="token punctuation">.</span>Target<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>ArrayList<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Collection<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Annotations</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Retention</span><span class="token punctuation">(</span>RetentionPolicy<span class="token punctuation">.</span>RUNTIME<span class="token punctuation">)</span>    <span class="token annotation punctuation">@Target</span><span class="token punctuation">(</span><span class="token punctuation">{</span>ElementType<span class="token punctuation">.</span>TYPE_USE<span class="token punctuation">,</span> ElementType<span class="token punctuation">.</span>TYPE_PARAMETER<span class="token punctuation">}</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> @<span class="token keyword">interface</span> <span class="token class-name">NonEmpty</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">Holder</span><span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> T<span class="token operator">></span> <span class="token keyword">extends</span> <span class="token annotation punctuation">@NonEmpty</span> Object <span class="token punctuation">{</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token annotation punctuation">@NonEmpty</span> Exception <span class="token punctuation">{</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unused"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span> holder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token annotation punctuation">@NonEmpty</span> Holder<span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@NonEmpty</span> Collection<span class="token operator">&lt;</span><span class="token annotation punctuation">@NonEmpty</span> String<span class="token operator">></span> strings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span><span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p><code>ElementType.TYPE_USER</code> 和 <code>ElementType.TYPE_PARAMETER</code> 是 Java 8 新增的两个注解，用于描述注解的使用场景。Java 语言也做了对应的改变，以识别这些新增的注解。</p><h3 id="Java-编译器的新特性"><a href="#Java-编译器的新特性" class="headerlink" title="Java 编译器的新特性"></a>Java 编译器的新特性</h3><h4 id="参数名称"><a href="#参数名称" class="headerlink" title="参数名称"></a>参数名称</h4><p>为了在运行时获得 Java 程序中方法的参数名称，老一辈的 Java 程序员必须使用不同方法，例如 <a href="https://github.com/paul-hammant/paranamer" target="_blank" rel="noopener">Paranamer liberary</a>。Java 8 终于将这个特性规范化，在语言层面（使用反射API和Parameter.getName()方法）和字节码层面（使用新的javac编译器以及-parameters参数）提供支持。</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>parameter<span class="token punctuation">.</span>names<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Method<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span class="token punctuation">.</span>Parameter<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParameterNames</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> Exception <span class="token punctuation">{</span>        Method method <span class="token operator">=</span> ParameterNames<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">.</span><span class="token function">getMethod</span><span class="token punctuation">(</span><span class="token string">"main"</span><span class="token punctuation">,</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">final</span> Parameter parameter <span class="token operator">:</span> method<span class="token punctuation">.</span><span class="token function">getParameters</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Parameter: "</span> <span class="token operator">+</span> parameter<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>在 Java 8 中这个特性是默认关闭的，因此如果不带 <code>-parameters</code> 参数编译上述代码并运行，则会输出如下结果：</p><pre class=" language-shell"><code class="language-shell">Parameter: arg0</code></pre><p>如果带 <code>-parameters</code> 参数，则会输出如下结果（正确的结果）：</p><pre class=" language-shell"><code class="language-shell">Parameter: args</code></pre><p>如果你使用 Maven 进行项目管理，则可以在 <code>maven-compiler-plugin</code> 编译器的配置项中配置 <code>-parameters</code> 参数：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>plugin</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">></span></span>org.apache.maven.plugins<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">></span></span>maven-compiler-plugin<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">></span></span>3.1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>configuration</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>compilerArgument</span><span class="token punctuation">></span></span>-parameters<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>compilerArgument</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>source</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>source</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>target</span><span class="token punctuation">></span></span>1.8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>target</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>configuration</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>plugin</span><span class="token punctuation">></span></span></code></pre><h3 id="Java-官方库的新特性"><a href="#Java-官方库的新特性" class="headerlink" title="Java 官方库的新特性"></a>Java 官方库的新特性</h3><p>Java 8 增加了很多新的工具类（date/time类），并扩展了现存的工具类，以支持现代的并发编程、函数式编程等。</p><h4 id="Optional"><a href="#Optional" class="headerlink" title="Optional"></a>Optional</h4><p>Java 应用中最常见的 bug 就是<a href="https://examples.javacodegeeks.com/java-basics/exceptions/java-lang-nullpointerexception-how-to-handle-null-pointer-exception/" target="_blank" rel="noopener">空值异常</a>。在 Java 8 之前，<a href="https://github.com/google/guava" target="_blank" rel="noopener">Google Guava</a> 引入了 <code>Optionals</code> 类来解决 <code>NullPointerException</code>，从而避免源码被各种 <code>null</code> 检查污染，以便开发者写出更加整洁的代码。Java 8 也将 <code>Optional</code> 加入了官方库。</p><p><code>Optional</code> 仅仅是一个容器：存放 <code>T</code> 类型的值或者 <code>null</code>，它提供了一些有用的方法来避免显式的 <code>null</code> 检查，可以参考 <a href="https://docs.oracle.com/javase/8/docs/api/" target="_blank" rel="noopener">Java 8 官方文档</a>了解更多细节。</p><p>接下来看一点使用 <code>Optional</code> 的例子：可能为空的值或者某个类型的值：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> fullName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">ofNullable</span><span class="token punctuation">(</span>null<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name is set? "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Full Name: "</span> <span class="token operator">+</span> fullName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>fullName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>如果 <code>Optional</code> 实例持有一个非空值，则 <code>isPresent()</code> 方法返回 true，否则返回 false；<code>orElseGet()</code> 方法，<code>Optional</code> 实例持有 <code>null</code>，则可以接受一个 lambda 表达式生成的默认值；<code>map()</code> 方法可以将现有的 <code>Opetional</code> 实例的值转换成新的值；<code>orElse()</code> 方法与 <code>orElseGet()</code> 方法类似，但是在持有null的时候返回传入的默认值。</p><p>上述代码的输出结果如下：</p><pre class=" language-shell"><code class="language-shell">Full Name is set? falseFull Name: [none]Hey Stranger!</code></pre><p>再看下另一个简单的例子：</p><pre class=" language-java"><code class="language-java">Optional<span class="token operator">&lt;</span>String<span class="token operator">></span> firstName <span class="token operator">=</span> Optional<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Tom"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name is set? "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">isPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"First Name: "</span> <span class="token operator">+</span> firstName<span class="token punctuation">.</span><span class="token function">orElseGet</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"[none]"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>firstName<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>s <span class="token operator">-</span><span class="token operator">></span> <span class="token string">"Hey "</span> <span class="token operator">+</span> s <span class="token operator">+</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">orElse</span><span class="token punctuation">(</span><span class="token string">"Hey Stranger!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个例子的输出是：</p><pre class=" language-shell"><code class="language-shell">First Name is set? trueFirst Name: TomHey Tom!</code></pre><p>如果想了解更多的细节，请参考<a href="https://docs.oracle.com/javase/8/docs/api/java/util/Optional.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="Streams-API"><a href="#Streams-API" class="headerlink" title="Streams API"></a>Streams API</h4><p>新增的 <a href="https://www.javacodegeeks.com/2014/05/the-effects-of-programming-with-java-8-streams-on-algorithm-performance.html" target="_blank" rel="noopener">Stream API</a>（java.util.stream）将生成环境的函数式编程引入了 Java 库中。这是目前为止最大的一次对 Java 库的完善，以便开发者能够写出更加有效、更加简洁和紧凑的代码。</p><p>Steam API 极大得简化了集合操作（后面我们会看到不止是集合），首先看下这个叫 Task 的类：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Streams</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">enum</span> Status <span class="token punctuation">{</span>        OPEN<span class="token punctuation">,</span> CLOSED    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">Task</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> Status status<span class="token punctuation">;</span>        <span class="token keyword">private</span> <span class="token keyword">final</span> Integer points<span class="token punctuation">;</span>        <span class="token function">Task</span><span class="token punctuation">(</span><span class="token keyword">final</span> Status status<span class="token punctuation">,</span> <span class="token keyword">final</span> Integer points<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">=</span> status<span class="token punctuation">;</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>points <span class="token operator">=</span> points<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Integer <span class="token function">getPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> points<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">public</span> Status <span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> status<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"[%s, %d]"</span><span class="token punctuation">,</span> status<span class="token punctuation">,</span> points<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>Task 类有一个分数（或伪复杂度）的概念，另外还有两种状态：OPEN 或者 CLOSED。现在假设有一个 task 集合：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Collection<span class="token operator">&lt;</span>Task<span class="token operator">></span> tasks <span class="token operator">=</span> Arrays<span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>        <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>Status<span class="token punctuation">.</span>OPEN<span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>Status<span class="token punctuation">.</span>OPEN<span class="token punctuation">,</span> <span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        <span class="token keyword">new</span> <span class="token class-name">Task</span><span class="token punctuation">(</span>Status<span class="token punctuation">.</span>CLOSED<span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>首先看一个问题：在这个 task 集合中一共有多少个 OPEN 状态的点？在 Java 8 之前，要解决这个问题，则需要使用 <code>foreach</code> 循环遍历 task 集合；但是在 Java 8 中可以利用 <code>steams</code> 解决：包括一系列元素的列表，并且支持顺序和并行处理。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Calculate total points of all active tasks using sum()</span><span class="token keyword">final</span> <span class="token keyword">long</span> totalPointsOfOpenTasks <span class="token operator">=</span> tasks        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">filter</span><span class="token punctuation">(</span>task <span class="token operator">-</span><span class="token operator">></span> task<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> Status<span class="token punctuation">.</span>OPEN<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span>Task<span class="token operator">:</span><span class="token operator">:</span>getPoints<span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">sum</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total points: "</span> <span class="token operator">+</span> totalPointsOfOpenTasks<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>运行这个方法的控制台输出是：</p><pre class=" language-shell"><code class="language-shell">Total points: 18</code></pre><p>这里有很多知识点值得说。首先，tasks 集合被转换成 <code>steam</code> 表示；其次，在 steam 上的 <code>filter</code> 操作会过滤掉所有 CLOSED 的 task；第三，<code>mapToInt</code> 操作基于每个 task 实例的 <code>Task::getPoints</code> 方法将 task 流转换成 Integer 集合；最后，通过 <code>sum</code> 方法计算总和，得出最后的结果。</p><p>在学习下一个例子之前，还需要记住一些 steams（<a href="https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html#StreamOps" target="_blank" rel="noopener">点此更多细节</a>）的知识点。Steam 之上的操作可分为中间操作和晚期操作。</p><p>中间操作会返回一个新的 steam —— 执行一个中间操作（例如filter）并不会执行实际的过滤操作，而是创建一个新的 steam，并将原 steam 中符合条件的元素放入新创建的 steam。</p><p>晚期操作（例如 <code>forEach</code> 或者 <code>sum</code>），会遍历 steam 并得出结果或者附带结果；在执行晚期操作之后，steam 处理线已经处理完毕，就不能使用了。在几乎所有情况下，晚期操作都是立刻对 steam 进行遍历。</p><p>steam 的另一个价值是创造性地支持并行处理（parallel processing）。对于上述的 tasks 集合，我们可以用下面的代码计算所有任务的点数之和：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Calculate total points of all tasks</span><span class="token keyword">final</span> <span class="token keyword">double</span> totalPoints <span class="token operator">=</span> tasks        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">parallel</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span>task <span class="token operator">-</span><span class="token operator">></span> task<span class="token punctuation">.</span><span class="token function">getPoints</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// or map( Task::getPoints )</span>        <span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> Integer<span class="token operator">:</span><span class="token operator">:</span>sum<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Total points (all tasks): "</span> <span class="token operator">+</span> totalPoints<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这里我们使用 <code>parallel</code> 方法并行处理所有的 task，并使用 <code>reduce</code> 方法计算最终的结果。控制台输出如下：</p><pre class=" language-shell"><code class="language-shell">Total points（all tasks）: 26.0</code></pre><p>对于一个集合，经常需要根据某些条件对其中的元素分组。利用 steam 提供的 API 可以很快完成这类任务，代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Group tasks by their status</span><span class="token keyword">final</span> Map<span class="token operator">&lt;</span>Status<span class="token punctuation">,</span> List<span class="token operator">&lt;</span>Task<span class="token operator">>></span> map <span class="token operator">=</span> tasks        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">groupingBy</span><span class="token punctuation">(</span>Task<span class="token operator">:</span><span class="token operator">:</span>getStatus<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>控制台的输出如下：</p><pre class=" language-shell"><code class="language-shell">{CLOSED=[[CLOSED, 8]], OPEN=[[OPEN, 5], [OPEN, 13]]}</code></pre><p>最后一个关于 tasks 集合的例子问题是：如何计算集合中每个任务的点数在集合中所占的比重，具体处理的代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Calculate the weight of each tasks (as percent of total points) </span><span class="token keyword">final</span> Collection<span class="token operator">&lt;</span>String<span class="token operator">></span> result <span class="token operator">=</span> tasks        <span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                      <span class="token comment" spellcheck="true">// Stream&lt; String ></span>        <span class="token punctuation">.</span><span class="token function">mapToInt</span><span class="token punctuation">(</span>Task<span class="token operator">:</span><span class="token operator">:</span>getPoints<span class="token punctuation">)</span>                     <span class="token comment" spellcheck="true">// IntStream</span>        <span class="token punctuation">.</span><span class="token function">asLongStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                <span class="token comment" spellcheck="true">// LongStream</span>        <span class="token punctuation">.</span><span class="token function">mapToDouble</span><span class="token punctuation">(</span>points <span class="token operator">-</span><span class="token operator">></span> points <span class="token operator">/</span> totalPoints<span class="token punctuation">)</span>   <span class="token comment" spellcheck="true">// DoubleStream</span>        <span class="token punctuation">.</span><span class="token function">boxed</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                                       <span class="token comment" spellcheck="true">// Stream&lt; Double ></span>        <span class="token punctuation">.</span><span class="token function">mapToLong</span><span class="token punctuation">(</span>weigth <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">(</span><span class="token keyword">long</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>weigth <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token comment" spellcheck="true">// LongStream</span>        <span class="token punctuation">.</span><span class="token function">mapToObj</span><span class="token punctuation">(</span>percentage <span class="token operator">-</span><span class="token operator">></span> percentage <span class="token operator">+</span> <span class="token string">"%"</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// Stream&lt; String></span>        <span class="token punctuation">.</span><span class="token function">collect</span><span class="token punctuation">(</span>Collectors<span class="token punctuation">.</span><span class="token function">toList</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token comment" spellcheck="true">// List&lt; String ></span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>控制台输出结果如下：</p><pre class=" language-shell"><code class="language-shell">[19%, 50%, 30%]</code></pre><p>最后，正如之前所说，Steam API 不仅可以作用于 Java 集合，传统的 IO 操作（从文件或者网络一行一行得读取数据）可以受益于 steam 处理，这里有一个小例子：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">final</span> Path path <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">File</span><span class="token punctuation">(</span>filename<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">(</span>Stream<span class="token operator">&lt;</span>String<span class="token operator">></span> lines <span class="token operator">=</span> Files<span class="token punctuation">.</span><span class="token function">lines</span><span class="token punctuation">(</span>path<span class="token punctuation">,</span> StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        lines<span class="token punctuation">.</span><span class="token function">onClose</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Done!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>System<span class="token punctuation">.</span>out<span class="token operator">:</span><span class="token operator">:</span>println<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>Stream 的方法 <code>onClose</code> 返回一个等价的有额外句柄的 Stream，当 Stream 的 <code>close()</code> 方法被调用的时候这个句柄会被执行。Stream API、Lambda 表达式还有接口默认方法和静态方法支持的方法引用，是 Java 8 对软件开发的现代范式的响应。</p><h4 id="Date-Time-API"><a href="#Date-Time-API" class="headerlink" title="Date/Time API"></a>Date/Time API</h4><p>Java 8 引入了<a href="https://jcp.org/en/jsr/detail?id=310" target="_blank" rel="noopener">新的 Date-Time API(JSR 310)</a>来改进时间、日期的处理。时间和日期的管理一直是最令 Java 开发者痛苦的问题。<code>java.util.Date</code> 和后来的 <code>java.util.Calendar</code> 一直没有解决这个问题（甚至令开发者更加迷茫）。</p><p>因为上面这些原因，诞生了第三方库 <a href="https://www.joda.org/joda-time/" target="_blank" rel="noopener">Joda-Time</a>，可以替代 Java 的时间管理 API。Java 8 中新的时间和日期管理 API 深受 Joda-Time 影响，并吸收了很多 Joda-Time 的精华。新的 java.time 包包含了所有关于日期、时间、时区、Instant（跟日期类似但是精确到纳秒）、duration（持续时间）和时钟操作的类。新设计的API认真考虑了这些类的不变性（从 java.util.Calendar 吸取的教训），如果某个实例需要修改，则返回一个新的对象。</p><p>我们接下来看看 java.time 包中的关键类和各自的使用例子。<br>首先，<code>Clock</code> 类使用时区来返回当前的纳秒时间和日期。<code>Clock</code> 可以替代 <code>System.currentTimeMillis()</code> 和 <code>TimeZone.getDefault()</code>。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Get the system clock as UTC offset </span><span class="token keyword">final</span> Clock clock <span class="token operator">=</span> Clock<span class="token punctuation">.</span><span class="token function">systemUTC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span><span class="token function">instant</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>clock<span class="token punctuation">.</span><span class="token function">millis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个例子的输出结果是：</p><pre class=" language-shell"><code class="language-shell">2014-04-12T15:19:29.282Z1397315969360</code></pre><p>第二，关注下 <code>LocalDate</code> 和 <code>LocalTime</code> 类。<code>LocalDate</code> 仅仅包含 ISO-8601 日历系统中的日期部分；<code>LocalTime</code> 则仅仅包含该日历系统中的时间部分。这两个类的对象都可以使用 <code>Clock</code> 对象构建得到。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Get the local date and local time</span><span class="token keyword">final</span> LocalDate date <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> LocalDate dateFromClock <span class="token operator">=</span> LocalDate<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>date<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>dateFromClock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// Get the local date and local time</span><span class="token keyword">final</span> LocalTime time <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> LocalTime timeFromClock <span class="token operator">=</span> LocalTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>time<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>timeFromClock<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述例子的输出结果如下：</p><pre class=" language-shell"><code class="language-shell">2014-04-122014-04-1211:25:54.56815:25:54.568</code></pre><p><code>LocalDateTime</code> 类包含了 <code>LocalDate</code> 和 <code>LocalTime</code> 的信息，但是不包含 ISO-8601 日历系统中的时区信息。这里有一些<a href="https://www.javacodegeeks.com/2014/04/java-8-date-time-api-tutorial-localdatetime.html" target="_blank" rel="noopener">关于 LocalDate 和 LocalTime 的例子</a>：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Get the local date/time</span><span class="token keyword">final</span> LocalDateTime datetime <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> LocalDateTime datetimeFromClock <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>datetime<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>datetimeFromClock<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>上述这个例子的输出结果如下：</p><pre class=" language-shell"><code class="language-shell">2014-04-12T11:37:52.3092014-04-12T15:37:52.309</code></pre><p>如果你需要特定时区的 data/time 信息，则可以使用 <code>ZoneDateTime</code>，它保存有 ISO-8601 日期系统的日期和时间，而且有时区信息。下面是一些使用不同时区的例子：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Get the zoned date/time</span><span class="token keyword">final</span> ZonedDateTime zonedDatetime <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> ZonedDateTime zonedDatetimeFromClock <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>clock<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> ZonedDateTime zonedDatetimeFromZone <span class="token operator">=</span> ZonedDateTime<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span>ZoneId<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"America/Los_Angeles"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zonedDatetime<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zonedDatetimeFromClock<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>zonedDatetimeFromZone<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个例子的输出结果是：</p><pre class=" language-shell"><code class="language-shell">2014-04-12T11:47:01.017-04:00[America/New_York]2014-04-12T15:47:01.017Z2014-04-12T08:47:01.017-07:00[America/Los_Angeles]</code></pre><p>最后看下 <code>Duration</code> 类，它持有的时间精确到秒和纳秒。这使得我们可以很容易得计算两个日期之间的不同，例子代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Get duration between two dates</span><span class="token keyword">final</span> LocalDateTime from <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2014</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>APRIL<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> LocalDateTime to <span class="token operator">=</span> LocalDateTime<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token number">2015</span><span class="token punctuation">,</span> Month<span class="token punctuation">.</span>APRIL<span class="token punctuation">,</span> <span class="token number">16</span><span class="token punctuation">,</span> <span class="token number">23</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">,</span> <span class="token number">59</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">final</span> Duration duration <span class="token operator">=</span> Duration<span class="token punctuation">.</span><span class="token function">between</span><span class="token punctuation">(</span>from<span class="token punctuation">,</span> to<span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Duration in days: "</span> <span class="token operator">+</span> duration<span class="token punctuation">.</span><span class="token function">toDays</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Duration in hours: "</span> <span class="token operator">+</span> duration<span class="token punctuation">.</span><span class="token function">toHours</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个例子用于计算2014年4月16日和2015年4月16日之间的天数和小时数，输出结果如下：</p><pre class=" language-shell"><code class="language-shell">Duration in days: 365Duration in hours: 8783</code></pre><p>对于 Java 8 的新日期时间的总体印象还是比较积极的，一部分是因为 Joda-Time 的积极影响，另一部分是因为官方终于听取了开发人员的需求。如果希望了解更多细节，可以参考<a href="https://docs.oracle.com/javase/tutorial/datetime/index.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="Nashorn-JavaScript-引擎"><a href="#Nashorn-JavaScript-引擎" class="headerlink" title="Nashorn JavaScript 引擎"></a>Nashorn JavaScript 引擎</h4><p>Java 8 提供了新的 <a href="https://www.javacodegeeks.com/2014/02/java-8-compiling-lambda-expressions-in-the-new-nashorn-js-engine.html" target="_blank" rel="noopener">Nashorn JavaScript 引擎</a>，使得我们可以在 JVM 上开发和运行 JS 应用。Nashorn JavaScript 引擎是 javax.script.ScriptEngine 的另一个实现版本，这类 Script 引擎遵循相同的规则，允许 Java 和 JavaScript 交互使用，例子代码如下：</p><pre class=" language-java"><code class="language-java">ScriptEngineManager manager <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ScriptEngineManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>ScriptEngine engine <span class="token operator">=</span> manager<span class="token punctuation">.</span><span class="token function">getEngineByName</span><span class="token punctuation">(</span><span class="token string">"JavaScript"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>engine<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Result:"</span> <span class="token operator">+</span> engine<span class="token punctuation">.</span><span class="token function">eval</span><span class="token punctuation">(</span><span class="token string">"function f() { return 1; }; f() + 1;"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>这个代码的输出结果如下：</p><pre class=" language-shell"><code class="language-shell">jdk.nashorn.api.scripting.NashornScriptEngineResult: 2</code></pre><h4 id="Base64"><a href="#Base64" class="headerlink" title="Base64"></a>Base64</h4><p><a href="https://www.javacodegeeks.com/2014/04/base64-in-java-8-its-not-too-late-to-join-in-the-fun.html" target="_blank" rel="noopener">对 Base64 编码的支持</a>已经被加入到 Java 8 官方库中，这样不需要使用第三方库就可以进行 Base64 编码，例子代码如下：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>base64<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>nio<span class="token punctuation">.</span>charset<span class="token punctuation">.</span>StandardCharsets<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Base64<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Base64s</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">final</span> String text <span class="token operator">=</span> <span class="token string">"Base64 finally in Java 8!"</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String encoded <span class="token operator">=</span> Base64                <span class="token punctuation">.</span><span class="token function">getEncoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span>                <span class="token punctuation">.</span><span class="token function">encodeToString</span><span class="token punctuation">(</span>text<span class="token punctuation">.</span><span class="token function">getBytes</span><span class="token punctuation">(</span>StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">final</span> String decoded <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span>                Base64<span class="token punctuation">.</span><span class="token function">getDecoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">decode</span><span class="token punctuation">(</span>encoded<span class="token punctuation">)</span><span class="token punctuation">,</span>                StandardCharsets<span class="token punctuation">.</span>UTF_8<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>decoded<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>这个例子的输出结果如下：</p><pre class=" language-shell"><code class="language-shell">QmFzZTY0IGZpbmFsbHkgaW4gSmF2YSA4IQ==Base64 finally in Java 8!</code></pre><p>新的 Base64 API 也支持 URL 和 MINE 的编码解码(<code>Base64.getUrlEncoder()</code> / <code>Base64.getUrlDecoder()</code>, <code>Base64.getMimeEncoder()</code> / <code>Base64.getMimeDecoder()</code>)。</p><p>BASE64不是用来加密的，是BASE64编码后的字符串，全部都是由标准键盘上面的常规字符组成，这样编码后的字符串在网关之间传递不会产生UNICODE字符串不能识别或者丢失的现象。你再仔细研究下EMAIL就会发现其实EMAIL就是用base64编码过后再发送的。然后接收的时候再还原。</p><h4 id="并行数组"><a href="#并行数组" class="headerlink" title="并行数组"></a>并行数组</h4><p>Java 8 版本新增了很多新的方法，用于支持并行数组处理。最重要的方法是 <code>parallelSort()</code>，可以显著加快多核机器上的数组排序。下面的例子论证了 <code>parallexXxx</code> 系列的方法：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">package</span> com<span class="token punctuation">.</span>javacodegeeks<span class="token punctuation">.</span>java8<span class="token punctuation">.</span>parallel<span class="token punctuation">.</span>arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>Arrays<span class="token punctuation">;</span><span class="token keyword">import</span> java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>ThreadLocalRandom<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ParallelArrays</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">long</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arrayOfLong <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">long</span><span class="token punctuation">[</span><span class="token number">20000</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">parallelSetAll</span><span class="token punctuation">(</span>arrayOfLong<span class="token punctuation">,</span>                index <span class="token operator">-</span><span class="token operator">></span> ThreadLocalRandom<span class="token punctuation">.</span><span class="token function">current</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>arrayOfLong<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>                i <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">parallelSort</span><span class="token punctuation">(</span>arrayOfLong<span class="token punctuation">)</span><span class="token punctuation">;</span>        Arrays<span class="token punctuation">.</span><span class="token function">stream</span><span class="token punctuation">(</span>arrayOfLong<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">limit</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span>                i <span class="token operator">-</span><span class="token operator">></span> System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span>i <span class="token operator">+</span> <span class="token string">" "</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>上述这些代码使用 <code>parallelSetAll()</code> 方法生成20000个随机数，然后使用 <code>parallelSort()</code> 方法进行排序。这个程序会输出乱序数组和排序数组的前10个元素。上述例子的代码输出的结果是：</p><pre class=" language-shell"><code class="language-shell">Unsorted: 591217 891976 443951 424479 766825 351964 242997 642839 119108 552378 Sorted: 39 220 263 268 325 607 655 678 723 793</code></pre><h4 id="并发性"><a href="#并发性" class="headerlink" title="并发性"></a>并发性</h4><p>基于新增的 lambda 表达式和 steam 特性，为 Java 8 中为 <code>java.util.concurrent.ConcurrentHashMap</code> 类添加了新的方法来支持聚焦操作；另外，也为 <code>java.util.concurrentForkJoinPool</code> 类添加了新的方法来支持通用线程池操作（更多内容可以参考我们的<a href="academy.javacodegeeks.com/course/java-concurrency-essentials/">并发编程课程</a>）。</p><p>Java 8 还添加了新的 <code>java.util.concurrent.locks.StampedLock</code> 类，用于支持基于容量的锁——该锁有三个模型用于支持读写操作（可以把这个锁当做是 <code>java.util.concurrent.locks.ReadWriteLock</code> 的替代者）。</p><p>在 <code>java.util.concurrent.atomic</code> 包中也新增了不少工具类，列举如下：</p><ul><li>DoubleAccumulator</li><li>DoubleAdder</li><li>LongAccumulator</li><li>LongAdder</li></ul><h3 id="新的-Java-工具"><a href="#新的-Java-工具" class="headerlink" title="新的 Java 工具"></a>新的 Java 工具</h3><p>Java 8 提供了一些新的命令行工具，这部分会讲解一些对开发者最有用的工具。</p><h4 id="Nashorn-引擎：jjs"><a href="#Nashorn-引擎：jjs" class="headerlink" title="Nashorn 引擎：jjs"></a>Nashorn 引擎：jjs</h4><p><code>jjs</code> 是一个基于标准 Nashorn 引擎的命令行工具，可以接受 js 源码并执行。例如，我们写一个 <code>func.js</code> 文件，内容如下：</p><pre class=" language-javascript"><code class="language-javascript"><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>可以在命令行中执行这个命令：jjs func.js，控制台输出结果是：</p><pre class=" language-shell"><code class="language-shell">2</code></pre><p>如果需要了解细节，可以参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jjs.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="类依赖分析器：jdeps"><a href="#类依赖分析器：jdeps" class="headerlink" title="类依赖分析器：jdeps"></a>类依赖分析器：jdeps</h4><p><code>jdeps</code> 是一个相当棒的命令行工具，它可以展示包层级和类层级的 Java 类依赖关系，它以 <code>.class</code> 文件、目录或者 JAR 文件为输入，然后会把依赖关系输出到控制台。</p><p>我们可以利用 jedps 分析下 Spring Framework 库，为了让结果少一点，仅仅分析一个 JAR 文件：<code>org.springframework.core-3.0.5.RELEASE.jar</code>。</p><pre class=" language-shell"><code class="language-shell">jdeps org.springframework.core-3.0.5.RELEASE.jar</code></pre><p>这个命令会输出很多结果，我们仅看下其中的一部分：依赖关系按照包分组，如果在 classpath 上找不到依赖，则显示 “not found”。</p><pre class=" language-shell"><code class="language-shell">org.springframework.core-3.0.5.RELEASE.jar -> C:\Program Files\Java\jdk1.8.0\jre\lib\rt.jar   org.springframework.core (org.springframework.core-3.0.5.RELEASE.jar)      -> java.io                                                  -> java.lang                                                -> java.lang.annotation                                     -> java.lang.ref                                            -> java.lang.reflect                                        -> java.util                                                -> java.util.concurrent                                     -> org.apache.commons.logging                         not found      -> org.springframework.asm                            not found      -> org.springframework.asm.commons                    not found   org.springframework.core.annotation (org.springframework.core-3.0.5.RELEASE.jar)      -> java.lang                                                -> java.lang.annotation                                     -> java.lang.reflect                                        -> java.util</code></pre><p>更多的细节可以参考<a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jdeps.html" target="_blank" rel="noopener">官方文档</a>。</p><h3 id="JVM的新特性"><a href="#JVM的新特性" class="headerlink" title="JVM的新特性"></a>JVM的新特性</h3><p>使用 <a href="https://www.javacodegeeks.com/2013/02/java-8-from-permgen-to-metaspace.html" target="_blank" rel="noopener">Metaspace</a>（<a href="http://openjdk.java.net/jeps/122" target="_blank" rel="noopener">JEP 122</a>）代替持久代（<code>PermGen space</code>）。在 JVM 参数方面，使用 <code>-XX:MetaSpaceSize</code> 和 <code>-XX:MaxMetaspaceSize</code> 代替原来的 <code>-XX:PermSize</code> 和 <code>-XX:MaxPermSize</code>。</p><h2 id="参考资源"><a href="#参考资源" class="headerlink" title="参考资源"></a>参考资源</h2><ul><li>参考 <a href="https://docs.oracle.com/javase/8/" target="_blank" rel="noopener">Java 8 官方文档</a>，了解 Java 8 的更多内容。</li><li>参考 <a href="https://docs.oracle.com/javase/8/docs/api/index.html" target="_blank" rel="noopener">Java 8 API 文档</a>，了解 Java 8 API 的细节。 </li><li>参考 <a href="https://www.oracle.com/technetwork/java/javase/8-whats-new-2157071.html" target="_blank" rel="noopener">What’s New in JDK 8</a>，了解 Java 8 的新特性。</li><li>参考 <a href="https://www.oracle.com/technetwork/java/javase/8u-relnotes-2225394.html" target="_blank" rel="noopener">Java 8 Release Notes</a>，了解 Java 8 的更新说明。</li></ul>]]></content>
      
      
      <categories>
          
          <category> Java </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JDK </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android KTX 简介</title>
      <link href="/posts/2018/476deb33.html"/>
      <url>/posts/2018/476deb33.html</url>
      
        <content type="html"><![CDATA[<h2 id="KTX-简介"><a href="#KTX-简介" class="headerlink" title="KTX 简介"></a>KTX 简介</h2><p>Android KTX 是一组 Kotlin 扩展程序，属于 Android Jetpack 系列。它优化了供 Kotlin 使用的 Jetpack 和 Android 平台 API。Android KTX 旨在让您利用 Kotlin 语言功能（例如扩展函数/属性、lambda、命名参数和参数默认值），以更简洁、更愉悦、更惯用的方式使用 Kotlin 进行 Android 开发。Android KTX 不会向现有的 Android API 添加任何新功能。</p><h2 id="KTX-使用"><a href="#KTX-使用" class="headerlink" title="KTX 使用"></a>KTX 使用</h2><p>要开始使用 Android KTX，请将以下代码添加到项目的 <code>build.gradle</code> 文件中：</p><pre class=" language-gradle"><code class="language-gradle">repositories {    google()}</code></pre><p>Android KTX 划分为不同的模块。每个模块都包含一个或多个软件包。</p><p>使用模块时，请在应用的 <code>build.gradle</code> 文件中为每个 Android KTX 软件工件添加一个依赖项。请记住在软件工件后面附上版本号。例如，如果您使用 <code>core-ktx</code> 模块，则完整的依赖项将如下所示：</p><pre class=" language-gradle"><code class="language-gradle">dependencies {    implementation 'androidx.core:core-ktx:1.0.0-alpha1'}</code></pre><h2 id="KTX-模块"><a href="#KTX-模块" class="headerlink" title="KTX 模块"></a>KTX 模块</h2><p>Android KTX 由以下 Maven 软件工件组成。要获取 API 参考文档，请点击特定软件包名称并查看扩展函数摘要。</p><table><thead><tr><th>KTX 模块</th><th>版本</th><th>软件包</th></tr></thead><tbody><tr><td>androidx.core:core-ktx</td><td>1.0.0-alpha1</td><td>查看下面的<a href="#core-ktx">所有核心软件包</a></td></tr><tr><td>androidx.fragment:fragment-ktx</td><td>1.0.0-alpha1</td><td><a href="https://developer.android.com/reference/kotlin/androidx/fragment/app/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.fragment.app</a></td></tr><tr><td>androidx.palette:palette-ktx</td><td>1.0.0-alpha1</td><td><a href="https://developer.android.com/reference/kotlin/androidx/palette/graphics/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.palette.graphics</a></td></tr><tr><td>androidx.sqlite:sqlite-ktx</td><td>1.0.0-alpha1</td><td><a href="https://developer.android.com/reference/kotlin/androidx/sqlite/db/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.sqlite.db</a></td></tr><tr><td>androidx.collection:collection-ktx</td><td>1.0.0-alpha1</td><td><a href="https://developer.android.com/reference/kotlin/androidx/collection/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.collection</a></td></tr><tr><td>androidx.lifecycle:lifecycle-viewmodel-ktx</td><td>2.0.0-alpha1</td><td><a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.lifecycle</a></td></tr><tr><td>androidx.lifecycle:lifecycle-reactivestreams-ktx</td><td>2.0.0-alpha1</td><td><a href="https://developer.android.com/reference/kotlin/androidx/lifecycle/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.lifecycle</a></td></tr><tr><td>android.arch.navigation:navigation-common-ktx</td><td>1.0.0-alpha01</td><td><a href="https://developer.android.com/reference/kotlin/androidx/navigation/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.navigation</a></td></tr><tr><td>android.arch.navigation:navigation-fragment-ktx</td><td>1.0.0-alpha01</td><td><a href="https://developer.android.com/reference/kotlin/androidx/navigation/fragment/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.navigation.fragment</a></td></tr><tr><td>android.arch.navigation:navigation-runtime-ktx</td><td>1.0.0-alpha01</td><td><a href="https://developer.android.com/reference/kotlin/androidx/navigation/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.navigation</a></td></tr><tr><td>android.arch.navigation:navigation-testing-ktx</td><td>1.0.0-alpha01</td><td><a href="https://developer.android.com/reference/kotlin/androidx/navigation/testing/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.navigation.testing</a></td></tr><tr><td>android.arch.navigation:navigation-ui-ktx</td><td>1.0.0-alpha01</td><td><a href="https://developer.android.com/reference/kotlin/androidx/navigation/ui/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.navigation.ui</a></td></tr><tr><td>android.arch.work:work-runtime-ktx</td><td>1.0.0-alpha01</td><td><a href="https://developer.android.com/reference/kotlin/androidx/work/ktx/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.work.ktx</a></td></tr></tbody></table><h3 id="core-ktx"><a href="#core-ktx" class="headerlink" title="core-ktx"></a>core-ktx</h3><p>核心模块包括以下软件包：</p><ul><li><a href="https://developer.android.com/reference/kotlin/androidx/core/animation/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.animation</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/content/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.content</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/graphics/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.graphics</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/graphics/drawable/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.graphics.drawable</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/net/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.net</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/os/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.os</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/preference/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.preference</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/text/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.text</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/transition/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.transition</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/util/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.util</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/view/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.view</a></li><li><a href="https://developer.android.com/reference/kotlin/androidx/core/widget/package-summary#extension-functions-summary" target="_blank" rel="noopener">androidx.core.widget</a></li></ul><h2 id="KTX-示例"><a href="#KTX-示例" class="headerlink" title="KTX 示例"></a>KTX 示例</h2><p>Android KTX 是 Android Jetpack 基础组件。您可以在 <a href="https://github.com/googlesamples/android-sunflower" target="_blank" rel="noopener">Sunflower</a> 演示应用中查看它的使用情况。</p><p>以下示例演示了一些 Android KTX 扩展函数。它们按模块（软件工件）名称分组。有关扩展函数的完整列表，请查看完整的软件包参考文档。</p><h3 id="androidx-core-core-ktx"><a href="#androidx-core-core-ktx" class="headerlink" title="androidx.core:core-ktx"></a>androidx.core:core-ktx</h3><p><strong>Kotlin:</strong></p><pre class=" language-kotlin"><code class="language-kotlin">sharedPreferences<span class="token punctuation">.</span><span class="token function">edit</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>Kotlin + Android KTX:</strong></p><pre class=" language-kotlin"><code class="language-kotlin">sharedPreferences<span class="token punctuation">.</span><span class="token function">edit</span> <span class="token punctuation">{</span>    <span class="token function">putBoolean</span><span class="token punctuation">(</span><span class="token string">"key"</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="androidx-sqlite-sqlite-ktx"><a href="#androidx-sqlite-sqlite-ktx" class="headerlink" title="androidx.sqlite:sqlite-ktx"></a>androidx.sqlite:sqlite-ktx</h3><p><strong>Kotlin:</strong></p><pre class=" language-kotlin"><code class="language-kotlin">db<span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// insert data</span>    db<span class="token punctuation">.</span><span class="token function">setTransactionSuccessful</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    db<span class="token punctuation">.</span><span class="token function">endTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><p><strong>Kotlin + Android KTX:</strong></p><pre class=" language-kotlin"><code class="language-kotlin">db<span class="token punctuation">.</span><span class="token function">transaction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// insert data</span><span class="token punctuation">}</span></code></pre><h3 id="androidx-fragment-fragment-ktx"><a href="#androidx-fragment-fragment-ktx" class="headerlink" title="androidx.fragment:fragment-ktx"></a>androidx.fragment:fragment-ktx</h3><p><strong>Kotlin:</strong></p><pre class=" language-kotlin"><code class="language-kotlin">supportFragmentManager    <span class="token punctuation">.</span><span class="token function">beginTransaction</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>my_fragment_container<span class="token punctuation">,</span> myFragment<span class="token punctuation">,</span> FRAGMENT_TAG<span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">commitAllowingStateLoss</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code></pre><p><strong>Kotlin + Android KTX:</strong></p><pre class=" language-kotlin"><code class="language-kotlin">supportFragmentManager<span class="token punctuation">.</span><span class="token function">transaction</span><span class="token punctuation">(</span>allowStateLoss <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token function">replace</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>id<span class="token punctuation">.</span>my_fragment_container<span class="token punctuation">,</span> myFragment<span class="token punctuation">,</span> FRAGMENT_TAG<span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h2 id="KTX-资源"><a href="#KTX-资源" class="headerlink" title="KTX 资源"></a>KTX 资源</h2><p>Android KTX 的相关网站：</p><ul><li><a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">Android KTX</a></li><li><a href="https://github.com/android/android-ktx" target="_blank" rel="noopener">Android KTX on GitHub</a></li><li><a href="https://android.github.io/android-ktx/core-ktx/" target="_blank" rel="noopener">Android KTX API Doc</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Kotlin </tag>
            
            <tag> KTX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 资源大全</title>
      <link href="/posts/2018/29d32baa.html"/>
      <url>/posts/2018/29d32baa.html</url>
      
        <content type="html"><![CDATA[<h2 id="官网及文档"><a href="#官网及文档" class="headerlink" title="官网及文档"></a>官网及文档</h2><ul><li><a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin 官网</a></li><li><a href="https://kotlinlang.org/docs/reference/" target="_blank" rel="noopener">Kotlin 官方文档</a></li><li><a href="https://blog.jetbrains.com/kotlin/" target="_blank" rel="noopener">Kotlin 官方博客</a></li><li><a href="https://discuss.kotlinlang.org/" target="_blank" rel="noopener">Kotlin 官方论坛</a></li><li><a href="https://www.kotlincn.net/" target="_blank" rel="noopener">Kotlin 中文官网</a></li><li><a href="https://www.kotlincn.net/docs/reference/" target="_blank" rel="noopener">Kotlin 中文文档</a></li><li><a href="https://www.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文博客</a></li><li><a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文论坛</a></li><li><a href="https://github.com/JetBrains/kotlin" target="_blank" rel="noopener">Kotlin on GitHub</a></li></ul><h2 id="社区资源"><a href="#社区资源" class="headerlink" title="社区资源"></a>社区资源</h2><ul><li><a href="https://juejin.im/tag/Kotlin" target="_blank" rel="noopener">掘金技术社区</a></li><li><a href="https://kotlin.link/" target="_blank" rel="noopener">kotlin.link</a></li><li><a href="https://superkotlin.com/" target="_blank" rel="noopener">SuperKotlin</a></li></ul><h2 id="教程-amp-文章"><a href="#教程-amp-文章" class="headerlink" title="教程 &amp; 文章"></a>教程 &amp; 文章</h2><h3 id="视频教程"><a href="#视频教程" class="headerlink" title="视频教程"></a>视频教程</h3><ul><li><a href="https://github.com/enbandari/Kotlin-Tutorials" target="_blank" rel="noopener">Kotlin 系列视频教程</a></li></ul><h3 id="开始用-Kotlin-之前"><a href="#开始用-Kotlin-之前" class="headerlink" title="开始用 Kotlin 之前"></a>开始用 Kotlin 之前</h3><ul><li><a href="https://www.jianshu.com/p/272d3260dbf5" target="_blank" rel="noopener">将 Kotlin 用于生产环境：你在犹豫什么？</a></li><li><a href="https://droidyue.com/blog/2017/05/18/why-do-i-turn-to-kotlin/" target="_blank" rel="noopener">为什么我要改用 Kotlin？</a></li><li><a href="https://www.jianshu.com/p/8a1fce6fa93a" target="_blank" rel="noopener">用 Kotlin 开发 Android 项目是一种什么样的感受？</a></li><li><a href="https://www.jianshu.com/p/b444aea1b038" target="_blank" rel="noopener">用 Kotlin 开发 Android 项目是一种什么样的感受？（二）</a></li></ul><h3 id="Kotlin-语言程序设计"><a href="#Kotlin-语言程序设计" class="headerlink" title="Kotlin 语言程序设计"></a>Kotlin 语言程序设计</h3><ul><li><a href="https://kymjs.com/code/2017/02/03/01/" target="_blank" rel="noopener">Kotlin Primer · 第一章 · 启程</a></li><li><a href="https://kymjs.com/code/2017/02/04/01/" target="_blank" rel="noopener">Kotlin Primer · 第二章 · 基本语法</a></li><li><a href="https://kymjs.com/code/2017/02/07/01/" target="_blank" rel="noopener">Kotlin Primer · 第三章 · Kotlin 与 Java 混编</a></li><li><a href="https://kymjs.com/code/2017/02/12/01/" target="_blank" rel="noopener">Kotlin Primer · 第四章 · Kotlin 的类特性(上)</a></li><li><a href="https://kymjs.com/code/2017/02/26/01/" target="_blank" rel="noopener">Kotlin Primer · 第四章 · Kotlin 的类特性(下)</a></li><li><a href="https://kymjs.com/code/2017/04/09/01/" target="_blank" rel="noopener">Kotlin Primer · 第五章 · 函数与闭包</a></li><li><a href="https://kymjs.com/code/2017/06/06/01/" target="_blank" rel="noopener">Kotlin Primer · 第六章 · 集合泛型与操作符</a></li><li><a href="https://kymjs.com/code/2017/11/24/01/" target="_blank" rel="noopener">Kotlin Primer · 第七章 · 协程库(上篇)</a></li><li><a href="https://kymjs.com/code/2017/11/06/01/" target="_blank" rel="noopener">Kotlin Primer · 第七章 · 协程库(中篇)</a></li><li><a href="https://kymjs.com/code/2017/11/24/01/" target="_blank" rel="noopener">Kotlin Primer · 第七章 · 协程库(下篇)</a></li></ul><h3 id="上手-Kotlin"><a href="#上手-Kotlin" class="headerlink" title="上手 Kotlin"></a>上手 Kotlin</h3><ul><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483899&amp;idx=2&amp;sn=76f84bf0ca00ab11f5c7d75d72cee731" target="_blank" rel="noopener">快速上手 Kotlin 的 11 招</a></li><li><a href="https://juejin.im/post/59006ef95c497d00581a8d7c" target="_blank" rel="noopener">Kotlin 初探</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483805&amp;idx=1&amp;sn=6382e2a758f4c50c0a31a3d36ccb81e7" target="_blank" rel="noopener">用 Kotlin 写 Android 01 难道只有环境搭建这么简单？</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483864&amp;idx=1&amp;sn=c7211842f5f28cb506841f5e50307d0f" target="_blank" rel="noopener">用 Kotlin 写 Android 02 说说 Anko</a></li></ul><h3 id="Kotlin-amp-Java"><a href="#Kotlin-amp-Java" class="headerlink" title="Kotlin &amp; Java"></a>Kotlin &amp; Java</h3><ul><li><a href="https://mp.weixin.qq.com/s/MzIzMTYzOTYzNA" target="_blank" rel="noopener">Kotlin 与 Java 共存 (1)</a></li><li><a href="https://mp.weixin.qq.com/s/kefHfwlTiUCQamdJXkL79g" target="_blank" rel="noopener">Kotlin 与 Java 共存 (2)</a></li><li><a href="https://juejin.im/post/583b042461ff4b007ecf00ff" target="_blank" rel="noopener">告别 Java，一起来使用kotlin开发完整客户端</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483911&amp;idx=1&amp;sn=3b0ebe8ea294429b8aa4974a70e6138b" target="_blank" rel="noopener">Kotlin 兼容 Java 遇到的最大的 “坑”</a></li><li><a href="https://github.com/MindorksOpenSource/from-java-to-kotlin" target="_blank" rel="noopener">Java -&gt; Kotlin 速查表</a></li></ul><h3 id="开发实践"><a href="#开发实践" class="headerlink" title="开发实践"></a>开发实践</h3><ul><li><a href="https://droidyue.com/blog/2017/05/08/how-to-study-kotlin/" target="_blank" rel="noopener">研究学习 Kotlin 的一些方法</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483875&amp;idx=1&amp;sn=b1b565f651ee1221d4bda19ab12009ce" target="_blank" rel="noopener">深入理解 Kotlin Coroutine（一）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483878&amp;idx=1&amp;sn=710189e6e22a13fc7d1ea67bc2dd9270" target="_blank" rel="noopener">深入理解 Kotlin Coroutine（二）</a></li><li><a href="https://mp.weixin.qq.com/s?__biz=MzIzMTYzOTYzNA==&amp;mid=2247483899&amp;idx=1&amp;sn=7d24a9aecb00c80c9c6165b48660394c" target="_blank" rel="noopener">Kotlin Script 及其运行机制简析</a></li><li><a href="https://mp.weixin.qq.com/s/KP8gXSE4iH-FWk7d2C49fA" target="_blank" rel="noopener">Kotlin Native 详细体验，你想要的都在这儿</a></li><li><a href="https://enbandari.github.io/2017/05/22/2017-5-11-KotlinDSL2/" target="_blank" rel="noopener">Kotlin 一个很厉害的 DSL 写法</a></li><li><a href="https://juejin.im/post/58fd31dd8d6d8100589813bf" target="_blank" rel="noopener">如何正确终止 forEach</a></li><li><a href="http://itangqi.me/2017/03/28/using-kotlin-for-android-development/" target="_blank" rel="noopener">Using Kotlin for Android Development</a></li><li><a href="https://github.com/raywenderlich/kotlin-style-guide" target="_blank" rel="noopener">Kotlin 代码风格指南</a></li></ul><h2 id="开源库和框架"><a href="#开源库和框架" class="headerlink" title="开源库和框架"></a>开源库和框架</h2><h3 id="Android-开发"><a href="#Android-开发" class="headerlink" title="Android 开发"></a>Android 开发</h3><ul><li><a href="https://github.com/pawegio/KAndroid" target="_blank" rel="noopener">KAndroid</a> - Kotlin library for Android</li><li><a href="https://github.com/TouK/bubble" target="_blank" rel="noopener">Bubble</a> - 屏幕方向监测</li><li><a href="https://github.com/chibatching/Kotpref" target="_blank" rel="noopener">Kotpref</a> - Android SharedPreference delegation for Kotlin.</li><li><a href="https://github.com/kittinunf/Fuse" target="_blank" rel="noopener">Fuese</a> - The simple generic LRU memory/disk cache for Android</li><li><a href="https://github.com/nekocode/Kotlin-Android-Template" target="_blank" rel="noopener">Kotlin-Android-Template</a> - An Android project template using Kotlin/MVP/ReactiveX.</li></ul><h3 id="Web-开发"><a href="#Web-开发" class="headerlink" title="Web 开发"></a>Web 开发</h3><ul><li><a href="https://github.com/Kotlin/ktor" target="_blank" rel="noopener">ktor</a> - 用 Kotlin 写的 Web 后端开发框架</li><li><a href="http://karaframework.com/" target="_blank" rel="noopener">Kara</a> - MVC 开发框架</li><li><a href="https://github.com/MarioAriasC/KotlinPrimavera" target="_blank" rel="noopener">KotlinPrimavera</a> - KotlinPrimavera is a set of Kotlin libraries to support Spring portfolio projects</li><li><a href="https://github.com/jean79/yested" target="_blank" rel="noopener">Yested</a> - 用来开发 SPA 应用的框架</li><li><a href="https://github.com/kohesive/kovert" target="_blank" rel="noopener">Kovert</a> - The invisible REST and web framework</li><li><a href="https://github.com/jaguililla/hexagon" target="_blank" rel="noopener">HEXAGON</a> - 微服务框架</li><li><a href="https://github.com/gimlet2/kottpd" target="_blank" rel="noopener">kottpd</a> - REST framework written in pure Kotlin</li></ul><h3 id="网络"><a href="#网络" class="headerlink" title="网络"></a>网络</h3><ul><li><a href="https://github.com/kittinunf/Fuel" target="_blank" rel="noopener">Fuel</a> - The easiest HTTP networking library for Kotlin/Android.</li><li><a href="https://github.com/wasabifx/wasabi" target="_blank" rel="noopener">Wasabi</a> - HTTP 框架</li><li><a href="https://github.com/jkcclemens/khttp" target="_blank" rel="noopener">khttp</a> - khttp is a simple library for HTTP requests in Kotlin.</li></ul><h3 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h3><ul><li><a href="https://github.com/JakeWharton/kotterknife" target="_blank" rel="noopener">Kotter Knife</a> - View “injection” library for Android</li><li><a href="https://github.com/square/kotlinpoet" target="_blank" rel="noopener">KotlinPoet</a></li><li><a href="https://github.com/kohesive/injekt" target="_blank" rel="noopener">injekt</a> - Kotlin 依赖注入</li><li><a href="https://github.com/SalomonBrys/Kodein" target="_blank" rel="noopener">Kodein</a> - 让你的 Kotlin 实现无痛依赖注入</li></ul><h3 id="函数式编程"><a href="#函数式编程" class="headerlink" title="函数式编程"></a>函数式编程</h3><ul><li><a href="https://github.com/ReactiveX/RxKotlin" target="_blank" rel="noopener">RxKotlin</a></li><li><a href="https://github.com/MarioAriasC/funKTionale" target="_blank" rel="noopener">funKTionale</a> - Functional constructs for Kotlin</li><li><a href="https://github.com/kittinunf/Result" target="_blank" rel="noopener">Result</a> - The modelling for success/failure of operations in Kotlin</li></ul><h3 id="JSON"><a href="#JSON" class="headerlink" title="JSON"></a>JSON</h3><ul><li><a href="https://github.com/cbeust/klaxon" target="_blank" rel="noopener">Klaxon</a> - 一个解析 JSON 的库</li></ul><h3 id="数据库"><a href="#数据库" class="headerlink" title="数据库"></a>数据库</h3><ul><li><a href="https://github.com/JetBrains/Exposed" target="_blank" rel="noopener">Exposed</a> - Kotlin SQL 库</li><li><a href="https://github.com/cheptsov/kotlin-nosql" target="_blank" rel="noopener">Kotlin NoSQL</a> - NoSQL database query and access library for Kotlin</li><li><a href="https://github.com/seratch/kotliquery" target="_blank" rel="noopener">KotliQuery</a> - A handy Database access library in Kotlin</li></ul><h3 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h3><ul><li><a href="http://spekframework.org/" target="_blank" rel="noopener">Spek</a> -     A Specification Framework</li><li><a href="https://github.com/npryce/hamkrest" target="_blank" rel="noopener">HamKrest</a> - Hamcrest for Kotlin</li><li><a href="https://github.com/ntaro/knit" target="_blank" rel="noopener">Knit</a> - JUnit API set for Kotlin</li><li><a href="https://github.com/kotlintest/kotlintest" target="_blank" rel="noopener">KotlinTest</a> - Kotlin 测试框架</li></ul><h3 id="构建工具"><a href="#构建工具" class="headerlink" title="构建工具"></a>构建工具</h3><ul><li><a href="http://beust.com/kobalt/home/index.html" target="_blank" rel="noopener">Kobalt</a> - 一个用 Kotlin 写的多功能构建工具</li></ul><h3 id="编辑器"><a href="#编辑器" class="headerlink" title="编辑器"></a>编辑器</h3><ul><li><a href="https://github.com/vkostyukov/kotlin-sublime-package" target="_blank" rel="noopener">Sublime Package</a> - Sublime Text 2 Package for Kotlin Programming Language</li><li><a href="https://github.com/udalov/kotlin-vim" target="_blank" rel="noopener">kotlin-vim</a> - Kotlin 语法高亮 for Vim</li></ul><h3 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h3><ul><li><a href="https://github.com/MehdiK/Humanizer.jvm" target="_blank" rel="noopener">Humanizer.jvm</a> - Humanizer Library</li><li><a href="https://github.com/leprosus/kotlin-hashids" target="_blank" rel="noopener">Hashids.kt</a> - Kotlin hashids hash function</li><li><a href="https://github.com/hotchemi/khronos" target="_blank" rel="noopener">khronos</a> - An intuitive Date extensions in Kotlin.</li></ul><h2 id="Demo"><a href="#Demo" class="headerlink" title="Demo"></a>Demo</h2><h3 id="Android-客户端"><a href="#Android-客户端" class="headerlink" title="Android 客户端"></a>Android 客户端</h3><ul><li><a href="https://github.com/githubwing/GankClient-Kotlin" target="_blank" rel="noopener">GankClient-Kotlin</a> - 用 Kotlin 写的 Gank 客户端</li><li><a href="https://github.com/TonnyL/FanfouHandpick" target="_blank" rel="noopener">饭否精选</a> - 使用 Kotlin 开发的饭否精选 App</li><li><a href="https://github.com/wuapnjie/PoiShuhui-Kotlin" target="_blank" rel="noopener">PoiShuhui-Kotlin</a> - 一个用 Kotlin 写的简单漫画 APP</li></ul>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Kotlin 简介与入门指南</title>
      <link href="/posts/2018/b8875af9.html"/>
      <url>/posts/2018/b8875af9.html</url>
      
        <content type="html"><![CDATA[<h2 id="Kotlin-是什么？"><a href="#Kotlin-是什么？" class="headerlink" title="Kotlin 是什么？"></a>Kotlin 是什么？</h2><p>Kotlin 是 JetBrains 开发的针对 JVM、Android 和浏览器的静态编程语言。</p><p>JetBrains，作为目前广受欢迎的 Java IDE IntelliJ IDEA 的开发商，在 Apache 许可下已经开源其 Kotlin 编程语言。JetBrains 作为最智能的 Java IDE 的开发商，对 Java 的了解是毋庸置疑的，在使用 Java 过程中，JetBrains 的工程师们发现了大量的问题，为了更高效的开发以及解决 Java 中的一些问题，JetBrains 开发了致力于替代 Java 的 Kotlin。</p><p>Kotlin 可以编译成Java字节码，也可以编译成 JavaScript，方便在没有 JVM 的设备上运行。</p><p>在2017年的 Google I/O 中，Google 宣布 Kotlin 成为 Android 官方开发语言。</p><p>Kotlin 被称之为 Android 世界的 Swift。</p><h2 id="为什么选择-Kotlin？"><a href="#为什么选择-Kotlin？" class="headerlink" title="为什么选择 Kotlin？"></a>为什么选择 Kotlin？</h2><p>使用 Kotlin 开发 Android 的好处太多了，它简单、易用、代码量少。有人说代码量减少3倍，别不信，这并不夸张，当代码量越大的时候我们就越会发现这一点。事实上，Kotlin 生来就是为了弥补 Java 缺失的现代语言的特性的，并极大的简化了代码，使得开发者可以编写尽量少的样板代码。</p><h3 id="简洁——大大减少样板代码的数量"><a href="#简洁——大大减少样板代码的数量" class="headerlink" title="简洁——大大减少样板代码的数量"></a>简洁——大大减少样板代码的数量</h3><p>使用一行代码创建一个包含 getters、 setters、 equals()、 hashCode()、 toString() 以及 copy() 的 POJO：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">data</span> <span class="token keyword">class</span> <span class="token function">Customer</span><span class="token punctuation">(</span><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> email<span class="token operator">:</span> String<span class="token punctuation">,</span> <span class="token keyword">val</span> company<span class="token operator">:</span> String<span class="token punctuation">)</span></code></pre><p>或者使用 lambda 表达式来过滤列表：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> positiveNumbers <span class="token operator">=</span> list<span class="token punctuation">.</span><span class="token function">filter</span> <span class="token punctuation">{</span> it <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">}</span></code></pre><p>想要单例？创建一个 object 就可以了：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">object</span> ThisIsASingleton <span class="token punctuation">{</span>    <span class="token keyword">val</span> companyName<span class="token operator">:</span> String <span class="token operator">=</span> <span class="token string">"JetBrains"</span><span class="token punctuation">}</span></code></pre><h3 id="安全——避免空指针异常等整个类的错误"><a href="#安全——避免空指针异常等整个类的错误" class="headerlink" title="安全——避免空指针异常等整个类的错误"></a>安全——避免空指针异常等整个类的错误</h3><p>彻底告别那些烦人的 NullPointerException——著名的<a href="http://www.infoq.com/presentations/Null-References-The-Billion-Dollar-Mistake-Tony-Hoare" target="_blank" rel="noopener">十亿美金的错误</a>：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">var</span> output<span class="token operator">:</span> Stringoutput <span class="token operator">=</span> <span class="token keyword">null</span>   <span class="token comment" spellcheck="true">// 编译错误</span></code></pre><p>Kotlin 可以保护你避免对可空类型的误操作：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">val</span> name<span class="token operator">:</span> String<span class="token operator">?</span> <span class="token operator">=</span> <span class="token keyword">null</span>    <span class="token comment" spellcheck="true">// 可控类型</span><span class="token function">println</span><span class="token punctuation">(</span>name<span class="token punctuation">.</span><span class="token function">length</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>      <span class="token comment" spellcheck="true">// 编译错误</span></code></pre><p>并且如果你检查类型是正确的，编译器会为你做自动类型转换：</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">fun</span> <span class="token function">calculateTotal</span><span class="token punctuation">(</span>obj<span class="token operator">:</span> Any<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">is</span> Invoice<span class="token punctuation">)</span>        obj<span class="token punctuation">.</span><span class="token function">calculateTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre><h3 id="多用途——支持多中类型的应用程序"><a href="#多用途——支持多中类型的应用程序" class="headerlink" title="多用途——支持多中类型的应用程序"></a>多用途——支持多中类型的应用程序</h3><ol><li>Android开发：没有性能影响。运行时非常小。</li><li>服务器应用。100％兼容所有JVM框架。</li><li>JavaScript。在Kotlin中编写代码，并转换为 JavaScrip 在 Node.js 或浏览器中运行。</li><li>企业。使用Kotlin进行任何类型的企业Java EE开发。</li><li>网页。无论您是要强制类型的HTML，CSS构建器还是简单的Web开发。</li><li>其他所有(iOS、嵌入式等等)：Kotlin/Native 在2017年4月份推出了预览版，并在在官方博客中描述了对 Kotlin/Native 的美好愿景。</li></ol><h3 id="互操作性——充分利用-JVM、Android-和浏览器的现有库"><a href="#互操作性——充分利用-JVM、Android-和浏览器的现有库" class="headerlink" title="互操作性——充分利用 JVM、Android 和浏览器的现有库"></a>互操作性——充分利用 JVM、Android 和浏览器的现有库</h3><p>使用 JVM 上的任何现有库，因为有 100％ 的兼容性，包括 SAM 支持。</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">import</span> io<span class="token punctuation">.</span>reactivex<span class="token punctuation">.</span>Flowable<span class="token keyword">import</span> io<span class="token punctuation">.</span>reactivex<span class="token punctuation">.</span>schedulers<span class="token punctuation">.</span>SchedulersFlowable    <span class="token punctuation">.</span><span class="token function">fromCallable</span> <span class="token punctuation">{</span>        Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token comment" spellcheck="true">// 模仿高开销的计算</span>        <span class="token string">"Done"</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token function">subscribeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">io</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">observeOn</span><span class="token punctuation">(</span>Schedulers<span class="token punctuation">.</span><span class="token function">single</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>    <span class="token punctuation">.</span><span class="token function">subscribe</span><span class="token punctuation">(</span><span class="token operator">::</span>println<span class="token punctuation">,</span> Throwable<span class="token operator">::</span>printStackTrace<span class="token punctuation">)</span></code></pre><p>无论是 JVM 还是 JavaScript 目标平台，都可用 Kotlin 写代码然后部署到你想要的地方</p><pre class=" language-kotlin"><code class="language-kotlin"><span class="token keyword">import</span> kotlin<span class="token punctuation">.</span>browser<span class="token punctuation">.</span>window<span class="token keyword">fun</span> <span class="token function">onLoad</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    window<span class="token punctuation">.</span>document<span class="token punctuation">.</span>body<span class="token operator">!!</span><span class="token punctuation">.</span>innerHTML <span class="token operator">+=</span> <span class="token string">"&lt;br/>Hello, Kotlin!"</span><span class="token punctuation">}</span></code></pre><p>Kotlin 和 Java 都属于基于 JVM 的编程语言，Kotlin 和 Java 的交互性很好，可以说是无缝连接，这表现在：</p><ul><li>Kotlin 可以自由的引用 Java 的代码，反之亦然</li><li>Kotlin 可以使用现有的全部的 Java 框架和库</li><li>Java 文件可以很轻松的借助 IntelliJ 的插件转成 Kotlin</li></ul><h3 id="工具友好——自由选择命令行编译器或一级-IDE-支持"><a href="#工具友好——自由选择命令行编译器或一级-IDE-支持" class="headerlink" title="工具友好——自由选择命令行编译器或一级 IDE 支持"></a>工具友好——自由选择命令行编译器或一级 IDE 支持</h3><p>一门语言需要工具化，而在 JetBrains，这正是我们做得最好的地方！Kotlin目前提供了四种编写方式：</p><ul><li><a href="http://kotlinlang.org/docs/tutorials/command-line.html" target="_blank" rel="noopener">命令行编译工具</a></li><li>在线编辑 <a href="https://try.kotlinlang.org/" target="_blank" rel="noopener">Try Kotlin</a> 和 <a href="https://play.kotlinlang.org/" target="_blank" rel="noopener">Try Online</a></li><li><a href="https://developer.android.com/studio/" target="_blank" rel="noopener">Android Studio</a> 和 <a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclipse</a></li><li><a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="noopener">IntelliJ IDEA</a></li></ul><blockquote><p>其中 <a href="https://www.jetbrains.com/idea/download/" target="_blank" rel="noopener"><code>IntelliJ IDEA</code></a> 提供了对 Kotlin 最新功能的支持，也是 Kotlin 最智能的编辑器。</p></blockquote><h2 id="Kotlin-相关资源"><a href="#Kotlin-相关资源" class="headerlink" title="Kotlin 相关资源"></a>Kotlin 相关资源</h2><ul><li><a href="https://kotlinlang.org/" target="_blank" rel="noopener">Kotlin 官网</a></li><li><a href="https://www.kotlincn.net/" target="_blank" rel="noopener">Kotlin 中文站</a></li><li><a href="https://blog.jetbrains.com/kotlin/" target="_blank" rel="noopener">Kotlin 官方博客</a></li><li><a href="https://www.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文博客</a></li><li><a href="https://discuss.kotlinlang.org/" target="_blank" rel="noopener">Kotlin 官方论坛</a></li><li><a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 中文论坛</a></li><li><a href="https://github.com/JetBrains/kotlin" target="_blank" rel="noopener">Kotlin on GitHub</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> Kotlin </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Kotlin </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android AndroidX 简介与迁移</title>
      <link href="/posts/2018/3e59253e.html"/>
      <url>/posts/2018/3e59253e.html</url>
      
        <content type="html"><![CDATA[<h2 id="AndroidX-简介"><a href="#AndroidX-简介" class="headerlink" title="AndroidX 简介"></a>AndroidX 简介</h2><p>AndroidX 是 Android 团队用于在 <a href="https://developer.android.com/jetpack" target="_blank" rel="noopener">Jetpack</a> 中开发，测试，打包，版本和发布库的开源项目 。</p><p>AndroidX 是对原始 Android <a href="https://developer.android.com/topic/libraries/support-library/index" target="_blank" rel="noopener">Support Library</a>的重大改进 。与支持库一样，AndroidX 与 Android 操作系统分开提供，并提供跨 Android 版本的向后兼容性。AndroidX 通过提供功能奇偶校验和新库完全取代了支持库。此外，AndroidX 还包括以下功能：</p><ul><li>AndroidX 中的所有软件包都以字符串开头，位于一致的命名空间中 <code>androidx</code>。支持库包已映射到相应的 <code>androidx.*</code> 包中。有关所有旧类和构建组件的完整映射到新构件。</li><li>与支持库不同，AndroidX 软件包是单独维护和更新的。这些 <code>androidx</code> 包使用从版本 1.0.0 开始的严格语义版本控制。开发者可以单独更新项目中的 AndroidX 库。</li><li>所有新的支持库开发都将在 AndroidX 库中进行。这包括维护原始支持库组件和引入新的 Jetpack 组件。</li></ul><h2 id="使用-AndroidX"><a href="#使用-AndroidX" class="headerlink" title="使用 AndroidX"></a>使用 AndroidX</h2><p>如果要在新项目中使用 AndroidX，则需要一下条件：</p><ul><li>使用 <code>Android Studio 3.2 及更高版本</code></li><li>将 <code>compileSdkVersion</code> 设置为 <code>28(Android 9.0)或更高版本</code></li><li>将 <code>gradle-wrapper.properties</code> 文件中的 Gradle 版本改为 <code>4.6或更高版本</code></li><li>在 <code>gradle.properties</code> 文件中将以下两个 Android Gradle 插件标志设置 <code>true</code>：<ul><li><code>android.useAndroidX：</code>设置 true 为时，Android 插件使用相应的 AndroidX 库而不是支持库，默认为 false。</li><li><code>android.enableJetifier：</code>设置 true 为时，Android 插件会自动迁移现有的第三方库，通过重写其二进制文件来使用 AndroidX，默认为 false。</li></ul></li></ul><h2 id="迁移到-AndroidX"><a href="#迁移到-AndroidX" class="headerlink" title="迁移到 AndroidX"></a>迁移到 AndroidX</h2><p>AndroidX 将原始支持库 API 包映射到 <code>androidx</code> 命名空间。只有包和 Maven 组件名称发生了变化; 类、方法和字段名称没有改变。</p><p>使用 Android Studio 3.2 及更高版本，您可以通过从菜单栏中选择 <strong>Refactor&gt; Migrate to AndroidX</strong> 快速迁移现有项目以使用 AndroidX 。</p><p>如果您有任何尚未迁移到 AndroidX 名称空间的 Maven 依赖项，那么当您将 <code>gradle.properties</code> 文件中以下两个 Android Gradle 插件标志设置 <code>true</code>，Android Studio 构建系统也会为您迁移这些依赖项：</p><pre class=" language-gradle"><code class="language-gradle">android.useAndroidX=trueandroid.enableJetifier=true</code></pre><p>要迁移不使用任何需要转换的依赖项的第三方库的现有项目，可以将 <code>android.useAndroidX</code> 标志设置为 <code>true</code>，将 <code>android.enableJetifier</code> 标志设置为 <code>false</code>。</p><h2 id="组件映射"><a href="#组件映射" class="headerlink" title="组件映射"></a>组件映射</h2><p>下表列出了从旧组件到新组件的当前映射，也可以下载<a href="https://developer.android.google.cn/topic/libraries/support-library/downloads/androidx-artifact-mapping.csv" target="_blank" rel="noopener">CSV格式</a>映射文件：</p><table><thead><tr><th>旧构建组件</th><th>AndroidX 构建组件</th></tr></thead><tbody><tr><td>android.arch.core:common</td><td>androidx.arch.core:core-common:2.0.0-rc01</td></tr><tr><td>android.arch.core:core</td><td>androidx.arch.core:core:2.0.0-rc01</td></tr><tr><td>android.arch.core:core-testing</td><td>androidx.arch.core:core-testing:2.0.0-rc01</td></tr><tr><td>android.arch.core:runtime</td><td>androidx.arch.core:core-runtime:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:common</td><td>androidx.lifecycle:lifecycle-common:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:common-java8</td><td>androidx.lifecycle:lifecycle-common-java8:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:compiler</td><td>androidx.lifecycle:lifecycle-compiler:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:extensions</td><td>androidx.lifecycle:lifecycle-extensions:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:livedata</td><td>androidx.lifecycle:lifecycle-livedata:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:livedata-core</td><td>androidx.lifecycle:lifecycle-livedata-core:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:reactivestreams</td><td>androidx.lifecycle:lifecycle-reactivestreams:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:runtime</td><td>androidx.lifecycle:lifecycle-runtime:2.0.0-rc01</td></tr><tr><td>android.arch.lifecycle:viewmodel</td><td>androidx.lifecycle:lifecycle-viewmodel:2.0.0-rc01</td></tr><tr><td>android.arch.paging:common</td><td>androidx.paging:paging-common:2.0.0-rc01</td></tr><tr><td>android.arch.paging:runtime</td><td>androidx.paging:paging-runtime:2.0.0-rc01</td></tr><tr><td>android.arch.paging:rxjava2</td><td>androidx.paging:paging-rxjava2:2.0.0-rc01</td></tr><tr><td>android.arch.persistence.room:common</td><td>androidx.room:room-common:2.0.0-rc01</td></tr><tr><td>android.arch.persistence.room:compiler</td><td>androidx.room:room-compiler:2.0.0-rc01</td></tr><tr><td>android.arch.persistence.room:guava</td><td>androidx.room:room-guava:2.0.0-rc01</td></tr><tr><td>android.arch.persistence.room:migration</td><td>androidx.room:room-migration:2.0.0-rc01</td></tr><tr><td>android.arch.persistence.room:runtime</td><td>androidx.room:room-runtime:2.0.0-rc01</td></tr><tr><td>android.arch.persistence.room:rxjava2</td><td>androidx.room:room-rxjava2:2.0.0-rc01</td></tr><tr><td>android.arch.persistence.room:testing</td><td>androidx.room:room-testing:2.0.0-rc01</td></tr><tr><td>android.arch.persistence:db</td><td>androidx.sqlite:sqlite:2.0.0-rc01</td></tr><tr><td>android.arch.persistence:db-framework</td><td>androidx.sqlite:sqlite-framework:2.0.0-rc01</td></tr><tr><td>com.android.support.constraint:constraint-layout</td><td>androidx.constraintlayout:constraintlayout:1.1.2</td></tr><tr><td>com.android.support.constraint:constraint-layout-solver</td><td>androidx.constraintlayout:constraintlayout-solver:1.1.2</td></tr><tr><td>com.android.support.test.espresso.idling:idling-concurrent</td><td>androidx.test.espresso.idling:idling-concurrent:3.1.0</td></tr><tr><td>com.android.support.test.espresso.idling:idling-net</td><td>androidx.test.espresso.idling:idling-net:3.1.0</td></tr><tr><td>com.android.support.test.espresso:espresso-accessibility</td><td>androidx.test.espresso:espresso-accessibility:3.1.0</td></tr><tr><td>com.android.support.test.espresso:espresso-contrib</td><td>androidx.test.espresso:espresso-contrib:3.1.0</td></tr><tr><td>com.android.support.test.espresso:espresso-core</td><td>androidx.test.espresso:espresso-core:3.1.0</td></tr><tr><td>com.android.support.test.espresso:espresso-idling-resource</td><td>androidx.test.espresso:espresso-idling-resource:3.1.0</td></tr><tr><td>com.android.support.test.espresso:espresso-intents</td><td>androidx.test.espresso:espresso-intents:3.1.0</td></tr><tr><td>com.android.support.test.espresso:espresso-remote</td><td>androidx.test.espresso:espresso-remote:3.1.0</td></tr><tr><td>com.android.support.test.espresso:espresso-web</td><td>androidx.test.espresso:espresso-web:3.1.0</td></tr><tr><td>com.android.support.test.janktesthelper:janktesthelper</td><td>androidx.test.jank:janktesthelper:1.0.1</td></tr><tr><td>com.android.support.test.services:test-services</td><td>androidx.test:test-services:1.1.0</td></tr><tr><td>com.android.support.test.uiautomator:uiautomator</td><td>androidx.test.uiautomator:uiautomator:2.2.0</td></tr><tr><td>com.android.support.test:monitor</td><td>androidx.test:monitor:1.1.0</td></tr><tr><td>com.android.support.test:orchestrator</td><td>androidx.test:orchestrator:1.1.0</td></tr><tr><td>com.android.support.test:rules</td><td>androidx.test:rules:1.1.0</td></tr><tr><td>com.android.support.test:runner</td><td>androidx.test:runner:1.1.0</td></tr><tr><td>com.android.support:animated-vector-drawable</td><td>androidx.vectordrawable:vectordrawable-animated:1.0.0</td></tr><tr><td>com.android.support:appcompat-v7</td><td>androidx.appcompat:appcompat:1.0.0</td></tr><tr><td>com.android.support:asynclayoutinflater</td><td>androidx.asynclayoutinflater:asynclayoutinflater:1.0.0</td></tr><tr><td>com.android.support:car</td><td>androidx.car:car:1.0.0</td></tr><tr><td>com.android.support:cardview-v7</td><td>androidx.cardview:cardview:1.0.0</td></tr><tr><td>com.android.support:collections</td><td>androidx.collection:collection:1.0.0</td></tr><tr><td>com.android.support:coordinatorlayout</td><td>androidx.coordinatorlayout:coordinatorlayout:1.0.0</td></tr><tr><td>com.android.support:cursoradapter</td><td>androidx.cursoradapter:cursoradapter:1.0.0</td></tr><tr><td>com.android.support:customtabs</td><td>androidx.browser:browser:1.0.0</td></tr><tr><td>com.android.support:customview</td><td>androidx.customview:customview:1.0.0</td></tr><tr><td>com.android.support:design</td><td>com.google.android.material:material:1.0.0-rc01</td></tr><tr><td>com.android.support:documentfile</td><td>androidx.documentfile:documentfile:1.0.0</td></tr><tr><td>com.android.support:drawerlayout</td><td>androidx.drawerlayout:drawerlayout:1.0.0</td></tr><tr><td>com.android.support:exifinterface</td><td>androidx.exifinterface:exifinterface:1.0.0</td></tr><tr><td>com.android.support:gridlayout-v7</td><td>androidx.gridlayout:gridlayout:1.0.0</td></tr><tr><td>com.android.support:heifwriter</td><td>androidx.heifwriter:heifwriter:1.0.0</td></tr><tr><td>com.android.support:interpolator</td><td>androidx.interpolator:interpolator:1.0.0</td></tr><tr><td>com.android.support:leanback-v17</td><td>androidx.leanback:leanback:1.0.0</td></tr><tr><td>com.android.support:loader</td><td>androidx.loader:loader:1.0.0</td></tr><tr><td>com.android.support:localbroadcastmanager</td><td>androidx.localbroadcastmanager:localbroadcastmanager:1.0.0</td></tr><tr><td>com.android.support:media2</td><td>androidx.media2:media2:1.0.0-alpha03</td></tr><tr><td>com.android.support:media2-exoplayer</td><td>androidx.media2:media2-exoplayer:1.0.0-alpha01</td></tr><tr><td>com.android.support:mediarouter-v7</td><td>androidx.mediarouter:mediarouter:1.0.0</td></tr><tr><td>com.android.support:multidex</td><td>androidx.multidex:multidex:2.0.0</td></tr><tr><td>com.android.support:multidex-instrumentation</td><td>androidx.multidex:multidex-instrumentation:2.0.0</td></tr><tr><td>com.android.support:palette-v7</td><td>androidx.palette:palette:1.0.0</td></tr><tr><td>com.android.support:percent</td><td>androidx.percentlayout:percentlayout:1.0.0</td></tr><tr><td>com.android.support:preference-leanback-v17</td><td>androidx.leanback:leanback-preference:1.0.0</td></tr><tr><td>com.android.support:preference-v14</td><td>androidx.legacy:legacy-preference-v14:1.0.0</td></tr><tr><td>com.android.support:preference-v7</td><td>androidx.preference:preference:1.0.0</td></tr><tr><td>com.android.support:print</td><td>androidx.print:print:1.0.0</td></tr><tr><td>com.android.support:recommendation</td><td>androidx.recommendation:recommendation:1.0.0</td></tr><tr><td>com.android.support:recyclerview-selection</td><td>androidx.recyclerview:recyclerview-selection:1.0.0</td></tr><tr><td>com.android.support:recyclerview-v7</td><td>androidx.recyclerview:recyclerview:1.0.0</td></tr><tr><td>com.android.support:slices-builders</td><td>androidx.slice:slice-builders:1.0.0</td></tr><tr><td>com.android.support:slices-core</td><td>androidx.slice:slice-core:1.0.0</td></tr><tr><td>com.android.support:slices-view</td><td>androidx.slice:slice-view:1.0.0</td></tr><tr><td>com.android.support:slidingpanelayout</td><td>androidx.slidingpanelayout:slidingpanelayout:1.0.0</td></tr><tr><td>com.android.support:support-annotations</td><td>androidx.annotation:annotation:1.0.0</td></tr><tr><td>com.android.support:support-compat</td><td>androidx.core:core:1.0.0</td></tr><tr><td>com.android.support:support-content</td><td>androidx.contentpager:contentpager:1.0.0</td></tr><tr><td>com.android.support:support-core-ui</td><td>androidx.legacy:legacy-support-core-ui:1.0.0</td></tr><tr><td>com.android.support:support-core-utils</td><td>androidx.legacy:legacy-support-core-utils:1.0.0</td></tr><tr><td>com.android.support:support-dynamic-animation</td><td>androidx.dynamicanimation:dynamicanimation:1.0.0</td></tr><tr><td>com.android.support:support-emoji</td><td>androidx.emoji:emoji:1.0.0</td></tr><tr><td>com.android.support:support-emoji-appcompat</td><td>androidx.emoji:emoji-appcompat:1.0.0</td></tr><tr><td>com.android.support:support-emoji-bundled</td><td>androidx.emoji:emoji-bundled:1.0.0</td></tr><tr><td>com.android.support:support-fragment</td><td>androidx.fragment:fragment:1.0.0</td></tr><tr><td>com.android.support:support-media-compat</td><td>androidx.media:media:1.0.0</td></tr><tr><td>com.android.support:support-tv-provider</td><td>androidx.tvprovider:tvprovider:1.0.0</td></tr><tr><td>com.android.support:support-v13</td><td>androidx.legacy:legacy-support-v13:1.0.0</td></tr><tr><td>com.android.support:support-v4</td><td>androidx.legacy:legacy-support-v4:1.0.0</td></tr><tr><td>com.android.support:support-vector-drawable</td><td>androidx.vectordrawable:vectordrawable:1.0.0</td></tr><tr><td>com.android.support:swiperefreshlayout</td><td>androidx.swiperefreshlayout:swiperefreshlayout:1.0.0</td></tr><tr><td>com.android.support:textclassifier</td><td>androidx.textclassifier:textclassifier:1.0.0</td></tr><tr><td>com.android.support:transition</td><td>androidx.transition:transition:1.0.0</td></tr><tr><td>com.android.support:versionedparcelable</td><td>androidx.versionedparcelable:versionedparcelable:1.0.0</td></tr><tr><td>com.android.support:viewpager</td><td>androidx.viewpager:viewpager:1.0.0</td></tr><tr><td>com.android.support:wear</td><td>androidx.wear:wear:1.0.0</td></tr><tr><td>com.android.support:webkit</td><td>androidx.webkit:webkit:1.0.0</td></tr></tbody></table><h2 id="类映射"><a href="#类映射" class="headerlink" title="类映射"></a>类映射</h2><p>下表列出了部分常用的从旧命名空间到新 <code>androidx</code> 包的当前映射，也可以下载<a href="https://developer.android.google.cn/topic/libraries/support-library/downloads/androidx-class-mapping.csv" target="_blank" rel="noopener">CSV格式</a>映射文件：</p><table><thead><tr><th>支持库类</th><th>AndroidX 类</th></tr></thead><tbody><tr><td>android.support.multidex.MultiDex</td><td>androidx.multidex.MultiDex</td></tr><tr><td>android.support.v4.app.ActivityCompat</td><td>androidx.core.app.ActivityCompat</td></tr><tr><td>android.support.v4.app.ActivityManagerCompat</td><td>androidx.core.app.ActivityManagerCompat</td></tr><tr><td>android.support.v4.app.ActivityOptionsCompat</td><td>androidx.core.app.ActivityOptionsCompat</td></tr><tr><td>android.support.v4.app.AlarmManagerCompat</td><td>androidx.core.app.AlarmManagerCompat</td></tr><tr><td>android.support.v4.app.BundleCompat</td><td>androidx.core.app.BundleCompat</td></tr><tr><td>android.support.v4.app.DialogFragment</td><td>androidx.fragment.app.DialogFragment</td></tr><tr><td>android.support.v4.app.Fragment</td><td>androidx.fragment.app.Fragment</td></tr><tr><td>android.support.v4.app.FragmentActivity</td><td>androidx.fragment.app.FragmentActivity</td></tr><tr><td>android.support.v4.app.FragmentManager</td><td>androidx.fragment.app.FragmentManager</td></tr><tr><td>android.support.v4.app.ListFragment</td><td>androidx.fragment.app.ListFragment</td></tr><tr><td>android.support.v4.app.LoaderManager</td><td>androidx.loader.app.LoaderManager</td></tr><tr><td>android.support.v4.app.NotificationCompat</td><td>androidx.core.app.NotificationCompat</td></tr><tr><td>android.support.v4.app.NotificationCompatBuilder</td><td>androidx.core.app.NotificationCompatBuilder</td></tr><tr><td>android.support.v4.app.NotificationManagerCompat</td><td>androidx.core.app.NotificationManagerCompat</td></tr><tr><td>android.support.v4.content.ContextCompat</td><td>androidx.core.content.ContextCompat</td></tr><tr><td>android.support.v4.content.CursorLoader</td><td>androidx.loader.content.CursorLoader</td></tr><tr><td>android.support.v4.content.FileProvider</td><td>androidx.core.content.FileProvider</td></tr><tr><td>android.support.v4.graphics.BitmapCompat</td><td>androidx.core.graphics.BitmapCompat</td></tr><tr><td>android.support.v4.graphics.ColorUtils</td><td>androidx.core.graphics.ColorUtils</td></tr><tr><td>android.support.v4.graphics.PaintCompat</td><td>androidx.core.graphics.PaintCompat</td></tr><tr><td>android.support.v4.graphics.PathParser</td><td>androidx.core.graphics.PathParser</td></tr><tr><td>android.support.v4.math.MathUtils</td><td>androidx.core.math.MathUtils</td></tr><tr><td>android.support.v4.util.LruCache</td><td>androidx.collection.LruCache</td></tr><tr><td>android.support.v4.util.Pair</td><td>androidx.core.util.Pair</td></tr><tr><td>android.support.v4.util.TimeUtils</td><td>androidx.core.util.TimeUtils</td></tr><tr><td>android.support.v4.widget.AutoScrollHelper</td><td>androidx.core.widget.AutoScrollHelper</td></tr><tr><td>android.support.v4.widget.AutoSizeableTextView</td><td>androidx.core.widget.AutoSizeableTextView</td></tr><tr><td>android.support.v4.widget.CircleImageView</td><td>androidx.swiperefreshlayout.widget.CircleImageView</td></tr><tr><td>android.support.v4.widget.DrawerLayout</td><td>androidx.drawerlayout.widget.DrawerLayout</td></tr><tr><td>android.support.v7.app.AlertDialog</td><td>androidx.appcompat.app.AlertDialog</td></tr><tr><td>android.support.v7.app.AppCompatActivity</td><td>androidx.appcompat.app.AppCompatActivity</td></tr><tr><td>android.support.v7.app.AppCompatDialog</td><td>androidx.appcompat.app.AppCompatDialog</td></tr><tr><td>android.support.v7.widget.CardView</td><td>androidx.cardview.widget.CardView</td></tr><tr><td>android.support.v7.widget.GridLayout</td><td>androidx.gridlayout.widget.GridLayout</td></tr><tr><td>android.support.v7.widget.GridLayoutManager</td><td>androidx.recyclerview.widget.GridLayoutManager</td></tr></tbody></table><h2 id="AndroidX-影响"><a href="#AndroidX-影响" class="headerlink" title="AndroidX 影响"></a>AndroidX 影响</h2><p>官方博客中有说道，为了给开发者一定迁移的时间，所以 <code>28.0.0</code> 的稳定版本还是采用 <code>android.support</code>，但是所有后续的功能版本都将采用 <code>androidx</code>。</p><p>其实目前对于我们影响也不是很大，我们可以选择不使用，毕竟不是强制的。但长远看来还是有好处的。AndroidX 重新设计了包结构，旨在鼓励库的小型化，支持库和架构组件包的名字也都简化了；而且也是减轻 Android 生态系统碎片化的有效方式。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> AndroidX </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Jetpack 简介</title>
      <link href="/posts/2018/741c7cd8.html"/>
      <url>/posts/2018/741c7cd8.html</url>
      
        <content type="html"><![CDATA[<p>Android Jetpack 深受支持库的启发，支持库包含的组件可以让开发者轻松利用 Android 新功能，同时保持向后兼容性；现在，应用商店中 99% 的应用都使用支持库。在支持库取得成功后，Google 推出了<a href="https://developer.android.com/jetpack/arch/" target="_blank" rel="noopener">架构组件</a>，让开发者在面对应用生命周期变化和复杂性时可以更轻松地处理数据。自从 Google 在去年的 I/O 大会上推出以来，相当数量的开发者已经采用这些组件。LinkedIn、Zillow 和 iHeartRadio 等公司取得了显著成效，他们应用的错误减少、可测试性提高，这让他们可以将更多时间放在精心打造自己的应用上。</p><h2 id="Jetpack-简介"><a href="#Jetpack-简介" class="headerlink" title="Jetpack 简介"></a>Jetpack 简介</h2><p>2018年的 Google I/O 大会上，谷歌推出了 Android Jetpack 架构组件。Android Jetpack 是一套组件、工具和指导，可以帮助您构建出色的 Android 应用。Android Jetpack 组件将现有的支持库与架构组件联系起来，并将它们分成四个类别：Architecture、Foundation、Behavior 以及 UI。<br><img src="https://henleylee.github.io/medias/android/android_jetpack.png" alt="Android Jetpack 分类"></p><p>Android Jetpack 组件以“未捆绑的”库形式提供，这些库不是基础 Android 平台的一部分。这就意味着，您可以根据自己的需求采用每一个组件。在新的 Android Jetpack 功能发布后，您可以将其添加到自己的应用中，将您的应用部署到应用商店并向用户提供新功能，如果您的行动足够快，所有这些可以在一天内完成！<br>未捆绑的 Android Jetpack 库已经全部转移到新的 <a href="https://developer.android.com/jetpack/androidx/" target="_blank" rel="noopener"><code>androidx.*</code></a> 命名空间中。这意味着它提供向后兼容性并且比 Android 平台更频繁地更新，确保开发者始终可以访问最新和最好的 Jetpack 组件版本。</p><p>Android Jetpack 是下一代的 Android 组件，该组件规模更庞大，并且具备支持库在向后兼容性和即时更新方面的优点，从而让开发者能够更轻松快捷地构建可靠的高品质应用。Android Jetpack 管理后台任务、导航和生命周期管理等活动，因此，您不必使用千篇一律的模板代码，而可以专注于如何让您的应用精彩绝伦。Android Jetpack 旨在与 Kotlin 搭配运行，在使用 Android KTX 时可以节省更多代码。</p><h2 id="Jetpack-的新组件"><a href="#Jetpack-的新组件" class="headerlink" title="Jetpack 的新组件"></a>Jetpack 的新组件</h2><p>Google 发布的全新 Android Jetpack 附带五个新组件：</p><ul><li><a href="https://developer.android.com/topic/libraries/architecture/workmanager/" target="_blank" rel="noopener">WorkManager</a></li><li><a href="https://developer.android.com/topic/libraries/architecture/navigation/" target="_blank" rel="noopener">Navigation</a></li><li><a href="https://developer.android.com/topic/libraries/architecture/paging/" target="_blank" rel="noopener">Paging</a></li><li><a href="https://developer.android.com/guide/slices/" target="_blank" rel="noopener">Slices</a></li><li><a href="https://developer.android.com/kotlin/ktx" target="_blank" rel="noopener">Android KTX</a></li></ul><h3 id="WorkManager"><a href="#WorkManager" class="headerlink" title="WorkManager"></a>WorkManager</h3><p><code>WorkMananager</code> 组件是一个功能强大的新库，可以为基于约束的后台作业（需要有保障的执行）提供一站式解决方案，消除了使用作业或 SyncAdapter 等框架的需求。WorkManager 提供了一个简化的现代化 API、在安装或未安装 Google Play 服务的设备上运行的功能、创建工作图的功能以及查询工作状态的功能。</p><p>WorkManager 根据设备 API 级别和应用程序状态等因素选择适当的方式来运行任务。如果 WorkManager 在应用程序运行时执行您的任务之一，WorkManager 可以在您应用程序进程的新线程中运行您的任务。如果您的应用程序未运行，WorkManager 会选择一种合适的方式来安排后台任务 - 具体取决于设备API级别和包含的依赖项，WorkManager 可能会使用 JobScheduler、Firebase JobDispatcher 或 AlarmManager。开发者无需编写设备逻辑来确定设备具有哪些功能并选择适当的 API; 相反，开发者可以将任务交给 WorkManager，让它选择最佳选项。</p><h3 id="Navigation"><a href="#Navigation" class="headerlink" title="Navigation"></a>Navigation</h3><p>尽管 Activity 是系统提供的您的应用界面的入口点，但在相互分享数据以及转场方面，Activity 表现得不够灵活，这就让它不适合作为构建您的应用内导航的理想架构。于是，Google 宣布推出<code>导航组件</code>，作为构建 Android 应用内界面的框架，重点是让单 Activity 应用成为首选架构。利用导航组件对 Fragment 的原生支持，开发者可以获得架构组件的所有好处（例如生命周期和 ViewModel），同时让此组件为开发者处理 FragmentTransaction 的复杂性。此外，导航组件还可以自动构建正确的“向上”和“返回”行为，包含对深层链接的完整支持，并提供了帮助程序，用于将导航关联到合适的 UI 小部件，例如抽屉式导航栏和底部导航。但这些并不是全部！<code>Android Studio 3.2</code> 中的<code>导航编辑器</code>让开发者可以直观地查看和管理导航属性：<br><img src="https://henleylee.github.io/medias/android/android_navigation.png" alt="导航编辑器"></p><h3 id="Paging"><a href="#Paging" class="headerlink" title="Paging"></a>Paging</h3><p>应用中呈现的数据可能非常大，这就导致加载的开销比较大，因此，避免一次下载、创建或呈现过多数据就显得非常重要。<code>分页组件</code>让开发者可以轻松加载和呈现大型数据集，同时在 <code>RecyclerView</code> 中进行快速、无限滚动。它可以从本地存储和/或网络加载分页数据，并让开发者能够定义内容的加载方式。此组件原生支持 <code>Room</code>、<code>LiveData</code> 和 <code>RxJava</code>。</p><h3 id="Slices"><a href="#Slices" class="headerlink" title="Slices"></a>Slices</h3><p><code>切片</code>提供能在 App 之外展示(Google Search App 和 Googel Assistant）App 数据的 UI 元素，：<br><img src="https://henleylee.github.io/medias/android/android_slices.png" alt="Slices"></p><p>Android Jetpack 内置了对切片的支持，可以一直延伸到 Android 4.4，大约 95% 的Android用户。</p><h3 id="Android-KTX"><a href="#Android-KTX" class="headerlink" title="Android KTX"></a>Android KTX</h3><p>Android KTX 是一组 Kotlin 扩展程序，属于 Android Jetpack 系列。它优化了供 Kotlin 使用的 Jetpack 和 Android 平台 API。Android KTX 旨在让开发者利用 Kotlin 语言功能（例如扩展函数/属性、lambda、命名参数和参数默认值），以更简洁、更愉悦、更惯用的方式使用 Kotlin 进行 Android 开发。Android KTX 不会向现有的 Android API 添加任何新功能。</p><p>Android Jetpack 利用 Kotlin 语言功能的一个目标是提高您的效率。Android KTX 可以让您将类似下面所示的 Kotlin 代码：</p><pre class=" language-kotlin"><code class="language-kotlin">view<span class="token punctuation">.</span>viewTreeObserver<span class="token punctuation">.</span><span class="token function">addOnPreDrawListener</span><span class="token punctuation">(</span>    <span class="token keyword">object</span> <span class="token operator">:</span> ViewTreeObserver<span class="token punctuation">.</span><span class="token function">OnPreDrawListener</span> <span class="token punctuation">{</span>        <span class="token keyword">override</span> <span class="token keyword">fun</span> <span class="token function">onPreDraw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">:</span> Boolean <span class="token punctuation">{</span>            viewTreeObserver<span class="token punctuation">.</span><span class="token function">removeOnPreDrawListener</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span>            <span class="token function">actionToBeTriggered</span><span class="token punctuation">(</span><span class="token punctuation">)</span>            <span class="token keyword">return</span> <span class="token boolean">true</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">)</span></code></pre><p>转换成如下所示的更精简的 Kotlin 代码：</p><pre class=" language-kotlin"><code class="language-kotlin">view<span class="token punctuation">.</span><span class="token function">doOnPreDraw</span> <span class="token punctuation">{</span>     <span class="token function">actionToBeTriggered</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Jetpack </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Activity 的生命周期和启动模式</title>
      <link href="/posts/2018/e0d2d667.html"/>
      <url>/posts/2018/e0d2d667.html</url>
      
        <content type="html"><![CDATA[<h2 id="Activity的生命周期"><a href="#Activity的生命周期" class="headerlink" title="Activity的生命周期"></a>Activity的生命周期</h2><blockquote><p>生命周期和启动模式以及 IntentFilter 的匹配规则分析。</p></blockquote><p>Activity 的生命周期分为两个部分：</p><ul><li>典型情况下的生命周期</li><li>异常情况下的生命周期</li></ul><h3 id="典型情况下的生命周期分析"><a href="#典型情况下的生命周期分析" class="headerlink" title="典型情况下的生命周期分析"></a>典型情况下的生命周期分析</h3><ul><li><strong><code>onCreate：</code></strong>首次创建 Activity 时调用。 您应该在此方法中执行所有正常的静态设置 — 创建视图、将数据绑定到列表等等。始终后接 <strong>onStart()</strong>。</li><li><strong><code>onRestart：</code></strong>在 Activity 已停止并即将再次启动前调用。始终后接 <strong>onStart()</strong>。</li><li><strong><code>onStart：</code></strong>在 Activity 即将对用户可见之前调用。如果 Activity 转入前台，则后接 <strong>onResume()</strong>，如果 Activity 转入隐藏状态，则后接 <strong>onStop()</strong>。</li><li><strong><code>onResume：</code></strong>在 Activity 即将开始与用户进行交互之前调用。此时，Activity 处于 Activity 堆栈的顶层，并具有用户输入焦点。始终后接 <strong>onPause()</strong>。</li><li><strong><code>onPause：</code></strong>当系统即将开始继续另一个 Activity 时调用。此方法通常用于确认对持久性数据的未保存更改、停止动画以及其他可能消耗 CPU 的内容，诸如此类。它应该非常迅速地执行所需操作，因为它返回后，下一个 Activity 才能继续执行。如果 Activity 返回前台，则后接 <strong>onResume()</strong>，如果 Activity 转入对用户不可见状态，则后接 <strong>onStop()</strong>。</li><li><strong><code>onStop：</code></strong>在 Activity 对用户不再可见时调用。如果 Activity 被销毁，或另一个 Activity（一个现有 Activity 或新 Activity）继续执行并将其覆盖，就可能发生这种情况。如果 Activity 恢复与用户的交互，则后接 <strong>onRestart()</strong>，如果 Activity 被销毁，则后接 <strong>onDestroy()</strong>。</li><li><strong><code>onDestroy：</code></strong>在 Activity 被销毁前调用。这是 Activity 将收到的最后调用。当 Activity 结束（有人对 Activity 调用了 finish()），或系统为节省空间而暂时销毁该 Activity 实例时，可能会调用它。可以通过 <strong>isFinishing()</strong> 方法区分这两种情形。</li></ul><p><img src="https://henleylee.github.io/medias/android/activity_lifecycle.png" alt="Activity 的生命周期"></p><blockquote><p>注意：</p><ul><li>onStart和onStop是从Activity是否可见这个角度来回调的</li><li>onResum和onPause是从Activity是否在前台这个角度来回调的</li></ul></blockquote><h3 id="异常情况下的生命周期分析"><a href="#异常情况下的生命周期分析" class="headerlink" title="异常情况下的生命周期分析"></a>异常情况下的生命周期分析</h3><h4 id="情况-1：资源相关的系统配置发生改变导致Activity被杀死并重新创建"><a href="#情况-1：资源相关的系统配置发生改变导致Activity被杀死并重新创建" class="headerlink" title="情况 1：资源相关的系统配置发生改变导致Activity被杀死并重新创建"></a>情况 1：资源相关的系统配置发生改变导致Activity被杀死并重新创建</h4><blockquote><p>比如说横屏手机和竖屏手机会拿到两张不同的图片（设定了 landscape 或者 portrait 状态下的图片）。本来手机在竖屏状态，突然旋转屏幕，由于系统配置发生了变化，在默认情况下，Activity 会被销毁并且重新创建，当然我们也可以阻止系统重新创建我们的 Activity。</p></blockquote><p>当系统配置发生改变后，Activity 会调用 <strong>onPause -&gt; onStop -&gt; onDestroy</strong>。</p><p>由于是异常情况终止，系统会在 <code>onStop</code> 之前调用 <code>onSaveInstanceState</code> 来保存当前 <code>Activity</code> 的状态。(与 <code>onPause</code> 没有时序关系)</p><p>当 <code>Activity</code> 被系统重新创建后，系统会调用 <code>onRestoreInstanceState</code>，把之前 <code>onSaveInstanceState</code> 方法所保存的 <code>Bundle</code> 对象作为参数同时传给 <code>onRestoreInstanceState</code> 和 <code>onCreate</code> 方法。(从时序来说，<code>onRestoreInstanceState</code> 的调用时机在 <code>onStart</code> 之后)<br><img src="https://henleylee.github.io/medias/android/activity_recreate.png" alt="异常情况下 Activity 的重建过程"></p><p>而在视图方面，当 Activity 在异常情况下需要重新创建时，系统会默认为我们保存当前 Activity 的视图结构，并且在 Activity 重启后为我们恢复这些数据。</p><p>其实每个 View 都有 onSaveInstanceState 和 onRestoreInstanceState，关于保存和恢复 View 层级结构，系统的工作流程如下：<br><img src="https://henleylee.github.io/medias/android/activity_view.png" alt="关于保存与恢复 View 层级结构"></p><blockquote><p>onSaveInstanceState 方法，系统只会在 Activity 即将被销毁并且有机会重新显示的情况下才会去调用它。</p></blockquote><h4 id="情况-2：资源内存不足导致低优先级的Activity被杀死"><a href="#情况-2：资源内存不足导致低优先级的Activity被杀死" class="headerlink" title="情况 2：资源内存不足导致低优先级的Activity被杀死"></a>情况 2：资源内存不足导致低优先级的Activity被杀死</h4><p>其实这种情况的数据存储与恢复过程与<code>情况 1</code>完全一致。</p><p>Activity的优先级情况：</p><ul><li><strong>前台的 Activity</strong> —— 正在和用户交互的 Activity，优先级最高</li><li><strong>可见但非前台的 Activity</strong> —— 比如 Activity 中弹出了一个对话框，导致 Activity 可见但是位于后台，无法和用户进行直接交互</li><li><strong>后台的 Activity</strong> —— 已经被暂停的 Activity，比如执行了 onStop，优先级最低</li></ul><p>当系统内存不足时，系统就会按照上述优先级去杀死目标 <code>Activity</code> 所在的进程，并在后续通过 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 来存储和恢复数据。而将后台工作放入 <code>Service</code> 中是一个比较好的方法。</p><h3 id="当系统配置改变后-Activity-如何不被重新创建"><a href="#当系统配置改变后-Activity-如何不被重新创建" class="headerlink" title="当系统配置改变后 Activity 如何不被重新创建"></a>当系统配置改变后 Activity 如何不被重新创建</h3><p>由于系统配置中有很多内容，如果当某项内容发生改变后，不想系统重新创建 <code>Activity</code>，可以给 <code>Activity</code> 指定 <code>configChanges</code> 属性：</p><pre class=" language-xml"><code class="language-xml">   android:configChanges="orientation|keyboardHidden"</code></pre><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>mcc</code></td><td>SIM卡唯一标识IMSI(国际移动用户识别码)中的国家代码，由3位数组成，中国为460.此项 标识mcc代码发生了改变</td></tr><tr><td><code>mnc</code></td><td>SIM卡唯一标识IMSI(国际移动用户识别码)中的运营商代码，由两位数字组成，中国移动TD系统为00，中国联通为01，中国电信为03。此项标识mnc发生改变</td></tr><tr><td><code>locale</code></td><td>设备的本地位置发生了改变们一般指切换了系统语言</td></tr><tr><td><code>touchscreen</code></td><td>触摸屏发生了改变，正常情况下无法发生，可以忽略它</td></tr><tr><td><code>keyboard</code></td><td>键盘类型发生了改变，比如用户使用了外插键盘</td></tr><tr><td><code>keyboardHidden</code></td><td>键盘的可访问性发生了改变，比如用户调出了键盘</td></tr><tr><td><code>navigation</code></td><td>系统导航方式发生了改变，比如采用了轨迹球导航，很难发生，可以忽略</td></tr><tr><td><code>screenLayout</code></td><td>屏幕布局发生了改变，很可能是用户激活了另一个显示设备</td></tr><tr><td><code>fontScale</code></td><td>系统字体缩放比如发生了改变，比如用户选择了一个新字号</td></tr><tr><td><code>uiMode</code></td><td>用户界面模式发生了改变，比如是否开启了夜间模式（API8新添加）</td></tr><tr><td><code>orientation</code></td><td>屏幕方向发生了改变，这个是最常用的，比如旋转了手机屏幕</td></tr><tr><td><code>screenSize</code></td><td>当屏幕的尺寸信息发生了改变，当旋转设备屏幕时，屏幕尺寸会发生变化，这个选项比较特殊，它和编译选项有关，当编译选项中的minSdkVersion和targetSdkVersion 均低于13时，此选项不会导致Activity重启，否则会导致Activity重启（API13新添加）</td></tr><tr><td><code>smallestScreenSize</code></td><td>设备的物理屏幕尺寸发生了改变，这个项目和屏幕的方向没有关系，仅仅表示在实际的物理屏幕的尺寸改变的时候发生，比如用户切换到了外部的显示设备，这个选项和screenSize一样，当编译选项中的minSdkVersion和targetSdkVersion均低于13时，此选项不会导致Activity重启，否则会导致Activity重启（API13新添加）</td></tr><tr><td><code>layoutDirection</code></td><td>当布局方向发生变化，这个属性用的比较少，正常情况下无须修改布局的layoutDirection属性（API17新添加）</td></tr></tbody></table><p>如果我们没有在 <code>Activity</code> 的 <code>configChanges</code> 属性中指定该选项的话，当配置发生改变后就会导致 Activity 重新创建。</p><p>最常用的只有 <code>locale</code>、<code>orientation</code> 和 <code>keyboardHidden</code>。需要修改的代码很简单，只需要在 <code>AndroidMenifest.xml</code> 中加入 <code>Activity</code> 的声明即可：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span>    <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.dimon.MainActivity<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>configChanges</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>orientation|screenSize<span class="token punctuation">"</span></span>    <span class="token attr-name"><span class="token namespace">android:</span>label</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/app_name<span class="token punctuation">"</span></span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.category.LAUNCHER<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>activity</span><span class="token punctuation">></span></span></code></pre><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onConfigurationChanged</span><span class="token punctuation">(</span>Configuration newConfig<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onConfigurationChanged</span><span class="token punctuation">(</span>newConfig<span class="token punctuation">)</span><span class="token punctuation">;</span>  Log<span class="token punctuation">.</span><span class="token function">d</span><span class="token punctuation">(</span>TAG<span class="token punctuation">,</span><span class="token string">"onConfigurationChanged,newOrientation:"</span> <span class="token operator">+</span> newConfig<span class="token punctuation">.</span>orientation<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p><code>Activity</code> 没有重新创建，并且没有调用 <code>onSaveInstanceState</code> 和 <code>onRestoreInstanceState</code> 来存储和恢复数据，而是系统调用了 <code>Activity</code> 的 <code>onConfigurationChanged</code> 方法，这个时候我们可以加入一些自己的特殊处理了。</p><h2 id="Activity的启动模式"><a href="#Activity的启动模式" class="headerlink" title="Activity的启动模式"></a>Activity的启动模式</h2><h3 id="Activity-的-LaunchMode"><a href="#Activity-的-LaunchMode" class="headerlink" title="Activity 的 LaunchMode"></a>Activity 的 LaunchMode</h3><blockquote><p>复习一点：启动 Activity 时，系统会创造实例并把他们放入任务栈里，而任务栈是一种“后进先出”的栈结构。</p></blockquote><p>Activity的四种启动模式：</p><ul><li><strong><code>standard：</code></strong>标准模式、默认模式。每次启动一个Activity都会重新创建一个新的实例，不管这个实例是否已经存在。在这种模式下，某个Activity启动了一号Activity，那么一号Activity就运行在启动它的那个Activity所在的栈中。</li><li><strong><code>singleTop：</code></strong>栈顶复用模式。如果新的Activity已经位于任务栈的栈顶，那么此Activity就不会被重新创建，同时它的onNewIntent方法会被回调，并且可以根据此方法的参数获得当前请求的信息。</li><li><strong><code>singleTask：</code></strong>栈内复用模式。在这种单实例模式下，只要Activity在一个栈中存在，那么多次启动此Activity都不会重新创建实例，系统也会调用其onNewIntent。</li><li><strong><code>singleInstance：</code></strong>单实例模式。这是一种加强的singleTask模式，除了具有singleTask模式的所有特性外，还加强了一点，那就是具体此种模式的Activity只能单独地位于一个任务栈中。</li></ul><blockquote><p>注：在任何跳转的时候，首先调用本 Activity 的 <code>onPause</code>，然后跳转。如果被跳转的 Activity 由于启动方式而没创建新的实例，则会先调用 <code>onNewIntent</code> ，然后按照正常的生命周期调用。</p></blockquote><p>如：</p><ul><li>A→B，A：onPause；B：onCreate，onStart，onResume。</li><li>A(singleTop)→A，A：onPause；A：onSaveInstanceState；A：onResume。</li></ul><h3 id="一些具体问题与情况"><a href="#一些具体问题与情况" class="headerlink" title="一些具体问题与情况"></a>一些具体问题与情况</h3><ol><li>首先要说明：任务栈分为前台任务栈和后台任务栈，后台任务栈中的 Activity 位于暂停状态。singleTask 模式的 Activity 切换到栈顶会导致在它之上的栈内的 Activity 出栈。</li><li>TaskAffinity：任务相关性。标识一个 Activity 所需要的任务栈的名字。<pre class=" language-xml"><code class="language-xml">adnroid:taskAffinity="com.dimon.task1"</code></pre>默认情况下 Activity 所需要的任务栈的名字为应用的包名。<br><img src="https://henleylee.github.io/medias/android/activity_taskaffinity.png" alt="TaskAffinity"></li></ol><h3 id="给-Activity-指定启动模式"><a href="#给-Activity-指定启动模式" class="headerlink" title="给 Activity 指定启动模式"></a>给 Activity 指定启动模式</h3><ul><li><p>方法一：通过 AndroidMenifest 为 Activity 指定启动模式</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>activity</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.dimon.SecondActivity<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>configChanges</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>screenLayout<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">adnroid:</span>taskAffinity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>com.dimon.task1<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>launchMode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>singleTask<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">android:</span>label</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@string/app_name<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li><li><p>方法二：通过 Intent 中设置标志位为 Activity 指定启动模式</p><pre class=" language-java"><code class="language-java">Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">setClass</span><span class="token punctuation">(</span>MainActivity<span class="token punctuation">.</span><span class="token keyword">this</span><span class="token punctuation">,</span> SecondActivity<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>intent<span class="token punctuation">.</span><span class="token function">addFlags</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>FLAG_ACTIVITY_NEW_TASK<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre></li></ul><blockquote><p>区别：<br>优先级：第二种方法比第一种优先级高，两种都存在时，以第二种为准。<br>限定范围：第一种方法比无法设置 <code>FLAG_ACTIVITY_CLEAR_TOP</code> 标识，而第二种方法比无法指定 <code>singleInstance</code> 模式。</p></blockquote><h3 id="Acticity-中常用的-Flags"><a href="#Acticity-中常用的-Flags" class="headerlink" title="Acticity 中常用的 Flags"></a>Acticity 中常用的 Flags</h3><ul><li><strong><code>FLAG_ACTIVITY_NEW_TASK：</code></strong>这个标记位的作用是为 Activity 指定 <code>singleTask</code> 启动模式，其效果和在 XML 中指定该启动模式相同。</li><li><strong><code>FLAG_ACTIVITY_SINGLE_TOP：</code></strong>这个标记位的作用是为 Activity 指定 <code>singleTop</code> 启动模式，其效果和在 XML 中指定该启动模式相同。</li><li><strong><code>FLAG_ACTIVITY_CLEAR_TOP：</code></strong>具有次标记位的 Activity，当它启动时，在同一个任务栈中所有位于它上面的 Activity 都要出栈，这个标记位一般会和 <code>singleTask</code> 启动模式一起出现。如果被启动的 Activity 的实例已经存在，那么系统就会调用它的 <code>onNewIntent</code>。如果被启动的Activity采用了 <code>standard</code> 启动模式，那么它以及它之上的 Activity 都要出栈，系统会创建新的 Activity 实例并放入栈顶。</li><li><strong><code>FLAG_ACTIVITY_EXCLUDE_FROM_RECENTS：</code></strong>具有这个标记的 Activity 不会出现在历史 Activity 的列表中，当某种情况下我们不希望用户通过历史列表回到我们的 Activity 的时候这个标记比较有用。它等同于在 XML 中指定 Activity 的属性 <code>android:excludeFromRecents=&quot;true&quot;</code>。</li></ul><h3 id="IntentFilter-的匹配规则"><a href="#IntentFilter-的匹配规则" class="headerlink" title="IntentFilter 的匹配规则"></a>IntentFilter 的匹配规则</h3><p>Intent 解析机制主要是通过查找已注册在 <code>AndroidManifest.xml</code> 中的所有 <code>IntentFilter</code> 及其中定义的 <code>Intent</code>，最终找到匹配的 <code>Intent</code>。在这个解析过程中，Android 是通过 Intent 的 <code>action</code>、<code>type</code>、<code>category</code> 这三个属性来进行匹配判断的。一个过滤列表中的 <code>action</code>、<code>type</code>、<code>category</code> 可以有多个，所有的 <code>action</code>、<code>type</code>、<code>category</code> 分别构成不同类别，同一类别信息共同约束当前类别的匹配过程。只有一个 Intent <strong>同时匹配 action、type、category</strong> 这三个类别才算完全匹配，<strong>只有完全匹配才能启动 Activity</strong>。另外一个组件若声明了多个 Intent Filter，只需要匹配任意一个即可启动该组件。 </p><h4 id="action-的匹配规则"><a href="#action-的匹配规则" class="headerlink" title="action 的匹配规则"></a>action 的匹配规则</h4><p>action 是一个字符串，如果 Intent 指明定了 action，则目标组件的 IntentFilter 的 action 列表中就必须包含有这个 action，否则不能匹配。一个 Intent Filter 中可声明多个 action，Intent 中的 action 与其中的任一个 action 在字符串形式上完全相同（<code>注意，区分大小写，大小写不同但字符串内容相同也会造成匹配失败</code>），action 方面就匹配成功。可通过 Intent 的 setAction 方法为 Intent 设置 action，也可在构造 Intent 时传入 action。需要注意的是，隐式 Intent 必须指定 action。</p><p>Android 系统预定义了许多 action，这些 action 代表了一些常见的操作。常见action如下（Intent类中的常量）：</p><pre class=" language-java"><code class="language-java">Intent<span class="token punctuation">.</span>ACTION_VIEWIntent<span class="token punctuation">.</span>ACTION_DIALIntent<span class="token punctuation">.</span>ACTION_SENDTOIntent<span class="token punctuation">.</span>ACTION_SENDIntent<span class="token punctuation">.</span>ACTION_WEB_SEARCH</code></pre><h4 id="category-的匹配规则"><a href="#category-的匹配规则" class="headerlink" title="category 的匹配规则"></a>category 的匹配规则</h4><p>category 也是一个字符串，但是它与 action 的过滤规则不同，它要求 Intent 中如果含有 category，那么所有的 category 都必须和过滤规则中的其中一个 category 相同。也就是说，Intent 中如果出现了 category，不管有几个 category，对于每个 category 来说，它必须是过滤规则中的定义了的 category。当然，Intent 中也可以没有 category（<code>若Intent中未指定category，系统会自动为它带上“android.intent.category.DEFAULT”</code>），如果没有，仍然可以匹配成功。category 和 action 的区别在于，action 要求 Intent 中必须有一个 action 且必须和过滤规则中的某几个 action 相同，而 category 要求 Intent 可以没有 category，但是一旦发现存在 category，不论你有多少，每个都要能够和过滤规则中的任何一个 category 相同。我们可以通过 addCategory 方法为 Intent 添加 category。<br>特别说明：</p><pre class=" language-xml"><code class="language-xml"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>intent-filter</span><span class="token punctuation">></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>action</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.action.MAIN<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>category</span> <span class="token attr-name"><span class="token namespace">android:</span>name</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>android.intent.category.LAUNCHER<span class="token punctuation">"</span></span> <span class="token punctuation">/></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>intent-filter</span><span class="token punctuation">></span></span></code></pre><p>这二者共同出现，标明该 Activity 是一个入口 Activity，并且会出现在系统应用列表中，二者缺一不可。</p><h4 id="data-的匹配规则"><a href="#data-的匹配规则" class="headerlink" title="data 的匹配规则"></a>data 的匹配规则</h4><p>如果 Intent 没有提供 type，系统将从 data 中得到数据类型。同 action 类似，只要 Intent 的 data 只要与 Intent Filter 中的任一个 data 声明完全相同，data 方面就完全匹配成功。</p><p>data由两部分组成：<code>mimeType</code> 和 <code>URI</code>。</p><ul><li>mimeType：媒体类型，例如 imgage/jpeg、auto/mpeg4 和 viedo/* 等，可以表示图片、文本、视频等不同的媒体格式。</li><li>uri：由 scheme、host、port、path | pathPattern | pathPrefix 这 4 部分组成。</li></ul><p><code>URI</code> 的结构如下：</p><pre><code>&lt;scheme&gt;://&lt;host&gt;:&lt;port&gt;/[&lt;path&gt;|&lt;pathPrefix&gt;|&lt;pathPattern &gt;]</code></pre><ul><li>scheme：URI 的模式，比如 http、https、file、content 等。</li><li>host：URI 的主机名，比如 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 。</li><li>port：URI 的端口号。</li><li>path、pathPattern 和 pathPrefix：这三个表示路径信息。path：用来匹配完整的路径；pathPrefix：用来匹配路径的前缀部分；pathPattern：用表达式来匹配整个路径。</li></ul><h3 id="IntentFilter-常见问题汇总"><a href="#IntentFilter-常见问题汇总" class="headerlink" title="IntentFilter 常见问题汇总"></a>IntentFilter 常见问题汇总</h3><h4 id="path、pathPattern-和-pathPrefix-的区别"><a href="#path、pathPattern-和-pathPrefix-的区别" class="headerlink" title="path、pathPattern 和 pathPrefix 的区别"></a>path、pathPattern 和 pathPrefix 的区别</h4><ul><li>path：用来匹配完整的路径，如：<a href="http://example.com/blog/abc.html" target="_blank" rel="noopener">http://example.com/blog/abc.html</a> ，这里将 path 设置为 /blog/abc.html 才能够进行匹配；</li><li>pathPrefix：用来匹配路径的前缀部分，拿上来的 Uri 来说，这里将 pathPrefix 设置为 /blog 就能进行匹配了；</li><li>pathPattern：用表达式来匹配整个路径，但是它里面可以包括通配符 <code>*</code>，注意正则表达式。</li></ul><blockquote><p>匹配符号：<br>    <code>*</code> 用来匹配0次或更多，如：<code>a*</code> 可以匹配“a”、“aa”、“aaa”…<br>    <code>.</code> 用来匹配任意字符，如：<code>.</code> 可以匹配“a”、“b”，“c”…<br>    <code>.*</code> 用来匹配任意字符0次或更多，如：<code>.*html</code> 可以匹配 “abchtml”、“chtml”，“html”，“sdf.html”…</p></blockquote><blockquote><p>转义：因为当读取 Xml 的时候，“\” 是被当作转义字符的（当它被用作 pathPattern 转义之前），因此这里需要两次转义，读取 Xml 是一次，在 pathPattern 中使用又是一次。如：“<em>” 这个字符就应该写成 “\</em>”，“\” 这个字符就应该写成 “\\”。</p></blockquote><h4 id="查询是否有-Activity-可以匹配指定-Intent-的组件"><a href="#查询是否有-Activity-可以匹配指定-Intent-的组件" class="headerlink" title="查询是否有 Activity 可以匹配指定 Intent 的组件"></a>查询是否有 Activity 可以匹配指定 Intent 的组件</h4><ul><li>采用 <code>PackageManager</code> 的 <code>resolveActivity</code> 或者 <code>Intent</code> 的 <code>resolveActivity</code> 方法会获得<code>最适合 Intent 的一个 Activity</code>。</li><li>调用 <code>PackageManager</code> 的 <code>queryIntentActivities</code> 会返回<code>所有成功匹配 Intent 的 Activity</code>。</li></ul><h4 id="android-intent-action-MAIN-与-android-intent-category-LAUNCHER-的区别"><a href="#android-intent-action-MAIN-与-android-intent-category-LAUNCHER-的区别" class="headerlink" title="android.intent.action.MAIN 与 android.intent.category.LAUNCHER 的区别"></a>android.intent.action.MAIN 与 android.intent.category.LAUNCHER 的区别</h4><ul><li>android.intent.action.MAIN：决定应用程序的入口 Activity，也就是决定一个应用程序最先启动那个组件。 </li><li>android.intent.category.LAUNCHER：决定应用程序是否被列入系统的启动器，也就是说是否在桌面上显示一个图标。Launcher 是安卓系统中的桌面启动器，是桌面UI的统称。</li></ul><p>这两个属性组合情况：</p><ul><li>第一种情况：有MAIN,无LAUNCHER，程序列表中无图标。原因：android.intent.category.LAUNCHER 决定应用程序是否显示在程序列表里。</li><li>第二种情况：无MAIN,有LAUNCHER，程序列表中无图标。原因：android.intent.action.MAIN 决定应用程序最先启动的 Activity，如果没有 Main，则不知启动哪个 Activity，所以也不会有图标出现。</li></ul><p>所以这两个属性一般成对出现。</p><blockquote><p>如果一个应用中有两个组件 intent-filter 都添加了 android.intent.action.MAIN 和 android.intent.category.LAUNCHER 这两个属性，则这个应用将会显示两个图标，写在前面的组件先运行。 </p></blockquote><h4 id="intent-filter-匹配优先级"><a href="#intent-filter-匹配优先级" class="headerlink" title="intent-filter 匹配优先级"></a>intent-filter 匹配优先级</h4><p>首先查看 Intent 的过滤器(intent-filter)，按照以下优先关系查找：<strong><code>action-&gt;data-&gt;category</code></strong>。</p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Activity </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之责任链模式</title>
      <link href="/posts/2018/1bb1b660.html"/>
      <url>/posts/2018/1bb1b660.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>很多情况下，在一个软件系统中可以处理某个请求的对象不止一个。例如审批工作流等，他们可以构成一条处理采购单的链式结构，采购单(可以看作是要处理的信息)沿着这条链进行传递，这条链就称为责任链。责任链可以是一条直线、一个环或者一个树形结构，最常见的责任链是直线型，即沿着一条单向的链来传递请求。链上的每一个对象都是请求处理者，责任链模式可以将请求的处理者组织成一条链，并让请求沿着链传递，由链上的处理者对请求进行相应的处理。在此过程中，客户端实际上无须关心请求的处理细节以及请求的传递，只需将请求发送到链上即可，从而实现请求发送者和请求处理者解耦。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>责任链模式(Chain of Responsibility Pattern)</code></strong>避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</p><p><strong>实质</strong>：责任链上的处理者负责处理请求，客户只需要将请求发送到责任链上即可，无须关心请求的处理细节和请求的传递，从而实现请求发送者与请求处理者的解耦。</p><blockquote><p>责任链模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>责任链模式包含如下角色：</p><ul><li><strong><code>Handler(抽象处理者)：</code></strong>它定义了一个处理请求的接口，一般设计为抽象类，由于不同的具体处理者处理请求的方式不同，因此在其中定义了抽象请求处理方法。因为每一个处理者的下家还是一个处理者，因此在抽象处理者中定义了一个抽象处理者类型的对象，作为其对下家的引用。通过该引用，处理者可以连成一条链。</li><li><strong><code>ConcreteHandler(具体处理者)：</code></strong>它是抽象处理者的子类，可以处理用户请求，在具体处理者类中实现了抽象处理者中定义的抽象请求处理方法，在处理请求之前需要进行判断，看是否有相应的处理权限，如果可以处理请求就处理它，否则将请求转发给后继者；在具体处理者中可以访问链中下一个对象，以便请求的转发。</li></ul><p>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</p><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/chain_responsibility_uml.jpg" alt="责任链模式结构图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象处理者。Handler 抽象类充当抽象处理者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象处理者 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 后继处理者角色 */</span>    <span class="token keyword">protected</span> Handler nextHandler<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 处理请求的抽象方法.     *     * @param condition 条件     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * nextHandler的Setter方法     *     * @param nextHandler 后继处理器     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNextHandler</span><span class="token punctuation">(</span>Handler nextHandler<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>nextHandler <span class="token operator">=</span> nextHandler<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>责任链模式的核心在于抽象处理者类的设计。</p></blockquote><p>其次，是具体处理者。ConcreteHandler1 和 ConcreteHandler2 类充当具体处理者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色1 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler1</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色1的处理方法     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler1"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体处理角色1的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体处理角色1 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色2 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandler2</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体处理角色2的处理方法     *     * @param condition 条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果是自己的责任，就自己处理，负责传给下家处理</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体处理角色2的处理方法handled1..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体处理角色2 通过..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            nextHandler<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span>condition<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体处理角色N */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteHandlerN</span> <span class="token keyword">extends</span> <span class="token class-name">Handler</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这里假设n是链的最后一个节点必须处理掉(在实际情况下，可能出现环，或者是树形，这里并不一定是最后一个节点)     *     * @param condition 参数条件     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span>String condition<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span> <span class="token string">"具体处理角色n的处理方法 结束..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>具体处理者是抽象处理者的子类，它具有两大作用：第一是处理请求，不同的具体处理者以不同的形式实现抽象请求处理方法handleRequest()；第二是转发请求，如果该请求超出了当前处理者类的权限，可以将该请求转发给下家。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ChainClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Handler handler1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handler2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandler2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Handler handlerN <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteHandlerN</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        handler1<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handler2<span class="token punctuation">)</span><span class="token punctuation">;</span>        handler2<span class="token punctuation">.</span><span class="token function">setNextHandler</span><span class="token punctuation">(</span>handlerN<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 假设这个请求是ConcreteHandler2的责任</span>        handler1<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token string">"ConcreteHandler2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>需要注意的是，<strong>责任链模式并不创建责任链，责任链的创建工作必须由系统的其他部分来完成，一般是在使用该责任链的客户端中创建责任链</strong>。责任链模式降低了请求的发送端和接收端之间的耦合，使多个对象都有机会处理这个请求。</p></blockquote><h2 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h2><p>责任链模式可分为两种：</p><ul><li>纯的责任链模式</li><li>不纯的责任链模式</li></ul><h3 id="纯的责任链模式"><a href="#纯的责任链模式" class="headerlink" title="纯的责任链模式"></a>纯的责任链模式</h3><p>一个纯的责任链模式要求一个具体处理者对象只能在两个行为中选择一个：<strong>要么承担全部责任，要么将责任推给下家</strong>，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的责任链模式中，<strong>要求一个请求必须被某一个处理者对象所接收</strong>，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的责任链模式。</p><h3 id="不纯的责任链模式"><a href="#不纯的责任链模式" class="headerlink" title="不纯的责任链模式"></a>不纯的责任链模式</h3><p>在一个不纯的责任链模式中<strong>允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收</strong>。每一级具体处理者在接收到事件时，都可以处理此事件，而不论此事件是否在上一级已得到处理，还存在事件未被处理的情况。</p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><p>责任链模式通过建立一条链来组织请求的处理者，请求将沿着链进行传递，请求发送者无须知道请求在何时、何处以及如何被处理，实现了请求发送者与处理者的解耦。在软件开发中，如果遇到有多个对象可以处理同一请求时可以应用责任链模式，例如在 Web 应用开发中创建一个过滤器(Filter)链来对请求数据进行过滤，在工作流系统中实现公文的分级审批等等，使用责任链模式可以较好地解决此类问题。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>责任链的主要优点如下：</p><ul><li>责任链模式使得一个对象无须知道是其他哪一个对象处理其请求，对象仅需知道该请求会被处理即可，接收者和发送者都没有对方的明确信息，且链中的对象不需要知道链的结构，由客户端负责链的创建，降低了系统的耦合度。</li><li>请求处理对象仅需维持一个指向其后继者的引用，而不需要维持它对所有的候选处理者的引用，可简化对象的相互连接。</li><li>在给对象分派职责时，责任链可以给我们更多的灵活性，可以通过在运行时对该链进行动态的增加或修改来增加或改变处理一个请求的职责。</li><li>在系统中增加一个新的具体请求处理者时无须修改原有系统的代码，只需要在客户端重新建链即可，从这一点来看是符合“开闭原则”的。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>责任链的的主要缺点如下：</p><ul><li>由于一个请求没有明确的接收者，那么就不能保证它一定会被处理，该请求可能一直到链的末端都得不到处理；一个请求也可能因责任链没有被正确配置而得不到处理。</li><li>对于比较长的责任链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li><li>如果建链不当，可能会造成循环调用，将导致系统陷入死循环。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用责任链模式：</p><ul><li>有多个对象可以处理同一个请求，具体哪个对象处理该请求待运行时刻再确定，客户端只需将请求提交到链上，而无须关心请求的处理对象是谁以及它是如何处理的。</li><li>在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。</li><li>可动态指定一组对象处理请求，客户端可以动态创建责任链来处理请求，还可以改变链中处理者之间的先后次序。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织链和分配责任。</li><li>责任链模式的主要优点在于可以降低系统的耦合度，简化对象的相互连接，同时增强给对象指派职责的灵活性，增加新的请求处理类也很方便；其主要缺点在于不能保证请求一定被接收，且对于比较长的责任链，请求的处理可能涉及到多个处理对象，系统性能将受到一定影响，而且在进行代码调试时不太方便。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之命令模式</title>
      <link href="/posts/2018/cdd1d929.html"/>
      <url>/posts/2018/cdd1d929.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在软件设计中，我们经常需要向某些对象发送请求，但是并不知道请求的接收者是谁，也不知道被请求的操作是哪个，我们只需在程序运行时指定具体的请求接收者即可，此时，可以使用命令模式来进行设计，使得请求发送者与请求接收者消除彼此之间的耦合，让对象之间的调用关系更加灵活。</p><p>命令模式可以对发送者和接收者完全解耦，发送者与接收者之间没有直接引用关系，发送请求的对象只需要知道如何发送请求，而不必知道如何完成请求。这就是命令模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>命令模式(Command Pattern)</code></strong>将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式的别名为动作(<code>Action</code>)模式或事务(<code>Transaction</code>)模式。</p><blockquote><p>命令模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>命令模式包含如下角色：</p><ul><li><strong><code>Command(抽象命令类)：</code></strong>抽象命令类一般是一个抽象类或接口，在其中声明了用于执行请求的 execute() 等方法，通过这些方法可以调用请求接收者的相关操作。</li><li><strong><code>ConcreteCommand(具体命令类)：</code></strong>具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中。在实现 execute() 方法时，将调用接收者对象的相关操作(Action)。</li><li><strong><code>Invoker(调用者)：</code></strong>调用者即请求发送者，它通过命令对象来执行请求。一个调用者并不需要在设计时确定其接收者，因此它只与抽象命令类之间存在关联关系。在程序运行时可以将一个具体命令对象注入其中，再调用具体命令对象的 execute() 方法，从而实现间接调用请求接收者的相关操作。</li><li><strong><code>Receiver(接收者)：</code></strong>接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/command_uml.jpg" alt="命令模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/command_seq.jpg" alt="命令模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象接收者和具体接收者。Receiver 抽象充当抽象接收者，ConcreteReceiver 抽象充当具体接收者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象接收者 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义每个接收者都必须完成的业务     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的接收者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteReceiver</span> <span class="token keyword">extends</span> <span class="token class-name">Receiver</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteReceiver处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其次，是抽象命令类和具体命令类。Command 抽象充当抽象命令类，ConcreteCommand 抽象充当具体命令类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象命令类 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 执行命令的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体命令类 */</span><span class="token keyword">class</span> <span class="token class-name">ConcreteCommand</span> <span class="token keyword">extends</span> <span class="token class-name">Command</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 维持一个对请求接收者对象的引用 */</span>    <span class="token keyword">private</span> Receiver receiver<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteCommand</span><span class="token punctuation">(</span>Receiver receiver<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>receiver <span class="token operator">=</span> receiver<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        receiver<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用请求接收者的业务处理方法action()</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是调用者。Invoker 抽象充当调用者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 调用者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Invoker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Command command<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCommand</span><span class="token punctuation">(</span>Command command<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command <span class="token operator">=</span> command<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 执行命令     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>command<span class="token punctuation">.</span><span class="token function">execute</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CommandClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Receiver receiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Command command <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteCommand</span><span class="token punctuation">(</span>receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>        Invoker invoker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Invoker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        invoker<span class="token punctuation">.</span><span class="token function">setCommand</span><span class="token punctuation">(</span>command<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 把命令交给调用者执行</span>        invoker<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 执行命令</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。</li><li>每一个命令都是一个操作：请求的一方发出请求，要求执行一个操作；接收的一方收到请求，并执行操作。</li><li>命令模式允许请求的一方和接收的一方独立开来，使得请求的一方不必知道接收请求的一方的接口，更不必知道请求是怎么被接收，以及操作是否被执行、何时被执行，以及是怎么被执行的。</li><li>命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的关键在于引入了抽象命令接口，且发送者针对抽象命令接口编程，只有实现了抽象命令接口的具体命令才能与接收者相关联。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>命令模式的主要优点如下：</p><ul><li>降低系统的耦合度。由于请求者与接收者之间不存在直接引用，因此请求者与接收者之间实现完全解耦，相同的请求者可以对应不同的接收者，同样，相同的接收者也可以供不同的请求者使用，两者之间具有良好的独立性。</li><li>新的命令可以很容易地加入到系统中。由于增加新的具体命令类不会影响到其他类，因此增加新的具体命令类很容易，无须修改原有系统源代码，甚至客户类代码，满足“开闭原则”的要求。</li><li>可以比较容易地设计一个命令队列或宏命令（组合命令）。</li><li>为请求的撤销(Undo)和恢复(Redo)操作提供了一种设计和实现方案。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>命令模式的主要缺点如下：</p><ul><li>使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个对请求接收者的调用操作都需要设计一个具体命令类，因此在某些系统中可能需要提供大量的具体命令类，这将影响命令模式的使用。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用命令模式：</p><ul><li>系统需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互。请求调用者无须知道接收者的存在，也无须知道接收者是谁，接收者也无须关心何时被调用。</li><li>系统需要在不同的时间指定请求、将请求排队和执行请求。一个命令对象和请求的初始调用者可以有不同的生命期，换言之，最初的请求发出者可能已经不在了，而命令对象本身仍然是活动的，可以通过该命令对象去调用请求接收者，而无须关心请求调用者的存在性，可以通过请求日志文件等机制来具体实现。</li><li>系统需要支持命令的撤销(Undo)操作和恢复(Redo)操作。</li><li>系统需要将一组操作组合在一起形成宏命令。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在命令模式中，将一个请求封装为一个对象，从而使我们可用不同的请求对客户进行参数化；对请求排队或者记录请求日志，以及支持可撤销的操作。命令模式是一种对象行为型模式，其别名为动作模式或事务模式。</li><li>命令模式包含四个角色：抽象命令类中声明了用于执行请求的 execute() 等方法，通过这些方法可以调用请求接收者的相关操作；具体命令类是抽象命令类的子类，实现了在抽象命令类中声明的方法，它对应具体的接收者对象，将接收者对象的动作绑定其中；调用者即请求的发送者，又称为请求者，它通过命令对象来执行请求；接收者执行与请求相关的操作，它具体实现对请求的业务处理。</li><li>命令模式的本质是对命令进行封装，将发出命令的责任和执行命令的责任分割开。命令模式使请求本身成为一个对象，这个对象和其他对象一样可以被存储和传递。</li><li>命令模式的主要优点在于降低系统的耦合度，增加新的命令很方便，而且可以比较容易地设计一个命令队列和宏命令，并方便地实现对请求的撤销和恢复；其主要缺点在于可能会导致某些系统有过多的具体命令类。</li><li>命令模式适用情况包括：需要将请求调用者和请求接收者解耦，使得调用者和接收者不直接交互；需要在不同的时间指定请求、将请求排队和执行请求；需要支持命令的撤销操作和恢复操作，需要将一组操作组合在一起，即支持宏命令。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之解释器模式</title>
      <link href="/posts/2018/4976d8cc.html"/>
      <url>/posts/2018/4976d8cc.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在某些情况下，为了更好地描述某一些特定类型的问题，我们可以创建一种新的语言，这种语言拥有自己的表达式和结构，即文法规则，这些问题的实例将对应为该语言中的句子。此时，可以使用解释器模式来设计这种新的语言。对解释器模式的学习能够加深我们对面向对象思想的理解，并且掌握编程语言中文法规则的解释过程。这就是解释器模式的动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>解释器模式(Interpreter Pattern)</code></strong>定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。</p><blockquote><p>解释器模式是一种<strong><code>类行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>解释器模式包含如下角色：</p><ul><li><strong><code>AbstractExpression(抽象表达式)：</code></strong>在抽象表达式中声明了抽象的解释操作，它是所有终结符表达式和非终结符表达式的公共父类。</li><li><strong><code>TerminalExpression(终结符表达式)：</code></strong>终结符表达式是抽象表达式的子类，它实现了与文法中的终结符相关联的解释操作，在句子中的每一个终结符都是该类的一个实例。通常在一个解释器模式中只有少数几个终结符表达式类，它们的实例可以通过非终结符表达式组成较为复杂的句子。</li><li><strong><code>NonterminalExpression(非终结符表达式)：</code></strong>非终结符表达式也是抽象表达式的子类，它实现了文法中非终结符的解释操作，由于在非终结符表达式中可以包含终结符表达式，也可以继续包含非终结符表达式，因此其解释操作一般通过递归的方式来完成。</li><li><strong><code>Context(环境类)：</code></strong>环境类又称为上下文类，它用于存储解释器之外的一些全局信息，通常它临时存储了需要解释的语句。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/interpreter_uml.jpg" alt="解释器模式结构图"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>首先，是抽象表达式。AbstractExpression 抽象类充当抽象表达式，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象表达式 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractExpression</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">int</span> <span class="token function">interpret</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一条文法规则，所以系统将具有较好的灵活性和可扩展性。对于所有的终结符和非终结符，我们首先需要抽象出一个公共父类，即抽象表达式类。</p></blockquote><p>其次，是终结符表达式和非终结符表达式。TerminalExpression 类充当终结符表达式，NonterminalExpression 类充当非终结符表达式，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 终结符表达式 */</span><span class="token keyword">class</span> <span class="token class-name">TerminalExpression</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExpression</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">interpret</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 终结符表达式的解释操作</span>        <span class="token keyword">return</span> context<span class="token punctuation">.</span><span class="token function">lookup</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非终结符表达式 */</span><span class="token keyword">class</span> <span class="token class-name">NonterminalExpression</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractExpression</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> AbstractExpression left<span class="token punctuation">;</span>    <span class="token keyword">private</span> AbstractExpression right<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">NonterminalExpression</span><span class="token punctuation">(</span>AbstractExpression left<span class="token punctuation">,</span> AbstractExpression right<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">interpret</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 调用每一个组成部分的interpret()方法，在调用时指定组成部分的连接方式，即非终结符的功能</span>        <span class="token keyword">return</span> left<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span> <span class="token operator">+</span> right<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>终结符表达式和非终结符表达式类都是抽象表达式类的子类。对于终结符表达式，其代码很简单，主要是对终结符元素的处理；对于非终结符表达式，其代码相对比较复杂，因为可以通过非终结符将表达式组合成更加复杂的结构。</p></blockquote><p>然后，是环境类。Context 类充当环境类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 环境类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>AbstractExpression<span class="token punctuation">,</span> Integer<span class="token operator">></span> values <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>AbstractExpression<span class="token punctuation">,</span> Integer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">assign</span><span class="token punctuation">(</span>AbstractExpression key<span class="token punctuation">,</span> Integer value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 往环境类中设值</span>        values<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> Integer <span class="token function">lookup</span><span class="token punctuation">(</span>AbstractExpression key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 获取存储在环境类中的值</span>        <span class="token keyword">return</span> values<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>环境类用于存储一些全局信息，通常在 Context 中包含了一个 HashMap 或 ArrayList 等类型的集合对象（也可以直接由 HashMap 等集合类充当环境类），存储一系列公共信息，如变量名与值的映射关系（key/value）等，用于在进行具体的解释操作时从中获取相关信息。<br>环境类通常作为参数被传递到所有表达式的解释方法 interpret() 中，可以在 Context 对象中存储和访问表达式解释器的状态，向表达式解释器提供一些全局的、公共的数据，此外还可以在 Context 中增加一些所有表达式解释器都共有的功能，减轻解释器的职责。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">InterpreterClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TerminalExpression expressionA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        TerminalExpression expressionB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TerminalExpression</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>expressionA<span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>expressionB<span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        AbstractExpression expression <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">NonterminalExpression</span><span class="token punctuation">(</span>expressionA<span class="token punctuation">,</span> expressionB<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>expression<span class="token punctuation">.</span><span class="token function">interpret</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>由于表达式可分为终结符表达式和非终结符表达式，因此解释器模式的结构与组合模式的结构有些类似，但在解释器模式中包含更多的组成元素。</li><li>解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>解释器模式的主要优点如下：</p><ul><li>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</li><li>实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码。</li><li>增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>解释器模式的主要缺点如下：</p><ul><li>对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。</li><li>执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用解释器模式：</p><ul><li>可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。</li><li>一些重复出现的问题可以用一种简单的语言来进行表达。</li><li>一个语言的文法较为简单。</li><li>执行效率不是关键问题。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>解释器模式定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码。解释器模式是一种类行为型模式。</li><li>在解释器模式中，每一种终结符和非终结符都有一个具体类与之对应，正因为使用类来表示每一条文法规则，所以系统将具有较好的灵活性和可扩展性。</li><li>由于表达式可分为终结符表达式和非终结符表达式，因此解释器模式的结构与组合模式的结构有些类似，但在解释器模式中包含更多的组成元素。</li><li>解释器模式为自定义语言的设计和实现提供了一种解决方案，它用于定义一组文法规则并通过这组文法规则来解释语言中的句子。</li><li>易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法。</li><li>每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之迭代器模式</title>
      <link href="/posts/2018/e9ec0609.html"/>
      <url>/posts/2018/e9ec0609.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在软件开发中，我们经常需要使用聚合对象来存储一系列数据。聚合对象拥有两个职责：一是存储数据；二是遍历数据。从依赖性来看，前者是聚合对象的基本职责；而后者既是可变化的，又是可分离的。因此，可以将遍历数据的行为从聚合对象中分离出来，封装在一个被称之为“迭代器”的对象中，由迭代器来提供遍历聚合对象内部数据的行为，这将简化聚合对象的设计，更符合“单一职责原则”的要求。这就是迭代器模式的动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>迭代器模式(Iterator Pattern)</code></strong>提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。</p><blockquote><p>迭代器模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>迭代器模式包含如下角色：</p><ul><li><strong><code>Iterator(抽象迭代器)：</code></strong>它定义了访问和遍历元素的接口，声明了用于遍历数据元素的方法，例如：用于获取第一个元素的 first() 方法，用于访问下一个元素的 next() 方法，用于判断是否还有下一个元素的 hasNext() 方法，用于获取当前元素的 currentItem() 方法等，在具体迭代器中将实现这些方法。</li><li><strong><code>ConcreteIterator(具体迭代器)：</code></strong>它实现了抽象迭代器接口，完成对聚合对象的遍历，同时在具体迭代器中通过游标来记录在聚合对象中所处的当前位置，在具体实现时，游标通常是一个表示位置的非负整数。</li><li><strong><code>Aggregate(抽象聚合类)：</code></strong>它用于存储和管理元素对象，声明一个 createIterator() 方法用于创建一个迭代器对象，充当抽象迭代器工厂角色。</li><li><strong><code>ConcreteAggregate(具体聚合类)：</code></strong>它实现了在抽象聚合类中声明的 createIterator() 方法，该方法返回一个与该具体聚合类对应的具体迭代器 ConcreteIterator 实例。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/iterator_uml.jpg" alt="迭代器模式结构图"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>首先，是抽象迭代器和具体迭代器。Iterator 接口充当抽象迭代器，ConcreteIterator 类充当具体迭代器，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象迭代器 */</span><span class="token keyword">interface</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 将游标指向第一个元素     */</span>    <span class="token keyword">void</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 将游标指向下一个元素     */</span>    <span class="token keyword">void</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 判断是否存在下一个元素     */</span>    <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取游标指向的当前元素     */</span>    Object <span class="token function">currentItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>在抽象迭代器中声明了用于遍历聚合对象中所存储元素的方法。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体迭代器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteIterator</span> <span class="token keyword">implements</span> <span class="token class-name">Iterator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 定义一个游标，用于记录当前访问位置 */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> cursor<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/** 维持一个对具体聚合对象的引用，以便于访问存储在聚合对象中的数据 */</span>    <span class="token keyword">private</span> ConcreteAggregate aggregate<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">ConcreteIterator</span><span class="token punctuation">(</span>ConcreteAggregate aggregate<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>aggregate <span class="token operator">=</span> aggregate<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">first</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 具体实现代码</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 具体实现代码</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 具体实现代码</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Object <span class="token function">currentItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 具体实现代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在具体迭代器中将实现抽象迭代器声明的遍历数据的方法。需要注意的是抽象迭代器接口的设计非常重要，一方面需要充分满足各种遍历操作的要求，尽量为各种遍历方法都提供声明，另一方面又不能包含太多方法，接口中方法太多将给子类的实现带来麻烦。因此，可以考虑使用抽象类来设计抽象迭代器，在抽象类中为每一个方法提供一个空的默认实现。如果需要在具体迭代器中为聚合对象增加全新的遍历操作，则必须修改抽象迭代器和具体迭代器的源代码，这将违反“开闭原则”，因此在设计时要考虑全面，避免之后修改接口。</p></blockquote><p>然后，是抽象聚合类和具体聚合类。Aggregate 接口充当抽象聚合类，ConcreteAggregate 类充当具体聚合类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象聚合类 */</span><span class="token keyword">interface</span> <span class="token class-name">Aggregate</span> <span class="token punctuation">{</span>    Iterator <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>聚合类用于存储数据并负责创建迭代器对象。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体聚合类 */</span><span class="token keyword">class</span> <span class="token class-name">ConcreteAggregate</span> <span class="token keyword">implements</span> <span class="token class-name">Aggregate</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Iterator <span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteIterator</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 下面是业务逻辑代码</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span></code></pre><blockquote><p>具体聚合类作为抽象聚合类的子类，一方面负责存储数据，另一方面实现了在抽象聚合类中声明的工厂方法 createIterator()，用于返回一个与该具体聚合类对应的具体迭代器对象。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">IteratorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ConcreteAggregate aggregate <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteAggregate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        aggregate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        aggregate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        aggregate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        aggregate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        aggregate<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">BigDecimal</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Iterator iterator <span class="token operator">=</span> aggregate<span class="token punctuation">.</span><span class="token function">createIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">hasNext</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>iterator<span class="token punctuation">.</span><span class="token function">currentItem</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            iterator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>除了使用关联关系外，为了能够让迭代器可以访问到聚合对象中的数据，我们还可以将迭代器类设计为聚合类的内部类，JDK 中的迭代器类就是通过这种方法来实现的。</p></blockquote><h2 id="JDK-中的迭代器模式"><a href="#JDK-中的迭代器模式" class="headerlink" title="JDK 中的迭代器模式"></a>JDK 中的迭代器模式</h2><p>为了让开发人员能够更加方便地操作聚合对象，在 Java、C# 等编程语言中都提供了内置迭代器。在 <code>Java 集合框架</code>中，常用的 <code>List</code> 和 <code>Set</code> 等聚合类都继承（或实现）了 <code>java.util.Collection</code> 接口。 JDK 中定义了抽象迭代器接口 <code>java.util.Iterator</code>。</p><p>在 JDK 中，Collection 接口和 Iterator 接口充当了迭代器模式的抽象层，分别对应于抽象聚合类和抽象迭代器，而 Collection 接口的子类充当了具体聚合类。</p><h3 id="Collection-接口"><a href="#Collection-接口" class="headerlink" title="Collection 接口"></a>Collection 接口</h3><p>在 <code>java.util.Collection</code> 接口中声明了如下方法(部分方法)：</p><table><thead><tr><th>方法名</th><th>方法描述</th></tr></thead><tbody><tr><td>size()</td><td>用于返回集合中元素的数量</td></tr><tr><td>isEmpty()</td><td>用于判断集合中元素是否为空</td></tr><tr><td>contains(Object o) 和 containsAll(Collection&lt;?&gt; c)</td><td>用于判断集合中是否包含指定元素</td></tr><tr><td>add(E e) 和 addAll(Collection&lt;? extends E&gt; c)</td><td>用于向集合中添加元素</td></tr><tr><td>remove(Object o) 和 removeAll(Collection&lt;?&gt; c)</td><td>用于从集合中删除元素</td></tr><tr><td>iterator()</td><td>用于返回一个迭代器对象</td></tr><tr><td>clear()</td><td>用于清空集合中的元素</td></tr></tbody></table><blockquote><p> 除了包含一些增加元素和删除元素的方法外，还提供了一个 iterator() 方法，用于返回一个 Iterator 迭代器对象，以便遍历聚合中的元素；具体的 Java 聚合类可以通过实现该 iterator() 方法返回一个具体的 Iterator 对象。</p></blockquote><h3 id="Iterator-接口"><a href="#Iterator-接口" class="headerlink" title="Iterator 接口"></a>Iterator 接口</h3><p>在 <code>java.util.Iterator</code> 接口中声明了如下方法(部分方法)：</p><table><thead><tr><th>方法名</th><th>方法描述</th></tr></thead><tbody><tr><td>hasNext()</td><td>用于判断聚合对象中是否还存在下一个元素</td></tr><tr><td>next()</td><td>用于将游标移至下一个元素并返回该元素</td></tr><tr><td>remove()</td><td>用于删除上次调用 next() 时所返回的元素</td></tr></tbody></table><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>在迭代器模式中，提供了一个外部的迭代器来对聚合对象进行访问和遍历，迭代器定义了一个访问该聚合元素的接口，并且可以跟踪当前遍历的元素，了解哪些元素已经遍历过而哪些没有。迭代器的引入，将使得对一个复杂聚合对象的操作变得简单。</li><li>迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>迭代器模式的主要优点如下：</p><ul><li>它支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>在迭代器模式中，由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>迭代器模式的主要缺点如下：</p><ul><li>由于迭代器模式将存储数据和遍历数据的职责分离，增加新的聚合类需要对应增加新的迭代器类，类的个数成对增加，这在一定程度上增加了系统的复杂性。</li><li>抽象迭代器的设计难度较大，需要充分考虑到系统将来的扩展，例如 JDK 内置迭代器 Iterator 就无法实现逆向遍历，如果需要实现逆向遍历，只能通过其子类 ListIterator 等来实现，而 ListIterator 迭代器无法用于操作 Set 类型的聚合对象。在自定义迭代器时，创建一个考虑全面的抽象迭代器并不是件很容易的事情。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用迭代器模式：</p><ul><li>访问一个聚合对象的内容而无须暴露它的内部表示。将聚合对象的访问与内部数据的存储分离，使得访问聚合对象时无须了解其内部实现细节。</li><li>需要为一个聚合对象提供多种遍历方式。</li><li>为遍历不同的聚合结构提供一个统一的接口，在该接口的实现类中为不同的聚合结构提供不同的遍历方式，而客户端可以一致性地操作该接口。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>迭代器模式提供一种方法来访问聚合对象，而不用暴露这个对象的内部表示，其别名为游标(Cursor)。迭代器模式是一种对象行为型模式。</li><li>迭代器模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>迭代器模式是一种使用频率非常高的设计模式，通过引入迭代器可以将数据的遍历功能从聚合对象中分离出来，聚合对象只负责存储数据，而遍历数据由迭代器来完成。</li><li>迭代器模式支持以不同的方式遍历一个聚合对象，在同一个聚合对象上可以定义多种遍历方式。在迭代器模式中只需要用一个不同的迭代器来替换原有迭代器即可改变遍历算法，我们也可以自己定义迭代器的子类以支持新的遍历方式。</li><li>迭代器简化了聚合类。由于引入了迭代器，在原有的聚合对象中不需要再自行提供数据遍历等方法，这样可以简化聚合类的设计。</li><li>迭代器模式中由于引入了抽象层，增加新的聚合类和迭代器类都很方便，无须修改原有代码，满足“开闭原则”的要求。</li><li>在 JDK 的 <code>java.util</code> 包中，提供了 <code>Collection</code> 接口以及 <code>Iterator</code> 接口，它们构成了 Java 语言对迭代器模式的支持。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之中介者模式</title>
      <link href="/posts/2018/a98fd302.html"/>
      <url>/posts/2018/a98fd302.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在用户与用户直接聊天的设计方案中，用户对象之间存在很强的关联性，将导致系统出现如下问题：</p><ul><li>系统结构复杂：对象之间存在大量的相互关联和调用，若有一个对象发生变化，则需要跟踪和该对象关联的其他所有对象，并进行适当处理。</li><li>对象可重用性差：由于一个对象和其他对象具有很强的关联，若没有其他对象的支持，一个对象很难被另一个系统或模块重用，这些对象表现出来更像一个不可分割的整体，职责较为混乱。</li><li>系统扩展性低：增加一个新的对象需要在原有相关对象上增加引用，增加新的引用关系也需要调整原有对象，系统耦合度很高，对象操作很不灵活，扩展性差。</li></ul><p>在面向对象的软件设计与开发过程中，根据“单一职责原则”，我们应该尽量将对象细化，使其只负责或呈现单一的职责。</p><p>对于一个模块，可能由很多对象构成，而且这些对象之间可能存在相互的引用，为了减少对象两两之间复杂的引用关系，使之成为一个松耦合的系统，我们需要使用中介者模式，这就是中介者模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>中介者模式(Mediator Pattern)</code></strong>：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式。</p><blockquote><p>中介者模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>中介者模式包含如下角色：</p><ul><li><strong><code>Mediator(抽象中介者)</code></strong>它定义一个接口，该接口用于与各同事对象之间进行通信。</li><li><strong><code>ConcreteMediator(具体中介者)</code></strong>它是抽象中介者的子类，通过协调各个同事对象来实现协作行为，它维持了对各个同事对象的引用。</li><li><strong><code>Colleague(抽象同事类)</code></strong>它定义各个同事类公有的方法，并声明了一些抽象方法来供子类实现，同时它维持了一个对抽象中介者类的引用，其子类可以通过该引用来与中介者通信。</li><li><strong><code>ConcreteColleague(具体同事类)</code></strong>它是抽象同事类的子类；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中声明的抽象方法。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/mediator_uml.jpg" alt="命令模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/mediator_seq.jpg" alt="命令模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象中介者和具体中介者。Mediator 抽象类充当抽象中介者，ConcreteMediator 类充当具体中介者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象中介者 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> ArrayList<span class="token operator">&lt;</span>Colleague<span class="token operator">></span> colleagues<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//用于存储同事对象</span>    <span class="token comment" spellcheck="true">/**     * 注册方法，用于增加同事对象     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">register</span><span class="token punctuation">(</span>Colleague colleague<span class="token punctuation">)</span> <span class="token punctuation">{</span>        colleagues<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>colleague<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 声明抽象的业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体中介者 */</span><span class="token keyword">class</span> <span class="token class-name">ConcreteMediator</span> <span class="token keyword">extends</span> <span class="token class-name">Mediator</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">//实现业务方法，封装同事之间的调用</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">(</span><span class="token punctuation">(</span>Colleague<span class="token punctuation">)</span> <span class="token punctuation">(</span>colleagues<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//通过中介者调用同事类的方法</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是抽象同事类和具体同事类。Colleague 抽象类充当抽象同事类，ConcreteColleagueA 和 ConcreteColleagueB 类充当具体同事类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象同事类 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> Mediator mediator<span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//维持一个抽象中介者的引用</span>    <span class="token keyword">public</span> <span class="token function">Colleague</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>mediator <span class="token operator">=</span> mediator<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">//声明自身方法，处理自己的行为</span>    <span class="token comment" spellcheck="true">/**     * 定义依赖方法，与中介者进行通信     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        mediator<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Colleague委托给中介者的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteColleagueA</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleagueA</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteColleagueA处理自己的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteColleagueB</span> <span class="token keyword">extends</span> <span class="token class-name">Colleague</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteColleagueB</span><span class="token punctuation">(</span>Mediator mediator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 自有方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteColleagueB处理自己的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MediatorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Mediator mediator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteMediator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleagueA colleagueA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleagueA</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        ConcreteColleagueB colleagueB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteColleagueB</span><span class="token punctuation">(</span>mediator<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>colleagueA<span class="token punctuation">)</span><span class="token punctuation">;</span>        mediator<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>colleagueB<span class="token punctuation">)</span><span class="token punctuation">;</span>        colleagueA<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleagueB<span class="token punctuation">.</span><span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleagueA<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        colleagueB<span class="token punctuation">.</span><span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>中介者模式将一个网状的系统结构变成一个以中介者对象为中心的星形结构，在这个星型结构中，使用中介者对象与其他对象的一对多关系来取代原有对象之间的多对多关系。</p><p>中介者模式的核心在于中介者类的引入，在中介者模式中，中介者类承担了两方面的职责：</p><ul><li><strong>中转作用（结构性）</strong>：通过中介者提供的中转作用，各个同事对象就不再需要显式引用其他同事，当需要和其他同事进行通信时，可通过中介者来实现间接调用。该中转作用属于中介者在结构上的支持。</li><li><strong>协调作用（行为性）</strong>：中介者可以更进一步的对同事之间的关系进行封装，同事可以一致的和中介者进行交互，而不需要指明中介者需要具体怎么做，中介者根据封装在自身内部的协调逻辑，对同事的请求进行进一步处理，将同事成员之间的关系行为进行分离和封装。该协调作用属于中介者在行为上的支持。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>中介者模式的主要优点如下：</p><ul><li>中介者模式简化了对象之间的交互，它用中介者和同事的一对多交互代替了原来同事之间的多对多交互，一对多关系更容易理解、维护和扩展，将原本难以理解的网状结构转换成相对简单的星型结构。</li><li>中介者模式可将各同事对象解耦。中介者有利于各同事之间的松耦合，我们可以独立的改变和复用每一个同事和中介者，增加新的中介者和新的同事类都比较方便，更好地符合“开闭原则”。</li><li>可以减少子类生成，中介者将原本分布于多个对象间的行为集中在一起，改变这些行为只需生成新的中介者子类即可，这使各个同事类可被重用，无须对同事类进行扩展。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>中介者模式的主要缺点如下：</p><ul><li>在具体中介者类中包含了大量同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用中介者模式：</p><ul><li>系统中对象之间存在复杂的引用关系，系统结构混乱且难以理解。</li><li>一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象。</li><li>想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。可以通过引入中介者类来实现，在中介者中定义对象交互的公共行为，如果需要改变行为则可以增加新的具体中介者类。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>中介者模式用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。中介者模式又称为调停者模式，它是一种对象行为型模式。</li><li>中介者模式包含四个角色：抽象中介者用于定义一个接口，该接口用于与各同事对象之间的通信；具体中介者是抽象中介者的子类，通过协调各个同事对象来实现协作行为，了解并维护它的各个同事对象的引用；抽象同事类定义各同事的公有方法；具体同事类是抽象同事类的子类，每一个同事对象都引用一个中介者对象；每一个同事对象在需要和其他同事对象通信时，先与中介者通信，通过中介者来间接完成与其他同事类的通信；在具体同事类中实现了在抽象同事类中定义的方法。</li><li>通过引入中介者对象，可以将系统的网状结构变成以中介者为中心的星形结构，中介者承担了中转作用和协调作用。中介者类是中介者模式的核心，它对整个系统进行控制和协调，简化了对象之间的交互，还可以对对象间的交互进行进一步的控制。</li><li>中介者模式的主要优点在于简化了对象之间的交互，将各同事解耦，还可以减少子类生成，对于复杂的对象之间的交互，通过引入中介者，可以简化各同事类的设计和实现；中介者模式主要缺点在于具体中介者类中包含了同事之间的交互细节，可能会导致具体中介者类非常复杂，使得系统难以维护。</li><li>中介者模式适用情况包括：系统中对象之间存在复杂的引用关系，产生的相互依赖关系结构混乱且难以理解；一个对象由于引用了其他很多对象并且直接和这些对象通信，导致难以复用该对象；想通过一个中间类来封装多个类中的行为，而又不想生成太多的子类。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之备忘录模式</title>
      <link href="/posts/2018/baaeb04b.html"/>
      <url>/posts/2018/baaeb04b.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>每个人都有过后悔的时候，但人生并无后悔药，有些错误一旦发生就无法再挽回，有些人一旦错过就不会再回来，有些话一旦说出口就不可能再收回，这就是人生。为了不后悔，凡事我们都需要三思而后行。说了这么多，大家可能已经晕了，不是在学设计模式吗？为什么弄出这么一堆人生感悟来，呵呵，别着急，本章将介绍一种让我们可以在软件中实现后悔机制的设计模式——备忘录模式，它是软件中的“后悔药”，是软件中的“月光宝盒”。这就是备忘录模式的动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>备忘录模式(Memento Pattern)</code></strong>在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。备忘录模式又叫做快照模式(Snapshot Pattern)或 Token 模式。</p><blockquote><p>备忘录模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>备忘录模式包含如下角色：</p><ul><li><strong><code>Originator(原发器)：</code></strong>它是一个普通类，可以创建一个备忘录，并存储它的当前内部状态，也可以使用备忘录来恢复其内部状态，一般将需要保存内部状态的类设计为原发器。</li><li><strong><code>Memento(备忘录)：</code></strong>存储原发器的内部状态，根据原发器来决定保存哪些内部状态。备忘录的设计一般可以参考原发器的设计，根据实际需要确定备忘录类中的属性。需要注意的是，除了原发器本身与负责人类之外，备忘录对象不能直接供其他类使用，原发器的设计在不同的编程语言中实现机制会有所不同。</li><li><strong><code>Caretaker(负责人)：</code></strong>负责人又称为管理者，它负责保存备忘录，但是不能对备忘录的内容进行操作或检查。在负责人类中可以存储一个或多个备忘录对象，它只负责存储对象，而不能修改对象，也无须知道对象的实现细节。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/memento_uml.jpg" alt="备忘录模式结构图"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>首先，是原发器。Originator 类充当原发器，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 原发器 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Originator</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 创建一个备忘录对象     */</span>    <span class="token keyword">public</span> Memento <span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Memento</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 根据备忘录对象恢复原发器先前状态     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">restoreMemento</span><span class="token punctuation">(</span>Memento memento<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> memento<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在真实业务中，原发器类是一个具体的业务类，它包含一些用于存储成员数据的属性。</p></blockquote><p>其次，是备忘录。Memento 类充当备忘录，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 备忘录 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Memento</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String state<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Memento</span><span class="token punctuation">(</span>Originator originator<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> originator<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>对于类而言，它通常提供了与原发器相对应的属性（可以是全部，也可以是部分）用于存储原发器的状态。<br>在设计备忘录类时需要考虑其封装性，除了 Originator 类，不允许其他类来调用备忘录类 Memento 的构造函数与相关方法，如果不考虑封装性，允许其他类调用 setState() 等方法，将导致在备忘录中保存的历史状态发生改变，通过撤销操作所恢复的状态就不再是真实的历史状态，备忘录模式也就失去了本身的意义。</p></blockquote><p>然后，是负责人。Context 类充当负责人，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 负责人 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Caretaker</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Memento memento<span class="token punctuation">;</span>    <span class="token keyword">public</span> Memento <span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> memento<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setMemento</span><span class="token punctuation">(</span>Memento memento<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>memento <span class="token operator">=</span> memento<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>对于负责人类 Caretaker，它用于保存备忘录对象，并提供 getMemento() 方法用于向客户端返回一个备忘录对象，原发器通过使用这个备忘录对象可以回到某个历史状态。在 Caretaker 类中不应该直接调用 Memento 中的状态改变方法，它的作用仅仅用于存储备忘录对象。将原发器备份生成的备忘录对象存储在其中，当用户需要对原发器进行恢复时再将存储在其中的备忘录对象取出。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MementoClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Caretaker caretaker <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Caretaker</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 创建负责人对象</span>        Originator originator <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Originator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建原发器对象</span>        originator<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 初始化状态标识 "0"</span>        Memento memento1 <span class="token operator">=</span> originator<span class="token punctuation">.</span><span class="token function">createMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建状态为"0"的备忘录对象</span>        caretaker<span class="token punctuation">.</span><span class="token function">setMemento</span><span class="token punctuation">(</span>memento1<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment" spellcheck="true">// 将记录了Originator状态的备忘录 交给 Caretaker备忘录管理者储存</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Originator 的当前状态："</span> <span class="token operator">+</span> originator<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----- 更改原发器的状态 -----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        originator<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span><span class="token string">"1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token comment" spellcheck="true">// 更改原发器的状态标识为"1"</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Originator 的当前状态："</span> <span class="token operator">+</span> originator<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"----- 撤销至原发器的先前状态 -----"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        originator<span class="token punctuation">.</span><span class="token function">restoreMemento</span><span class="token punctuation">(</span>caretaker<span class="token punctuation">.</span><span class="token function">getMemento</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Originator 的当前状态："</span> <span class="token operator">+</span> originator<span class="token punctuation">.</span><span class="token function">getState</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>备忘录是一个很特殊的对象，只有原发器对它拥有控制的权力，负责人只负责管理，而其他类无法访问到备忘录，因此我们需要对备忘录进行封装。</li><li>为了实现对备忘录对象的封装，需要对备忘录的调用进行控制，对于原发器而言，它可以调用备忘录的所有信息，允许原发器访问返回到先前状态所需的所有数据；对于负责人而言，只负责备忘录的保存并将备忘录传递给其他对象；对于其他对象而言，只需要从负责人处取出备忘录对象并将原发器对象的状态恢复，而无须关心备忘录的保存细节。理想的情况是只允许生成该备忘录的那个原发器访问备忘录的内部状态。</li><li>备忘录模式在很多软件的使用过程中普遍存在，但是在应用软件开发中，它的使用频率并不太高，因为现在很多基于窗体和浏览器的应用软件并没有提供撤销操作。如果需要为软件提供撤销功能，备忘录模式无疑是一种很好的解决方案。在一些字处理软件、图像编辑软件、数据库管理系统等软件中备忘录模式都得到了很好的应用。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>备忘录模式的主要优点如下：</p><ul><li>它提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</li><li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>备忘录模式的主要缺点如下：</p><ul><li>资源消耗过大，如果需要保存的原发器类的成员变量太多，就不可避免需要占用大量的存储空间，每保存一次对象的状态都需要消耗一定的系统资源。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用备忘录模式：</p><ul><li>保存一个对象在某一个时刻的全部状态或部分状态，这样以后需要时它能够恢复到先前的状态，实现撤销操作。</li><li>防止外界对象破坏一个对象历史状态的封装性，避免将对象历史状态的实现细节暴露给外界对象。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>备忘录模式在不破坏封装的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态，这样可以在以后将对象恢复到原先保存的状态。备忘录模式是一种对象行为型模式。</li><li>备忘录是一个很特殊的对象，只有原发器对它拥有控制的权力，负责人只负责管理，而其他类无法访问到备忘录，因此我们需要对备忘录进行封装。</li><li>为了实现对备忘录对象的封装，需要对备忘录的调用进行控制，对于原发器而言，它可以调用备忘录的所有信息，允许原发器访问返回到先前状态所需的所有数据；对于负责人而言，只负责备忘录的保存并将备忘录传递给其他对象；对于其他对象而言，只需要从负责人处取出备忘录对象并将原发器对象的状态恢复，而无须关心备忘录的保存细节。理想的情况是只允许生成该备忘录的那个原发器访问备忘录的内部状态。</li><li>备忘录模式提供了一种状态恢复的实现机制，使得用户可以方便地回到一个特定的历史步骤，当新的状态无效或者存在问题时，可以使用暂时存储起来的备忘录将状态复原。</li><li>备忘录实现了对信息的封装，一个备忘录对象是一种原发器对象状态的表示，不会被其他代码所改动。备忘录保存了原发器的状态，采用列表、堆栈等集合来存储备忘录对象可以实现多次撤销操作。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之观察者模式</title>
      <link href="/posts/2018/e39db608.html"/>
      <url>/posts/2018/e39db608.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>建立一种对象与对象之间的依赖关系，一个对象发生改变时将自动通知其他对象，其他对象将相应做出反应。在此，发生改变的对象称为观察目标，而被通知的对象称为观察者，一个观察目标可以对应多个观察者，而且这些观察者之间没有相互联系，可以根据需要增加和删除观察者，使得系统更易于扩展，这就是观察者模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>观察者模式(Observer Pattern)</code></strong>定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅(<code>Publish/Subscribe</code>)模式、模型-视图(<code>Model/View</code>)模式、源-监听器（<code>Source/Listener</code>）模式或从属者(<code>Dependents</code>)模式。</p><blockquote><p>观察者模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>观察者模式包含如下角色：</p><ul><li><strong><code>Subject(目标)：</code></strong>目标又称为主题，它是指被观察的对象。在目标中定义了一个观察者集合，一个观察目标可以接受任意数量的观察者来观察，它提供一系列方法来增加和删除观察者对象，同时它定义了通知方法 notify()。目标类可以是接口，也可以是抽象类或具体类。</li><li><strong><code>ConcreteSubject(具体目标)：</code></strong>具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；同时它还实现了在目标类中定义的抽象业务逻辑方法（如果有的话）。如果无须扩展目标类，则具体目标类可以省略。</li><li><strong><code>Observer(观察者)：</code></strong>观察者将对观察目标的改变做出反应，观察者一般定义为接口，该接口声明了更新数据的方法 update()，因此又称为抽象观察者。</li><li><strong><code>ConcreteObserver(具体观察者)：</code></strong>在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致；它实现了在抽象观察者 Observer 中定义的 update() 方法。通常在实现时，可以调用具体目标类的 attach() 方法将自己添加到目标类的集合中或通过 detach() 方法将自己从目标类的集合中删除。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/observer_uml.jpg" alt="观察者模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/observer_seq.jpg" alt="观察者模式时序图"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>首先，是观察者和具体观察者。Observer 接口充当观察者，ConcreteObserver 类充当具体观察者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 观察者接口 */</span><span class="token keyword">interface</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 更新的方法     */</span>    <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的观察者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteObserver</span> <span class="token keyword">implements</span> <span class="token class-name">Observer</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 实现更新方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"接收到信息，开始进行处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是被观察者和具体被观察者。Subject 抽象类充当被观察者，ConcreteSubject 类充当具体被观察者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 被观察者的抽象类 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个观察者的集合     */</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Observer<span class="token operator">></span> observers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Observer<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 增加一个观察者     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addObserver</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 删除一个观察者     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">deleteObserver</span><span class="token punctuation">(</span>Observer observer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>observers<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通知所有观察者     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 遍历观察者集合，通知每一个观察者更新</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Observer observer <span class="token operator">:</span> observers<span class="token punctuation">)</span> <span class="token punctuation">{</span>            observer<span class="token punctuation">.</span><span class="token function">update</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的被观察者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体的业务     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">notifyObservers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObserverClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ConcreteSubject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 创建一个被观察者</span>        Observer observer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteObserver</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 创建一个观察者</span>        subject<span class="token punctuation">.</span><span class="token function">addObserver</span><span class="token punctuation">(</span>observer<span class="token punctuation">)</span><span class="token punctuation">;</span>                     <span class="token comment" spellcheck="true">// 观察者观察被观察者</span>        subject<span class="token punctuation">.</span><span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                             <span class="token comment" spellcheck="true">// 观察者开始活动</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在有些更加复杂的情况下，具体观察者类 ConcreteObserver的update() 方法在执行时需要使用到具体目标类 ConcreteSubject中的状态（属性），因此在 ConcreteObserver 与 ConcreteSubject 之间有时候还存在关联或依赖关系，在 ConcreteObserver 中定义一个 ConcreteSubject 实例，通过该实例获取存储在 ConcreteSubject 中的状态。<br>如果 ConcreteObserver 的 update() 方法不需要使用到 ConcreteSubject 中的状态属性，则可以对观察者模式的标准结构进行简化，在具体观察者 ConcreteObserver 和具体目标 ConcreteSubject 之间无须维持对象引用。</p></blockquote><h2 id="JDK-中的观察者模式"><a href="#JDK-中的观察者模式" class="headerlink" title="JDK 中的观察者模式"></a>JDK 中的观察者模式</h2><p>观察者模式在 Java 语言中的地位非常重要。在 <code>JDK</code> 的 <code>java.util</code> 包中，提供了 <code>Observable</code> 类以及 <code>Observer</code> 接口，它们构成了 JDK 对观察者模式的支持。JDK 提供的 Observable 类及 Observer 接口结构图如下图所示：<br><img src="https://henleylee.github.io/medias/design_pattern/observer_jdk.jpg" alt="JDK提供的Observable类及Observer接口结构图"></p><h3 id="Observer-接口"><a href="#Observer-接口" class="headerlink" title="Observer 接口"></a>Observer 接口</h3><p>在 <code>java.util.Observer</code> 接口中只声明一个方法，它充当抽象观察者，其方法声明代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">void</span>  <span class="token function">update</span><span class="token punctuation">(</span>Observable o<span class="token punctuation">,</span> Object arg<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>当观察目标的状态发生变化时，该方法将会被调用，在 Observer 的子类中将实现 update() 方法，即具体观察者可以根据需要具有不同的更新行为。当调用观察目标类 Observable 的 notifyObservers() 方法时，将执行观察者类中的 update() 方法。</p><h3 id="Observable-类"><a href="#Observable-类" class="headerlink" title="Observable 类"></a>Observable 类</h3><p><code>java.util.Observable</code> 类充当观察目标类，在 Observable 中定义了一个向量 Vector 来存储观察者对象，它所包含的方法及说明见下表：</p><table><thead><tr><th>方法名</th><th>方法描述</th></tr></thead><tbody><tr><td>Observable()</td><td>构造方法，实例化 Vector 向量。</td></tr><tr><td>addObserver(Observer o)</td><td>用于注册新的观察者对象到向量中。</td></tr><tr><td>deleteObserver (Observer o)</td><td>用于删除向量中的某一个观察者对象。</td></tr><tr><td>notifyObservers()和notifyObservers(Object arg)</td><td>通知方法，用于在方法内部循环调用向量中每一个观察者的 update() 方法。</td></tr><tr><td>deleteObservers()</td><td>用于清空向量，即删除向量中所有观察者对象。</td></tr><tr><td>setChanged()</td><td>该方法被调用后会设置一个 boolean 类型的内部标记变量 changed 的值为 true，表示观察目标对象的状态发生了变化。</td></tr><tr><td>clearChanged()</td><td>用于将 changed 变量的值设为 false，表示对象状态不再发生改变或者已经通知了所有的观察者对象，调用了它们的 update() 方法。</td></tr><tr><td>hasChanged()</td><td>用于测试对象状态是否改变。</td></tr><tr><td>countObservers()</td><td>用于返回向量中观察者的数量。</td></tr></tbody></table><p>我们可以直接使用 Observer 接口和 Observable 类来作为观察者模式的抽象层，再自定义具体观察者类和具体观察目标类，通过使用 JDK 中的 Observer 接口和 Observable 类，可以更加方便地在 Java 语言中应用观察者模式。</p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>观察者模式描述了如何建立对象与对象之间的依赖关系，如何构造满足这种需求的系统。</li><li>这一模式中的关键对象是观察目标和观察者，一个目标可以有任意数目的与之相依赖的观察者，一旦目标的状态发生改变，所有的观察者都将得到通知。</li><li>作为对这个通知的响应，每个观察者都将即时更新自己的状态，以与目标状态同步，这种交互也称为<strong>发布-订阅</strong>(<code>publish-subscribe</code>)。目标是通知的发布者，它发出通知时并不需要知道谁是它的观察者，可以有任意数目的观察者订阅它并接收通。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>观察者模式的主要优点如下：</p><ul><li>观察者模式可以实现表示层和数据逻辑层的分离，并定义了稳定的消息更新传递机制，抽象了更新接口，使得可以有各种各样不同的表示层作为具体观察者角色。</li><li>观察者模式在观察目标和观察者之间建立一个抽象的耦合。</li><li>观察者模式支持广播通信。</li><li>观察者模式符合“开闭原则”的要求。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>观察者模式的主要缺点如下：</p><ul><li>如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间。</li><li>如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式没有相应的机制让观察者知道所观察的目标对象是怎么发生变化的，而仅仅只是知道观察目标发生了变化。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用观察者模式：</p><ul><li>一个抽象模型有两个方面，其中一个方面依赖于另一个方面。将这些方面封装在独立的对象中使它们可以各自独立地改变和复用。</li><li>一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变，可以降低对象之间的耦合度。</li><li>一个对象必须通知其他对象，而并不知道这些对象是谁。</li><li>需要在系统中创建一个触发链，A对象的行为将影响B对象，B对象的行为将影响C对象……，可以使用观察者模式创建一种链式触发机制。</li></ul><blockquote><p>观察者模式在软件开发中应用非常广泛，如某电子商务网站可以在执行发送操作后给用户多个发送商品打折信息，某团队战斗游戏中某队友牺牲将给所有成员提示等等，凡是涉及到一对一或者一对多的对象交互场景都可以使用观察者模式。</p></blockquote><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>观察者模式定义对象间的一种一对多依赖关系，使得每当一个对象状态发生改变时，其相关依赖对象皆得到通知并被自动更新。观察者模式又叫做发布-订阅模式、模型-视图模式、源-监听器模式或从属者模式。观察者模式是一种对象行为型模式。</li><li>观察者模式包含四个角色：目标又称为主题，它是指被观察的对象；具体目标是目标类的子类，通常它包含有经常发生改变的数据，当它的状态发生改变时，向它的各个观察者发出通知；观察者将对观察目标的改变做出反应；在具体观察者中维护一个指向具体目标对象的引用，它存储具体观察者的有关状态，这些状态需要和具体目标的状态保持一致。</li><li>观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个目标对象，当这个目标对象的状态发生变化时，会通知所有观察者对象，使它们能够自动更新。</li><li>观察者模式的主要优点在于可以实现表示层和数据逻辑层的分离，并在观察目标和观察者之间建立一个抽象的耦合，支持广播通信；其主要缺点在于如果一个观察目标对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间，而且如果在观察者和观察目标之间有循环依赖的话，观察目标会触发它们之间进行循环调用，可能导致系统崩溃。</li><li>观察者模式适用情况包括：一个抽象模型有两个方面，其中一个方面依赖于另一个方面；一个对象的改变将导致其他一个或多个对象也发生改变，而不知道具体有多少对象将发生改变；一个对象必须通知其他对象，而并不知道这些对象是谁；需要在系统中创建一个触发链。</li><li>在 JDK 的 <code>java.util</code> 包中，提供了 <code>Observable</code> 类以及 <code>Observer</code> 接口，它们构成了 Java 语言对观察者模式的支持。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之状态模式</title>
      <link href="/posts/2018/3f098e58.html"/>
      <url>/posts/2018/3f098e58.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对象的行为依赖于它的状态（属性），并且可以根据它的状态改变而改变它的相关行为。</p><p>在很多情况下，一个对象的行为取决于一个或多个动态变化的属性，这样的属性叫做状态，这样的对象叫做有状态的(<code>stateful</code>)对象，这样的对象状态是从事先定义好的一系列值中取出的。当一个这样的对象与外部事件产生互动时，其内部状态就会改变，从而使得系统的行为也随之发生变化。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>状态模式(State Pattern)</code></strong>允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象(<code>Objects for States</code>)。</p><blockquote><p>状态模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>状态模式包含如下角色：</p><ul><li><strong><code>Context(环境角色)</code></strong>环境类又称为上下文类，它是拥有多种状态的对象。由于环境类的状态存在多样性且在不同状态下对象的行为有所不同，因此将状态独立出去形成单独的状态类。在环境类中维护一个抽象状态类 State 的实例，这个实例定义当前状态，在具体实现时，它是一个 State 子类的对象。</li><li><strong><code>State(抽象状态角色)</code></strong>它用于定义一个接口以封装与环境类的一个特定状态相关的行为，在抽象状态类中声明了各种不同状态对应的方法，而在其子类中实现类这些方法，由于不同状态下对象的行为可能不同，因此在不同子类中方法的实现可能存在不同，相同的方法可以写在抽象状态类中。</li><li><strong><code>ConcreteState(具体状态角色)</code></strong>它是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li></ul><blockquote><p>在状态模式中，我们将对象在不同状态下的行为封装到不同的状态类中，为了让系统具有更好的灵活性和可扩展性，同时对各状态下的共有行为进行封装，我们需要对状态进行抽象。</p></blockquote><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/state_uml.jpg" alt="状态模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/state_seq.jpg" alt="状态模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象状态角色。State 抽象类充当抽象状态角色，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象状态角色 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 声明抽象业务方法，不同的具体状态类可以不同的实现     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>接下来，是具体状态角色。ConcreteStateA 和 ConcreteStateB 类充当具体状态角色，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类A */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStateA</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类A中的方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类A中的方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体状态角色类B */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteStateB</span> <span class="token keyword">extends</span> <span class="token class-name">State</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体状态角色类B中的方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行了具体状态角色类B中的方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在抽象状态类的子类即具体状态类中实现了在抽象状态类中声明的业务方法，不同的具体状态类可以提供完全不同的方法实现，在实际使用时，在一个状态类中可能包含多个业务方法，如果在具体状态类中某些业务方法的实现完全相同，可以将这些方法移至抽象状态类，实现代码的复用。</p></blockquote><p>然后，是环境类。Context 类充当环境类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 环境角色类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 当前状态 */</span>    <span class="token keyword">private</span> State state<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 设置状态对象     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setState</span><span class="token punctuation">(</span>State state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state <span class="token operator">=</span> state<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 其他代码</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>state<span class="token punctuation">.</span><span class="token function">handle</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 其他代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>环境类实际上是真正拥有状态的对象，我们只是将环境类中与状态有关的代码提取出来封装到专门的状态类中。在状态模式结构图中，环境类 Context 与抽象状态类 State 之间存在单向关联关系，在 Context 中定义了一个 State 对象。在实际使用时，它们之间可能存在更为复杂的关系，State 与 Context 之间可能也存在依赖或者关联关系。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StateClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ConcreteStateA stateA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteStateA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">setState</span><span class="token punctuation">(</span>stateA<span class="token punctuation">)</span><span class="token punctuation">;</span>        context<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>状态模式将一个对象在不同状态下的不同行为封装在一个个状态类中，通过设置不同的状态对象可以让环境对象拥有不同的行为，而状态转换的细节对于客户端而言是透明的，方便了客户端的使用。在实际开发中，状态模式具有较高的使用频率，在工作流和游戏开发中状态模式都得到了广泛的应用，例如公文状态的转换、游戏中角色的升级等。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>状态模式的主要优点如下：</p><ul><li>封装了状态的转换规则，在状态模式中可以将状态的转换代码封装在环境类或者具体状态类中，可以对状态转换代码进行集中管理，而不是分散在一个个业务方法中。</li><li>将所有与某个状态有关的行为放到一个类中，只需要注入一个不同的状态对象即可使环境对象拥有不同的行为。</li><li>允许状态转换逻辑与状态对象合成一体，而不是提供一个巨大的条件语句块，状态模式可以让我们避免使用庞大的条件语句来将业务方法和状态转换代码交织在一起。</li><li>可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>状态模式的主要缺点如下：</p><ul><li>状态模式的使用必然会增加系统中类和对象的个数，导致系统运行开销增大。</li><li>状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，增加系统设计的难度。</li><li>状态模式对“开闭原则”的支持并不太好，增加新的状态类需要修改那些负责状态转换的源代码，否则无法转换到新增状态；而且修改某个状态类的行为也需修改对应类的源代码。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用状态模式：</p><ul><li>对象的行为依赖于它的状态（如某些属性值），状态的改变将导致行为的变化。</li><li>在代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，并且导致客户类与类库之间的耦合增强。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>状态模式允许一个对象在其内部状态改变时改变它的行为，对象看起来似乎修改了它的类。其别名为状态对象，状态模式是一种对象行为型模式。</li><li>状态模式包含三个角色：环境类又称为上下文类，它是拥有状态的对象，在环境类中维护一个抽象状态类State的实例，这个实例定义当前状态，在具体实现时，它是一个State子类的对象，可以定义初始状态；抽象状态类用于定义一个接口以封装与环境类的一个特定状态相关的行为；具体状态类是抽象状态类的子类，每一个子类实现一个与环境类的一个状态相关的行为，每一个具体状态类对应环境的一个具体状态，不同的具体状态类其行为有所不同。</li><li>状态模式描述了对象状态的变化以及对象如何在每一种状态下表现出不同的行为。</li><li>状态模式的主要优点在于封装了转换规则，并枚举可能的状态，它将所有与某个状态有关的行为放到一个类中，并且可以方便地增加新的状态，只需要改变对象状态即可改变对象的行为，还可以让多个环境对象共享一个状态对象，从而减少系统中对象的个数；其缺点在于使用状态模式会增加系统类和对象的个数，且状态模式的结构与实现都较为复杂，如果使用不当将导致程序结构和代码的混乱，对于可以切换状态的状态模式不满足“开闭原则”的要求。</li><li>状态模式适用情况包括：对象的行为依赖于它的状态（属性）并且可以根据它的状态改变而改变它的相关行为；代码中包含大量与对象状态有关的条件语句，这些条件语句的出现，会导致代码的可维护性和灵活性变差，不能方便地增加和删除状态，使客户类与类库之间的耦合增强。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之策略模式</title>
      <link href="/posts/2018/c721215f.html"/>
      <url>/posts/2018/c721215f.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>完成一项任务，往往可以有多种不同的方式，每一种方式称为一个策略，我们可以根据环境或者条件的不同选择不同的策略来完成该项任务。在软件开发中也常常遇到类似的情况，实现某一个功能有多个途径，此时可以使用一种设计模式来使得系统可以灵活地选择解决途径，也能够方便地增加新的解决途径。</p><p>在软件系统中，有许多算法可以实现某一功能，如查找、排序等，一种常用的方法是硬编码(<code>Hard Coding</code>)在一个类中，如需要提供多种查找算法，可以将这些算法写到一个类中，在该类中提供多个方法，每一个方法对应一个具体的查找算法；当然也可以将这些查找算法封装在一个统一的方法中，通过 if…else… 等条件判断语句来进行选择。这两种实现方法我们都可以称之为硬编码，如果需要增加一种新的查找算法，需要修改封装算法类的源代码；更换查找算法，也需要修改客户端调用代码。在这个算法类中封装了大量查找算法，该类代码将较复杂，维护较为困难。</p><p>除了提供专门的查找算法类之外，还可以在客户端程序中直接包含算法代码，这种做法更不可取，将导致客户端程序庞大而且难以维护，如果存在大量可供选择的算法时问题将变得更加严重。</p><p>为了解决这些问题，可以定义一些独立的类来封装不同的算法，每一个类封装一个具体的算法，在这里，每一个封装算法的类我们都可以称之为<code>策略(Strategy)</code>，为了保证这些策略的一致性，一般会用一个抽象的策略类来做算法的定义，而具体每种算法则对应于一个具体策略类。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>策略模式(Strategy Pattern)</code></strong>定义一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式(Policy)。</p><blockquote><p>策略模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>策略模式包含如下角色：</p><ul><li><strong><code>Context(环境类)：</code></strong>环境类是使用算法的角色，它在解决某个问题（即实现某个方法）时可以采用多种策略。在环境类中维持一个对抽象策略类的引用实例，用于定义所采用的策略。</li><li><strong><code>Strategy(抽象策略类)：</code></strong>它为所支持的算法声明了抽象方法，是所有策略类的父类，它可以是抽象类或具体类，也可以是接口。环境类通过抽象策略类中声明的方法在运行时调用具体策略类中实现的算法。</li><li><strong><code>ConcreteStrategy(具体策略类)：</code></strong>它实现了在抽象策略类中声明的算法，在运行时，具体策略类将覆盖在环境类中定义的抽象策略类对象，使用一种具体的算法实现某个业务处理。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/strategy_uml.jpg" alt="策略模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/strategy_seq.jpg" alt="策略模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象策略类。AbstractStrategy 抽象类充当抽象策略类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 声明抽象算法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其次，是具体策略类。ConcreteStrategyA 和 ConcreteStrategyB 充当具体策略类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteStrategyA</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 策略的具体实现     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 算法 A 的具体实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">ConcreteStrategyB</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractStrategy</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 策略的具体实现     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 算法 B 的具体实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是环境类。Context 充当环境类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Context</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 维持一个对抽象策略类的引用 */</span>    <span class="token keyword">private</span> AbstractStrategy strategy<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setStrategy</span><span class="token punctuation">(</span>AbstractStrategy strategy<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>strategy <span class="token operator">=</span> strategy<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 调用策略类中的策略实现     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        strategy<span class="token punctuation">.</span><span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StrategyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractStrategy strategy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteStrategyA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明一个具体的策略</span>        Context context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 声明环境类</span>        context<span class="token punctuation">.</span><span class="token function">setStrategy</span><span class="token punctuation">(</span>strategy<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 设置一个策略</span>        context<span class="token punctuation">.</span><span class="token function">algorithm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用策略类中的策略实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在客户端代码中只需注入一个具体策略对象，可以将具体策略类类名存储在配置文件中，通过反射来动态创建具体策略对象，从而使得用户可以灵活地更换具体策略类，增加新的具体策略类也很方便。策略模式提供了一种<code>可插入式(Pluggable)算法</code>的实现方案。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>策略模式是一个比较容易理解和使用的设计模式，策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。用一句话来说，就是“准备一组算法，并将每一个算法封装起来，使得它们可以互换”。</li><li>在策略模式中，应当由客户端自己决定在什么情况下使用什么具体策略角色。</li><li>策略模式仅仅封装算法，提供新算法插入到已有系统中，以及老算法从系统中“退休”的方便，策略模式并不决定在何时使用何种算法，算法的选择由客户端来决定。这在一定程度上提高了系统的灵活性，但是客户端需要理解所有具体策略类之间的区别，以便选择合适的算法，这也是策略模式的缺点之一，在一定程度上增加了客户端的使用难度。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>策略模式的主要优点如下：</p><ul><li>策略模式提供了对“开闭原则”的完美支持，用户可以在不修改原有系统的基- 础上选择算法或行为，也可以灵活地增加新的算法或行为。</li><li>策略模式提供了管理相关的算法族的办法。</li><li>策略模式提供了可以替换继承关系的办法。</li><li>使用策略模式可以避免使用多重条件转移语句。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>策略模式的主要缺点如下：</p><ul><li>客户端必须知道所有的策略类，并自行决定使用哪一个策略类。</li><li>策略模式将造成产生很多策略类，可以通过使用享元模式在一定程度上减少对象的数量。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用策略模式：</p><ul><li>如果在一个系统里面有许多类，它们之间的区别仅在于它们的行为，那么使用策略模式可以动态地让一个对象在许多行为中选择一种行为。</li><li>一个系统需要动态地在几种算法中选择一种。</li><li>如果一个对象有很多的行为，如果不用恰当的模式，这些行为就只好使用多重的条件选择语句来实现。</li><li>不希望客户端知道复杂的、与算法相关的数据结构，在具体策略类中封装算法和相关的数据结构，提高算法的保密性与安全性。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>策略模式与状态模式：</p><ul><li>可以通过环境类状态的个数来决定是使用策略模式还是状态模式。</li><li>策略模式的环境类自己选择一个具体策略类，具体策略类无须关心环境类；而状态模式的环境类由于外在因素需要放进一个具体状态中，以便通过其方法实现状态的切换，因此环境类和状态类之间存在一种双向的关联关系。</li><li>使用策略模式时，客户端需要知道所选的具体策略是哪一个，而使用状态模式时，客户端无须关心具体状态，环境类的状态会根据用户的操作自动转换。</li><li>如果系统中某个类的对象存在多种状态，不同状态下行为有差异，而且这些状态之间可以发生转换时使用状态模式；如果系统中某个类的某一行为存在多种实现方式，而且这些实现方式可以互换时使用策略模式。</li></ul><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>在策略模式中定义了一系列算法，将每一个算法封装起来，并让它们可以相互替换。策略模式让算法独立于使用它的客户而变化，也称为政策模式。策略模式是一种对象行为型模式。</li><li>策略模式包含三个角色：环境类在解决某个问题时可以采用多种策略，在环境类中维护一个对抽象策略类的引用实例；抽象策略类为所支持的算法声明了抽象方法，是所有策略类的父类；具体策略类实现了在抽象策略类中定义的算法。</li><li>策略模式是对算法的封装，它把算法的责任和算法本身分割开，委派给不同的对象管理。策略模式通常把一个系列的算法封装到一系列的策略类里面，作为一个抽象策略类的子类。</li><li>策略模式主要优点在于对“开闭原则”的完美支持，在不修改原有系统的基础上可以更换算法或者增加新的算法，它很好地管理算法族，提高了代码的复用性，是一种替换继承，避免多重条件转移语句的实现方式；其缺点在于客户端必须知道所有的策略类，并理解其区别，同时在一定程度上增加了系统中类的个数，可能会存在很多策略类。</li><li>策略模式适用情况包括：在一个系统里面有许多类，它们之间的区别仅在于它们的行为，使用策略模式可以动态地让一个对象在许多行为中选择一种行为；一个系统需要动态地在几种算法中选择一种；避免使用难以维护的多重条件选择语句；希望在具体策略类中封装算法和与相关的数据结构。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之模板模式</title>
      <link href="/posts/2018/a0cc9445.html"/>
      <url>/posts/2018/a0cc9445.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在软件开发中，有时也会遇到类似的情况，某个方法的实现需要多个步骤（类似“请客”），其中有些步骤是固定的（类似“点单”和“买单”），而有些步骤并不固定，存在可变性（类似“吃东西”）。为了提高代码的复用性和系统的灵活性，可以使用一种称之为模板方法模式的设计模式来对这类情况进行设计，在模板方法模式中，将实现功能的每一个步骤所对应的方法称为基本方法（例如“点单”、“吃东西”和“买单”），而调用这些基本方法同时定义基本方法的执行次序的方法称为模板方法（例如“请客”）。</p><p>在模板方法模式中，可以将相同的代码放在父类中，例如将模板方法“请客”以及基本方法“点单”和“买单”的实现放在父类中，而对于基本方法“吃东西”，在父类中只做一个声明，将其具体实现放在不同的子类中，在一个子类中提供“吃面条”的实现，而另一个子类提供“吃满汉全席”的实现。通过使用模板方法模式，一方面提高了代码的复用性，另一方面还可以利用面向对象的多态性，在运行时选择一种具体子类，实现完整的“请客”方法，提高系统的灵活性和可扩展性。这就是模板模式的动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>模板模式(Template Pattern)</code></strong>定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板方法模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板模式又称为模板方法模式</p><blockquote><p>模板模式是一种基于继承的代码复用技术，它是一种<strong><code>类行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><p>模板模式包含如下角色：</p><ul><li><strong><code>AbstractClass(抽象类)：</code></strong>在抽象类中定义了一系列基本操作(PrimitiveOperations)，这些基本操作可以是具体的，也可以是抽象的，每一个基本操作对应算法的一个步骤，在其子类中可以重定义或实现这些步骤。同时，在抽象类中实现了一个模板方法(Template Method)，用于定义一个算法的框架，模板方法不仅可以调用在抽象类中实现的基本方法，也可以调用在抽象类的子类中实现的基本方法，还可以调用其他对象中的方法。</li><li><strong><code>ConcreteClass(具体子类)：</code></strong>它是抽象类的子类，用于实现在父类中声明的抽象基本操作以完成子类特定算法的步骤，也可以覆盖在父类中已经实现的具体基本操作。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/template_uml.jpg" alt="模板模式结构图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>在实现模板方法模式时，开发抽象类的软件设计师和开发具体子类的软件设计师之间可以进行协作。一个设计师负责给出一个算法的轮廓和框架，另一些设计师则负责给出这个算法的各个逻辑步骤。实现这些具体逻辑步骤的方法即为基本方法，而将这些基本方法汇总起来的方法即为模板方法，模板方法模式的名字也因此而来。下面将详细介绍模板方法和基本方法：</p><h3 id="模板方法"><a href="#模板方法" class="headerlink" title="模板方法"></a>模板方法</h3><p>一个模板方法是定义在抽象类中的、把基本操作方法组合在一起形成一个总算法或一个总行为的方法。这个模板方法定义在抽象类中，并由子类不加以修改地完全继承下来。模板方法是一个具体方法，它给出了一个顶层逻辑框架，而逻辑的组成步骤在抽象类中可以是具体方法，也可以是抽象方法。由于模板方法是具体方法，因此模板方法模式中的抽象层只能是抽象类，而不是接口。</p><h3 id="基本方法"><a href="#基本方法" class="headerlink" title="基本方法"></a>基本方法</h3><p>基本方法是实现算法各个步骤的方法，是模板方法的组成部分。基本方法又可以分为三种：抽象方法(Abstract Method)、具体方法(Concrete Method)和钩子方法(Hook Method)。</p><ul><li>抽象方法：一个抽象方法由抽象类声明、由其具体子类实现。在 Java 和 C# 语言里一个抽象方法以 abstract 关键字标识。</li><li>具体方法：一个具体方法由一个抽象类或具体类声明并实现，其子类可以进行覆盖也可以直接继承。</li><li>钩子方法：一个钩子方法由一个抽象类或具体类声明并实现，而其子类可能会加以扩展。通常在父类中给出的实现是一个空实现，并以该空实现作为方法的默认实现，当然钩子方法也可以提供一个非空的默认实现。</li></ul><h3 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h3><p>首先，是抽象类。AbstractClass 抽象类充当抽象类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象类 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractClass</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 模板方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">primitiveOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">primitiveOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">primitiveOperation3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法-具体方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">primitiveOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 具体实现代码</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 基本方法-抽象方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">primitiveOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 基本方法-钩子方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">primitiveOperation3</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是具体子类。ConcreteClass 充当具体子类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体子类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteClass</span> <span class="token keyword">extends</span> <span class="token class-name">AbstractClass</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">primitiveOperation1</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 具体实现代码</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">primitiveOperation2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 具体实现代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">TemplateClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        AbstractClass abstractClass <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        abstractClass<span class="token punctuation">.</span><span class="token function">templateMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>模板模式的关键是：子类可以置换掉父类的可变部分，但是子类却不可以改变模板方法所代表的顶级逻辑。<br>每当定义一个新的子类时，不要按照控制流程的思路去想，而应当按照“责任”的思路去想。换言之，应当考虑哪些操作是必须置换掉的，哪些操作是可以置换掉的，以及哪些操作是不可以置换掉的。使用模板模式可以使这些责任变得清晰。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="总体分析"><a href="#总体分析" class="headerlink" title="总体分析"></a>总体分析</h3><ul><li>模板模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板方法模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。模板方法模式提供了一个模板方法来定义算法框架，而某些具体步骤的实现可以在其子类中完成。</li><li>模板模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板方法模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序（如框架的初始化，测试流程的设置等）。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>模板模式的主要优点如下：</p><ul><li>在父类中形式化地定义一个算法，而由它的子类来实现细节的处理，在子类实现详细的处理算法时并不会改变算法中步骤的执行次序。</li><li>模板方法模式是一种代码复用技术，它在类库设计中尤为重要，它提取了类库中的公共行为，将公共行为放在父类中，而通过其子类来实现不同的行为，它鼓励我们恰当使用继承来实现代码复用。</li><li>可实现一种反向控制结构，通过子类覆盖父类的钩子方法来决定某一特定步骤是否需要执行。</li><li>在模板方法模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>模板模式的主要缺点如下：</p><ul><li>需要为每一个基本方法的不同实现提供一个子类，如果父类中可变的基本方法太多，将会导致类的个数增加，系统更加庞大，设计也更加抽象，此时，可结合桥接模式来进行设计。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用模板模式：</p><ul><li>对一些复杂的算法进行分割，将其算法中固定不变的部分设计为模板方法和父类具体方法，而一些可以改变的细节由其子类来实现。即：一次性实现一个算法的不变部分，并将可变的行为留给子类来实现。</li><li>各子类中公共的行为应被提取出来并集中到一个公共父类中以避免代码重复。</li><li>需要通过子类来决定父类算法中某个步骤是否执行，实现子类对父类的反向控制。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>模板模式与策略模式：</p><ul><li>模板方法的意图：定义一个算法流程，将一些特定步骤的具体实现、延迟到子类。使得可以在不改变算法流程的情况下，通过不同的子类、来实现“定制”流程中的特定的步骤。</li><li>策略模式的意图：使不同的算法可以被相互替换，而不影响客户端的使用。</li></ul><p>在意图上看，模板方法更加强调：</p><ul><li>定义一条线（算法流程），线上的多个点是可以变化的（具体实现在子类中完成），线上的多个点一定是会被执行的，并且一定是按照特定流程被执行的。</li><li>算法流程只有唯一的入口，对于点的访问是受限的(通常用受保护的虚函数来定义可变点)。</li></ul><p>策略模式更注重于：一个“策略”是一个整体的(完整的)算法，算法是可以被整体替换的。而模板方法只能被替换其中的特定点，算法流程是固定不可变的。</p><p>在这样的细节上看来，模板方法和一组策略模式是不可以划等号的。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>模板模式定义一个操作中算法的框架，而将一些步骤延迟到子类中。模板模式使得子类可以不改变一个算法的结构即可重定义该算法的某些特定步骤。模板模式是一种类行为型模式</li><li>模板模式是结构最简单的行为型设计模式，在其结构中只存在父类与子类之间的继承关系。通过使用模板模式，可以将一些复杂流程的实现步骤封装在一系列基本方法中，在抽象父类中提供一个称之为模板方法的方法来定义这些基本方法的执行次序，而通过其子类来覆盖某些步骤，从而使得相同的算法框架可以有不同的执行结果。。</li><li>模板模式是基于继承的代码复用技术，它体现了面向对象的诸多重要思想，是一种使用较为频繁的模式。模板模式广泛应用于框架设计中，以确保通过父类来控制处理流程的逻辑顺序。</li><li>模板模式中可以通过子类来覆盖父类的基本方法，不同的子类可以提供基本方法的不同实现，更换和增加新的子类很方便，符合单一职责原则和开闭原则。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之访问者模式</title>
      <link href="/posts/2018/1d0ccac7.html"/>
      <url>/posts/2018/1d0ccac7.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>访问者模式的目的是封装一些施加于某种数据结构元素之上的操作，一旦这些操作需要修改的话，接受这个操作的数据结构可以保持不变。为不同类型的元素提供多种访问操作方式，且可以在不修改原有系统的情况下增加新的操作方式，这就是访问者模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>访问者模式(Visitor Pattern)</code></strong>提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。</p><blockquote><p>访问者模式是一种<strong><code>对象行为型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>访问者模式包含如下角色：</p><ul><li><strong><code>Vistor(抽象访问者)：</code></strong>抽象访问者为对象结构中每一个具体元素类 ConcreteElement 声明一个访问操作，从这个操作的名称或参数类型可以清楚知道需要访问的具体元素的类型，具体访问者需要实现这些操作方法，定义对这些元素的访问操作。</li><li><strong><code>ConcreteVisitor(具体访问者)：</code></strong>具体访问者实现了每个由抽象访问者声明的操作，每一个操作用于访问对象结构中一种类型的元素。</li><li><strong><code>Element(抽象元素)：</code></strong>抽象元素一般是抽象类或者接口，它定义一个 accept() 方法，该方法通常以一个抽象访问者作为参数。</li><li><strong><code>ConcreteElement(具体元素)：</code></strong>具体元素实现了 accept() 方法，在 accept()方法中调用访问者的访问方法以便完成对一个元素的操作。</li><li><strong><code>ObjectStructure(对象结构)：</code></strong>对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。它可以结合组合模式来实现，也可以是一个简单的集合对象，如一个 List 对象或一个 Set 对象。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/visitor_uml.jpg" alt="访问者模式结构图"></p><h2 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h2><p>首先，是抽象访问者和具体访问者。Visitor 抽象类充当抽象访问者，ConcreteVisitor 类充当具体访问者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象访问者 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementA elementA<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementB elementB<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>在访问者模式中，抽象访问者定义了访问元素对象的方法，通常为每一种类型的元素对象都提供一个访问方法，而具体访问者可以实现这些访问方法。这些访问方法的命名一般有两种方式：一种是直接在方法名中标明待访问元素对象的具体类型，如 visitElementA(ElementA elementA)，还有一种是统一取名为 visit()，通过参数类型的不同来定义一系列重载的 visit()方法。当然，如果所有的访问者对某一类型的元素的访问操作都相同，则可以将操作代码移到抽象访问者类中。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体访问者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteVisitor</span> <span class="token keyword">extends</span> <span class="token class-name">Visitor</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementA elementA<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"元素ConcreteElementA的业务逻辑...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">visit</span><span class="token punctuation">(</span>ConcreteElementB elementB<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"元素ConcreteElementB的业务逻辑...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在这里使用了重载 visit() 方法的方式来定义多个方法用于操作不同类型的元素对象。在抽象访问者 Visitor 类的子类 ConcreteVisitor 中实现了抽象的访问方法，用于定义对不同类型元素对象的操作。</p></blockquote><p>其次，是抽象元素和具体元素。Element 接口充当抽象访问者，ConcreteElementA 和 ConcreteElementB 类充当具体访问者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象元素 */</span><span class="token keyword">interface</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>对于元素类而言，在其中一般都定义了一个 accept()方法，用于接受访问者的访问。需要注意的是该方法传入了一个抽象访问者 Visitor 类型的参数，即针对抽象访问者进行编程，而不是具体访问者，在程序运行时再确定具体访问者的类型，并调用具体访问者对象的 visit() 方法实现对元素对象的操作。</p></blockquote><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体元素A */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteElementA</span> <span class="token keyword">implements</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"元素ConcreteElementA的业务逻辑...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体元素B */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteElementB</span> <span class="token keyword">implements</span> <span class="token class-name">Element</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">accept</span><span class="token punctuation">(</span>Visitor visitor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        visitor<span class="token punctuation">.</span><span class="token function">visit</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"元素ConcreteElementB的业务逻辑...."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在抽象元素类Element的子类中实现了accept()方法，用于接受访问者的访问，在具体元素类中还可以定义不同类型的元素所特有的业务方法。</p></blockquote><p>然后，是对象结构。ObjectStructure 类充当对象结构，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ObjectStructure</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> List<span class="token operator">&lt;</span>Element<span class="token operator">></span> elements <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Element<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span>Visitor vistor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Element element <span class="token operator">:</span> elements<span class="token punctuation">)</span> <span class="token punctuation">{</span>            element<span class="token punctuation">.</span><span class="token function">accept</span><span class="token punctuation">(</span>vistor<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Element node<span class="token punctuation">)</span> <span class="token punctuation">{</span>        elements<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>对象结构是一个元素的集合，它用于存放元素对象，并且提供了遍历其内部元素的方法。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">VisitorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        ObjectStructure structure <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ObjectStructure</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        structure<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteElementA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        structure<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ConcreteElementB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Visitor visitor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteVisitor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        structure<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span>visitor<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构：</p><ul><li>一个是访问者层次结构，提供了抽象访问者和具体访问者。</li><li>一个是元素层次结构，提供了抽象元素和具体元素。</li></ul><p>相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。在访问者模式中，增加新的访问者无须修改原有系统，系统具有较好的可扩展性。</p><p>由于访问者模式的使用条件较为苛刻，本身结构也较为复杂，因此在实际应用中使用频率不是特别高。当系统中存在一个较为复杂的对象结构，且不同访问者对其所采取的操作也不相同时，可以考虑使用访问者模式进行设计。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>访问者模式的主要优点如下：</p><ul><li>增加新的访问操作很方便。使用访问者模式，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。</li><li>将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。</li><li>让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>访问者模式的主要缺点如下：</p><ul><li>增加新的元素类很困难。在访问者模式中，每增加一个新的元素类都意味着要在抽象访问者角色中增加一个新的抽象操作，并在每一个具体访问者类中增加相应的具体操作，这违背了“开闭原则”的要求。</li><li>破坏封装。访问者模式要求访问者对象访问并调用每一个元素对象的操作，这意味着元素对象有时候必须暴露一些自己的内部操作和内部状态，否则无法供访问者访问。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用访问者模式：</p><ul><li>一个对象结构包含多个类型的对象，希望对这些对象实施一些依赖其具体类型的操作。在访问者中针对每一种具体的类型都提供了一个访问操作，不同类型的对象可以有不同的访问操作。</li><li>需要对一个对象结构中的对象进行很多不同的并且不相关的操作，而需要避免让这些操作“污染”这些对象的类，也不希望在增加新操作时修改这些类。访问者模式使得我们可以将相关的访问操作集中起来定义在访问者类中，对象结构可以被多个不同的访问者类所使用，将对象本身与对象的访问操作分离。</li><li>对象结构中对象对应的类很少改变，但经常需要在此对象结构上定义新的操作。</li></ul><h3 id="模式拓展"><a href="#模式拓展" class="headerlink" title="模式拓展"></a>模式拓展</h3><p>访问者模式与组合模式联用：在访问者模式中，包含一个用于存储元素对象集合的对象结构，我们通常可以使用迭代器来遍历对象结构，同时具体元素之间可以存在整体与部分关系，有些元素作为容器对象，有些元素作为成员对象，可以使用组合模式来组织元素。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li>访问者模式提供一个作用于某对象结构中的各元素的操作表示，它使我们可以在不改变各元素的类的前提下定义作用于这些元素的新操作。访问者模式是一种对象行为型模式。</li><li>访问者模式中对象结构存储了不同类型的元素对象，以供不同访问者访问。访问者模式包括两个层次结构，一个是访问者层次结构，提供了抽象访问者和具体访问者，一个是元素层次结构，提供了抽象元素和具体元素。相同的访问者可以以不同的方式访问不同的元素，相同的元素可以接受不同访问者以不同访问方式访问。</li><li>访问者模式中，增加新的访问操作就意味着增加一个新的具体访问者类，实现简单，无须修改源代码，符合“开闭原则”。</li><li>访问者模式将有关元素对象的访问行为集中到一个访问者对象中，而不是分散在一个个的元素类中。类的职责更加清晰，有利于对象结构中元素对象的复用，相同的对象结构可以供多个不同的访问者访问。</li><li>访问者模式让用户能够在不修改现有元素类层次结构的情况下，定义作用于该层次结构的操作。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之代理模式</title>
      <link href="/posts/2018/ce93993e.html"/>
      <url>/posts/2018/ce93993e.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在某些情况下，一个客户不想或者不能直接引用一个对象，此时可以通过一个称之为“代理”的第三者来实现间接引用。代理对象可以在客户端和目标对象之间起到中介的作用，并且可以通过代理对象去掉客户不能看到 的内容和服务或者添加客户需要的额外服务。</p><p>通过引入一个新的对象来实现对真实对象的操作或者将新的对象作为真实对象的一个替身，这种实现机制即为代理模式，通过引入代理对象来间接访问一个对象，这就是代理模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>代理模式(Proxy Pattern)</code></strong>给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做 <code>Proxy</code> 或 <code>Surrogate</code>。</p><p>在代理模式中引入了一个新的代理对象，代理对象在客户端对象和目标对象之间起到中介的作用，它去掉客户不能看到的内容和服务或者增添客户需要的额外的新服务。</p><blockquote><p>代理模式是一种<strong><code>对象结构型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>代理模式包含如下角色：</p><ul><li><strong><code>Subject(抽象主题)</code></strong>它声明了真实主题和代理主题的共同接口，这样一来在任何使用真实主题的地方都可以使用代理主题，客户端通常需要针对抽象主题角色进行编程。</li><li><strong><code>RealSubject(真实主题)</code></strong>它定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的操作。</li><li><strong><code>Proxy(代理主题)</code></strong>它包含了对真实主题的引用，从而可以在任何时候操作真实主题对象；在代理主题角色中提供一个与真实主题角色相同的接口，以便在任何时候都可以替代真实主题；代理主题角色还可以控制对真实主题的使用，负责在需要的时候创建和删除真实主题对象，并对真实主题对象的使用加以约束。通常，在代理主题角色中，客户端在调用所引用的真实主题操作之前或之后还需要执行其他操作，而不仅仅是单纯调用真实主题对象中的操作。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/proxy_uml.jpg" alt="代理模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/proxy_seq.jpg" alt="代理模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象主题和真实主题。Subject 抽象类充当抽象主题，RealSubject 类充当真实主题，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象主题 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 真实主题 */</span><span class="token keyword">class</span> <span class="token class-name">RealSubject</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 业务方法具体实现代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是代理主题。Proxy 类充当代理主题，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Proxy</span> <span class="token keyword">extends</span> <span class="token class-name">Subject</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Subject subject<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Proxy</span><span class="token punctuation">(</span>Subject subject<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject <span class="token operator">=</span> subject<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">preRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>subject<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">afterRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 预处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">preRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行前(before)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 善后处理     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">afterRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"执行后(after)的处理..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ProxyClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Subject subject <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RealSubject</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Proxy proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>        proxy<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h2><p>在实际开发过程中，代理类的实现比上述代码要复杂很多，代理模式根据其目的和实现方式不同可分为很多种类，其中常用的几种代理模式简要说明如下：</p><ul><li><strong><code>远程代理(Remote Proxy)：</code></strong>为一个位于不同的地址空间的对象提供一个本地的代理对象，这个不同的地址空间可以是在同一台主机中，也可是在另一台主机中，远程代理又称为大使(Ambassador)。</li><li><strong><code>虚拟代理(Virtual Proxy)：</code></strong>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建。</li><li><strong><code>保护代理(Protect Proxy)：</code></strong>控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li><li><strong><code>缓冲代理(Cache Proxy)：</code></strong>为某一个目标操作的结果提供临时的存储空间，以便多个客户端可以共享这些结果。</li><li><strong><code>智能引用代理(Smart Reference Proxy)：</code></strong>当一个对象被引用时，提供一些额外的操作，例如将对象被调用的次数记录下来等。</li></ul><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>代理模式的主要优点如下：</p><ul><li>能够协调调用者和被调用者，在一定程度上降低了系统的耦合度。</li><li>客户端可以针对抽象主题角色进行编程，增加和更换代理类无须修改源代码，符合开闭原则，系统具有较好的灵活性和可扩展性。</li></ul><p>此外，不同类型的代理模式也具有独特的优点，例如：</p><ul><li>远程代理为位于两个不同地址空间对象的访问提供了一种实现机制，可以将一些消耗资源较多的对象和操作移至性能更好的计算机上，提高系统的整体运行效率。</li><li>虚拟代理通过一个消耗资源较少的对象来代表一个消耗资源较多的对象，可以在一定程度上节省系统的运行开销。</li><li>缓冲代理为某一个操作的结果提供临时的缓存存储空间，以便在后续使用中能够共享这些结果，优化系统性能，缩短执行时间。</li><li>保护代理可以控制对一个对象的访问权限，为不同用户提供不同级别的使用权限。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>代理模式的的主要缺点如下：</p><ul><li>由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，例如保护代理。</li><li>实现代理模式需要额外的工作，而且有些代理模式的实现过程较为复杂，例如远程代理。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>代理模式的类型较多，不同类型的代理模式有不同的优缺点，它们应用于不同的场合：</p><ul><li>当客户端对象需要访问远程主机中的对象时可以使用远程代理。</li><li>当需要用一个消耗资源较少的对象来代表一个消耗资源较多的对象，从而降低系统开销、缩短运行时间时可以使用虚拟代理，例如一个对象需要很长时间才能完成加载时。</li><li>当需要为某一个被频繁访问的操作结果提供一个临时存储空间，以供多个客户端共享访问这些结果时可以使用缓冲代理。通过使用缓冲代理，系统无须在客户端每一次访问时都重新执行操作，只需直接从临时缓冲区获取操作结果即可。</li><li>当需要控制对一个对象的访问，为不同用户提供不同级别的访问权限时可以使用保护代理。</li><li>当需要为一个对象的访问（引用）提供一些额外的操作时可以使用智能引用代理。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在代理模式中，要求给某一个对象提供一个代理，并由代理对象控制对原对象的引用。代理模式的英文叫做 Proxy 或 Surrogate，它是一种对象结构型模式。</li><li>代理模式包含三个角色：抽象主题角色声明了真实主题和代理主题的共同接口；代理主题角色内部包含对真实主题的引用，从而可以在任何时候操作真实主题对象；真实主题角色定义了代理角色所代表的真实对象，在真实主题角色中实现了真实的业务操作，客户端可以通过代理主题角色间接调用真实主题角色中定义的方法。</li><li>代理模式的优点在于能够协调调用者和被调用者，在一定程度上降低了系统的耦合度；其缺点在于由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢，并且实现代理模式需要额外的工作，有些代理模式的实现非常复杂。远程代理为一个位于不同的地址空间的对象提供一个本地的代表对象，它使得客户端可以访问在远程机器上的对象，远程机器可能具有更好的计算性能与处理速度，可以快速响应并处理客户端请求。</li><li>如果需要创建一个资源消耗较大的对象，先创建一个消耗相对较小的对象来表示，真实对象只在需要时才会被真正创建，这个小对象称为虚拟代理。虚拟代理通过使用一个小对象来代表一个大对象，可以减少系统资源的消耗，对系统进行优化并提高运行速度。</li><li>保护代理可以控制对一个对象的访问，可以给不同的用户提供不同级别的使用权限。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之享元模式</title>
      <link href="/posts/2018/545f3e64.html"/>
      <url>/posts/2018/545f3e64.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>面向对象技术可以很好地解决一些灵活性或可扩展性问题，但在很多情况下需要在系统中增加类和对象的个数。当对象数量太多时，将导致运行代价过高，带来性能下降等问题。享元模式通过共享技术实现相同或相似对象的重用提高系统资源的利用率。本文首先阐述了享元模式要解决的问题和解决问题的理念，然后从实现角度重点说明了该模式的本质，并进一步给出了其所包含的角色和组织结构。最后，给出了共享模式的应用实例和使用场景。这就是享元模式的动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>享元模式(Flyweight Pattern)</code></strong>运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用。由于享元模式要求能够共享的对象必须是细粒度对象，因此它又称为轻量级模式。</p><blockquote><p>享元模式是一种<strong><code>对象结构型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>享元模式包含如下角色：</p><ul><li><strong><code>Flyweight(抽象享元类)：</code></strong>通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）。</li><li><strong><code>ConcreteFlyweight(具体享元类)：</code></strong>它实现了抽象享元类，其实例称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象。</li><li><strong><code>UnsharedConcreteFlyweight(非共享具体享元类)：</code></strong>并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建。</li><li><strong><code>FlyweightFactory(享元工厂类)：</code></strong>享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中，享元池一般设计为一个存储“键值对”的集合（也可以是其他类型的集合），可以结合工厂模式进行设计；当用户请求一个具体享元对象时，享元工厂提供一个存储在享元池中已创建的实例或者创建一个新的实例（如果不存在的话），返回新创建的实例并将其存储在享元池中。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/flyweight_uml.jpg" alt="享元模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/flyweight_seq.jpg" alt="享元模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>标准的享元模式结构图中既包含可以共享的具体享元类，也包含不可以共享的非共享具体享元类。但是在实际使用过程中，我们有时候会用到两种特殊的享元模式：单纯享元模式和复合享元模式。</p><h3 id="单纯享元模式"><a href="#单纯享元模式" class="headerlink" title="单纯享元模式"></a>单纯享元模式</h3><p>首先，是抽象享元类和具体享元类。Flyweight 接口充当抽象享元类，ConcreteFlyweight 类充当具体享元类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象享元类 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 示意性方法，参数state是外蕴状态     */</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体享元类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的 */</span>    <span class="token keyword">private</span> String intrinsicState<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数，内蕴状态作为参数传入     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteFlyweight</span><span class="token punctuation">(</span>String intrinsicState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState <span class="token operator">=</span> intrinsicState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 外蕴状态作为参数传入方法中，改变方法的行为，但是并不改变对象的内蕴状态。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>String extrinsicState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Intrinsic State = "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Extrinsic State = "</span> <span class="token operator">+</span> extrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是享元工厂类。Abstraction 类充当享元工厂类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 享元工厂类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义一个HashMap用于存储享元对象，实现享元池     */</span>    <span class="token keyword">private</span> HashMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Flyweight<span class="token operator">></span> flyweights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Flyweight<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> Flyweight <span class="token function">getFlyweight</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果对象存在，则直接从享元池获取</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flyweights<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> flyweights<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span>        Flyweight flyweight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把这个新的Flyweight对象添加到缓存中</span>        flyweights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> flyweight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> flyweight<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        FlyweightFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight flyweight <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flyweight<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"First Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flyweight <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flyweight<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"Second Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flyweight <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        flyweight<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"Third Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在单纯享元模式中，所有的具体享元类都是可以共享的，即所有抽象享元类的子类都可共享，不存在非共享具体享元类。</p></blockquote><h3 id="复合享元模式"><a href="#复合享元模式" class="headerlink" title="复合享元模式"></a>复合享元模式</h3><p>首先，是抽象享元类、具体享元类和非共享具体享元类。Flyweight 接口充当抽象享元类，ConcreteFlyweight 类充当具体享元类，UnsharedConcreteFlyweight 类充当非共享具体享元类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象享元类 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 示意性方法，参数state是外蕴状态     */</span>    <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体享元类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 内部状态intrinsicState作为成员变量，同一个享元对象其内部状态是一致的 */</span>    <span class="token keyword">private</span> String intrinsicState<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 构造函数，内蕴状态作为参数传入     */</span>    <span class="token keyword">public</span> <span class="token function">ConcreteFlyweight</span><span class="token punctuation">(</span>String intrinsicState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState <span class="token operator">=</span> intrinsicState<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 外蕴状态作为参数传入方法中，改变方法的行为，但是并不改变对象的内蕴状态。     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>String extrinsicState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Intrinsic State = "</span> <span class="token operator">+</span> <span class="token keyword">this</span><span class="token punctuation">.</span>intrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"Extrinsic State = "</span> <span class="token operator">+</span> extrinsicState<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非共享具体享元类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UnsharedConcreteFlyweight</span> <span class="token keyword">implements</span> <span class="token class-name">Flyweight</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Flyweight<span class="token operator">></span> flyweights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Flyweight<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 增加一个新的单纯享元对象到聚集中     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>String key <span class="token punctuation">,</span> Flyweight flyweight<span class="token punctuation">)</span><span class="token punctuation">{</span>        flyweights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>flyweight<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 外蕴状态作为参数传入到方法中     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Collection<span class="token operator">&lt;</span>Flyweight<span class="token operator">></span> values <span class="token operator">=</span> flyweights<span class="token punctuation">.</span><span class="token function">values</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span><span class="token punctuation">(</span>Flyweight flyweight <span class="token operator">:</span> values<span class="token punctuation">)</span><span class="token punctuation">{</span>            flyweight<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是享元工厂类。Abstraction 类充当享元工厂类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 享元工厂类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Map<span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Flyweight<span class="token operator">></span> flyweights <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token operator">&lt;</span>String<span class="token punctuation">,</span>Flyweight<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 复合享元工厂方法     */</span>    <span class="token keyword">public</span> Flyweight <span class="token function">getFlyweight</span><span class="token punctuation">(</span>List<span class="token operator">&lt;</span>String<span class="token operator">></span> compositeState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        UnsharedConcreteFlyweight compositeFly <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">UnsharedConcreteFlyweight</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>String state <span class="token operator">:</span> compositeState<span class="token punctuation">)</span> <span class="token punctuation">{</span>            compositeFly<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> compositeFly<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 单纯享元工厂方法     */</span>    <span class="token keyword">public</span> Flyweight <span class="token function">getFlyweight</span><span class="token punctuation">(</span>String state<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 如果对象存在，则直接从享元池获取</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flyweights<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> flyweights<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token comment" spellcheck="true">// 如果对象不存在，先创建一个新的对象添加到享元池中，然后返回</span>        Flyweight flyweight <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 把这个新的Flyweight对象添加到缓存中</span>        flyweights<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>state<span class="token punctuation">,</span> flyweight<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> flyweight<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FlyweightClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        List<span class="token operator">&lt;</span>String<span class="token operator">></span> compositeState <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeState<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        FlyweightFactory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FlyweightFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight compositeFly1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span>compositeState<span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight compositeFly2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span>compositeState<span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeFly1<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token string">"Composite Call"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"复合享元模式是否可以共享对象："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>compositeFly1 <span class="token operator">==</span> compositeFly2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        String state <span class="token operator">=</span> <span class="token string">"A"</span><span class="token punctuation">;</span>        Flyweight flyweight1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        Flyweight flyweight2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">getFlyweight</span><span class="token punctuation">(</span>state<span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"单纯享元模式是否可以共享对象："</span> <span class="token operator">+</span> <span class="token punctuation">(</span>flyweight1 <span class="token operator">==</span> flyweight2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>将一些单纯享元使用组合模式加以组合，可以形成复合享元对象，这样的复合享元对象本身不能共享，但是它们可以分解成单纯享元对象，而后者则可以共享。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>享元模式是一个考虑系统性能的设计模式，通过使用享元模式可以节约内存空间，提高系统的性能。</p><p>享元模式的核心在于享元工厂类，享元工厂类的作用在于提供一个用于存储享元对象的享元池，用户需要对象时，首先从享元池中获取，如果享元池中不存在，则创建一个新的享元对象返回给用户，并在享元池中保存该新增对象。</p><p>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态(Internal State)和外部状态(External State)：</p><ul><li>内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享。</li><li>外部状态是随环境改变而改变的、不可以共享的状态。享元对象的外部状态必须由客户端保存，并在享元对象被创建之后，在需要使用的时候再传入到享元对象内部。一个外部状态与另一个外部状态之间是相互独立的。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>享元模式的主要优点如下：</p><ul><li>可以极大减少内存中对象的数量，使得相同或相似对象在内存中只保存一份，从而可以节约系统资源，提高系统性能。</li><li>享元模式的外部状态相对独立，而且不会影响其内部状态，从而使得享元对象可以在不同的环境中被共享。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>享元模式的主要缺点如下：</p><ul><li>享元模式使得系统变得复杂，需要分离出内部状态和外部状态，这使得程序的逻辑复杂化。</li><li>为了使对象可以共享，享元模式需要将享元对象的部分状态外部化，而读取外部状态将使得运行时间变长。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用享元模式：</p><ul><li>一个系统有大量相同或者相似的对象，造成内存的大量耗费。</li><li>对象的大部分状态都可以外部化，可以将这些外部状态传入对象中。</li><li>在使用享元模式时需要维护一个存储享元对象的享元池，而这需要耗费一定的系统资源，因此，应当在需要多次重复使用享元对象时才值得使用享元模式。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>享元模式通常需要和其他模式一起联用，几种常见的联用方式如下：</p><ul><li>在享元模式的享元工厂类中通常提供一个静态的工厂方法用于返回享元对象，使用简单工厂模式来生成享元对象。</li><li>在一个系统中，通常只有唯一一个享元工厂，因此可以使用单例模式进行享元工厂类的设计。</li><li>享元模式可以结合组合模式形成复合享元模式，统一对多个享元对象设置外部状态。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>享元模式运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用，它是一种对象结构型模式。</li><li>享元模式包含四个角色：抽象享元类声明一个接口，通过它可以接受并作用于外部状态；具体享元类实现了抽象享元接口，其实例称为享元对象；非共享具体享元是不能被共享的抽象享元类的子类；享元工厂类用于创建并管理享元对象，它针对抽象享元类编程，将各种类型的具体享元对象存储在一个享元池中。</li><li>享元模式以共享的方式高效地支持大量的细粒度对象，享元对象能做到共享的关键是区分内部状态和外部状态。其中内部状态是存储在享元对象内部并且不会随环境改变而改变的状态，因此内部状态可以共享；外部状态是随环境改变而改变的、不可以共享的状态。</li><li>享元模式主要优点在于它可以极大减少内存中对象的数量，使得相同对象或相似对象在内存中只保存一份；其缺点是使得系统更加复杂，并且需要将享元对象的状态外部化，而读取外部状态使得运行时间变长。</li><li>享元模式适用情况包括：一个系统有大量相同或者相似的对象，由于这类对象的大量使用，造成内存的大量耗费；对象的大部分状态都可以外部化，可以将这些外部状态传入对象中；多次重复使用享元对象。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之外观模式</title>
      <link href="/posts/2018/421c1d86.html"/>
      <url>/posts/2018/421c1d86.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在软件开发中，有时候为了完成一项较为复杂的功能，一个客户类需要和多个业务类交互，而这些需要交互的业务类经常会作为一个整体出现，由于涉及到的类比较多，导致使用时代码较为复杂，此时，特别需要一个类似服务员一样的角色，由它来负责和多个业务类进行交互，而客户类只需与该类交互。这就是外观模式的动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>外观模式(Facade Pattern)</code></strong>为子系统中的一组接口提供一个统一的入口。外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式。</p><blockquote><p>外观模式是一种<strong><code>对象结构型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>外观模式包含如下角色：</p><ul><li><strong><code>Facade(外观角色)：</code></strong>在客户端可以调用它的方法，在外观角色中可以知道相关的（一个或者多个）子系统的功能和责任；在正常情况下，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理。</li><li><strong><code>SubSystem(子系统角色)：</code></strong>在软件系统中可以有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能；每一个子系统都可以被客户端直接调用，或者被外观角色调用，它处理由外观类传过来的请求；子系统并不知道外观的存在，对于子系统而言，外观角色仅仅是另外一个客户端而已。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/facade_uml.jpg" alt="外观模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/facade_seq.jpg" alt="外观模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是子系统角色。SystemA、SystemB 和 SystemC 类充当子系统角色，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统角色A */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SystemA</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SystemA处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统角色B */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SystemB</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SystemB处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 子系统角色C */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">SystemC</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"SystemC处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>外观模式中所指的子系统是一个广义的概念，它可以是一个类、一个功能模块、系统的一个组成部分或者一个完整的系统。子系统类通常是一些业务类，实现了一些具体的、独立的业务功能。</p></blockquote><p>然后，是外观角色。Facade 类充当外观角色，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 外观角色 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Facade</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> SystemA systemA <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SystemA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> SystemB systemB <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SystemB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> SystemC systemC <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">SystemC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 以下是提供给外部访问的方法</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>systemA<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>systemB<span class="token punctuation">.</span><span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>systemC<span class="token punctuation">.</span><span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>由于在外观类中维持了对子系统对象的引用，客户端可以通过外观类来间接调用子系统对象的业务方法，而无须与子系统对象直接交互。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FacadeClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Facade facade <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Facade</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建外观对象</span>        facade<span class="token punctuation">.</span><span class="token function">methodA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        facade<span class="token punctuation">.</span><span class="token function">methodB</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        facade<span class="token punctuation">.</span><span class="token function">methodC</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>根据“单一职责原则”，在软件中将一个系统划分为若干个子系统有利于降低整个系统的复杂性，一个常见的设计目标是使子系统间的通信和相互依赖关系达到最小，而达到该目标的途径之一就是引入一个外观对象，它为子系统的访问提供了一个简单而单一的入口。</li><li>外观模式也是“迪米特法则”的体现，通过引入一个新的外观类可以降低原有系统的复杂度，同时降低客户类与子系统类的耦合度。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式的目的在于降低系统的复杂程度。</li><li>外观模式从很大程度上提高了客户端使用的便捷性，使得客户端无须关心子系统的工作细节，通过外观角色即可调用相关功能。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>外观模式的主要优点如下：</p><ul><li>外观模式对客户端屏蔽了子系统组件，减少了客户端所需处理的对象数目，并使得子系统使用起来更加容易。通过引入外观模式，客户端代码将变得很简单，与之关联的对象也很少。</li><li>外观模式实现了子系统与客户端之间的松耦合关系，这使得子系统的变化不会影响到调用它的客户端，只需要调整外观类即可。</li><li>一个子系统的修改对其他子系统没有任何影响，而且子系统内部变化也不会影响到外观对象。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>外观模式的主要缺点如下：</p><ul><li>不能很好地限制客户端直接使用子系统类，如果对客户端访问子系统类做太多的限制则减少了可变性和灵活 性。</li><li>如果设计不当，增加新的子系统可能需要修改外观类的源代码，违背了开闭原则。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用外观模式：</p><ul><li>当要为访问一系列复杂的子系统提供一个简单入口时可以使用外观模式。</li><li>客户端程序与多个子系统之间存在很大的依赖性。引入外观类可以将子系统与客户端解耦，从而提高子系统的独立性和可移植性。</li><li>在层次化结构中，可以使用外观模式定义系统中每一层的入口，层与层之间不直接产生联系，而通过外观类建立联系，降低层之间的耦合度。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>在外观模式中，外部与一个子系统的通信必须通过一个统一的外观对象进行，为子系统中的一组接口提供一个一致的界面，外观模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。外观模式又称为门面模式，它是一种对象结构型模式。</li><li>外观模式包含两个角色：外观角色是在客户端直接调用的角色，在外观角色中可以知道相关的(一个或者多个)子系统的功能和责任，它将所有从客户端发来的请求委派到相应的子系统去，传递给相应的子系统对象处理；在软件系统中可以同时有一个或者多个子系统角色，每一个子系统可以不是一个单独的类，而是一个类的集合，它实现子系统的功能。</li><li>外观模式要求一个子系统的外部与其内部的通信通过一个统一的外观对象进行，外观类将客户端与子系统的内部复杂性分隔开，使得客户端只需要与外观对象打交道，而不需要与子系统内部的很多对象打交道。</li><li>外观模式主要优点在于对客户屏蔽子系统组件，减少了客户处理的对象数目并使得子系统使用起来更加容易，它实现了子系统与客户之间的松耦合关系，并降低了大型软件系统中的编译依赖性，简化了系统在不同平台之间的移植过程；其缺点在于不能很好地限制客户使用子系统类，而且在不引入抽象外观类的情况下，增加新的子系统可能需要修改外观类或客户端的源代码，违背了“开闭原则”。</li><li>外观模式适用情况包括：要为一个复杂子系统提供一个简单接口；客户程序与多个子系统之间存在很大的依赖性；在层次化结构中，需要定义系统中每一层的入口，使得层与层之间不直接产生联系。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之装饰模式</title>
      <link href="/posts/2018/53b39445.html"/>
      <url>/posts/2018/53b39445.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>一般有两种方式可以实现给一个类或对象增加行为：</p><ul><li>继承机制，使用继承机制是给现有类添加功能的一种有效途径，通过继承一个现有类可以使得子类在拥有自身方法的同时还拥有父类的方法。但是这种方法是静态的，用户不能控制增加行为的方式和时机。</li><li>关联机制，即将一个类的对象嵌入另一个对象中，由另一个对象来决定是否调用嵌入对象的行为以便扩展自己的行为，我们称这个嵌入的对象为装饰器(Decorator)。</li></ul><p>装饰模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是装饰模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>装饰模式(Decorator Pattern)</code></strong>动态地给一个对象增加一些额外的职责(Responsibility)，就增加对象功能来说，装饰模式比生成子类实现更为灵活。其别名也可以称为包装器(Wrapper)，与适配器模式的别名相同，但它们适用于不同的场合。根据翻译的不同，装饰模式也有人称之为“油漆工模式”。</p><blockquote><p>装饰模式是一种<strong><code>对象结构型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>装饰模式包含如下角色：</p><ul><li><strong><code>Component(抽象构件)：</code></strong>它是具体构件和抽象装饰类的共同父类，声明了在具体构件中实现的业务方法，它的引入可以使客户端以一致的方式处理未被装饰的对象以及装饰之后的对象，实现客户端的透明操作。</li><li><strong><code>ConcreteComponent(具体构件)：</code></strong>它是抽象构件类的子类，用于定义具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）。</li><li><strong><code>Decorator(抽象装饰类)：</code></strong>它也是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现。它维护一个指向抽象构件对象的引用，通过该引用可以调用装饰之前构件对象的方法，并通过其子类扩展该方法，以达到装饰的目的。</li><li><strong><code>ConcreteDecorator(具体装饰类)：</code></strong>它是抽象装饰类的子类，负责向构件添加新的职责。每一个具体装饰类都定义了一些新的行为，它可以调用在抽象装饰类中定义的方法，并可以增加新的方法用以扩充对象的行为。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/decorator_uml.jpg" alt="装饰模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/decorator_seq.jpg" alt="装饰模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象构件和具体构件。Component 接口充当抽象构件，ConcreteComponent 类充当具体构件，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象构件 */</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 接口方法     */</span>    <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体构件 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteComponent</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 具体实现方法     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteComponent处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是抽象装饰类和具体装饰类。Decorator 类充当抽象装饰类，ConcreteDecoratorA 和 ConcreteDecoratorB 类充当具体装饰类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象装饰类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Decorator</span> <span class="token keyword">implements</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 维持一个对抽象构件对象的引用     */</span>    <span class="token keyword">private</span> Component component<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 通过构造函数传递被修饰者     */</span>    <span class="token keyword">public</span> <span class="token function">Decorator</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component <span class="token operator">=</span> component<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 委托给被修饰者执行     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用原有业务方法</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体装饰类A */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorA</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecoratorA</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用原有业务方法</span>        <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用新增业务方法</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 新增业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体装饰类A的新增业务..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体装饰类B */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteDecoratorB</span> <span class="token keyword">extends</span> <span class="token class-name">Decorator</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">ConcreteDecoratorB</span><span class="token punctuation">(</span>Component component<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用原有业务方法</span>        <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用新增业务方法</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 新增业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">addedBehavior</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"具体装饰类B的新增业务..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p> 由于在抽象装饰类 Decorator 中注入的是 Component 类型的对象，因此我们可以将一个具体构件对象注入其中，再通过具体装饰类来进行装饰；此外，我们还可以将一个已经装饰过的 Decorator 子类的对象再注入其中进行多次装饰，从而对原有功能的多次扩展。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DecoratorClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Component component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteComponent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 具体构件</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecoratorA</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第一修饰</span>        component <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteDecoratorB</span><span class="token punctuation">(</span>component<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 第二修饰</span>        component<span class="token punctuation">.</span><span class="token function">operate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                              <span class="token comment" spellcheck="true">// 修饰后运行</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h2><p>在实际使用过程中，由于新增行为可能需要单独调用，因此这种形式的装饰模式也经常出现，这种装饰模式被称为半透明(Semi-transparent)装饰模式，而标准的装饰模式是透明(Transparent)装饰模式。</p><h3 id="透明装饰模式"><a href="#透明装饰模式" class="headerlink" title="透明装饰模式"></a>透明装饰模式</h3><p>在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该将对象声明为具体构件类型或具体装饰类型，而应该全部声明为抽象构件类型。对于客户端而言，具体构件对象和具体装饰对象没有任何区别。</p><p>使用抽象构件类型 Component 定义全部具体构件对象和具体装饰对象，客户端可以一致地使用这些对象，因此符合透明装饰模式的要求。</p><p>透明装饰模式可以让客户端透明地使用装饰之前的对象和装饰之后的对象，无须关心它们的区别，此外，还可以对一个已装饰过的对象进行多次装饰，得到更为复杂、功能更为强大的对象。在实现透明装饰模式时，要求具体装饰类的 operation() 方法覆盖抽象装饰类的 operation() 方法，除了调用原有对象的 operation() 外还需要调用新增的 addedBehavior() 方法来增加新行为</p><h3 id="半透明装饰模式"><a href="#半透明装饰模式" class="headerlink" title="半透明装饰模式"></a>半透明装饰模式</h3><p>透明装饰模式的设计难度较大，而且有时我们需要单独调用新增的业务方法。为了能够调用到新增方法，我们不得不用具体装饰类型来定义装饰之后的对象，而具体构件类型还是可以使用抽象构件类型来定义，这种装饰模式即为半透明装饰模式，也就是说，对于客户端而言，具体构件类型无须关心，是透明的；但是具体装饰类型必须指定，这是不透明的。</p><p>半透明装饰模式可以给系统带来更多的灵活性，设计相对简单，使用起来也非常方便；但是其最大的缺点在于不能实现对同一个对象的多次装饰，而且客户端需要有区别地对待装饰之前的对象和装饰之后的对象。在实现半透明的装饰模式时，我们只需在具体装饰类中增加一个独立的 addedBehavior() 方法来封装相应的业务处理，由于客户端使用具体装饰类型来定义装饰后的对象，因此可以单独调用 addedBehavior() 方法来扩展系统功能。</p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>装饰模式降低了系统的耦合度，可以动态增加或删除对象的职责，并使得需要装饰的具体构件类和具体装饰类可以独立变化，以便增加新的具体构件类和具体装饰类。在软件开发中，装饰模式应用较为广泛，例如在 Java IO 中的输入流和输出流的设计、javax.swing 包中一些图形界面构件功能的增强等地方都运用了装饰模式。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>装饰模式的主要优点如下：</p><ul><li>对于扩展一个对象的功能，装饰模式比继承更加灵活性，不会导致类的个数急剧增加。</li><li>可以通过一种动态的方式来扩展一个对象的功能，通过配置文件可以在运行时选择不同的具体装饰类，从而实现不同的行为。</li><li>可以对一个对象进行多次装饰，通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，得到功能更为强大的对象。</li><li>具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类，原有类库代码无须改变，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>装饰模式的主要缺点如下：</p><ul><li>使用装饰模式进行系统设计时将产生很多小对象，这些对象的区别在于它们之间相互连接的方式有所不同，而不是它们的类或者属性值有所不同，大量小对象的产生势必会占用更多的系统资源，在一定程序上影响程序的性能。</li><li>装饰模式提供了一种比继承更加灵活机动的解决方案，但同时也意味着比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为繁琐。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用装饰模式：</p><ul><li>在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责。</li><li>当不能采用继承的方式对系统进行扩展或者采用继承不利于系统扩展和维护时可以使用装饰模式。不能采用继承的情况主要有两类：第一类是系统中存在大量独立的扩展，为支持每一种扩展或者扩展之间的组合将产生大量的子类，使得子类数目呈爆炸性增长；第二类是因为类已定义为不能被继承（如Java语言中的final类）。</li></ul><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><p>在使用装饰模式时，通常我们需要注意以下几个问题：</p><ul><li>尽量保持装饰类的接口与被装饰类的接口相同，这样，对于客户端而言，无论是装饰之前的对象还是装饰之后的对象都可以一致对待。这也就是说，在可能的情况下，我们应该尽量使用透明装饰模式。</li><li>尽量保持具体构件类 ConcreteComponent 是一个“轻”类，也就是说不要把太多的行为放在具体构件类中，我们可以通过装饰类对其进行扩展。</li><li>如果只有一个具体构件类，那么抽象装饰类可以作为该具体构件类的直接子类。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>装饰模式用于动态地给一个对象增加一些额外的职责，就增加对象功能来说，装饰模式比生成子类实现更为灵活。它是一种对象结构型模式。</li><li>装饰模式包含四个角色：抽象构件定义了对象的接口，可以给这些对象动态增加职责（方法）；具体构件定义了具体的构件对象，实现了在抽象构件中声明的方法，装饰器可以给它增加额外的职责（方法）；抽象装饰类是抽象构件类的子类，用于给具体构件增加职责，但是具体职责在其子类中实现；具体装饰类是抽象装饰类的子类，负责向构件添加新的职责。</li><li>使用装饰模式来实现扩展比继承更加灵活，它以对客户透明的方式动态地给一个对象附加更多的责任。装饰模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。</li><li>装饰模式的主要优点在于可以提供比继承更多的灵活性，可以通过一种动态的方式来扩展一个对象的功能，并通过使用不同的具体装饰类以及这些装饰类的排列组合，可以创造出很多不同行为的组合，而且具体构件类与具体装饰类可以独立变化，用户可以根据需要增加新的具体构件类和具体装饰类；其主要缺点在于使用装饰模式进行系统设计时将产生很多小对象，而且装饰模式比继承更加易于出错，排错也很困难，对于多次装饰的对象，调试时寻找错误可能需要逐级排查，较为烦琐。</li><li>装饰模式适用情况包括：在不影响其他对象的情况下，以动态、透明的方式给单个对象添加职责；需要动态地给一个对象增加功能，这些功能也可以动态地被撤销；当不能采用继承的方式对系统进行扩充或者采用继承不利于系统扩展和维护时。</li><li>装饰模式可分为透明装饰模式和半透明装饰模式：在透明装饰模式中，要求客户端完全针对抽象编程，装饰模式的透明性要求客户端程序不应该声明具体构件类型和具体装饰类型，而应该全部声明为抽象构件类型；半透明装饰模式允许用户在客户端声明具体装饰者类型的对象，调用在具体装饰者中新增的方法。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之组合模式</title>
      <link href="/posts/2018/6a4500bc.html"/>
      <url>/posts/2018/6a4500bc.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于树形结构，当容器对象（如文件夹）的某一个方法被调用时，将遍历整个树形结构，寻找也包含这个方法的成员对象（可以是容器对象，也可以是叶子对象）并调用执行，牵一而动百，其中使用了递归调用的机制来对整个结构进行处理。由于容器对象和叶子对象在功能上的区别，在使用这些对象的代码中必须有区别地对待容器对象和叶子对象，而实际上大多数情况下我们希望一致地处理它们，因为对于这些对象的区别对待将会使得程序非常复杂。组合模式为解决此类问题而诞生，它可以让叶子对象和容器对象的使用具有一致性。这就是组合模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>组合模式(Composite Pattern)</code></strong>组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式。</p><blockquote><p>组合模式是一种<strong><code>对象结构型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>组合模式包含如下角色：</p><ul><li><strong><code>Component(抽象构件)：</code></strong>它可以是接口或抽象类，为叶子构件和容器构件对象声明接口，在该角色中可以包含所有子类共有行为的声明和实现。在抽象构件中定义了访问及管理它的子构件的方法，如增加子构件、删除子构件、获取子构件等。</li><li><strong><code>Leaf(叶子构件)：</code></strong>它在组合结构中表示叶子节点对象，叶子节点没有子节点，它实现了在抽象构件中定义的行为。对于那些访问及管理子构件的方法，可以通过异常等方式进行处理。</li><li><strong><code>Composite(容器构件)：</code></strong>它在组合结构中表示容器节点对象，容器节点包含子节点，其子节点可以是叶子节点，也可以是容器节点，它提供一个集合用于存储子节点，实现了在抽象构件中定义的行为，包括那些访问及管理子构件的方法，在其业务方法中可以递归调用其子节点的业务方法。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/composite_uml.jpg" alt="组合模式结构图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象构件。Component 抽象类充当抽象构件，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象构件 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">protected</span> String name<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Component</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 增加成员     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 删除成员     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 获取成员     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> Component <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 业务方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><blockquote><p>一般将抽象构件类设计为接口或抽象类，将所有子类共有方法的声明和实现放在抽象构件类中。对于客户端而言，将针对抽象构件编程，而无须关心其具体子类是容器构件还是叶子构件。</p></blockquote><p>其次，是叶子构件。Leaf 类充当叶子构件，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 叶子构件 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Leaf</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token function">Leaf</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 异常处理或错误提示</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 异常处理或错误提示</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Component <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 异常处理或错误提示</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 叶子构件具体业务方法的实现</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>作为抽象构件类的子类，在叶子构件中需要实现在抽象构件类中声明的所有方法，包括业务方法以及管理和访问子构件的方法，但是叶子构件不能再包含子构件，因此在叶子构件中实现子构件管理和访问方法时需要提供异常处理或错误提示。当然，这无疑会给叶子构件的实现带来麻烦。</p></blockquote><p>然后，是容器构件。Composite 类充当容器构件，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 容器构件 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Composite</span> <span class="token keyword">extends</span> <span class="token class-name">Component</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> ArrayList<span class="token operator">&lt;</span>Component<span class="token operator">></span> components <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token operator">&lt;</span>Component<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Composite</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        components<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">remove</span><span class="token punctuation">(</span>Component c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        components<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> Component <span class="token function">getChild</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> components<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 容器构件具体业务方法的实现</span>        <span class="token comment" spellcheck="true">// 递归调用成员构件的业务方法</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span>Component component <span class="token operator">:</span> components<span class="token punctuation">)</span> <span class="token punctuation">{</span>            component<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>在容器构件中实现了在抽象构件中声明的所有方法，既包括业务方法，也包括用于访问和管理成员子构件的方法，如 add()、remove() 和 getChild() 等方法。需要注意的是在实现具体业务方法时，由于容器构件充当的是容器角色，包含成员构件，因此它将调用其成员构件的业务方法。在组合模式结构中，由于容器构件中仍然可以包含容器构件，因此在对容器构件进行处理时需要使用递归算法，即在容器构件的 operation() 方法中递归调用其成员构件的 operation() 方法。</p></blockquote><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">CompositeClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Composite compositeRoot <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"Root"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeRoot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"Leaf A"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeRoot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"Leaf B"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Composite compositeX <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"Composite X"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeX<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"Leaf XA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeX<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"Leaf XB"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeRoot<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>compositeX<span class="token punctuation">)</span><span class="token punctuation">;</span>        Composite compositeY <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Composite</span><span class="token punctuation">(</span><span class="token string">"Composite Y"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeY<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"Leaf YA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeY<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Leaf</span><span class="token punctuation">(</span><span class="token string">"Leaf YB"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeX<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>compositeY<span class="token punctuation">)</span><span class="token punctuation">;</span>        compositeRoot<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分类"><a href="#模式分类" class="headerlink" title="模式分类"></a>模式分类</h2><p>在使用组合模式时，根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式：</p><h3 id="透明组合模式"><a href="#透明组合模式" class="headerlink" title="透明组合模式"></a>透明组合模式</h3><p>透明组合模式中，抽象构件 Component 中声明了所有用于管理成员对象的方法，包括 add()、remove() 以及 getChild() 等方法，这样做的好处是确保所有的构件类都有相同的接口。在客户端看来，叶子对象与容器对象所提供的方法是一致的，客户端可以相同地对待所有的对象。透明组合模式也是组合模式的标准形式。</p><h3 id="安全组合模式"><a href="#安全组合模式" class="headerlink" title="安全组合模式"></a>安全组合模式</h3><p>安全组合模式中，在抽象构件 Component 中没有声明任何用于管理成员对象的方法，而是在 Composite 类中声明并实现这些方法。这种做法是安全的，因为根本不向叶子对象提供这些管理成员对象的方法，对于叶子对象，客户端不可能调用到这些方法。</p><p>安全组合模式的缺点是不够透明，因为叶子构件和容器构件具有不同的方法，且容器构件中那些用于管理成员对象的方法没有在抽象构件类中定义，因此客户端不能完全针对抽象编程，必须有区别地对待叶子构件和容器构件。</p><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>组合模式的关键是定义了一个抽象构件类，它既可以代表叶子，又可以代表容器，而客户端针对该抽象构件类进行编程，无须知道它到底表示的是叶子还是容器，可以对其进行统一处理。同时容器对象与抽象构件类之间还建立一个聚合关联关系，在容器对象中既可以包含叶子，也可以包含容器，以此实现递归组合，形成一个树形结构。</li><li>如果不使用组合模式，客户端代码将过多地依赖于容器对象复杂的内部实现结构，容器对象内部实现结构的变化将引起客户代码的频繁变化，带来了代码维护复杂、可扩展性差等弊端。组合模式的引入将在一定程度上解决这些问题。</li><li>组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>组合模式的主要优点如下：</p><ul><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>客户端可以一致地使用一个组合结构或其中单个对象，不必关心处理的是单个对象还是整个组合结构，简化了客户端代码。</li><li>在组合模式中增加新的容器构件和叶子构件都很方便，无须对现有类库进行任何修改，符合“开闭原则”。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>组合模式的主要缺点如下：</p><ul><li>在增加新构件时很难对容器中的构件类型进行限制。有时候我们希望一个容器中只能有某些特定类型的对象，例如在某个文件夹中只能包含文本文件，使用组合模式时，不能依赖类型系统来施加这些约束，因为它们都来自于相同的抽象层，在这种情况下，必须通过在运行时进行类型检查来实现，这个实现过程较为复杂。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用组合模式：</p><ul><li>在具有整体和部分的层次结构中，希望通过一种方式忽略整体与部分的差异，客户端可以一致地对待它们。</li><li>在一个使用面向对象语言开发的系统中需要处理一个树形结构。</li><li>在一个系统中能够分离出叶子对象和容器对象，而且它们的类型不固定，需要增加一些新的类型。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>组合模式组合多个对象形成树形结构以表示具有“整体—部分”关系的层次结构。组合模式对单个对象（即叶子对象）和组合对象（即容器对象）的使用具有一致性，组合模式又可以称为“整体—部分”(Part-Whole)模式。</li><li>组合模式包含三个角色：抽象构件定义了叶子构件和容器构件对象的接口，可以包含所有子类共有行为的声明和实现；叶子构件定义了叶子节点对象，实现了在抽象构件中定义的行为；容器构件定义了容器节点对象，提供一个集合用于存储子节点，实现了在抽象构件中定义的行为。</li><li>组合模式可以清楚地定义分层次的复杂对象，表示对象的全部或部分层次，它让客户端忽略了层次的差异，方便对整个层次结构进行控制。</li><li>组合模式为树形结构的面向对象实现提供了一种灵活的解决方案，通过叶子对象和容器对象的递归组合，可以形成复杂的树形结构，但对树形结构的控制却非常简单。</li><li>组合模式使用面向对象的思想来实现树形结构的构建与处理，描述了如何将容器对象和叶子对象进行递归组合，实现简单，灵活性好。由于在软件开发中存在大量的树形结构，因此组合模式是一种使用频率较高的结构型设计模式。</li><li>组合模式根据抽象构件类的定义形式，我们可将组合模式分为透明组合模式和安全组合模式两种形式。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之桥接模式</title>
      <link href="/posts/2018/e3f0fff2.html"/>
      <url>/posts/2018/e3f0fff2.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>设想如果要绘制矩形、圆形、椭圆、正方形，我们至少需要4个形状类，但是如果绘制的图形需要具有不同的颜色，如红色、绿色、蓝色等，此时至少有如下两种设计方案：</p><ul><li>第一种设计方案是为每一种形状都提供一套各种颜色的版本。</li><li>第二种设计方案是根据实际需要对形状和颜色进行组合</li></ul><p>对于有两个变化维度（即两个变化的原因）的系统，采用方案二来进行设计系统中类的个数更少，且系统扩展更为方便。设计方案二即是桥接模式的应用。桥接模式将继承关系转换为关联关系，从而降低了类与类之间的耦合，减少了代码编写量。这就是桥接模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>桥接模式(Bridge Pattern)</code></strong>将抽象部分与它的实现部分分离，使它们都可以独立地变化。桥接模式又称为柄体(Handle and Body)模式或接口(Interface)模式。</p><blockquote><p>桥接模式是一种<strong><code>对象结构型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>桥接模式包含如下角色：</p><ul><li><strong><code>Abstraction(抽象类)：</code></strong>用于定义抽象类的接口，它一般是抽象类而不是接口，其中定义了一个 Implementor(实现类接口)类型的对象并可以维护该对象，它与 Implementor 之间具有关联关系，它既可以包含抽象业务方法，也可以包含具体业务方法。</li><li><strong><code>RefinedAbstraction(扩充抽象类)：</code></strong>扩充由 Abstraction 定义的接口，通常情况下它不再是抽象类而是具体类，它实现了在 Abstraction 中声明的抽象业务方法，在 RefinedAbstraction 中可以调用在 Implementor 中定义的业务方法。</li><li><strong><code>Implementor(实现类接口)：</code></strong>定义实现类的接口，这个接口不一定要与 Abstraction 的接口完全一致，事实上这两个接口可以完全不同，一般而言，Implementor 接口仅提供基本操作，而 Abstraction 定义的接口可能会做更多更复杂的操作。Implementor 接口对这些基本操作进行了声明，而具体实现交给其子类。通过关联关系，在 Abstraction 中不仅拥有自己的方法，还可以调用到 Implementor 中定义的方法，使用关联关系来替代继承关系。</li><li><strong><code>ConcreteImplementor(具体实现类)：</code></strong>具体实现 Implementor 接口，在不同的 ConcreteImplementor 中提供基本操作的不同实现，在程序运行时，ConcreteImplementor 对象将替换其父类对象，提供给抽象类具体的业务操作方法。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/bridge_uml.jpg" alt="桥接模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/bridge_seq.jpg" alt="桥接模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是实现类接口和具体实现类。Implementor 接口充当实现类接口，ConcreteImplementorA 和 ConcreteImplementorB 类充当具体实现类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 实现类接口 */</span><span class="token keyword">interface</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体实现类A */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorA</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementorA处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体实现类B */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteImplementorB</span> <span class="token keyword">implements</span> <span class="token class-name">Implementor</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"ConcreteImplementorB处理的业务逻辑..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是抽象类和扩充抽象类。Abstraction 类充当抽象类，RefinedAbstraction 类充当扩充抽象类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象类 */</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 定义实现类接口对象     */</span>    <span class="token keyword">private</span> Implementor implementor<span class="token punctuation">;</span>    <span class="token keyword">public</span> Implementor <span class="token function">getImplementor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> implementor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setImplementor</span><span class="token punctuation">(</span>Implementor implementor<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>implementor <span class="token operator">=</span> implementor<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//声明抽象业务方法</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 扩充抽象类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">RefinedAbstraction</span> <span class="token keyword">extends</span> <span class="token class-name">Abstraction</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 业务代码</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">getImplementor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">operationImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 调用实现类的方法</span>        <span class="token comment" spellcheck="true">// 业务代码</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BridgeClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Implementor implementor <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteImplementorA</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Abstraction abstraction <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">RefinedAbstraction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        abstraction<span class="token punctuation">.</span><span class="token function">setImplementor</span><span class="token punctuation">(</span>implementor<span class="token punctuation">)</span><span class="token punctuation">;</span>        abstraction<span class="token punctuation">.</span><span class="token function">operation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>桥接模式是一个非常有用的模式，在桥接模式中体现了很多面向对象设计原则的思想，包括“单一职责原则”、“开闭原则”、“合成复用原则”、“里氏代换原则”、“依赖倒转原则”等。熟悉桥接模式有助于我们深入理解这些设计原则，也有助于我们形成正确的设计思想和培养良好的设计风格。</p><p>理解桥接模式，重点需要理解如何将抽象化(Abstraction)与实现化(Implementation)脱耦，使得二者可以独立地变化。</p><ul><li>抽象化：抽象化就是忽略一些信息，把不同的实体当作同样的实体对待。在面向对象中，将对象的共同性质抽取出来形成类的过程即为抽象化的过程。</li><li>实现化：针对抽象化给出的具体实现，就是实现化，抽象化与实现化是一对互逆的概念，实现化产生的对象比抽象化更具体，是对抽象化事物的进一步具体化的产物。</li><li>脱耦：脱耦就是将抽象化和实现化之间的耦合解脱开，或者说是将它们之间的强关联改换成弱关联，将两个角色之间的继承关系改为关联关系。桥接模式中的所谓脱耦，就是指在一个软件系统的抽象化和实现化之间使用关联关系（组合或者聚合关系）而不是继承关系，从而使两者可以相对独立地变化，这就是桥接模式的用意。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>桥接模式的主要优点如下：</p><ul><li>分离抽象接口及其实现部分。桥接模式使用“对象间的关联关系”解耦了抽象和实现之间固有的绑定关系，使得抽象和实现可以沿着各自的维度来变化。所谓抽象和实现沿着各自维度的变化，也就是说抽象和实现不再在同一个继承层次结构中，而是“子类化”它们，使它们各自都具有自己的子类，以便任何组合子类，从而获得多维度组合对象。</li><li>在很多情况下，桥接模式可以取代多层继承方案，多层继承方案违背了“单一职责原则”，复用性较差，且类的个数非常多，桥接模式是比多层继承方案更好的解决方法，它极大减少了子类的个数。</li><li>桥接模式提高了系统的可扩展性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，符合“开闭原则”。</li><li>实现细节对客户透明，可以对用户隐藏实现细节。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>桥接模式的主要缺点如下：</p><ul><li>桥接模式的使用会增加系统的理解与设计难度，由于关联关系建立在抽象层，要求开发者一开始就针对抽象层进行设计与编程。</li><li>桥接模式要求正确识别出系统中两个独立变化的维度，因此其使用范围具有一定的局限性，如何正确识别两个独立维度也需要一定的经验积累。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用桥接模式：</p><ul><li>如果一个系统需要在抽象化和具体化之间增加更多的灵活性，避免在两个层次之间建立静态的继承关系，通过桥接模式可以使它们在抽象层建立一个关联关系。</li><li>“抽象部分”和“实现部分”可以以继承的方式独立扩展而互不影响，在程序运行时可以动态将一个抽象化子类的对象和一个实现化子类的对象进行组合，即系统需要对抽象化角色和实现化角色进行动态耦合。</li><li>一个类存在两个（或多个）独立变化的维度，且这两个（或多个）维度都需要独立进行扩展。</li><li>对于那些不希望使用继承或因为多层继承导致系统类的个数急剧增加的系统，桥接模式尤为适用。</li></ul><h3 id="模式扩展"><a href="#模式扩展" class="headerlink" title="模式扩展"></a>模式扩展</h3><p>适配器模式与桥接模式的联用:</p><ul><li>桥接模式和适配器模式用于设计的不同阶段，桥接模式用于系统的初步设计，对于存在两个独立变化维度的类可以将其分为抽象化和实现化两个角色，使它们可以分别进行变化；而在初步设计完成之后，当发现系统与已有类无法协同工作时，可以采用适配器模式。但有时候在设计初期也需要考虑适配器模式，特别是那些涉及到大量第三方应用接口的情况。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>桥接模式将抽象部分与它的实现部分分离，使它们都可以独立地变化。它是一种对象结构型模式，又称为柄体(Handle and Body)模式或接口(Interface)模式。</li><li>桥接模式包含如下四个角色：抽象类中定义了一个实现类接口类型的对象并可以维护该对象；扩充抽象类扩充由抽象类定义的接口，它实现了在抽象类中定义的抽象业务方法，在扩充抽象类中可以调用在实现类接口中定义的业务方法；实现类接口定义了实现类的接口，实现类接口仅提供基本操作，而抽象类定义的接口可能会做更多更复杂的操作；具体实现类实现了实现类接口并且具体实现它，在不同的具体实现类中提供基本操作的不同实现，在程序运行时，具体实现类对象将替换其父类对象，提供给客户端具体的业务操作方法。</li><li>在桥接模式中，抽象化(Abstraction)与实现化(Implementation)脱耦，它们可以沿着各自的维度独立变化。</li><li>桥接模式的主要优点是分离抽象接口及其实现部分，是比多继承方案更好的解决方法，桥接模式还提高了系统的可扩充性，在两个变化维度中任意扩展一个维度，都不需要修改原有系统，实现细节对客户透明，可以对用户隐藏实现细节；其主要缺点是增加系统的理解与设计难度，且识别出系统中两个独立变化的维度并不是一件容易的事情。</li><li>桥接模式适用情况包括：需要在构件的抽象化角色和具体化角色之间增加更多的灵活性，避免在两个层次之间建立静态的继承联系；抽象化角色和实现化角色可以以继承的方式独立扩展而互不影响；一个类存在两个独立变化的维度，且这两个维度都需要进行扩展；设计要求需要独立管理抽象化角色和具体化角色；不希望使用继承或因为多层次继承导致系统类的个数急剧增加的系统。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之适配器模式</title>
      <link href="/posts/2018/8c7ce1f4.html"/>
      <url>/posts/2018/8c7ce1f4.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>在软件开发中采用类似于电源适配器的设计和编码技巧被称为适配器模式。</p><p>通常情况下，客户端可以通过目标类的接口访问它所提供的服务。有时，现有的类可以满足客户类的功能需要，但是它所提供的接口不一定是客户类所期望的，这可能是因为现有类中方法名与目标类中定义的方法名不一致等原因所导致的。在这种情况下，现有的接口需要转化为客户类期望的接口，这样保证了对现有类的重用。如果不进行这样的转化，客户类就不能利用现有类所提供的功能，适配器模式可以完成这样的转化。</p><p>在适配器模式中可以定义一个包装类，包装不兼容接口的对象，这个包装类指的就是适配器(Adapter)，它所包装的对象就是适配者(Adaptee)，即被适配的类。</p><p>适配器提供客户类需要的接口，适配器的实现就是把客户类的请求转化为对适配者的相应接口的调用。也就是说：当客户类调用适配器的方法时，在适配器类的内部将调用适配者类的方法，而这个过程对客户类是透明的，客户类并不直接访问适配者类。因此，适配器可以使由于接口不兼容而不能交互的类可以一起工作。这就是适配器模式的模式动机。</p><p>适配器模式以对客户透明的方式动态地给一个对象附加上更多的责任，换言之，客户端并不会觉得对象在装饰前和装饰后有什么不同。适配器模式可以在不需要创造更多子类的情况下，将对象的功能加以扩展。这就是适配器模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>适配器模式(Adapter Pattern)</code></strong>将一个接口转换成客户希望的另一个接口，使接口不兼容的那些类可以一起工作，其别名为包装器(Wrapper)。</p><blockquote><p>适配器模式既可以作为<strong><code>类结构型模式</code></strong>，也可以作为<strong><code>对象结构型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>适配器模式包含如下角色：</p><ul><li><strong><code>Target(目标抽象类)：</code></strong>目标抽象类定义客户所需接口，可以是一个抽象类或接口，也可以是具体类。</li><li><strong><code>Adaptee(适配者类)：</code></strong>适配者即被适配的角色，它定义了一个已经存在的接口，这个接口需要适配，适配者类一般是一个具体类，包含了客户希望使用的业务方法，在某些情况下可能没有适配者类的源代码。</li><li><strong><code>Adapter(适配器类)：</code></strong>适配器可以调用另一个接口，作为一个转换器，对 Adaptee 和 Target 进行适配，适配器类是适配器模式的核心，在对象适配器中，它通过继承 Target 并关联一个 Adaptee 对象使二者产生联系。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p>适配器模式有两种实现：</p><ul><li><p>对象适配器<br><img src="https://henleylee.github.io/medias/design_pattern/adapter_uml_object.jpg" alt="对象适配器模式结构图"></p></li><li><p>类适配器<br><img src="https://henleylee.github.io/medias/design_pattern/adapter_uml_class.jpg" alt="类适配器模式结构图"></p></li></ul><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/adapter_seq.jpg" alt="适配器模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><h3 id="对象适配器"><a href="#对象适配器" class="headerlink" title="对象适配器"></a>对象适配器</h3><p>首先，是目标抽象类。Target 接口充当目标抽象类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 目标抽象类 */</span><span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这是适配者类Adapteee没有的方法     */</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其次，是适配者类。Adaptee 类充当适配者类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配者类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 需要适配的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"需要适配的方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是适配器类。Adapter 类充当适配器类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配器类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 维持一个对适配者对象的引用     */</span>    <span class="token keyword">private</span> Adaptee adaptee<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Adapter</span><span class="token punctuation">(</span>Adaptee adaptee<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>adaptee <span class="token operator">=</span> adaptee<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        adaptee<span class="token punctuation">.</span><span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 使用委托的方式完成转发调用</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdapterClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Adaptee adaptee <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adaptee</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 创建适配者对象</span>        Adapter adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span>adaptee<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 创建适配器对象</span>        adapter<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 使用委托的方式完成转发调用</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>对象的适配器模式是把适配的类的 API 转换成为目标类的 API。Adapter 与 Adaptee 是委派关系，这决定了这个适配器模式是对象的。</p></blockquote><h3 id="类适配器"><a href="#类适配器" class="headerlink" title="类适配器"></a>类适配器</h3><p>首先，是目标抽象类。Target 接口充当目标抽象类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 目标抽象类 */</span><span class="token keyword">interface</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 这是适配者类Adapteee没有的方法     */</span>    <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>其次，是适配者类。Adaptee 类充当适配者类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配者类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adaptee</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 需要适配的方法     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"需要适配的方法..."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是适配器类。Adapter 类充当适配器类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 适配器类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Adapter</span> <span class="token keyword">extends</span> <span class="token class-name">Adaptee</span> <span class="token keyword">implements</span> <span class="token class-name">Target</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">specificRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AdapterClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Adapter adapter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Adapter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token comment" spellcheck="true">// 创建适配器对象</span>        adapter<span class="token punctuation">.</span><span class="token function">request</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                         <span class="token comment" spellcheck="true">// 通过 Adapter 类调用所需要的方法从而实现目标</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>类的适配器模式也是把适配的类的 API 转换成为目标类的 API。Adapter 与 Adaptee 是继承关系，这决定了这个适配器模式是类的。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><ul><li>在适配器模式定义中所提及的接口是指广义的接口，它可以表示一个方法或者方法的集合。</li><li>在适配器模式中，我们通过增加一个新的适配器类来解决接口不兼容的问题，使得原本没有任何关系的类可以协同工作。根据适配器类与适配者类的关系不同，适配器模式可分为对象适配器和类适配器两种，在对象适配器模式中，适配器与适配者之间是关联关系；在类适配器模式中，适配器与适配者之间是继承（或实现）关系。在实际开发中，对象适配器的使用频率更高。</li><li>适配器模式将现有接口转化为客户类所期望的接口，实现了对现有类的复用，它是一种使用频率非常高的设计模式，在软件开发中得以广泛应用，在 Spring 等开源框架、驱动程序设计（如 JDBC 中的数据库驱动程序）中也使用了适配器模式。</li></ul><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>无论是对象适配器模式还是类适配器模式都具有如下优点：</p><ul><li>将目标类和适配者类解耦，通过引入一个适配器类来重用现有的适配者类，无须修改原有结构。</li><li>增加了类的透明性和复用性，将具体的业务实现过程封装在适配者类中，对于客户端类而言是透明的，而且提高了适配者的复用性，同一个适配者类可以在多个不同的系统中复用。</li><li>灵活性和扩展性都非常好，通过使用配置文件，可以很方便地更换适配器，也可以在不修改原有代码的基础上增加新的适配器类，完全符合“开闭原则”。</li></ul><p>具体来说，类适配器模式还有如下优点：</p><ul><li>由于适配器类是适配者类的子类，因此可以在适配器类中置换一些适配者的方法，使得适配器的灵活性更强。</li></ul><p>对象适配器模式还有如下优点：</p><ul><li>一个对象适配器可以把多个不同的适配者适配到同一个目标；</li><li>可以适配一个适配者的子类，由于适配器和适配者之间是关联关系，根据“里氏代换原则”，适配者的子类也可通过该适配器进行适配。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>类适配器模式的缺点如下：</p><ul><li>对于 Java、C# 等不支持多重类继承的语言，一次最多只能适配一个适配者类，不能同时适配多个适配者；</li><li>适配者类不能为最终类，如在 Java 中不能为 final 类，C# 中不能为 sealed 类；</li><li>在 Java、C# 等语言中，类适配器模式中的目标抽象类只能为接口，不能为类，其使用有一定的局限性。</li></ul><p>对象适配器模式的缺点如下：</p><ul><li>与类适配器模式相比，要在适配器中置换适配者类的某些方法比较麻烦。如果一定要置换掉适配者类的一个或多个方法，可以先做一个适配者类的子类，将适配者类的方法置换掉，然后再把适配者类的子类当做真正的适配者进行适配，实现过程较为复杂。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用适配器模式：</p><ul><li>系统需要使用一些现有的类，而这些类的接口（如方法名）不符合系统的需要，甚至没有这些类的源代码。</li><li>想创建一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类，包括一些可能在将来引进的类一起工作。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>结构型模式描述如何将类或者对象结合在一起形成更大的结构。</li><li>适配器模式用于将一个接口转换成客户希望的另一个接口，适配器模式使接口不兼容的那些类可以一起工作，其别名为包装器。适配器模式既可以作为类结构型模式，也可以作为对象结构型模式。</li><li>适配器模式包含四个角色：目标抽象类定义客户要用的特定领域的接口；适配器类可以调用另一个接口，作为一个转换器，对适配者和抽象目标类进行适配，它是适配器模式的核心；适配者类是被适配的角色，它定义了一个已经存在的接口，这个接口需要适配；在客户类中针对目标抽象类进行编程，调用在目标抽象类中定义的业务方法。</li><li>在类适配器模式中，适配器类实现了目标抽象类接口并继承了适配者类，并在目标抽象类的实现方法中调用所继承的适配者类的方法；在对象适配器模式中，适配器类继承了目标抽象类并定义了一个适配者类的对象实例，在所继承的目标抽象类方法中调用适配者类的相应业务方法。</li><li>适配器模式的主要优点是将目标类和适配者类解耦，增加了类的透明性和复用性，同时系统的灵活性和扩展性都非常好，更换适配器或者增加新的适配器都非常方便，符合“开闭原则”；类适配器模式的缺点是适配器类在很多编程语言中不能同时适配多个适配者类，对象适配器模式的缺点是很难置换适配者类的方法。</li><li>适配器模式适用情况包括：系统需要使用现有的类，而这些类的接口不符合系统的需要；想要建立一个可以重复使用的类，用于与一些彼此之间没有太大关联的一些类一起工作。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之原型模式</title>
      <link href="/posts/2018/246f0bcd.html"/>
      <url>/posts/2018/246f0bcd.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>原型模式(Prototype Pattern)</code></strong>使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</p><p>原型模式的工作原理很简单：将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。由于在软件系统中我们经常会遇到需要创建多个相同或者相似对象的情况，因此原型模式在真实开发中的使用频率还是非常高的。原型模式是一种“另类”的创建型模式，创建克隆对象的工厂就是原型类自身，工厂方法由克隆方法来实现。</p><p>需要注意的是通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。通过不同的方式修改可以得到一系列相似但不完全相同的对象。</p><blockquote><p>原型模式属于<strong><code>对象创建型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>原型模式包含如下角色：</p><ul><li><strong><code>Prototype(抽象原型类)：</code></strong>它是声明克隆方法的接口，是所有具体原型类的公共父类，可以是抽象类也可以是接口，甚至还可以是具体实现类。</li><li><strong><code>ConcretePrototype(具体原型类)：</code></strong>它实现在抽象原型类中声明的克隆方法，在克隆方法中返回自己的一个克隆对象。</li><li><strong><code>Client(客户端)：</code></strong>让一个原型对象克隆自身从而创建一个新的对象，在客户类中只需要直接实例化或通过工厂方法等方式创建一个原型对象，再通过调用该对象的克隆方法即可得到多个相同的对象。由于客户类针对抽象原型类 Prototype 编程，因此用户可以根据需要选择具体原型类，系统具有较好的可扩展性，增加或更换具体原型类都很方便。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/prototype_uml.jpg" alt="原型模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/prototype_seq.jpg" alt="原型模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象原型类。Object 类充当抽象原型类。</p><p>学过 Java 语言的人都知道，所有的 Java 类都继承自 <code>java.lang.Object</code>。事实上，<code>Object</code> 类提供一个 <code>clone()</code> 方法，可以将一个 Java 对象复制一份。因此在 Java 中可以直接使用 <code>Object</code> 提供的 <code>clone()</code> 方法来实现对象的克隆，Java 语言中的原型模式实现很简单。</p><blockquote><p>需要注意的是能够实现克隆的 Java 类必须实现一个标识接口 <code>Cloneable</code>，表示这个 Java 类支持被复制。如果一个类没有实现这个接口但是调用了 <code>clone()</code> 方法，Java 编译器将抛出一个 <code>CloneNotSupportedException</code> 异常。</p></blockquote><p>然后，是具体原型类。WeeklyLog 充当具体原型类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体原型类 */</span><span class="token keyword">class</span> <span class="token class-name">WeeklyLog</span> <span class="token keyword">implements</span> <span class="token class-name">Cloneable</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>    <span class="token keyword">private</span> String date<span class="token punctuation">;</span>    <span class="token keyword">private</span> String content<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setDate</span><span class="token punctuation">(</span>String date<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>date <span class="token operator">=</span> date<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setContent</span><span class="token punctuation">(</span>String content<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>content <span class="token operator">=</span> content<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>date<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>content<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 克隆方法clone()，此处使用Java语言提供的克隆机制</span>    <span class="token keyword">public</span> WeeklyLog <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Object obj <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            obj <span class="token operator">=</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span>WeeklyLog<span class="token punctuation">)</span> obj<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"不支持复制！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 原型模式的客户端场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PrototypeClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> CloneNotSupportedException <span class="token punctuation">{</span>        WeeklyLog weeklyLog1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeeklyLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">//创建原型对象</span>        weeklyLog1<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"张无忌"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weeklyLog1<span class="token punctuation">.</span><span class="token function">setDate</span><span class="token punctuation">(</span><span class="token string">"第1周"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        weeklyLog1<span class="token punctuation">.</span><span class="token function">setContent</span><span class="token punctuation">(</span><span class="token string">"这周工作很忙，每天加班！"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"****周报****"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"周次："</span> <span class="token operator">+</span> weeklyLog1<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名："</span> <span class="token operator">+</span> weeklyLog1<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"内容："</span> <span class="token operator">+</span> weeklyLog1<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"--------------------------------"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        WeeklyLog weeklyLog2 <span class="token operator">=</span> weeklyLog1<span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 调用克隆方法创建克隆对象</span>        weeklyLog2<span class="token punctuation">.</span><span class="token function">setDate</span><span class="token punctuation">(</span><span class="token string">"第2周"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"****周报****"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"周次："</span> <span class="token operator">+</span> weeklyLog2<span class="token punctuation">.</span><span class="token function">getDate</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"姓名："</span> <span class="token operator">+</span> weeklyLog2<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"内容："</span> <span class="token operator">+</span> weeklyLog2<span class="token punctuation">.</span><span class="token function">getContent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="浅克隆和深克隆"><a href="#浅克隆和深克隆" class="headerlink" title="浅克隆和深克隆"></a>浅克隆和深克隆</h2><p>克隆方法有两种：</p><ul><li>浅克隆(ShallowClone)</li><li>深克隆(DeepClone)</li></ul><p>在 Java 语言中，数据类型分为值类型（基本数据类型）和引用类型，值类型包括 <code>int</code>、<code>double</code>、<code>byte</code>、<code>boolean</code>、<code>char</code> 等简单数据类型，引用类型包括类、接口、数组等复杂类型。浅克隆和深克隆的主要区别在于<code>是否支持引用类型的成员变量的复制</code>，下面将对两者进行详细介绍。</p><h3 id="浅克隆"><a href="#浅克隆" class="headerlink" title="浅克隆"></a>浅克隆</h3><p>在浅克隆中，如果原型对象的成员变量是值类型，将复制一份给克隆对象；如果原型对象的成员变量是引用类型，则将引用对象的地址复制一份给克隆对象，也就是说原型对象和克隆对象的成员变量指向相同的内存地址。简单来说，在浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制。下图为浅克隆示意图：<br><img src="https://henleylee.github.io/medias/design_pattern/clone_shallow.jpg" alt="浅克隆示意图"></p><blockquote><p>在 Java 语言中，通过覆盖 <code>Object</code> 类的 <code>clone()</code> 方法可以实现浅克隆。</p></blockquote><h3 id="深克隆"><a href="#深克隆" class="headerlink" title="深克隆"></a>深克隆</h3><p>在深克隆中，无论原型对象的成员变量是值类型还是引用类型，都将复制一份给克隆对象，深克隆将原型对象的所有引用对象也复制一份给克隆对象。简单来说，在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。下图为深克隆示意图：<br><img src="https://henleylee.github.io/medias/design_pattern/clone_deep.jpg" alt="深克隆示意图"></p><blockquote><p>在 Java 语言中，如果需要实现深克隆，可以通过<code>序列化(Serialization)</code>等方式来实现。序列化就是将对象写到流的过程，写到流中的对象是原有对象的一个拷贝，而原对象仍然存在于内存中。通过序列化实现的拷贝不仅可以复制对象本身，而且可以复制其引用的成员对象，因此通过序列化将对象写到一个流中，再从流里将其读出来，可以实现深克隆。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>原型模式作为一种快速创建大量相同或相似对象的方式，在软件开发中应用较为广泛，很多软件提供的<code>复制(Ctrl + C)</code>和<code>粘贴(Ctrl + V)</code>操作就是原型模式的典型应用，下面对该模式的使用效果和适用情况进行简单的总结。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>原型模式的主要优点如下：</p><ul><li>当创建新的对象实例较为复杂时，使用原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</li><li>扩展性较好，由于在原型模式中提供了抽象原型类，在客户端可以针对抽象原型类进行编程，而将具体原型类写在配置文件中，增加或减少产品类对原有系统都没有任何影响。</li><li>原型模式提供了简化的创建结构，工厂方法模式常常需要有一个与产品类等级结构相同的工厂等级结构，而原型模式就不需要这样，原型模式中产品的复制是通过封装在原型类中的克隆方法实现的，无须专门的工厂类来创建产品。</li><li>可以使用深克隆的方式保存对象的状态，使用原型模式将对象复制一份并将其状态保存起来，以便在需要的时候使用(如恢复到某一历史状态)，可辅助实现撤销操作。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>原型模式的主要缺点如下：</p><ul><li>需要为每一个类配备一个克隆方法，而且该克隆方法位于一个类的内部，当对已有的类进行改造时，需要修改源代码，违背了“开闭原则”。</li><li>在实现深克隆时需要编写较为复杂的代码，而且当对象之间存在多重的嵌套引用时，为了实现深克隆，每一层对象对应的类都必须支持深克隆，实现起来可能会比较麻烦。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用原型模式：</p><ul><li>创建新对象成本较大(如初始化需要占用较长的时间，占用太多的CPU资源或网络资源)，新的对象可以通过原型模式对已有对象进行复制来获得，如果是相似对象，则可以对其成员变量稍作修改。</li><li>如果系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时，可以使用原型模式配合备忘录模式来实现。</li><li>需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态，通过复制原型对象得到新实例可能比使用构造函数创建一个新实例更加方便。</li></ul><h3 id="拓展"><a href="#拓展" class="headerlink" title="拓展"></a>拓展</h3><p>Java 语言提供的 <code>Cloneable</code> 接口和 <code>Serializable</code> 接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉 <code>JRE</code> 这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。</p><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>原型模式使用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li><li>原型模式的工作原理是将一个原型对象传给那个要发动创建的对象，这个要发动创建的对象通过请求原型对象拷贝自己来实现创建过程。</li><li>原型模式通过克隆方法所创建的对象是全新的对象，它们在内存中拥有新的地址，通常对克隆所产生的对象进行修改对原型对象不会造成任何影响，每一个克隆对象都是相互独立的。</li><li>原型模式可以简化对象的创建过程，通过复制一个已有实例可以提高新实例的创建效率。</li><li>建造者模式适用情况包括：创建新对象成本较大；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；系统要保存对象的状态，而对象的状态变化很小，或者对象本身占用内存较少时；需要避免使用分层次的工厂类来创建分层次的对象，并且类的实例对象只有一个或很少的几个组合状态。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之建造者模式</title>
      <link href="/posts/2018/8738b822.html"/>
      <url>/posts/2018/8738b822.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>无论是在现实世界中还是在软件系统中，都存在一些复杂的对象，它们拥有多个组成部分，如汽车，它包括车轮、方向盘、发动机等各种部件。而对于大多数用户而言，无须知道这些部件的装配细节，也几乎不会使用单独某个部件，而是使用一辆完整的汽车，可以通过建造者模式对其进行设计与描述，建造者模式可以将部件和其组装过程分开，一步一步创建一个复杂的对象。用户只需要指定复杂对象的类型就可以得到该对象，而无须知道其内部的具体构造细节。</p><p>在软件开发中，也存在大量类似汽车一样的复杂对象，它们拥有一系列成员属性，这些成员属性中有些是引用类型的成员对象。而且在这些复杂对象中，还可能存在一些限制条件，如某些属性没有赋值则复杂对象不能作为一个完整的产品使用；有些属性的赋值必须按照某个顺序，一个属性没有赋值之前，另一个属性可能无法赋值等。</p><p>复杂对象相当于一辆有待建造的汽车，而对象的属性相当于汽车的部件，建造产品的过程就相当于组合部件的过程。由于组合部件的过程很复杂，因此，这些部件的组合过程往往被“外部化”到一个称作建造者的对象里，建造者返还给客户端的是一个已经建造完毕的完整产品对象，而用户无须关心该对象所包含的属性以及它们的组装方式，这就是建造者模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>建造者模式(Builder Pattern)</code></strong>又可以称为生成器模式，将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。</p><p>建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。</p><blockquote><p>建造者模式属于<strong><code>对象创建型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="角色组成"><a href="#角色组成" class="headerlink" title="角色组成"></a>角色组成</h3><p>建造者模式包含如下角色：</p><ul><li><strong><code>Builder(抽象建造者)：</code></strong>它为创建一个产品 Product 对象的各个部件指定抽象接口，在该接口中一般声明两类方法，一类方法是 buildPartX()，它们用于创建复杂对象的各个部件；另一类方法是 getResult()，它们用于返回复杂对象。Builder 既可以是抽象类，也可以是接口。</li><li><strong><code>ConcreteBuilder(具体建造者)：</code></strong>它实现了 Builder 接口，实现各个部件的具体构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象。</li><li><strong><code>Product(产品角色)：</code></strong>它是被构建的复杂对象，包含多个组成部件，具体建造者创建该产品的内部表示并定义它的装配过程。</li><li><strong><code>Director(指挥者)：</code></strong>指挥者又称为导演类，它负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其 construct() 建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造。客户端一般只需要与指挥者进行交互，在客户端确定具体建造者的类型，并实例化具体建造者对象（也可以通过配置文件和反射机制），然后通过指挥者类的构造函数或者 Setter 方法将该对象传入指挥者类中。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/builder_uml.jpg" alt="建造者模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/builder_seq.jpg" alt="建造者模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是产品类。Product 类充当产品类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 产品类 */</span><span class="token keyword">class</span> <span class="token class-name">Product</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> String number<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 产品编号</span>    <span class="token keyword">private</span> String name<span class="token punctuation">;</span>     <span class="token comment" spellcheck="true">// 产品名称</span>    <span class="token keyword">private</span> String price<span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">// 产品价格</span>    <span class="token comment" spellcheck="true">/* getter 和 setter方法. */</span>    <span class="token keyword">public</span> String <span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> number<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setNumber</span><span class="token punctuation">(</span>String number<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>number <span class="token operator">=</span> number<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setName</span><span class="token punctuation">(</span>String name<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> String <span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> price<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPrice</span><span class="token punctuation">(</span>String price<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>price <span class="token operator">=</span> price<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其实，是抽象的建造者和具体的建造者。Builder 接口充当抽象的建造者，ConcreteBuilder 类充当具体的建造者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象的建造者 */</span><span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 需要建造的产品 */</span>    <span class="token keyword">protected</span> Product product <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Product</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 建造产品编号     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 建造产品名称     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 建造产品价格     */</span>    <span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">void</span> <span class="token function">buildPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 返回建造的产品     */</span>    <span class="token keyword">public</span> Product <span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> product<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 具体的建造者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConcreteBuilder</span> <span class="token keyword">implements</span> <span class="token class-name">Builder</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 建造产品名称     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setNumber</span><span class="token punctuation">(</span><span class="token string">"00001"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品建造部分B     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setName</span><span class="token punctuation">(</span><span class="token string">"小机器人"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 建造产品价格     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">buildPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        product<span class="token punctuation">.</span><span class="token function">setPrice</span><span class="token punctuation">(</span><span class="token string">"18.88"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是指挥者。Director 类充当具体的指挥者，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 指挥者 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Director</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 当前需要的建造者对象 */</span>    <span class="token keyword">private</span> Builder builder<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token function">Director</span><span class="token punctuation">(</span>Builder builder<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>builder <span class="token operator">=</span> builder<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 产品构建与组装方法     */</span>    <span class="token keyword">public</span> Product <span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        builder<span class="token punctuation">.</span><span class="token function">buildNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        builder<span class="token punctuation">.</span><span class="token function">buildPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> builder<span class="token punctuation">.</span><span class="token function">createProduct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 建造者模式的客户端场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">BuilderClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String<span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Builder builder <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ConcreteBuilder</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Director director <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Director</span><span class="token punctuation">(</span>builder<span class="token punctuation">)</span><span class="token punctuation">;</span>        Product product <span class="token operator">=</span> director<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品编号："</span> <span class="token operator">+</span> product<span class="token punctuation">.</span><span class="token function">getNumber</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品名称："</span> <span class="token operator">+</span> product<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"产品价格："</span> <span class="token operator">+</span> product<span class="token punctuation">.</span><span class="token function">getPrice</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>抽象建造者类中定义了产品的创建方法和返回方法;</p><p>建造者模式的结构中还引入了一个导演者类 <code>Director</code>，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。导演者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过导演者类调用建造者的相关方法，返回一个完整的产品对象</p><p>在客户端代码中，无须关心产品对象的具体组装过程，只需确定具体建造者的类型即可，建造者模式将复杂对象的构建与对象的表现分离开来，这样使得同样的构建过程可以创建出不同的表现。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>建造者模式的主要优点如下：</p><ul><li>在建造者模式中， 客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象。</li><li>每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者， 用户使用不同的具体建造者即可得到不同的产品对象 。</li><li>可以更加精细地控制产品的创建过程 。将复杂产品的创建步骤分解在不同的方法中，使得创建过程更加清晰，也更方便使用程序来控制创建过程。</li><li>增加新的具体建造者无须修改原有类库的代码，指挥者类针对抽象建造者类编程，系统扩展方便，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>建造者模式的主要缺点如下：</p><ul><li>建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，如果产品之间的差异性很大，则不适合使用建造者模式，因此其使用范围受到一定的限制。</li><li>如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用建造者模式：</p><ul><li>需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性。</li><li>需要生成的产品对象的属性相互依赖，需要指定其生成顺序。</li><li>对象的创建过程独立于创建该对象的类。在建造者模式中引入了指挥者类，将创建过程封装在指挥者类中，而不在建造者类中。</li><li>隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同的产品。</li></ul><h3 id="建造者模式与抽象工厂模式的比较"><a href="#建造者模式与抽象工厂模式的比较" class="headerlink" title="建造者模式与抽象工厂模式的比较"></a>建造者模式与抽象工厂模式的比较</h3><ul><li>与抽象工厂模式相比，建造者模式返回一个组装好的完整产品，而抽象工厂模式返回一系列相关的产品，这些产品位于不同的产品等级结构，构成了一个产品族。</li><li>在抽象工厂模式中，客户端实例化工厂类，然后调用工厂方法获取所需产品对象，而在建造者模式中，客户端可以不直接调用建造者的相关方法，而是通过指挥者类来指导如何生成对象，包括对象的组装过程和建造步骤，它侧重于一步步构造一个复杂对象，返回一个完整的对象。</li><li>如果将抽象工厂模式看成汽车配件生产工厂，生产一个产品族的产品，那么建造者模式就是一个汽车组装工厂，通过对部件的组装可以返回一辆完整的汽车。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>建造者模式将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示。建造者模式是一步一步创建一个复杂的对象，它允许用户只通过指定复杂对象的类型和内容就可以构建它们，用户不需要知道内部的具体构建细节。建造者模式属于对象创建型模式。</li><li>建造者模式包含如下四个角色：抽象建造者为创建一个产品对象的各个部件指定抽象接口；具体建造者实现了抽象建造者接口，实现各个部件的构造和装配方法，定义并明确它所创建的复杂对象，也可以提供一个方法返回创建好的复杂产品对象；产品角色是被构建的复杂对象，包含多个组成部件；指挥者负责安排复杂对象的建造次序，指挥者与抽象建造者之间存在关联关系，可以在其<code>construct()</code>建造方法中调用建造者对象的部件构造与装配方法，完成复杂对象的建造</li><li>在建造者模式的结构中引入了一个导演者类，该类的作用主要有两个：一方面它隔离了客户与生产过程；另一方面它负责控制产品的生成过程。指挥者针对抽象建造者编程，客户端只需要知道具体建造者的类型，即可通过指挥者类调用建造者的相关方法，返回一个完整的产品对象。</li><li>建造者模式的主要优点在于客户端不必知道产品内部组成的细节，将产品本身与产品的创建过程解耦，使得相同的创建过程可以创建不同的产品对象，每一个具体建造者都相对独立，而与其他的具体建造者无关，因此可以很方便地替换具体建造者或增加新的具体建造者，符合“开闭原则”，还可以更加精细地控制产品的创建过程；其主要缺点在于由于建造者模式所创建的产品一般具有较多的共同点，其组成部分相似，因此其使用范围受到一定的限制，如果产品的内部变化复杂，可能会导致需要定义很多具体建造者类来实现这种变化，导致系统变得很庞大。</li><li>建造者模式适用情况包括：需要生成的产品对象有复杂的内部结构，这些产品对象通常包含多个成员属性；需要生成的产品对象的属性相互依赖，需要指定其生成顺序；对象的创建过程独立于创建该对象的类；隔离复杂对象的创建和使用，并使得相同的创建过程可以创建不同类型的产品。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之抽象工厂模式</title>
      <link href="/posts/2018/da2ceb52.html"/>
      <url>/posts/2018/da2ceb52.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>抽象工厂模式(Abstract Factory Pattern)</code></strong>是围绕一个超级工厂创建其他工厂。该超级工厂又称为其他工厂的工厂，它提供了一种创建对象的最佳方式。</p><p>在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</p><blockquote><p>抽象工厂模式属于<strong><code>对象创建型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>抽象工厂模式包含如下角色：</p><ul><li><strong><code>AbstractProduct(抽象产品)：</code></strong>它为每种产品声明接口，在抽象产品中声明了产品所具有的业务方法。</li><li><strong><code>ConcreteProduct(具体产品)：</code></strong>它定义具体工厂生产的具体产品对象，实现抽象产品接口中声明的业务方法。</li><li><strong><code>AbstractFactory(抽象工厂)：</code></strong>它声明了一组用于创建一族产品的方法，每一个方法对应一种产品。</li><li><strong><code>ConcreteFactory(具体工厂)：</code></strong>它实现了在抽象工厂中声明的创建产品的方法，生成一组具体产品，这些产品构成了一个产品族，每一个产品都位于某个产品等级结构中。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/abatractfactory_uml.jpg" alt="抽象工厂模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/abatractfactory_seq.jpg" alt="抽象工厂模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象的产品类和具体的产品类。接口 Button、ComboBox 和 TextField 充当抽象产品，其子类 SpringButton、SpringComboBox、SpringTextField 和 SummerButton、SummerComboBox、SummerTextField 充当具体产品。完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 按钮接口：抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Spring按钮类：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">SpringButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示浅绿色按钮。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Summer按钮类：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">SummerButton</span> <span class="token keyword">implements</span> <span class="token class-name">Button</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示浅蓝色按钮。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 组合框接口：抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Spring组合框类：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">SpringComboBox</span> <span class="token keyword">implements</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示绿色边框组合框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Summer组合框类：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">SummerComboBox</span> <span class="token keyword">implements</span> <span class="token class-name">ComboBox</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示蓝色边框组合框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 文本框接口：抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Spring文本框类：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">SpringTextField</span> <span class="token keyword">implements</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示绿色边框文本框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment" spellcheck="true">/** * Summer文本框类：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">SummerTextField</span> <span class="token keyword">implements</span> <span class="token class-name">TextField</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"显示蓝色边框文本框。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>其次，是抽象的工厂类和具体的工厂类。SkinFactory 接口充当抽象工厂，其子类 SpringSkinFactory 和 SummerSkinFactory 充当具体工厂，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 界面皮肤工厂接口：抽象工厂 */</span><span class="token keyword">interface</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Spring皮肤工厂：具体工厂 */</span><span class="token keyword">class</span> <span class="token class-name">SpringSkinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * Summer皮肤工厂：具体工厂 */</span><span class="token keyword">class</span> <span class="token class-name">SummerSkinFactory</span> <span class="token keyword">implements</span> <span class="token class-name">SkinFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> Button <span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> ComboBox <span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> TextField <span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是工厂创造器/生成器类。FactoryProducer 类充当工厂创造器/生成器类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂创造器/生成器类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryProducer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> SkinFactory <span class="token function">getFactory</span><span class="token punctuation">(</span>String choice<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>choice<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"Spring"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SpringSkinFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>choice<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span><span class="token string">"Summer"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">SummerSkinFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> null<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 抽象工厂模式客户端场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AbstractFactoryClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        SkinFactory factory <span class="token operator">=</span> FactoryProducer<span class="token punctuation">.</span><span class="token function">getFactory</span><span class="token punctuation">(</span><span class="token string">"Spring"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>factory <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            Button button <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createButton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            ComboBox comboBox <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createComboBox</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            TextField textField <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createTextField</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            button<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            comboBox<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            textField<span class="token punctuation">.</span><span class="token function">display</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和 API 类库的设计中，例如在 Java 语言的 AWT(抽象窗口工具包)中就使用了抽象工厂模式，它使用抽象工厂模式来实现在不同的操作系统中应用程序呈现与所在操作系统一致的外观界面。抽象工厂模式也是在软件开发中最常用的设计模式之一。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>抽象工厂模式的主要优点如下：</p><ul><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li><li>当一个产品族中的多个对象被设计成一起工作时，它能够保证客户端始终只使用同一个产品族中的对象。</li><li>增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>抽象工厂模式的主要缺点如下：</p><ul><li>增加新的产品等级结构麻烦，需要对原有系统进行较大的修改，甚至需要修改抽象层代码，这显然会带来较大的不便，违背了“开闭原则”。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以考虑使用抽象工厂模式：</p><ul><li>一个系统不应当依赖于产品类实例如何被创建、组合和表达的细节，这对于所有类型的工厂模式都是很重要的，用户无须关心对象的创建过程，将对象的创建和使用解耦。</li><li>系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li><li>属于同一个产品族的产品将在一起使用，这一约束必须在系统的设计中体现出来。同一个产品族中的产品可以是没有任何关系的对象，但是它们都具有一些共同的约束，如同一操作系统下的按钮和文本框，按钮与文本框之间没有直接关系，但它们都是属于某一操作系统的，此时具有一个共同的约束条件：操作系统的类型。</li><li>产品等级结构稳定，设计完成之后，不会向系统中增加新的产品等级结构或者删除已有的产品等级结构。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>抽象工厂模式是围绕一个超级工厂创建其他工厂，它属于类创建型模式。在抽象工厂模式中，接口是负责创建一个相关对象的工厂，不需要显式指定它们的类。每个生成的工厂都能按照工厂模式提供对象。</li><li>抽象工厂模式是工厂方法模式的进一步延伸，由于它提供了功能更为强大的工厂类并且具备较好的可扩展性，在软件开发中得以广泛应用，尤其是在一些框架和 API 类库的设计中。</li><li>抽象工厂模式隔离了具体类的生成，使得客户并不需要知道什么被创建。由于这种隔离，更换一个具体工厂就变得相对容易，所有的具体工厂都实现了抽象工厂中定义的那些公共接口，因此只需改变具体工厂的实例，就可以在某种程度上改变整个软件系统的行为。</li><li>抽象工厂模式增加新的产品族很方便，无须修改已有系统，符合“开闭原则”。。</li><li>抽象工厂模式适用情况包括：系统中有多于一个的产品族，而每次只使用其中某一产品族。可以通过配置文件等方式来使得用户可以动态改变产品族，也可以很方便地增加新的产品族。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之工厂方法模式</title>
      <link href="/posts/2018/90801a9.html"/>
      <url>/posts/2018/90801a9.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>工厂方法模式(Factory Method Pattern)</code></strong>又称为工厂模式，也叫虚拟构造器(Virtual Constructor)模式或者多态工厂(Polymorphic Factory)模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</p><blockquote><p>工厂方法模式属于<strong><code>创建型模式</code></strong>。</p></blockquote><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>工厂方法模式包含如下角色：</p><ul><li><strong><code>Product(抽象产品)：</code></strong>它是定义产品的接口，是工厂方法模式所创建对象的超类型，也就是产品对象的公共父类。</li><li><strong><code>ConcreteProduct(具体产品)：</code></strong>它实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，具体工厂和具体产品之间一一对应。</li><li><strong><code>Factory(抽象工厂)：</code></strong>在抽象工厂类中，声明了工厂方法(Factory Method)，用于返回一个产品。抽象工厂是工厂方法模式的核心，所有创建对象的工厂类都必须实现该接口。</li><li><strong><code>ConcreteFactory(具体工厂)：</code></strong>它是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户端调用，返回一个具体产品类的实例。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/factorymethod_uml.jpg" alt="工厂方法模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/factorymethod_seq.jpg" alt="工厂方法模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><p>首先，是抽象的产品类和具体的产品类。Logger 接口充当抽象产品，其子类 FileLogger 和 DatabaseLogger 充当具体产品，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 日志记录器接口：抽象产品 */</span><span class="token keyword">interface</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 数据库日志记录器：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">DatabaseLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"数据库日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 文件日志记录器：具体产品 */</span><span class="token keyword">class</span> <span class="token class-name">FileLogger</span> <span class="token keyword">implements</span> <span class="token class-name">Logger</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"文件日志记录。"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>然后，是抽象的工厂类和具体的工厂类。Factory接口充当抽象工厂，其子类LoggerFactory充当具体工厂，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 日志记录器工厂接口：抽象工厂类 */</span><span class="token keyword">interface</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Logger</span><span class="token operator">></span> T <span class="token function">createLogger</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> cls<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 日志记录器工厂类：具体工厂 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggerFactory</span> <span class="token keyword">implements</span> <span class="token class-name">Factory</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/**     * 运用了Java中的泛型和反射技术,生成某种具体的产品(其输入类型可以自行设置)     */</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token operator">&lt;</span>T <span class="token keyword">extends</span> <span class="token class-name">Logger</span><span class="token operator">></span> T <span class="token function">createLogger</span><span class="token punctuation">(</span>Class<span class="token operator">&lt;</span>T<span class="token operator">></span> cls<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Logger logger <span class="token operator">=</span> null<span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            logger <span class="token operator">=</span> <span class="token punctuation">(</span>Logger<span class="token punctuation">)</span> Class<span class="token punctuation">.</span><span class="token function">forName</span><span class="token punctuation">(</span>cls<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            System<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"生产产品出错"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>T<span class="token punctuation">)</span> logger<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>最后，是客户端场景类，完整代码如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 工厂方法模式客户端场景类 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">FactoryMethodClient</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span>String args<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Factory factory <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Logger logger1 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createLogger</span><span class="token punctuation">(</span>DatabaseLogger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger1<span class="token punctuation">.</span><span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        Logger logger2 <span class="token operator">=</span> factory<span class="token punctuation">.</span><span class="token function">createLogger</span><span class="token punctuation">(</span>FileLogger<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        logger2<span class="token punctuation">.</span><span class="token function">writeLog</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责哪一个产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>工厂方法模式的主要优点如下：</p><ul><li>在工厂方法模式中，工厂方法用来创建客户所需要的产品，同时还向客户隐藏了哪种具体产品类将被实例化这一细节，用户只需要关心所需产品对应的工厂，无须关心创建细节，甚至无须知道具体产品类的类名。</li><li>基于工厂角色和产品角色的多态性设计是工厂方法模式的关键。它能够使工厂可以自主确定创建何种产品对象，而如何创建这个对象的细节则完全封装在具体工厂内部。工厂方法模式之所以又被称为多态工厂模式，是因为所有的具体工厂类都具有同一抽象父类。</li><li>使用工厂方法模式的另一个优点是在系统中加入新产品时，无须修改抽象工厂和抽象产品提供的接口，无须修改客户端，也无须修改其他的具体工厂和具体产品，而只要添加一个具体工厂和具体产品就可以了。这样，系统的可扩展性也就变得非常好，完全符合“开闭原则”。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>工厂方法模式的主要缺点如下：</p><ul><li>在添加新产品时，需要编写新的具体产品类，而且还要提供与之对应的具体工厂类，系统中类的个数将成对增加，在一定程度上增加了系统的复杂度，有更多的类需要编译和运行，会给系统带来一些额外的开销。</li><li>由于考虑到系统的可扩展性，需要引入抽象层，在客户端代码中均使用抽象层进行定义，增加了系统的抽象性和理解难度，且在实现时可能需要用到DOM、反射等技术，增加了系统的实现难度。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用工厂方法模式：</p><ul><li>一个类不知道它所需要的对象的类：在工厂方法模式中，客户端不需要知道具体产品类的类名，只需要知道所对应的工厂即可，具体的产品对象由具体工厂类创建；客户端需要知道创建具体产品的工厂类。</li><li>一个类通过其子类来指定创建哪个对象：在工厂方法模式中，对于抽象工厂类只需要提供一个创建产品的接口，而由其子类来确定具体要创建的对象，利用面向对象的多态性和里氏代换原则，在程序运行时，子类对象将覆盖父类对象，从而使得系统更容易扩展。</li><li>将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定，可将具体工厂类的类名存储在配置文件或数据库中。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>工厂方法模式又称为工厂模式，它属于类创建型模式。在工厂方法模式中，工厂父类负责定义创建产品对象的公共接口，而工厂子类则负责生成具体的产品对象，这样做的目的是将产品类的实例化操作延迟到工厂子类中完成，即通过工厂子类来确定究竟应该实例化哪一个具体产品类。</li><li>工厂方法模式包含四个角色：抽象产品是定义产品的接口，是工厂方法模式所创建对象的超类型，即产品对象的共同父类或接口；具体产品实现了抽象产品接口，某种类型的具体产品由专门的具体工厂创建，它们之间往往一一对应；抽象工厂中声明了工厂方法，用于返回一个产品，它是工厂方法模式的核心，任何在模式中创建对象的工厂类都必须实现该接口；具体工厂是抽象工厂类的子类，实现了抽象工厂中定义的工厂方法，并可由客户调用，返回一个具体产品类的实例。</li><li>工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了面向对象的多态性，工厂方法模式保持了简单工厂模式的优点，而且克服了它的缺点。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不负责产品类被实例化这种细节，这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。</li><li>工厂方法模式的主要优点是增加新的产品类时无须修改现有系统，并封装了产品对象的创建细节，系统具有良好的灵活性和可扩展性；其缺点在于增加新产品的同时需要增加新的工厂，导致系统类的个数成对增加，在一定程度上增加了系统的复杂性。</li><li>工厂方法模式适用情况包括：一个类不知道它所需要的对象的类；一个类通过其子类来指定创建哪个对象；将创建对象的任务委托给多个工厂子类中的某一个，客户端在使用时可以无须关心是哪一个工厂子类创建产品子类，需要时再动态指定。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式之单例模式</title>
      <link href="/posts/2018/44a28b10.html"/>
      <url>/posts/2018/44a28b10.html</url>
      
        <content type="html"><![CDATA[<h2 id="模式动机"><a href="#模式动机" class="headerlink" title="模式动机"></a>模式动机</h2><p>对于系统中的某些类来说，只有一个实例很重要，例如，一个系统中可以存在多个打印任务，但是只能有一个正在工作的任务；一个系统只能有一个窗口管理器或文件系统；一个系统只能有一个计时工具或 ID(序号)生成器。</p><p>如何保证一个类只有一个实例并且这个实例易于被访问呢？定义一个全局变量可以确保对象随时都可以被访问，但不能防止我们实例化多个对象。</p><p>一个更好的解决办法是让类自身负责保存它的唯一实例。这个类可以保证没有其他实例被创建，并且它可以提供一个访问该实例的方法。这就是单例模式的模式动机。</p><h2 id="模式定义"><a href="#模式定义" class="headerlink" title="模式定义"></a>模式定义</h2><p><strong><code>单例模式(Singleton Pattern)</code></strong>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式又名单件模式或单态模式。</p><blockquote><p>在计算机系统中，线程池、缓存、日志对象、对话框、打印机、显卡的驱动程序对象常被设计成单例。这些应用都或多或少具有资源管理器的功能。每台计算机可以有若干个打印机，但只能有一个Printer Spooler，以避免两个打印作业同时输出到打印机中。每台计算机可以有若干通信端口，系统应当集中管理这些通信端口，以避免一个通信端口同时被两个请求同时调用。总之，选择单例模式就是为了避免不一致状态，避免政出多头。</p></blockquote><blockquote><p>单例模式属于<strong><code>对象创建型模式</code></strong>。</p></blockquote><h2 id="模式特点"><a href="#模式特点" class="headerlink" title="模式特点"></a>模式特点</h2><p>单例模式的特点有三个：</p><ol><li>单例类只能有一个实例。</li><li>单例类必须自己创建自己的唯一实例。</li><li>单例类必须给所有其他对象提供这一实例。</li></ol><h2 id="模式结构"><a href="#模式结构" class="headerlink" title="模式结构"></a>模式结构</h2><h3 id="参与角色"><a href="#参与角色" class="headerlink" title="参与角色"></a>参与角色</h3><p>单例模式包含的角色只有一个：</p><ul><li><strong><code>Singleton(单例):</code></strong>在单例类的内部实现只生成一个实例，同时它提供一个静态的 getInstance() 工厂方法，让客户可以访问它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有；在单例类内部定义了一个 Singleton 类型的静态对象，作为外部共享的唯一实例。</li></ul><h3 id="结构图"><a href="#结构图" class="headerlink" title="结构图"></a>结构图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/singleton_uml.jpg" alt="单例模式结构图"></p><h3 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h3><p><img src="https://henleylee.github.io/medias/design_pattern/singleton_seq.jpg" alt="单例模式时序图"></p><h2 id="模式实现"><a href="#模式实现" class="headerlink" title="模式实现"></a>模式实现</h2><h3 id="非线程安全懒汉式-不推荐使用"><a href="#非线程安全懒汉式-不推荐使用" class="headerlink" title="非线程安全懒汉式(不推荐使用)"></a>非线程安全懒汉式(不推荐使用)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 非线程安全的懒汉式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取实例，但是非线程安全     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>非线程安全的懒汉式单例：使用懒加载的方式实现，但在多线程环境下可能会产生多个实例对象，非线程安全。不推荐使用。</p></blockquote><h3 id="线程安全懒汉式-不推荐使用"><a href="#线程安全懒汉式-不推荐使用" class="headerlink" title="线程安全懒汉式(不推荐使用)"></a>线程安全懒汉式(不推荐使用)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 线程安全的懒汉式，但是效率低下 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过 'synchronized' 关键字来保证线程安全，也是懒加载的方式来获取实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>线程安全的懒汉式单例：使用懒加载的方式实现，也线程安全，能够在多线程中很好的工作，但是效率低下，99% 的情况下不需要同步。不推荐使用。</p></blockquote><h3 id="双重校验锁线程安全懒汉式-推荐使用"><a href="#双重校验锁线程安全懒汉式-推荐使用" class="headerlink" title="双重校验锁线程安全懒汉式(推荐使用)"></a>双重校验锁线程安全懒汉式(推荐使用)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 双重校验锁线程安全懒汉式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> Singleton INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过'双重校验锁'来更高效的保证线程安全，也是懒加载的方式来获取实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>Singleton<span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>INSTANCE <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>双重校验锁线程安全懒汉式单例：通过双重校验锁使用懒加载的方式实现，也线程安全，且在多线程情况下能保持高性能。推荐使用。</p></blockquote><h3 id="饿汉式-推荐使用"><a href="#饿汉式-推荐使用" class="headerlink" title="饿汉式(推荐使用)"></a>饿汉式(推荐使用)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 饿汉式单例模式 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">/** 全局唯一实例 */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>饿汉式单例：在类加载初始化时就创建好一个静态的对象供外部使用，除非系统重启，这个对象不会改变，所以本身就是线程安全的。这种方式避免了多线程的同步问题，但不是懒加载。如果不需要懒加载的方式，推荐使用。</p></blockquote><h3 id="静态内部类-推荐使用"><a href="#静态内部类-推荐使用" class="headerlink" title="静态内部类(推荐使用)"></a>静态内部类(推荐使用)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通过使用静态内部类的方式来实现懒加载且线程安全的创建单例 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 静态内部类     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">class</span> <span class="token class-name">SingletonHolder</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> Singleton INSTANCE <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">/**     * 通过懒加载的方式获取唯一实例     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> Singleton <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> SingletonHolder<span class="token punctuation">.</span>INSTANCE<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>静态内部类单例：这种方式利用了 <code>ClassLoader</code> 的机制保证初始化 <code>INSTANCE</code> 时只有一个线程，其只有显示通过调用 <code>getInstance</code> 方法时，才会显示装载 <code>SingletonHolder</code> 类，从而实例化 <code>INSTANCE</code> 。推荐使用。</p></blockquote><h3 id="枚举-推荐使用"><a href="#枚举-推荐使用" class="headerlink" title="枚举(推荐使用)"></a>枚举(推荐使用)</h3><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">/** * 通过使用枚举的方式来实现且线程安全的创建单例 */</span><span class="token keyword">public</span> <span class="token keyword">enum</span> Singleton <span class="token punctuation">{</span>    INSTANCE<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><blockquote><p>枚举单例：在<code>《Effective Java》</code>一书中强烈推荐使用枚举来实现单例模式，该方式简单可自由序列化；保证只有一个实例(即使使用反射机制也无法多次实例化一个枚举量)；线程安全。唯一的缺点是非懒加载方式。推荐使用。</p></blockquote><h2 id="模式分析"><a href="#模式分析" class="headerlink" title="模式分析"></a>模式分析</h2><p>单例模式的目的是保证一个类仅有一个实例，并提供一个访问它的全局访问点。单例模式包含的角色只有一个，就是单例类 —— <code>Singleton</code>。</p><h3 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h3><p>单例模式的的主要优点如下：</p><ul><li>提供了对唯一实例的受控访问。因为单例类封装了它的唯一实例，所以它可以严格控制客户怎样以及何时访问它，并为设计及开发团队提供了共享的概念。</li><li>由于在系统内存中只存在一个对象，因此可以节约系统资源，对于一些需要频繁创建和销毁的对象，单例模式无疑可以提高系统的性能。</li><li>允许可变数目的实例。我们可以基于单例模式进行扩展，使用与单例控制相似的方法来获得指定个数的对象实例。</li></ul><h3 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h3><p>单例模式的的主要缺点如下：</p><ul><li>由于单例模式中没有抽象层，因此单例类的扩展有很大的困难。</li><li>单例类的职责过重，在一定程度上违背了“单一职责原则”。因为单例类既充当了工厂角色，提供了工厂方法，同时又充当了产品角色，包含一些业务方法，将产品的创建和产品的本身的功能融合到一起。</li><li>滥用单例将带来一些负面问题，如为了节省资源将数据库连接池对象设计为单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出；现在很多面向对象语言(如<code>Java</code>、<code>C#</code>)的运行环境都提供了自动垃圾回收的技术，因此，如果实例化的对象长时间不被利用，系统会认为它是垃圾，会自动销毁并回收资源，下次利用时又将重新实例化，这将导致对象状态的丢失。</li></ul><h3 id="适用环境"><a href="#适用环境" class="headerlink" title="适用环境"></a>适用环境</h3><p>在以下情况下可以使用单例模式：</p><ul><li>系统只需要一个实例对象，如系统要求提供一个唯一的序列号生成器，或者需要考虑资源消耗太大而只允许创建一个对象。</li><li>客户调用类的单个实例只允许使用一个公共访问点，除了该公共访问点，不能通过其他途径访问该实例。</li><li>在一个系统中要求一个类只有一个实例时才应当使用单例模式。反过来，如果一个类可以有几个实例共存，就需要对单例模式进行改进，使之成为多例模式。</li></ul><h2 id="模式总结"><a href="#模式总结" class="headerlink" title="模式总结"></a>模式总结</h2><ul><li>单例模式确保某一个类只有一个实例，而且自行实例化并向整个系统提供这个实例，这个类称为单例类，它提供全局访问的方法。单例模式的要点有三个：一是单例类只能有一个实例；二是单例类必须自行创建这个实例；三是单例类必须自行向整个系统提供这个实例。单例模式是一种对象创建型模式。</li><li>单例模式只包含一个单例角色：在单例类的内部实现只生成一个实例，同时它提供一个静态的工厂方法，让客户可以使用它的唯一实例；为了防止在外部对其实例化，将其构造函数设计为私有。</li><li>实现单例模式，如果不需要懒加载的效果，则推荐使用枚举和饿汉式的方式；如果需要懒加载的效果，则推荐使用静态内部类来实现更好。</li><li>单例模式的主要优点在于提供了对唯一实例的受控访问并可以节约系统资源；其主要缺点在于因为缺少抽象层而难以扩展，且单例类职责过重。</li><li>单例模式适用情况包括：系统只需要一个实例对象；客户调用类的单个实例只允许使用一个公共访问点。</li></ul><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Java 设计模式简介</title>
      <link href="/posts/2018/2c9d8138.html"/>
      <url>/posts/2018/2c9d8138.html</url>
      
        <content type="html"><![CDATA[<h2 id="设计模式简介"><a href="#设计模式简介" class="headerlink" title="设计模式简介"></a>设计模式简介</h2><p>设计模式(<code>Design pattern</code>)代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><p>设计模式是一套被反复使用的、多数人知晓的、经过分类编目的、代码设计经验的总结。使用设计模式是为了重用代码、让代码更容易被他人理解、保证代码可靠性。 毫无疑问，设计模式于己于他人于系统都是多赢的，设计模式使代码编制真正工程化，设计模式是软件工程的基石，如同大厦的一块块砖石一样。项目中合理地运用设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了一个在我们周围不断重复发生的问题，以及该问题的核心解决方案，这也是设计模式能被广泛应用的原因。</p><blockquote><p><strong>模式：在某些场景下，针对某类问题的某种通用的解决方案。</strong><br>场景：项目所在的环境<br>问题：约束条件，项目目标等<br>解决方案：通用、可复用的设计，解决约束达到目标。</p></blockquote><h2 id="设计模式的由来"><a href="#设计模式的由来" class="headerlink" title="设计模式的由来"></a>设计模式的由来</h2><p>在 1994 年，由 Erich Gamma、Richard Helm、Ralph Johnson 和 John Vlissides 四人合著出版了一本名为 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式-可复用的面向对象软件元素）的书，该书首次提到了软件开发中设计模式的概念。</p><p>四位作者合称 GOF（四人帮，全拼 Gang of Four）。他们所提出的设计模式主要是基于以下的面向对象设计原则：</p><ul><li>对接口编程而不是对实现编程。</li><li>优先使用对象组合而不是继承。</li></ul><h2 id="设计模式的使用"><a href="#设计模式的使用" class="headerlink" title="设计模式的使用"></a>设计模式的使用</h2><p>设计模式在软件开发中的两个主要用途：</p><ul><li>开发人员的共同平台：设计模式提供了一个标准的术语系统，且具体到特定的情景。例如，单例设计模式意味着使用单个对象，这样所有熟悉单例设计模式的开发人员都能使用单个对象，并且可以通过这种方式告诉对方，程序使用的是单例模式。</li><li>最佳的实践：设计模式已经经历了很长一段时间的发展，它们提供了软件开发过程中面临的一般问题的最佳解决方案。学习这些模式有助于经验不足的开发人员通过一种简单快捷的方式来学习软件设计。</li></ul><h2 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h2><h3 id="设计模式的三大分类"><a href="#设计模式的三大分类" class="headerlink" title="设计模式的三大分类"></a>设计模式的三大分类</h3><p>根据设计模式的参考书 Design Patterns - Elements of Reusable Object-Oriented Software（中文译名：设计模式-可复用的面向对象软件元素）中所提到的，总共有 <strong><code>23</code></strong> 种设计模式。这些模式可以分为三大类：</p><ul><li><strong>创建型模式(Creational Patterns)：</strong>对象实例化的模式，创建型模式用于解耦对象的实例化过程。</li><li><strong>结构型模式(Structural Patterns)：</strong>把类或对象结合在一起形成一个更大的结构。</li><li><strong>行为型模式(Behavioral Patterns)：</strong>类和对象如何交互，及划分责任和算法。</li></ul><p>如下图所示：<br><img src="https://henleylee.github.io/medias/design_pattern/design_pattern_category.jpg" alt="设计模式的类型"></p><h3 id="各分类中模式的关键点"><a href="#各分类中模式的关键点" class="headerlink" title="各分类中模式的关键点"></a>各分类中模式的关键点</h3><p>下面简单介绍一下各分类中模式的关键点：</p><ul><li><p>创建型模式（Creational Patterns）</p><ul><li>单例模式：保证一个类仅有一个实例，并提供一个访问它的全局访问点。</li><li>工厂方法模式：定义一个创建对象的接口，让其子类自己决定实例化哪一个工厂类，工厂模式使其创建过程延迟到子类进行。</li><li>抽象工厂模式：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。</li><li>建造者模式：将一个复杂的构建与其表示相分离，使得同样的构建过程可以创建不同的表示。</li><li>原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。</li></ul></li><li><p>结构型模式（Structural Patterns）</p><ul><li>适配器模式：将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类可以一起工作。</li><li>桥接模式：将抽象部分与实现部分分离，使它们都可以独立的变化。</li><li>组合模式：将对象组合成树形结构以表示”部分-整体”的层次结构，使得用户对单个对象和组合对象的使用具有一致性。</li><li>装饰模式：动态地给一个对象添加一些额外的职责。就增加功能来说，装饰器模式相比生成子类更为灵活。</li><li>外观模式：对外提供一个统一的方法，来访问子系统中的一群接口。</li><li>亨元模式：通过共享技术来有效的支持大量细粒度的对象。</li><li>代理模式：为其他对象提供一种代理以控制对这个对象的访问。</li></ul></li><li><p>行为型模式（Behavioral Patterns）</p><ul><li>模板模式：定义一个算法结构，而将一些步骤延迟到子类实现。</li><li>策略模式：定义一系列算法，把他们封装起来，并且使它们可以相互替换。</li><li>状态模式：允许对象在其内部状态发生改变时改变它的行为，对象看起来好像修改了它的类。</li><li>命令模式：将命令请求封装成一个对象，从而使得可以用不同的请求对客户进行参数化。</li><li>访问者模式：在不改变数据结构的前提下，增加作用于一组对象元素的新功能。</li><li>观察者模式：定义对象间的一种一对多的依赖关系，当一个对象的状态发生改变时，所有依赖于它的对象都得到通知并被自动更新。</li><li>解释器模式：给定一个语言，定义它的文法表示，并定义一个解释器，这个解释器使用该标识来解释语言中的句子。</li><li>备忘录模式：在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。</li><li>中介者模式：用一个中介对象来封装一系列的对象交互，中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立地改变它们之间的交互。</li><li>责任链模式：将请求的发送者和接收者解耦，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止。</li><li>迭代器模式：提供一种方法顺序访问一个聚合对象中各个元素, 而又无须暴露该对象的内部表示。</li></ul></li></ul><p>下面用一个图片来整体描述一下设计模式之间的关系：<br><img src="https://henleylee.github.io/medias/design_pattern/design_pattern_relation.jpg" alt="设计模式的类型"></p><h2 id="设计模式的七大原则"><a href="#设计模式的七大原则" class="headerlink" title="设计模式的七大原则"></a>设计模式的七大原则</h2><h3 id="开闭原则-Open-Close-Principle-OCP"><a href="#开闭原则-Open-Close-Principle-OCP" class="headerlink" title="开闭原则(Open Close Principle,OCP)"></a>开闭原则(Open Close Principle,OCP)</h3><p>开闭原则的意思是：对扩展开放，对修改关闭。也就是说，在程序需要进行拓展的时候，不能去修改原有的代码，实现一个热插拔的效果。简言之，是为了使程序的扩展性好，易于维护和升级。</p><h3 id="单一职责原则-Single-Responsibility-Principle-SRP"><a href="#单一职责原则-Single-Responsibility-Principle-SRP" class="headerlink" title="单一职责原则(Single Responsibility Principle,SRP)"></a>单一职责原则(Single Responsibility Principle,SRP)</h3><p>一个类，只有一个引起它变化的原因。应该只有一个职责。每一个职责都是变化的一个轴线。<br>一个类承担的职责过多，就相当于将这些职责耦合在一起，当其中一个职责变化时，可能会影响其他职责的运作，因此要将这些职责进行分离，将不同的职责封装在不同的类中，即将不同的变化原因封装在不同的类中，如果多个职责总是同时发生改变则可将它们封装在同一类中。<br>简单通俗的来说：一个类只负责一项职责。</p><h3 id="里氏替换原则-Liskov-Substitution-Principle-LSP"><a href="#里氏替换原则-Liskov-Substitution-Principle-LSP" class="headerlink" title="里氏替换原则(Liskov Substitution Principle,LSP)"></a>里氏替换原则(Liskov Substitution Principle,LSP)</h3><p>里氏代换原则是面向对象设计的基本原则之一。里氏代换原则中说，任何基类可以出现的地方，子类一定可以出现。<br>LSP 是继承复用的基石，只有当派生类可以替换掉基类，且软件单位的功能不受到影响时，基类才能真正被复用，而派生类也能够在基类的基础上增加新的行为。里氏代换原则是对开闭原则的补充。实现开闭原则的关键步骤就是抽象化，而基类与子类的继承关系就是抽象化的具体实现，所以里氏代换原则是对实现抽象化的具体步骤的规范。</p><h3 id="接口隔离原则-Interface-Segregation-Principle-ISP"><a href="#接口隔离原则-Interface-Segregation-Principle-ISP" class="headerlink" title="接口隔离原则(Interface Segregation Principle,ISP)"></a>接口隔离原则(Interface Segregation Principle,ISP)</h3><p>接口隔离原则是指：使用多个隔离的接口，比使用单个接口要好。它还有另外一个意思是：降低类之间的耦合度。由此可见，其实设计模式就是从大型软件架构出发、便于升级和维护的软件设计思想，它强调降低依赖，降低耦合。</p><h3 id="依赖倒置原则-Dependence-Inversion-Principle-DIP"><a href="#依赖倒置原则-Dependence-Inversion-Principle-DIP" class="headerlink" title="依赖倒置原则(Dependence Inversion Principle,DIP)"></a>依赖倒置原则(Dependence Inversion Principle,DIP)</h3><p>这个原则是开闭原则的基础，具体内容：针对接口编程，依赖于抽象而不依赖于具体。他主要有两个方面的内容：</p><ul><li>高层模块不应该依赖低层模块，他们都应该依赖于抽象；</li><li>抽象不应该依赖于具体实现，具体实现应该依赖于抽象。</li></ul><h3 id="迪米特法则-Demeter-Principle-DP"><a href="#迪米特法则-Demeter-Principle-DP" class="headerlink" title="迪米特法则(Demeter Principle,DP)"></a>迪米特法则(Demeter Principle,DP)</h3><p>迪米特法则，又称最少知道原则。为什么叫最少知道原则，就是说：一个实体应当尽量少的与其他实体之间发生相互作用，使得系统功能模块相对独立。</p><h3 id="合成复用原则-Composite-Reuse-Principle-CRP"><a href="#合成复用原则-Composite-Reuse-Principle-CRP" class="headerlink" title="合成复用原则(Composite Reuse Principle,CRP)"></a>合成复用原则(Composite Reuse Principle,CRP)</h3><p>合成复用原则是指：要尽量的使用合成和聚合的方式，而不是继承关系达到复用的目的。该原则就是在一个新的对象里面使用一些已有的对象，使之成为新对象的一部分：新的对象通过向这些对象的委派达到复用已有功能的目的。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.gitbook.com/book/quanke/design-pattern-java/" target="_blank" rel="noopener">Java Design Pattern</a></p>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>看懂 UML 类图和时序图</title>
      <link href="/posts/2018/5fd8d58a.html"/>
      <url>/posts/2018/5fd8d58a.html</url>
      
        <content type="html"><![CDATA[<p>这里不会将 UML 的各种元素都提到，我只想讲讲类图中各个类之间的关系；能看懂类图中各个类之间的线条、箭头代表什么意思后，也就足够应对 日常的工作和交流；同时，我们应该能将类图所表达的含义和最终的代码对应起来。</p><h2 id="UML类关系图示例"><a href="#UML类关系图示例" class="headerlink" title="UML类关系图示例"></a>UML类关系图示例</h2><p>请看以下这个类图，类之间的关系是我们需要关注的：<br><img src="https://henleylee.github.io/medias/design_pattern/uml_class_struct.jpg" alt="车的类图结构"></p><ul><li>车的类图结构为&lt;<abstract>&gt;，表示车是一个抽象类；</abstract></li><li>它有两个继承类：小汽车和自行车；它们之间的关系为实现关系，使用带空心箭头的虚线表示；</li><li>小汽车为与SUV之间也是继承关系，它们之间的关系为泛化关系，使用带空心箭头的实线表示；</li><li>小汽车与发动机之间是组合关系，使用带实心箭头的实线表示；</li><li>学生与班级之间是聚合关系，使用带空心箭头的实线表示；</li><li>学生与身份证之间为关联关系，使用一根实线表示；</li><li>学生上学需要用到自行车，与自行车是一种依赖关系，使用带箭头的虚线表示；</li></ul><h2 id="类之间的关系"><a href="#类之间的关系" class="headerlink" title="类之间的关系"></a>类之间的关系</h2><h3 id="泛化关系-generalization"><a href="#泛化关系-generalization" class="headerlink" title="泛化关系(generalization)"></a>泛化关系(generalization)</h3><p>类的继承结构表现在 UML 中为：泛化(generalize)与实现(realize)。</p><p><strong>继承</strong>指的是一个类（称为子类、子接口）继承另外的一个类（父类、父接口）的功能，并可以增加它自己的新功能的能力。<br><strong>继承关系为 <code>is-a</code> 的关系</strong>，是类与类或者接口与接口之间最常见的关系之一。在 Java 中继承关系通过关键字 <code>extends</code> 明确标识，在设计时一般没有争议性。</p><p>在 UML 类图设计中，<strong>泛化关系</strong>用一条<strong>带空心箭头的直接</strong>表示。如下图表示(A继承自B)：<br><img src="https://henleylee.github.io/medias/design_pattern/uml_generalization.jpg" alt="A继承自B"></p><blockquote><p><strong>注</strong>：表现在代码中，继承关系表现为一个类继承另一个类或者一个接口继承另一个接口。</p></blockquote><h3 id="实现关系-realization"><a href="#实现关系-realization" class="headerlink" title="实现关系(realization)"></a>实现关系(realization)</h3><p>在 UML 类图设计中，<strong>实现关系</strong>用一条<strong>带空心箭头的虚线</strong>表示。如下图所示(A实现B)：<br><img src="https://henleylee.github.io/medias/design_pattern/uml_realize.jpg" alt="A实现B"></p><p><strong>实现</strong>指的是一个 <code>class</code> 类实现 <code>interface</code> 接口（可以是多个）的功能。实现是类与接口之间最常见的关系之一，在 Java 中实现关系通过关键字 <code>implements</code> 来表示。</p><blockquote><p><strong>注意</strong>：表现在代码中，实现关系表现为<strong>普通类实现某个接口</strong>。</p></blockquote><h3 id="聚合关系-aggregation"><a href="#聚合关系-aggregation" class="headerlink" title="聚合关系(aggregation)"></a>聚合关系(aggregation)</h3><p>在 UML 类图设计中，<strong>聚合关系</strong>用一条<strong>带空心菱形箭头的直线</strong>表示。如下图所示(A聚合到B上，或者说B由A组成)：<br><img src="https://henleylee.github.io/medias/design_pattern/uml_aggregation.jpg" alt="A聚合到B"></p><p><strong>聚合关系</strong>用于表示实体对象之间的关系，表示整体由部分构成的意思。<br><strong>聚合是关联关系的一种特例，它体现的是整体与部分、拥有的关系，即 <code>has-a</code> 的关系</strong>，此时整体与部分之间是<strong>可分离</strong>的，他们可以具有各自的生命周期，部分可以属于多个整体对象，也可以为多个整体对象共享。例如一个部门由多个员工组成。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。聚合与组合不同的是，整体和部分不是强依赖的，即使整体不存在了，部分仍然存在；例如，部门撤销了，人员不会消失，他们依然存在。</p></blockquote><h3 id="组合关系-composition"><a href="#组合关系-composition" class="headerlink" title="组合关系(composition)"></a>组合关系(composition)</h3><p>在 UML 类图设计中，<strong>组合关系</strong>用一条<strong>带实心菱形箭头的直线</strong>表示。如下图表示(A组成B，或者B由A组成)：<br><img src="https://henleylee.github.io/medias/design_pattern/uml_composition.jpg" alt="A组合到B"></p><p><strong>组合</strong>关系同样表示整体由部分组成的意思。与聚合关系一样，<strong>组合也是关联关系的一种特例，它体现的是一种整体与部分不可分割的关系，即 <code>contains-a</code> 的关系，这种关系比聚合更强，也称为强聚合</strong>。例如公司由多个部门组成组合，但此时整体与部分是<strong>不可分离</strong>的，整体的生命周期结束也就意味着部分的生命周期结束。</p><blockquote><p><strong>注意</strong>：表现在代码中，和关联关系是一致的，只能从语义级别来区分。组合关系是一种强依赖的特殊聚合关系，如果整体不存在了，则部分也就不存在了。例如，公司不存在了，部门也将不存在了。</p></blockquote><h3 id="关联关系-association"><a href="#关联关系-association" class="headerlink" title="关联关系(association)"></a>关联关系(association)</h3><p>在 UML 类图设计中，<strong>关联</strong>关系是用一条<strong>可能会有方向的直线</strong>表示的。关联关系默认不强调方向，表示对象间相互知道；如果特别强调方向，如下图所示(表示A关联B，但B不关联A)：<br><img src="https://henleylee.github.io/medias/design_pattern/uml_association.jpg" alt="A关联B"></p><p><strong>关联</strong>关系体现的是两个类、或者类与接口之间语义级别的一种强依赖的结构关系，是一种长期的静态稳定的关系，通常与运行状态无关，一般由常识等因素决定的。</p><p>例如：乘车人和车票之间就是一种关联关系。</p><blockquote><p><strong>注意</strong>：表现在代码中，关联对象通常是以成员变量的形式实现的。</p></blockquote><h3 id="依赖关系-dependency"><a href="#依赖关系-dependency" class="headerlink" title="依赖关系(dependency)"></a>依赖关系(dependency)</h3><p>在 UML 类图设计中，<strong>依赖关系</strong>是用一套<strong>带箭头的虚线</strong>表示的。依赖关系描述一个对象在运行期间会用到另一个对象的关系，如下图所示(A依赖于B)。<br><img src="https://henleylee.github.io/medias/design_pattern/uml_dependency.jpg" alt="A依赖于B"></p><p><strong>依赖</strong>关系是一个类A使用到了另一个类B，而这种使用关系是具有偶然性的、临时性的、非常弱的，但是B类的变化会影响到A，与关联关系不同的是，它是一种<strong>临时性</strong>的关系，通常在运行期间产生，并且随着运行时的变化依赖关系也可能发生变化。</p><p>显然，依赖也有方向，双向依赖是一种非常糟糕的结构，我们总是应该保持单向依赖，杜绝双向依赖的产生。</p><blockquote><p><strong>注意</strong>：表现在代码中，依赖关系体现为<strong>类的构造方法及类方法的传入参数</strong>。</p></blockquote><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>对于继承、实现这两种关系没多少疑问，它们体现的是类和类、类与接口之间的纵向关系。其他的四种关系体现的是类与类、或者类与接口之间的引用、横向关系，是比较难区分的，有很多事物间的关系要想准确定位是很难的。前面也提到，这四种关系都是语义级别的，所以从代码层面并不能完全区分各种关系，但总的来说，后几种关系所表现的强弱程度依次为：组合&gt;聚合&gt;关联&gt;依赖。</p><h2 id="时序图"><a href="#时序图" class="headerlink" title="时序图"></a>时序图</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p><strong>时序图(Sequence Diagram)</strong>又名序列图、循序图，是一种UML交互图。时序图的重点是标记出某个行为的对象类和这些对象类之间所传递的消息及其时间顺序。另外时序图允许直观地表示出对象的生存期，在生存期内，对象可以对输入消息做出响应，并且可以发送消息。正是对象生存期的引入，时序图具备了时间顺序的概念，从而可以清晰地表示出对象在其生存期的某一个时刻的动态行为。这种时间概念的精确性使时序图在描述对象动态行为的时间特性方面具备了卓越的能力。</p><blockquote><p>UML 时序图是一个二维图形。其中纵轴是时间轴，时间沿竖线向下延伸；横轴代表了在写作中个独立的对象。</p></blockquote><h3 id="基本元素"><a href="#基本元素" class="headerlink" title="基本元素"></a>基本元素</h3><p>时序图包括的建模元素主要有：角色(Actor)、对象(Object)、生命线(Lifeline)、控制焦点(Focus of Control)、消息(Message)等等。</p><ul><li>角色：系统角色，可以是人、及其甚至其他的系统或者子系统。</li><li>对象：对象代表时序图中的对象在交互中所扮演的角色。对象包括三种命名方式：<ul><li>第一种方式包括对象名和类名；</li><li>第二中方式只显示类名不显示对象名，即表示他是一个匿名对象；</li><li>第三种方式只显示对象名不显示类名。</li></ul></li><li>生命线：生命线是一条垂直的虚线，从对象底部延伸出来的，表示时序图中对象存在的时间。时序图中每个对象和底部中心都有一条垂直的虚线，这就是对象的生命线，对象间的消息存在于两条虚线间。</li><li>控制焦点：控制焦点是顺序图中表示时间段的符号，在这个时间段内对象将执行相应的操作，在时序图中每条生命线上的窄的矩形代表活动期。</li><li>消息：对象之间发出的交互，显示为箭头。消息一般分为同步消息(Synchronous Message)、异步消息(Asynchronous Message)和返回消息(Return Message)：<ul><li>同步消息：用实心箭头表示。消息的发送者把控制传递给消息的接收者，然后停止活动，等待消息的接收者放弃或者返回控制。用来表示同步的意义。</li><li>异步消息：用线性箭头表示。消息发送者通过消息把信号传递给消息的接收者，然后继续自己的活动，不等待接受者返回消息或者控制。异步消息的接收者和发送者是并发工作的。</li><li>返回消息：用虚线的线性箭头表示。返回消息表示从过程调用返回。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> 设计模式 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 面向对象编程 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Java 编程规范</title>
      <link href="/posts/2018/cd0e4ea6.html"/>
      <url>/posts/2018/cd0e4ea6.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-前言"><a href="#1-前言" class="headerlink" title="1 前言"></a>1 前言</h2><p>这份文档是 <code>Google Java</code> 编程风格规范的完整定义。当且仅当一个 <code>Java</code> 源文件符合此文档中的规则，我们才认为它符合 <code>Google</code> 的 <code>Java</code> 编程风格。</p><p>与其它的编程风格指南一样，这里所讨论的不仅仅是编码格式美不美观的问题，同时也讨论一些约定及编码标准。然而，这份文档主要侧重于我们所普遍遵循的规则，对于那些不是明确强制要求的，我们尽量避免提供意见。</p><h3 id="1-1-术语说明"><a href="#1-1-术语说明" class="headerlink" title="1.1 术语说明"></a>1.1 术语说明</h3><p>本文档中除非特殊说明，否则：</p><ul><li>术语 <code>class</code> 可表示一个普通类、枚举类、接口或者注解。</li><li>术语 <code>comment</code> 只用来指代实现的注释(<code>implementation comments</code>)，我们不使用文档注释(<code>documentation comments</code>)一词，而是用 <code>Javadoc</code>。</li></ul><p>其他术语说明，将在文档中需要说明的地方单独说明。</p><h3 id="1-2-指南说明"><a href="#1-2-指南说明" class="headerlink" title="1.2 指南说明"></a>1.2 指南说明</h3><p>本文档中的示例代码并不作为规范。也就是说，虽然示例代码是遵循 Google 编程风格，但并不意味着这是展现这些代码的唯一方式。示例中的格式选择不应该被强制定为规则。</p><h2 id="2-源文件基础"><a href="#2-源文件基础" class="headerlink" title="2 源文件基础"></a>2 源文件基础</h2><h3 id="2-1-文件名"><a href="#2-1-文件名" class="headerlink" title="2.1 文件名"></a>2.1 文件名</h3><p>源文件以其最顶层的类名来命名，大小写敏感，文件扩展名为 <code>.java</code>。</p><h3 id="2-2-文件编码：UTF-8"><a href="#2-2-文件编码：UTF-8" class="headerlink" title="2.2 文件编码：UTF-8"></a>2.2 文件编码：UTF-8</h3><p>源文件编码格式使用 <code>UTF-8</code>。</p><h3 id="2-3-特殊字符"><a href="#2-3-特殊字符" class="headerlink" title="2.3 特殊字符"></a>2.3 特殊字符</h3><h4 id="2-3-1-空格字符"><a href="#2-3-1-空格字符" class="headerlink" title="2.3.1 空格字符"></a>2.3.1 空格字符</h4><p>除了换行符外，<code>ASCII</code> 水平空格字符(0x20，即空格)是源文件中唯一允许出现的空白字符，这意味着：</p><ul><li>所有其他空白字符将被转义。</li><li><code>Tab</code> 字符不被用作缩进控制。</li></ul><h4 id="2-3-2-特殊转义字符串"><a href="#2-3-2-特殊转义字符串" class="headerlink" title="2.3.2 特殊转义字符串"></a>2.3.2 特殊转义字符串</h4><p>对于具有特殊<a href="https://docs.oracle.com/javase/tutorial/java/data/characters.html" target="_blank" rel="noopener">转义序列</a>的任何字符(<code>\b</code>, <code>\t</code>, <code>\n</code>, <code>\f</code>, <code>\r</code>, <code>\&#39;</code>, <code>\&quot;</code>, <code>\\</code>等)，我们使用它的转义序列，而不是相应的八进制(比如<code>\012</code>)或 Unicode(比如<code>\u000a</code>)转义。</p><h4 id="2-3-3-非-ASCII-字符"><a href="#2-3-3-非-ASCII-字符" class="headerlink" title="2.3.3 非 ASCII 字符"></a>2.3.3 非 ASCII 字符</h4><p>对于其余的非 <code>ASCII</code> 字符，是直接使用 <code>Unicode</code> 字符(例如 <code>∞</code>)，还是使用对应的 <code>Unicode</code> 码（例如：<code>\u221e</code>）转义，都是允许的。<strong>唯一需要考虑的是，何种方式更能使代码容易阅读和理解</strong>。</p><blockquote><p><strong>注意</strong>：在使用<code>Unicode</code>码转义，或者甚至是有时直接使用 <code>Unicode</code> 字符的时候，建议多添加一些注释说明，将对别人读懂代码很有帮助。</p></blockquote><p>例子：</p><table><thead><tr><th>示例</th><th>结论</th></tr></thead><tbody><tr><td>String unitAbbrev = “μs”;</td><td>赞：即使没有注释也非常清晰。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // “μs”</td><td>允许，但没有理由要这样做。</td></tr><tr><td>String unitAbbrev = “\u03bcs”; // Greek letter mu, “s”</td><td>允许，但这样做显得笨拙还容易出错。</td></tr><tr><td>String unitAbbrev = “\u03bcs”;</td><td>很糟：读者根本看不出这是什么。</td></tr><tr><td>return ‘\ufeff’ + content; // byte order mark</td><td>很好：对于非打印字符，使用转义，并在必要时写上注释。</td></tr></tbody></table><blockquote><p><strong>注意</strong>：永远不要由于害怕某些程序可能无法正确处理非 <code>ASCII</code> 字符而让你的代码可读性变差。当程序无法正确处理非 <code>ASCII</code> 字符时，它自然无法正确运行，你就会去 <code>fix</code> 这些问题的了。(言下之意就是大胆去用非 <code>ASCII</code> 字符，如果真的有需要的话)</p></blockquote><h2 id="3-源文件结构"><a href="#3-源文件结构" class="headerlink" title="3 源文件结构"></a>3 源文件结构</h2><p>源文件按照先后顺序，由以下几部分组成：</p><ul><li>许可证(<code>License</code>)或版权信息(<code>copyright</code>)（如果需要）</li><li><code>package</code> 语句</li><li><code>import</code> 语句</li><li><code>class</code> 类声明（每个源码文件只能有唯一一个顶级 <code>class</code>）。</li></ul><blockquote><p><strong>注意</strong>：以上每个部分之间用一个空行隔开。</p></blockquote><h3 id="3-1-许可证或版权信息"><a href="#3-1-许可证或版权信息" class="headerlink" title="3.1 许可证或版权信息"></a>3.1 许可证或版权信息</h3><p>如果一个文件包含许可证或版权信息，那么它应当被放在文件最前面。</p><h3 id="3-2-package-语句"><a href="#3-2-package-语句" class="headerlink" title="3.2 package 语句"></a>3.2 package 语句</h3><p><code>package</code>语句不换行，单行长度限制(4.4节)不适用于package语句。(即package语句写在一行里)</p><h3 id="3-3-import-语句"><a href="#3-3-import-语句" class="headerlink" title="3.3 import 语句"></a>3.3 import 语句</h3><h4 id="3-3-1-import-不使用通配符"><a href="#3-3-1-import-不使用通配符" class="headerlink" title="3.3.1 import 不使用通配符"></a>3.3.1 import 不使用通配符</h4><p><code>import</code> 语句中不应该使用通配符，不管是否是静态导入。即，不要出现类似这样的 import 语句：<code>import java.util.*;</code></p><h4 id="3-3-2-import-不换行"><a href="#3-3-2-import-不换行" class="headerlink" title="3.3.2 import 不换行"></a>3.3.2 import 不换行</h4><p><code>import</code> 语句不换行，列限制(4.4节)并不适用于 <code>import</code> 语句。(每个 <code>import</code> 语句独立成行)</p><h4 id="3-3-3-顺序和间距"><a href="#3-3-3-顺序和间距" class="headerlink" title="3.3.3 顺序和间距"></a>3.3.3 顺序和间距</h4><p><code>import</code> 语句可分为以下几组，按照顺序，每组由一个空行分隔：</p><ul><li>所有的静态导入(static import)归为一组</li><li><code>com.google</code> 包的 <code>import</code> 归为一组，(仅当这个源文件是在 <code>com.google</code> 包下)</li><li>使用的第三方包的导入，每个顶级按字典顺序归为一组。例如：android, com, junit, org, sun</li><li><code>java</code> 包归为一组</li><li><code>javax</code> 包归为一组</li></ul><blockquote><p><strong>注意</strong>：同一组内的 <code>import</code> 语句之间不使用空行隔开，按字典序排列。</p></blockquote><h3 id="3-4-类声明"><a href="#3-4-类声明" class="headerlink" title="3.4 类声明"></a>3.4 类声明</h3><h4 id="3-4-1-只声明唯一一个顶级类声明"><a href="#3-4-1-只声明唯一一个顶级类声明" class="headerlink" title="3.4.1 只声明唯一一个顶级类声明"></a>3.4.1 只声明唯一一个顶级类声明</h4><p>每个顶级类都在一个与它同名的源文件中(包含 .java 后缀)。</p><p>例外：package-info.java，该文件中可没有 package-info 类。</p><h4 id="3-4-2-类成员顺序"><a href="#3-4-2-类成员顺序" class="headerlink" title="3.4.2 类成员顺序"></a>3.4.2 类成员顺序</h4><p>类成员的顺序对代码的易读性有很大影响，但是没有一个统一正确的标准。不同的类可能有不同的排序方式。</p><p>最重要的一点，<strong>每个类应该以某种逻辑去排序它的成员，维护者应该要能解释这种排序逻辑</strong>。比如，新的方法不能总是习惯性地添加到类的结尾，因为这样就是按时间顺序而非某种逻辑来排序的。</p><h5 id="3-4-2-1-重载：永不分离"><a href="#3-4-2-1-重载：永不分离" class="headerlink" title="3.4.2.1 重载：永不分离"></a>3.4.2.1 重载：永不分离</h5><p>当一个类有多个构造函数，或是多个同名方法，这些方法应该按顺序出现在一起，中间不要放进其它方法。</p><h2 id="4-格式"><a href="#4-格式" class="headerlink" title="4 格式"></a>4 格式</h2><blockquote><p><strong>术语说明</strong>：块状结构(<code>block-­like construct</code>)指的是一个类，方法或构造函数的主体。需要注意的是，数组初始化中的初始值可被选择性地视为块状结构(4.8.3.1节)。</p></blockquote><h3 id="4-1-大括号"><a href="#4-1-大括号" class="headerlink" title="4.1 大括号"></a>4.1 大括号</h3><h4 id="4-1-1-使用大括号-即使是可选的"><a href="#4-1-1-使用大括号-即使是可选的" class="headerlink" title="4.1.1 使用大括号(即使是可选的)"></a>4.1.1 使用大括号(即使是可选的)</h4><p>大括号一般用在 <code>if</code>, <code>else</code>, <code>for</code>, <code>do</code>, <code>while</code> 等语句，即使只有一条语句(或是空)，也应该把大括号写上。</p><h4 id="4-1-2-非空语句块采用-K-amp-R-风格"><a href="#4-1-2-非空语句块采用-K-amp-R-风格" class="headerlink" title="4.1.2 非空语句块采用 K &amp; R 风格"></a>4.1.2 非空语句块采用 <code>K &amp; R</code> 风格</h4><p>对于非空语句块，大括号遵循 <code>Kernighan</code> 和 <code>Ritchie</code> 风格 (<a href="https://blog.codinghorror.com/new-programming-jargon/" target="_blank" rel="noopener">Egyptian brackets</a>):</p><ul><li>左大括号前不换行</li><li>左大括号后换行</li><li>右大括号前换行</li><li>如果右大括号结束是一个<code>语句块</code>或者<code>方法体</code>、<code>构造函数体</code>或者<code>有命名的类体</code>，则需要换行。当右括号后面接 <code>else</code> 或者<code>逗号</code>时，不应该换行。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">method</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">condition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token function">something</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ProblemException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">recover</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">otherCondition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token function">somethingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                <span class="token function">lastThing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>一些例外的情况，将在<code>4.8.1</code>节讲<code>枚举类型</code>的时候讲到。</p><h4 id="4-1-3-空语句块：使代码更简洁"><a href="#4-1-3-空语句块：使代码更简洁" class="headerlink" title="4.1.3 空语句块：使代码更简洁"></a>4.1.3 空语句块：使代码更简洁</h4><p>一个空的语句块，可以在左大括号之后直接接右大括号，中间不需要空格或换行。但是当一个由几个语句块联合组成的语句块时，则需要换行(例如：<code>if/else</code> 或者 <code>try/catch/finally</code>)。</p><p>示例：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 这是可接受的</span>    <span class="token keyword">void</span> <span class="token function">doNothing</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 这同样是可接受的</span>    <span class="token keyword">void</span> <span class="token function">doNothingElse</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span></code></pre><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">// 这是不可接受的：多块语句中没有简洁的空语句块</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token function">doSomething</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Exception</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></code></pre><h3 id="4-2块缩进：2个空格"><a href="#4-2块缩进：2个空格" class="headerlink" title="4.2块缩进：2个空格"></a>4.2块缩进：2个空格</h3><p>每当一个新的语句块产生，缩进就增加两个空格。当这个语句块结束时，缩进恢复到上一层级的缩进格数。缩进要求对整个语句块中的代码和注释都适用。（例子可参考之前4.1.2节中的例子）。</p><blockquote><p><strong>注意</strong>：根据实际的编程经验，<code>2</code>个空格缩进的代码在当前大屏的计算机上会显得十分拥挤，反而使得代码<code>臃肿</code>不够美观。所以，我这里建议使用<code>4</code>个空格来缩进，会使得更加美观，而且能侧面督促开发人员减少代码的嵌套层数。</p></blockquote><h3 id="4-3-一行一个语句"><a href="#4-3-一行一个语句" class="headerlink" title="4.3 一行一个语句"></a>4.3 一行一个语句</h3><p>每条语句结束都需要换行。</p><h3 id="4-4-列长度限制：100"><a href="#4-4-列长度限制：100" class="headerlink" title="4.4 列长度限制：100"></a>4.4 列长度限制：100</h3><p>Java代码的列长度限制为 <code>100个</code> 字符。 除了如下所述，任何超过此限制的行都必须跳行。这在4.5节会有详细解释。</p><p>例外：</p><ul><li>不可能满足行长度限制的行(例如，Javadoc 中的一个长 URL，或是一个长的 JSNI 方法参考)</li><li><code>package</code> 和 <code>import</code> 语句(见3.2节和3.3节)</li><li>注释中那些可能被剪切并粘贴到 shell 中的命令行</li></ul><blockquote><p><strong>注意</strong>：当前的计算机屏幕都已经比很宽了，而且变量及方法命名都较长，<code>100</code>个字符的长度反而会出现很多不必要的跳行，已经不适应当今的情况了，根据实际编程经验，我这里建议使用<code>120</code>个字符的宽度更为合适。</p></blockquote><h3 id="4-5-换行"><a href="#4-5-换行" class="headerlink" title="4.5 换行"></a>4.5 换行</h3><p><strong>术语说明</strong>：一般情况下，一行长代码为了避免超出列限制(<code>100</code> 个字符)而被分为多行，我们称之为断行(<code>line­-wrapping</code>)。</p><p>我们并没有全面，确定性的准则来决定在每一种情况下如何断行。很多时候，对于同一段代码会有好几种有效的换断行方式。</p><blockquote><p><strong>注意</strong>: 提取<code>方法</code>或<code>局部变量</code>可以解决问题，而不不需要进行断行。</p></blockquote><h4 id="4-5-1-在何处断行"><a href="#4-5-1-在何处断行" class="headerlink" title="4.5.1 在何处断行"></a>4.5.1 在何处断行</h4><p>断行的主要原则是：<strong>选择在更高级的语法逻辑处断行</strong>。其他一些原则如下：</p><ul><li>当一个<code>非赋值运算</code>的语句断行时，在运算符号之前断行。注意：这一点与 Google 其它语言的编程风格不同(如 C++ 和 JavaScript)。</li><li>如果要在<code>非赋值运算符</code>处断行，那么在该符号前断开(比如<code>+</code>操作符，它将位于下一行)。以下的<code>类运算符</code>也可作为参考：<ul><li>点操作符<code>.</code></li><li>类型界限中的<code>&amp;</code>、<code>||</code>等（例如：<code>&lt;T extends Foo &amp; Bar&gt;</code>)</li></ul></li><li>当要在一个<code>赋值运算</code>语句处断行时，一般在赋值符号之后断行。但是也可以在之前断行。(例如：<code>=</code>，它与前面的内容留在同一行)。<ul><li>这条规则也适用于<code>foreach</code>语句中的冒号。</li></ul></li><li>方法名或构造函数名与左括号留在同一行。</li><li>逗号(<code>,</code>)与其前面的内容留在同一行。也就是在逗号之后断行。</li><li><code>Lambda</code> 表达式在箭头符号(<code>-&gt;</code>)后断行。</li></ul><p>示例：</p><pre class=" language-java"><code class="language-java">    MyLambda<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Long<span class="token punctuation">,</span> Object<span class="token operator">></span> lambda <span class="token operator">=</span>        <span class="token punctuation">(</span>String label<span class="token punctuation">,</span> Long value<span class="token punctuation">,</span> Object obj<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>            <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>        <span class="token punctuation">}</span><span class="token punctuation">;</span>    Predicate<span class="token operator">&lt;</span>String<span class="token operator">></span> predicate <span class="token operator">=</span> str <span class="token operator">-</span><span class="token operator">></span>        <span class="token function">longExpressionInvolving</span><span class="token punctuation">(</span>str<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><blockquote><p><strong>注意</strong>：换行的主要目标是使代码更清晰易读。</p></blockquote><h4 id="4-5-2-断行的缩进：至少-4个空格"><a href="#4-5-2-断行的缩进：至少-4个空格" class="headerlink" title="4.5.2 断行的缩进：至少+4个空格"></a>4.5.2 断行的缩进：至少+4个空格</h4><p>自动换行时，第一行后的每一行至少比第一行多缩进 <code>4</code> 个空格(注意：制表符不用于缩进。见2.3.1节)。</p><p>当存在连续自动换行时，缩进可能会多缩进不只 <code>4</code> 个空格(语法元素存在多级时)。一般而言，两个连续行使用相同的缩进当且仅当它们开始于同级语法元素。</p><p>第4.6.3水平对齐一节中指出，不鼓励使用可变数目的空格来对齐前面行的符号。</p><h3 id="4-6-空白"><a href="#4-6-空白" class="headerlink" title="4.6 空白"></a>4.6 空白</h3><h4 id="4-6-1-垂直空白"><a href="#4-6-1-垂直空白" class="headerlink" title="4.6.1 垂直空白"></a>4.6.1 垂直空白</h4><p>以下情况需要使用单行空行：</p><ul><li>类成员之间需要单个空行隔开：例如：<code>字段</code>，<code>构造函数</code>，<code>方法</code>，<code>嵌套类</code>，<code>静态初始化块</code>，<code>实例初始化块</code>。但也有以下两种例外情况：<ul><li>两个连续字段之间的空行是可选的，根据需要使用空行来创建字段间的逻辑分组。</li><li>枚举常量之间的的空行也是可选的，根据需要使用空行来创建枚举常量间的逻辑分组。</li></ul></li><li>在方法体内，根据代码的逻辑分组的需要，设置空白行作为间隔。</li><li>类的第一个成员之前或最后一个成员之后，使用空行(可选)。</li><li>本文档所介绍的其他章节的空行要求(比如3.3节：<code>import</code> 语句)。</li></ul><h4 id="4-6-2-水平空白"><a href="#4-6-2-水平空白" class="headerlink" title="4.6.2 水平空白"></a>4.6.2 水平空白</h4><p>除了语法、其他规则、词语分隔、注释和javadoc外，水平的ASCII空格只在以下情况出现：</p><ul><li>所有保留的关键字与紧接它之后的位于同一行的左大括号之间需要用空格隔开。(例如：<code>if</code>, <code>for</code> <code>catch</code> 等)</li><li>所有保留的关键字与在它之前的右大括号之间需要空格隔开。（例如：<code>else</code>、<code>catch</code>）</li><li>在左大括号之前都需要空格隔开。只有两种例外：<ul><li><code>@SomeAnnotation({a, b})</code></li><li><code>String[][] x = foo;</code></li></ul></li><li>所有的二元运算符和三元运算符的两边，都需要空格隔开。(例如：<code>a + b</code>、<code>b = a &lt; 0 ? 0 : a</code>)</li><li>逗号(<code>,</code>)、冒号(<code>:</code>)、分号(<code>;</code>)和右小括号(<code>)</code>)、Lambda 箭头符号(<code>-&gt;</code>)之后，需要空格隔开。</li><li><code>//</code>双斜线开始一行注释时，双斜线两边都应该用空格隔开。并且可使用多个空格。(可选，例如：<code>a = 0; // 赋值为0</code>)</li><li>变量声明时，变量类型和变量名之间需要用空格隔开。(例如：<code>List&lt;String&gt; list</code>)</li><li>初始化一个数组时，花括号之间可以用空格隔开，也可以不使用。(可选，例如：<code>new int[] {5, 6}</code>和<code>new int[] { 5, 6 }</code>)</li></ul><blockquote><p><strong>注意</strong>：这个规则并不要求或禁止一行的开关或结尾需要额外的空格，只对内部空格做要求。</p></blockquote><h4 id="4-6-3-水平对齐：不做要求"><a href="#4-6-3-水平对齐：不做要求" class="headerlink" title="4.6.3 水平对齐：不做要求"></a>4.6.3 水平对齐：不做要求</h4><blockquote><p><strong>术语说明</strong>：水平对齐，是指通过添加多个空格，使本行的某一符号与上一行的某一符号上下对齐。</p></blockquote><p>这种对齐是被允许的，但是不会做强制要求。</p><p>以下是没有水平对齐和水平对齐的例子：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">private</span> <span class="token keyword">int</span> x<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 这种挺好</span>    <span class="token keyword">private</span> Color color<span class="token punctuation">;</span>   <span class="token comment" spellcheck="true">// 同上</span>    <span class="token keyword">private</span> <span class="token keyword">int</span>   x<span class="token punctuation">;</span>      <span class="token comment" spellcheck="true">// 允许，但是未来会继续编辑</span>    <span class="token keyword">private</span> Color color<span class="token punctuation">;</span>  <span class="token comment" spellcheck="true">// 可能会使它对不齐</span></code></pre><blockquote><p><strong>注意</strong>：水平对齐能够增加代码的可读性，但是增加了未来维护代码的难度。考虑到维护时只需要改变一行代码，之前的对齐可以不需要改动。为了对齐，你更有可能改了一行代码，同时需要更改附近的好几行代码，而这几行代码的改动，可能又会引起一些为了保持对齐的代码改动。那原本这行改动，我们称之为<strong>爆炸半径</strong>。这种改动，在最坏的情况下可能会导致大量的无意义的工作，即使在最好的情况下，也会影响版本历史信息，减慢代码<code>review</code>的速度，引起更多<code>merge</code>代码冲突的情况。</p></blockquote><h3 id="4-7-分组小括号：推荐使用"><a href="#4-7-分组小括号：推荐使用" class="headerlink" title="4.7 分组小括号：推荐使用"></a>4.7 分组小括号：推荐使用</h3><p>除非作者和 <code>reviewer</code> 都认为去掉小括号也不会使代码被误解，或是去掉小括号能让代码更易于阅读，否则我们不应该去掉小括号。我们没有理由假设读者能记住整个 Java 运算符优先级表。</p><h3 id="4-8-特殊结构"><a href="#4-8-特殊结构" class="headerlink" title="4.8 特殊结构"></a>4.8 特殊结构</h3><h4 id="4-8-1-枚举类型"><a href="#4-8-1-枚举类型" class="headerlink" title="4.8.1 枚举类型"></a>4.8.1 枚举类型</h4><p>枚举常量间用逗号隔开，换行是可选的。而且还允许附加的空行(通常只有一个)。以下就是一种可能性的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Answer <span class="token punctuation">{</span>    YES <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> String <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token string">"yes"</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span>    NO<span class="token punctuation">,</span>    MAYBE<span class="token punctuation">}</span></code></pre><p>没有方法和 Javadoc 的枚举类可写成数组初始化的格式：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">enum</span> Suit <span class="token punctuation">{</span> CLUBS<span class="token punctuation">,</span> HEARTS<span class="token punctuation">,</span> SPADES<span class="token punctuation">,</span> DIAMONDS <span class="token punctuation">}</span></code></pre><p>由于枚举类也是一个类，因此所有适用于其它类的格式规则也适用于枚举类。</p><h4 id="4-8-2-变量声明"><a href="#4-8-2-变量声明" class="headerlink" title="4.8.2 变量声明"></a>4.8.2 变量声明</h4><h5 id="4-8-2-1-每次声明一个变量"><a href="#4-8-2-1-每次声明一个变量" class="headerlink" title="4.8.2.1 每次声明一个变量"></a>4.8.2.1 每次声明一个变量</h5><p>不要使用组合声明。例如：<code>int a, b;</code>是不允许的。</p><h5 id="4-8-2-2-需要时才声明，尽快进行初始化"><a href="#4-8-2-2-需要时才声明，尽快进行初始化" class="headerlink" title="4.8.2.2 需要时才声明，尽快进行初始化"></a>4.8.2.2 需要时才声明，尽快进行初始化</h5><p>不要在一个代码块的开头把局部变量一次性都声明了(这是 c 语言的做法)，而是在第一次需要使用它时才声明。局部变量在声明时最好就进行初始化，或者声明后尽快进行初始化。</p><h4 id="4-8-3-数组"><a href="#4-8-3-数组" class="headerlink" title="4.8.3 数组"></a>4.8.3 数组</h4><h5 id="4-8-3-1-数组初始化：可写成块状结构"><a href="#4-8-3-1-数组初始化：可写成块状结构" class="headerlink" title="4.8.3.1 数组初始化：可写成块状结构"></a>4.8.3.1 数组初始化：可写成块状结构</h5><p>数组初始化可以写成块状结构，例如以下格式的写法都是允许的：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>           <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>      <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>            <span class="token number">0</span><span class="token punctuation">,</span>    <span class="token punctuation">}</span>                       <span class="token number">1</span><span class="token punctuation">,</span>                            <span class="token number">2</span><span class="token punctuation">,</span>    <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span>             <span class="token number">3</span><span class="token punctuation">,</span>      <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span>               <span class="token punctuation">}</span>      <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span>    <span class="token punctuation">}</span>                     <span class="token keyword">new</span> <span class="token class-name">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span>                              <span class="token punctuation">{</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">}</span></code></pre><h5 id="4-8-3-2-非C风格的数组声明"><a href="#4-8-3-2-非C风格的数组声明" class="headerlink" title="4.8.3.2 非C风格的数组声明"></a>4.8.3.2 非C风格的数组声明</h5><p>中括号是类型的一部分：<code>String[] args</code>， 而非<code>String args[]</code>。</p><h4 id="4-8-4-switch语句"><a href="#4-8-4-switch语句" class="headerlink" title="4.8.4 switch语句"></a>4.8.4 switch语句</h4><p><strong>术语说明</strong>：<code>switch</code> 块的大括号内是一个或多个语句组。每个语句组包含一个或多个 <code>switch</code> 标签(<code>case FOO:</code> 或 <code>default:</code>)，后面跟着一条或多条语句。</p><h5 id="4-8-4-1-缩进"><a href="#4-8-4-1-缩进" class="headerlink" title="4.8.4.1 缩进"></a>4.8.4.1 缩进</h5><p>和其他语句块一样，<code>switch</code> 大括号之后缩进两个字符。每个 <code>switch</code> 标签之后，后面紧接的非标签的新行，按照大括号相同的处理方式缩进两个字符。在标签结束后，恢复到之前的缩进，类似大括号结束。</p><h5 id="4-8-4-2-继续向下执行的注释"><a href="#4-8-4-2-继续向下执行的注释" class="headerlink" title="4.8.4.2 继续向下执行的注释"></a>4.8.4.2 继续向下执行的注释</h5><p>在一个 <code>switch</code> 块内，每个语句组要么通过 <code>break</code>、<code>continue</code>、<code>return</code> 或<code>抛出异常</code>来终止，要么通过一条注释来说明程序将继续执行到下一个语句组，任何能表达这个意思的注释都是可以的(典型的是用<code>// fall through</code>)。这个特殊的注释并不需要在最后一个语句组(一般是 <code>default</code>)中出现。例如：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">switch</span> <span class="token punctuation">(</span>input<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> <span class="token number">1</span><span class="token operator">:</span>        <span class="token keyword">case</span> <span class="token number">2</span><span class="token operator">:</span>            <span class="token function">prepareOneOrTwo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// fall through</span>        <span class="token keyword">case</span> <span class="token number">3</span><span class="token operator">:</span>            <span class="token function">handleOneTwoOrThree</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">default</span><span class="token operator">:</span>            <span class="token function">handleLargeNumber</span><span class="token punctuation">(</span>input<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><blockquote><p><strong>注意</strong>：在<code>case 1</code>之后不需要该注释，仅在语句组的末尾。</p></blockquote><h5 id="4-8-4-3-default-标签需要显式声明"><a href="#4-8-4-3-default-标签需要显式声明" class="headerlink" title="4.8.4.3 default 标签需要显式声明"></a>4.8.4.3 default 标签需要显式声明</h5><p>每个 <code>switch</code> 语句中，都需要显式声明 <code>default</code> 标签。即使没有任何代码也需要显示声明。</p><blockquote><p><strong>注意</strong>：枚举类型的 <code>switch</code> 语句可以省略 <code>default</code> 语句组，如果它包含覆盖该类型的所有可能值的显式情况。这使得IDE或其他静态分析工具能够在丢失任何情况时发出警告。</p></blockquote><h4 id="4-8-5-注解"><a href="#4-8-5-注解" class="headerlink" title="4.8.5 注解"></a>4.8.5 注解</h4><p>注解应用到类、方法或者构造方法时，应紧接 <code>Javadoc</code> 之后。每一行只有一个注解。注解所在行不受列长度限制，也不需要增加缩进。例如：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span>    <span class="token annotation punctuation">@Nullable</span>    <span class="token keyword">public</span> String <span class="token function">getNameIfPresent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p><strong>例外</strong>：如果注解只有一个，并且不带参数。则它可以和类或方法名放在同一行。例如：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Override</span> <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>注解应用到成员变量时，也是紧接 <code>Javadoc</code> 之后。不同的是，多个注解可以放在同一行。例如：</p><pre class=" language-java"><code class="language-java">    <span class="token annotation punctuation">@Partial</span> <span class="token annotation punctuation">@Mock</span> DataLoader loader<span class="token punctuation">;</span></code></pre><p>对于参数或者局部变量使用注解的情况，没有特定的规范。</p><h4 id="4-8-6-注释"><a href="#4-8-6-注释" class="headerlink" title="4.8.6 注释"></a>4.8.6 注释</h4><h5 id="4-8-6-1-块注释风格"><a href="#4-8-6-1-块注释风格" class="headerlink" title="4.8.6.1 块注释风格"></a>4.8.6.1 块注释风格</h5><p>注释的缩进与它所注释的代码缩进相同。可以采用 <code>/* */</code> 进行注释，也可以用 <code>//</code> 进行注释。当使用 <code>/* */</code> 进行多行注释时，每一行都应该以<code>*</code>开始，并且<code>*</code>应该上下对齐。</p><p>例如：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/*     * This is     * okay.     */</span>    <span class="token comment" spellcheck="true">// And so</span>    <span class="token comment" spellcheck="true">// is this.</span>    <span class="token comment" spellcheck="true">/* Or you can     * even do this. */</span></code></pre><blockquote><p><strong>注意</strong>：多行注释时，如果你希望集成开发环境能自动对齐注释，你应该使用 <code>/* */</code>，<code>//</code> 一般不会自动对齐。</p></blockquote><h4 id="4-8-7-修饰符"><a href="#4-8-7-修饰符" class="headerlink" title="4.8.7 修饰符"></a>4.8.7 修饰符</h4><p>类和成员变量的修饰符，按 <code>Java Lauguage Specification</code> 中介绍的先后顺序排序。具体是：</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">protected</span> <span class="token keyword">private</span> <span class="token keyword">abstract</span> <span class="token keyword">default</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">transient</span> <span class="token keyword">volatile</span> <span class="token keyword">synchronized</span> <span class="token keyword">native</span> <span class="token keyword">strictfp</span></code></pre><h4 id="4-8-8-数字字面量"><a href="#4-8-8-数字字面量" class="headerlink" title="4.8.8 数字字面量"></a>4.8.8 数字字面量</h4><p>长整型的数字字面量使用大写的 <code>L</code> 作为后缀，不得使用小写(避免与数字1混淆)。例如：使用 <code>3000000000L</code>，而不是 <code>3000000000l</code>。</p><h2 id="5-命名约定"><a href="#5-命名约定" class="headerlink" title="5 命名约定"></a>5 命名约定</h2><h3 id="5-1-对所有标识符都通用的规则"><a href="#5-1-对所有标识符都通用的规则" class="headerlink" title="5.1 对所有标识符都通用的规则"></a>5.1 对所有标识符都通用的规则</h3><p>标识符只能使用 <code>ASCII</code> 字母和数字，因此每个有效的标识符名称都能匹配正则表达式 <code>\w+</code>。</p><p>在 Google 其它编程语言风格中使用的特殊前缀或后缀，如 <code>name_</code>, <code>mName</code>, <code>s_name</code> 和 <code>kName</code>，在 Java 编程风格中都不再使用。</p><h3 id="5-2-标识符类型的规则"><a href="#5-2-标识符类型的规则" class="headerlink" title="5.2 标识符类型的规则"></a>5.2 标识符类型的规则</h3><h4 id="5-2-1-包名"><a href="#5-2-1-包名" class="headerlink" title="5.2.1 包名"></a>5.2.1 包名</h4><p>包名全部小写，连续的单词只是简单地连接起来，不使用下划线。例如：使用 <code>com.example.deepspace</code>，而不是 <code>com.example.deepSpace</code> 或者 <code>com.example.deep_space</code>。</p><h4 id="5-2-2-类名"><a href="#5-2-2-类名" class="headerlink" title="5.2.2 类名"></a>5.2.2 类名</h4><p>类名都以 <code>UpperCamelCase</code> 风格编写。</p><p>类名通常是名词或名词短语。例如：<code>Character</code> 或者 <code>ImmutableList</code>。接口名称也可以是名词或名词短语（例如：<code>List</code>），但有时可能是形容词或形容词短语(例如：<code>Readable</code>)。现在还没有特定的规则或行之有效的约定来命名注解类型。</p><p>测试类的命名以它要测试的类的名称开始，以 <code>Test</code> 结束。例如：<code>HashTest</code> 或 <code>HashIntegrationTest</code>。</p><h4 id="5-2-3-方法名"><a href="#5-2-3-方法名" class="headerlink" title="5.2.3 方法名"></a>5.2.3 方法名</h4><p>方法名都以 <code>lowerCamelCase</code> 风格编写。</p><p>方法名通常是动词或动词短语。例如：<code>sendMessage</code> 或者 <code>stop</code>。</p><p>下划线可能出现在 JUnit 测试方法名称中用以分隔名称的逻辑组件。一个典型的模式是：<code>test&lt;MethodUnderTest&gt;_&lt;state&gt;</code>，例如：<code>testPop_emptyStack</code>。 并不存在唯一正确的方式来命名测试方法。</p><h4 id="5-2-4-常量名"><a href="#5-2-4-常量名" class="headerlink" title="5.2.4 常量名"></a>5.2.4 常量名</h4><p>常量名命名模式为 <code>CONSTANT_CASE</code>，全部字母大写，用下划线分隔单词。那到底什么算是一个常量呢？</p><p>每个常量都是一个静态 <code>final</code> 字段，其内容是不可变的，且没有可检测的副作用。这包括原始类型、字符串、不可变类型和不可变类型的不可变集合。如果任何一个实例的观测状态是可变的，则它肯定不会是一个常量。只是永远不打算改变对象也是不够的。例如：</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 常量</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> NUMBER <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableList<span class="token operator">&lt;</span>String<span class="token operator">></span> NAMES <span class="token operator">=</span> ImmutableList<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> Integer<span class="token operator">></span> AGES <span class="token operator">=</span> ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> <span class="token number">35</span><span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> <span class="token number">32</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Joiner COMMA_JOINER <span class="token operator">=</span> Joiner<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 因为Joiner是不可变的</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> SomeMutableType<span class="token punctuation">[</span><span class="token punctuation">]</span> EMPTY_ARRAY <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token keyword">enum</span> SomeEnum <span class="token punctuation">{</span> ENUM_CONSTANT <span class="token punctuation">}</span>    <span class="token comment" spellcheck="true">// 非常量</span>    <span class="token keyword">static</span> String nonFinal <span class="token operator">=</span> <span class="token string">"non-final"</span><span class="token punctuation">;</span>    <span class="token keyword">final</span> String nonStatic <span class="token operator">=</span> <span class="token string">"non-static"</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Set<span class="token operator">&lt;</span>String<span class="token operator">></span> mutableCollection <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashSet</span><span class="token operator">&lt;</span>String<span class="token operator">></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableSet<span class="token operator">&lt;</span>SomeMutableType<span class="token operator">></span> mutableElements <span class="token operator">=</span> ImmutableSet<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span>mutable<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> ImmutableMap<span class="token operator">&lt;</span>String<span class="token punctuation">,</span> SomeMutableType<span class="token operator">></span> mutableValues <span class="token operator">=</span>        ImmutableMap<span class="token punctuation">.</span><span class="token function">of</span><span class="token punctuation">(</span><span class="token string">"Ed"</span><span class="token punctuation">,</span> mutableInstance<span class="token punctuation">,</span> <span class="token string">"Ann"</span><span class="token punctuation">,</span> mutableInstance2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> Logger logger <span class="token operator">=</span> Logger<span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span>MyClass<span class="token punctuation">.</span><span class="token function">getName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">static</span> <span class="token keyword">final</span> String<span class="token punctuation">[</span><span class="token punctuation">]</span> nonEmptyArray <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"these"</span><span class="token punctuation">,</span> <span class="token string">"can"</span><span class="token punctuation">,</span> <span class="token string">"change"</span><span class="token punctuation">}</span><span class="token punctuation">;</span></code></pre><p>这些常量的名字通常是名词或名词短语。</p><h4 id="5-2-5-非常量字段名"><a href="#5-2-5-非常量字段名" class="headerlink" title="5.2.5 非常量字段名"></a>5.2.5 非常量字段名</h4><p>非常量字段名以 <code>lowerCamelCase</code> 风格编写。</p><p>这些名字通常是名词或名词短语。例如：<code>computedValues</code> 或者 <code>index</code>。</p><h4 id="5-2-6-参数名"><a href="#5-2-6-参数名" class="headerlink" title="5.2.6 参数名"></a>5.2.6 参数名</h4><p>参数名以<code>lowerCamelCase</code>风格编写。</p><p>参数应该避免用单个字符命名。</p><h4 id="5-2-7-局部变量名"><a href="#5-2-7-局部变量名" class="headerlink" title="5.2.7 局部变量名"></a>5.2.7 局部变量名</h4><p>局部变量名以 <code>lowerCamelCase</code> 风格编写。</p><p>即使局部变量是 <code>final</code> 和<code>不可改变</code>的，也不应该把它示为常量，当然也就不能用常量的规则去命名它。</p><h4 id="5-2-8-类型变量名"><a href="#5-2-8-类型变量名" class="headerlink" title="5.2.8 类型变量名"></a>5.2.8 类型变量名</h4><p>类型变量可用以下两种风格之一进行命名：</p><ul><li>单个的大写字母，后面可以视具体情况跟一个数字(如：<code>E</code>, <code>T</code>, <code>X</code>, <code>T2</code>)。</li><li>以类命名方式(5.2.2节)，后面加个大写的T(如：<code>RequestT</code>, <code>FooBarT</code>)。</li></ul><h3 id="5-3-驼峰式命名法-CamelCase"><a href="#5-3-驼峰式命名法-CamelCase" class="headerlink" title="5.3 驼峰式命名法(CamelCase)"></a>5.3 驼峰式命名法(CamelCase)</h3><p><a href="https://zh.wikipedia.org/wiki/駝峰式大小寫" target="_blank" rel="noopener"><strong>驼峰式命名法</strong></a>分大驼峰式命名法(<code>UpperCamelCase</code>)和小驼峰式命名法(<code>lowerCamelCase</code>)。有时，我们有不只一种合理的方式将一个英语词组转换成驼峰形式，如缩略语或不寻常的结构(例如：<code>IPv6</code>或<code>iOS</code>)。Google指定了以下的转换方案。</p><p>名字从散文形式(prose form)开始:</p><ul><li>把短语转换为纯 <code>ASCII</code> 码，并且移除任何单引号。例如：<code>Müller’s algorithm</code> 将变成 <code>Muellers algorithm</code>。</li><li>把这个结果切分成单词，在空格或其它标点符号(通常是连字符)处分割开。<ul><li><strong>推荐</strong>：如果某个单词已经有了常用的驼峰表示形式，按它的组成将它分割开(如 <code>AdWords</code> 将分割成 <code>ad words</code>)。</li><li>需要注意的是 iOS 并不是一个真正的驼峰表示形式，因此该推荐对它并不适用。</li></ul></li><li>现在将所有字母都小写(包括缩写)，然后将单词的第一个字母大写：<ul><li>每个单词的第一个字母都大写，来得到大驼峰式命名。</li><li>除了第一个单词，每个单词的第一个字母都大写，来得到小驼峰式命名。</li></ul></li><li>最后将所有的单词连接起来得到一个标识符。</li></ul><p>示例：</p><table><thead><tr><th>散文形式</th><th>正确</th><th>不正确</th></tr></thead><tbody><tr><td>“XML HTTP request”</td><td>XmlHttpRequest</td><td>XMLHTTPRequest</td></tr><tr><td>“new customer ID”</td><td>newCustomerId</td><td>newCustomerID</td></tr><tr><td>“inner stopwatch”</td><td>innerStopwatch</td><td>innerStopWatch</td></tr><tr><td>“supports IPv6 on iOS?”</td><td>supportsIpv6OnIos</td><td>supportsIPv6OnIOS</td></tr><tr><td>“YouTube importer”</td><td>YouTubeImporter YoutubeImporter*</td></tr></tbody></table><p>加 <code>^</code> 号处表示可以，但不推荐。</p><blockquote><p><strong>注意</strong>：在英语中，某些带有连字符的单词形式不唯一。例如：<code>nonempty</code> 和 <code>non-empty</code> 都是正确的，因此方法名 <code>checkNonempty</code> 和 <code>checkNonEmpty</code> 也都是正确的。</p></blockquote><h2 id="6-编程实践"><a href="#6-编程实践" class="headerlink" title="6 编程实践"></a>6 编程实践</h2><h3 id="6-1-Override：总是使用"><a href="#6-1-Override：总是使用" class="headerlink" title="6.1 @Override：总是使用"></a>6.1 <code>@Override</code>：总是使用</h3><p>只要是合法的方法，就把 <code>@Override</code> 注解加上。这包括覆盖超类方法的类方法，实现接口方法的类方法。</p><p><strong>例外</strong>：当父方法为 <code>@Deprecated</code> 时，可以省略 <code>@Override</code> 。</p><h3 id="6-2-捕获的异常：不能忽视"><a href="#6-2-捕获的异常：不能忽视" class="headerlink" title="6.2 捕获的异常：不能忽视"></a>6.2 捕获的异常：不能忽视</h3><p>除了下面的例子，对捕获的异常不做任何响应是极少的。(典型的响应方式是打印日志，或者如果它被认为是不可能的，则把它当作一个 <code>AssertionError</code> 重新抛出。)</p><p>如果它确实是不需要在 <code>catch</code> 块中做任何响应，需要做注释加以说明(如下面的例子)。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">try</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> i <span class="token operator">=</span> Integer<span class="token punctuation">.</span><span class="token function">parseInt</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">handleNumericResponse</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NumberFormatException</span> ok<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// 它不是一个数字，不过没关系，继续</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token function">handleTextResponse</span><span class="token punctuation">(</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>例外：在测试中，如果一个捕获的异常被命名为 <code>expected</code>，则它可以被不加注释地忽略。下面是一种非常常见的情形，用以确保所测试的方法会抛出一个期望中的异常， 因此在这里就没有必要加注释。</p><pre class=" language-java"><code class="language-java">    <span class="token keyword">try</span> <span class="token punctuation">{</span>        emptyStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">fail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">NoSuchElementException</span> expected<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span></code></pre><h3 id="6-3-静态成员：使用类来调用"><a href="#6-3-静态成员：使用类来调用" class="headerlink" title="6.3 静态成员：使用类来调用"></a>6.3 静态成员：使用类来调用</h3><p>使用类名调用静态的类成员，而不是具体某个对象或表达式。</p><pre class=" language-java"><code class="language-java">Foo aFoo <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span>Foo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 好</span>aFoo<span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 糟</span><span class="token function">somethingThatYieldsAFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">aStaticMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// 很糟</span></code></pre><h3 id="6-4-Finalizers-禁用"><a href="#6-4-Finalizers-禁用" class="headerlink" title="6.4 Finalizers: 禁用"></a>6.4 <code>Finalizers</code>: 禁用</h3><p>极少会去重载 <code>Object.finalize</code>。</p><blockquote><p><strong>注意</strong>：不要使用 <code>finalize</code>。如果你非要使用它，请先仔细阅读和理解 <a href="https://legacy.gitbook.com/book/zhengyq/effective-java-2/" target="_blank" rel="noopener"><code>Effective Java</code></a><code>第7条款</code>：“Avoid Finalizers”，然后不要使用它。</p></blockquote><h2 id="7-Javadoc"><a href="#7-Javadoc" class="headerlink" title="7 Javadoc"></a>7 Javadoc</h2><h3 id="7-1-格式"><a href="#7-1-格式" class="headerlink" title="7.1 格式"></a>7.1 格式</h3><h4 id="7-1-1-一般形式"><a href="#7-1-1-一般形式" class="headerlink" title="7.1.1 一般形式"></a>7.1.1 一般形式</h4><p><code>Javadoc</code> 块的基本格式如下所示：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * Multiple lines of Javadoc text are written here,     * wrapped normally...     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">method</span><span class="token punctuation">(</span>String p1<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span></code></pre><p>或者是以下单行形式：</p><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/** An especially short bit of Javadoc. */</span></code></pre><p>基本格式总是可以接受的。当整个 <code>Javadoc</code> 块能容纳于一行时(且没有标记 <code>@XXX</code> )，就可以使用单行形式。</p><h4 id="7-1-2-段落"><a href="#7-1-2-段落" class="headerlink" title="7.1.2 段落"></a>7.1.2 段落</h4><p>空行(只包含最左侧星号的行)会出现在段落之间和 <code>Javadoc</code> 标记(<code>@XXX</code>)之前(如果有的话)。 除了第一个段落，每个段落第一个单词前都有标签 <code>&lt;p&gt;</code>，并且它和第一个单词间没有空格。</p><h4 id="7-1-3-Javadoc标记"><a href="#7-1-3-Javadoc标记" class="headerlink" title="7.1.3 Javadoc标记"></a>7.1.3 Javadoc标记</h4><p>标准的<code>Javadoc</code>标记按以下顺序出现：<code>@param</code>, <code>@return</code>, <code>@throws</code>, <code>@deprecated</code>, 前面这4种标记如果出现，描述都不能为空。 当描述无法在一行中容纳，连续行需要至少再缩进 <code>4</code> 个空格(<strong>注</strong>：如果你的缩进统一采用采用 <code>4</code> 个空格，那么这里就应该是 <code>8</code> 个空格)。</p><h3 id="7-2-摘要片段"><a href="#7-2-摘要片段" class="headerlink" title="7.2 摘要片段"></a>7.2 摘要片段</h3><p>每个类或成员的 <code>Javadoc</code> 以一个简短的摘要片段开始。这个片段是非常重要的，在某些情况下，它是唯一出现的文本，比如在类和方法索引中。</p><p>这只是一个小片段，可以是一个名词短语或动词短语，但不是一个完整的句子。它不会以 <code>A {@code Foo} is a...</code> 或者 <code>This method returns...</code> 开头, 它也不会是一个完整的祈使句，如 <code>Save the record.</code>。然而，由于开头大写及被加了标点，它看起来就像是个完整的句子。</p><blockquote><p><strong>注意</strong>：一个常见的错误是把简单的 Javadoc 写成 <code>/** @return the customer ID */</code>，这是不正确的。它应该写成 <code>/** Returns the customer ID. */</code>。</p></blockquote><h3 id="7-3-在哪里使用-Javadoc"><a href="#7-3-在哪里使用-Javadoc" class="headerlink" title="7.3 在哪里使用 Javadoc"></a>7.3 在哪里使用 Javadoc</h3><p>至少在每个 <code>public</code> 类及它的每个 <code>public</code> 和 <code>protected</code> 成员处使用 <code>Javadoc</code>，以下是一些例外：</p><h4 id="7-3-1-例外：不言自明的方法"><a href="#7-3-1-例外：不言自明的方法" class="headerlink" title="7.3.1 例外：不言自明的方法"></a>7.3.1 例外：不言自明的方法</h4><p>对于简单明显的方法如 <code>getFoo</code>，<code>Javadoc</code> 是可选的(可以不写)。这种情况下除了写 <code>Returns the foo</code>，确实也没有什么值得写了。</p><p>单元测试类中的测试方法可能是不言自明的最常见例子了，我们通常可以从这些方法的描述性命名中知道它是干什么的，因此不需要额外的文档说明。</p><blockquote><p><strong>注意</strong>：如果有一些相关信息是需要读者了解的，那么以上的例外不应作为忽视这些信息的理由。例如，对于方法名 <code>getCanonicalName</code>，就不应该忽视文档说明，因为读者很可能不知道词语 <code>canonical name</code> 指的是什么。</p></blockquote><h4 id="7-3-2-例外：重载"><a href="#7-3-2-例外：重载" class="headerlink" title="7.3.2 例外：重载"></a>7.3.2 例外：重载</h4><p>如果一个方法重载了超类中的方法，那么 <code>Javadoc</code> 并非必需的。</p><h4 id="7-3-3-可选的Javadoc"><a href="#7-3-3-可选的Javadoc" class="headerlink" title="7.3.3 可选的Javadoc"></a>7.3.3 可选的Javadoc</h4><p>对于包外不可见的类和方法，如有需要，也是要使用 <code>Javadoc</code> 的。如果一个注释是用来定义一个类，方法，字段的整体目的或行为， 那么这个注释应该写成 <code>Javadoc</code>，这样更统一更友好。</p><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="http://checkstyle.sourceforge.net/reports/google-java-style-20170228.html" target="_blank" rel="noopener">Google Java Style Guide</a></p>]]></content>
      
      
      <categories>
          
          <category> 编程之道 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Lottie - 轻松实现复杂的动画效果</title>
      <link href="/posts/2018/238b7a36.html"/>
      <url>/posts/2018/238b7a36.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Lottie-介绍"><a href="#1-Lottie-介绍" class="headerlink" title="1. Lottie 介绍"></a>1. Lottie 介绍</h2><p>Lottie 是 <a href="https://github.com/airbnb" target="_blank" rel="noopener">Airbnb</a> 开源的一套跨平台的完整的动画效果解决方案，设计师可以使用 <a href="https://www.adobe.com/cn/products/aftereffects.html" target="_blank" rel="noopener">Adobe After Effects</a> 设计出漂亮的动画之后，使用 <code>Lottic</code> 提供的 <a href="https://github.com/airbnb/lottie-web" target="_blank" rel="noopener">Bodymovin</a> 插件将设计好的动画导出成 JSON 格式，就可以直接运用在 <code>iOS</code>、<code>Android</code>、<code>Web</code> 和 <code>React Native</code>之上，无需其他额外操作。</p><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659ed59b2e5b3f2?w=1308&amp;h=358&amp;f=png&amp;s=42684" alt=""></p><p>Lottie 相关网站：</p><ul><li><a href="http://airbnb.io/lottie/" target="_blank" rel="noopener">Lottie 官网</a></li><li><a href="https://github.com/airbnb" target="_blank" rel="noopener">Lottie on Github</a></li><li><a href="https://github.com/airbnb/lottie-android" target="_blank" rel="noopener">Lottie for Android</a></li><li><a href="https://github.com/airbnb/lottie-ios" target="_blank" rel="noopener">Lottie for iOS</a></li><li><a href="https://github.com/airbnb/lottie-web" target="_blank" rel="noopener">Lottie for Web</a></li><li><a href="https://github.com/airbnb/lottie-react-native" target="_blank" rel="noopener">Lottie for React Native</a></li></ul><h2 id="2-Lottie-使用"><a href="#2-Lottie-使用" class="headerlink" title="2. Lottie 使用"></a>2. Lottie 使用</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164ff072f3b9c346?w=770&amp;h=385&amp;f=gif&amp;s=347496" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/8/3/164ff0758f7e8915?w=770&amp;h=385&amp;f=gif&amp;s=2132669" alt=""></p><p>Lottie 支持 <code>Jellybean (API 16)</code> 及以上版本。最简单的使用方式是直接使用 <code>LottieAnimationView</code>， <code>LottieAnimationView</code> 直接继承自 <code>AppCompatImageView</code> 。</p><h3 id="2-1-Lottie-依赖"><a href="#2-1-Lottie-依赖" class="headerlink" title="2.1 Lottie 依赖"></a>2.1 Lottie 依赖</h3><p><code>Gradle</code> 是唯一支持的构建配置，所以只需要在项目的 <code>build.gradle</code> 文件中添加依赖即可:</p><pre class=" language-gradle"><code class="language-gradle">dependencies {  implementation "com.airbnb.android:lottie:$lottieVersion"}</code></pre><p><span>最新版本是： </span><a href="https://search.maven.org/search?q=a:lottie" target="_blank" rel="noopener"><img src="https://user-gold-cdn.xitu.io/2018/8/20/165551befe8dc066" style="vertical-align:middle;"></a></p><h3 id="2-2-Lottie-核心类"><a href="#2-2-Lottie-核心类" class="headerlink" title="2.2 Lottie 核心类"></a>2.2 Lottie 核心类</h3><ul><li><strong>LottieAnimationView</strong>：继承自 <code>AppCompatImageView</code>，是加载 <code>Lottie</code> 动画的默认和最简单的方式。</li><li><strong>LottieDrawable</strong>：具有大多数与 <code>LottieAnimationView</code> 相同的 <code>API</code>，因此可以在任何视图上使用它。</li></ul><h3 id="2-3-加载动画"><a href="#2-3-加载动画" class="headerlink" title="2.3 加载动画"></a>2.3 加载动画</h3><p>Lottie 支持 <code>Jellybean (API 16)</code> 及以上版本。Lottie 动画支持从以下位置加载动画：</p><ul><li><code>src/main/res/raw</code> 中的 json 动画。</li><li><code>src/main/assets</code> 中的 json 文件。</li><li><code>src/main/assets</code> 中的 zip 文件。有关详细信息，请参阅 <a href="http://airbnb.io/lottie/android/images.html" target="_blank" rel="noopener">images docs</a>。</li><li>json 或 zip 文件的 <code>Url</code>。</li><li><code>json 字符串</code>。源可以来自任何东西，包括自己的网络堆栈。</li><li>json 文件或 zip 文件的 <code>InputStream</code>。</li></ul><h4 id="2-3-1-在-XML-中使用"><a href="#2-3-1-在-XML-中使用" class="headerlink" title="2.3.1 在 XML 中使用"></a>2.3.1 在 XML 中使用</h4><p>最简单的使用方法是使用 <code>LottieAnimationView</code>。Lottie 支持加载来自 <code>res/raw</code> 或 <code>assets/</code> 的动画资源。建议使用 <code>res/raw</code>，因为可以对动画通过 <code>R 文件</code>使用静态引用，而不只是使用字符串名称。这也可以帮助构建静态分析，因为它可以跟踪动画的使用。</p><p><code>LottieAnimationView</code> 的常用属性及其功能如下：</p><table><thead><tr><th>属性</th><th>功能</th></tr></thead><tbody><tr><td>lottie_fileName</td><td>设置播放动画的 json 文件名称</td></tr><tr><td>lottie_rawRes</td><td>设置播放动画的 json 文件资源</td></tr><tr><td>lottie_autoPlay</td><td>设置动画是否自动播放(默认为false)</td></tr><tr><td>lottie_loop</td><td>设置动画是否循环(默认为false)</td></tr><tr><td>lottie_repeatMode</td><td>设置动画的重复模式(默认为restart)</td></tr><tr><td>lottie_repeatCount</td><td>设置动画的重复次数(默认为-1)</td></tr><tr><td>lottie_cacheStrategy</td><td>设置动画的缓存策略(默认为weak)</td></tr><tr><td>lottie_colorFilter</td><td>设置动画的着色颜色(优先级最低)</td></tr><tr><td>lottie_scale</td><td>设置动画的比例(默认为1f)</td></tr><tr><td>lottie_progress</td><td>设置动画的播放进度</td></tr><tr><td>lottie_imageAssetsFolder</td><td>设置动画依赖的图片资源文件地址</td></tr></tbody></table><p>在 <code>res/raw (lottie_rawRes)</code> 或 <code>assets/ (lottie_fileName)</code> 中存放动画的 JSON 文件，然后就可以在 xml 中直接使用，如下：</p><pre class=" language-xml"><code class="language-xml">&lt;com.airbnb.lottie.LottieAnimationView        android:id="@+id/animation_view"        android:layout_width="wrap_content"        android:layout_height="wrap_content"        app:lottie_rawRes="@raw/hello_world"        // or        app:lottie_fileName="hello_world.json"        app:lottie_loop="true"        app:lottie_autoPlay="true" /></code></pre><h4 id="2-3-2-在代码中使用"><a href="#2-3-2-在代码中使用" class="headerlink" title="2.3.2 在代码中使用"></a>2.3.2 在代码中使用</h4><p><code>LottieAnimationView</code> 的常用方法及其功能如下：</p><table><thead><tr><th>方法</th><th>功能</th></tr></thead><tbody><tr><td>setAnimation(String)</td><td>设置播放动画的 json 文件名称</td></tr><tr><td>setAnimation(String, CacheStrategy)</td><td>设置播放动画的 json 文件资源和缓存策略</td></tr><tr><td>setAnimation(int)</td><td>设置播放动画的 json 文件名称</td></tr><tr><td>setAnimation(int, CacheStrategy)</td><td>设置播放动画的 json 文件资源和缓存策略</td></tr><tr><td>loop(boolean)</td><td>设置动画是否循环(默认为false)</td></tr><tr><td>setRepeatMode(int)</td><td>设置动画的重复模式(默认为restart)</td></tr><tr><td>setRepeatCount(int)</td><td>设置动画的重复次数(默认为-1)</td></tr><tr><td>lottie_cacheStrategy</td><td>设置动画的缓存策略(默认为weak)</td></tr><tr><td>lottie_colorFilter</td><td>设置动画的着色颜色(优先级最低)</td></tr><tr><td>setScale(float)</td><td>设置动画的比例(默认为1f)</td></tr><tr><td>setProgress(float)</td><td>设置动画的播放进度</td></tr><tr><td>setImageAssetsFolder(String)</td><td>设置动画依赖的图片资源文件地址</td></tr><tr><td>playAnimation()</td><td>从头开始播放动画</td></tr><tr><td>pauseAnimation()</td><td>暂停播放动画</td></tr><tr><td>resumeAnimation()</td><td>继续从当前位置播放动画</td></tr><tr><td>cancelAnimation()</td><td>取消播放动画</td></tr></tbody></table><p>如果不想用 xml 实现，可以通过代码来实现，可以直接加载本地动画资源，也可以从网络请求加载动画。</p><ul><li>从 <code>res/raw</code> 或 <code>assets/</code> 加载动画资源：<br><code>`</code>java<br>LottieAnimationView animationView = …</li></ul><p>animationView.setAnimation(R.raw.hello_world);<br>// or<br>animationView.setAnimation(R.raw.hello_world.json);</p><p>animationView.playAnimation();</p><pre><code>该方法在后台加载文件并解析动画，并在完成后异步开始渲染。 - 从网络请求加载动画：Lottie 的一个优点是可以从网络请求加载动画。所以，应该将网络请求的响应内容转换为字符串格式。Lottie使用一个流化的 json 反序列化器来提高性能和内存使用率，所以不要将它转换成您自己的 JSONObject，这只会损害性能。```javaLottieAnimationView animationView = ...// This allows lottie to use the streaming deserializer mentioned above.JsonReader jsonReader = new JsonReader(new StringReader(json.toString()));animationView.setAnimation(jsonReader);animationView.playAnimation();</code></pre><h3 id="2-4-Lottie-的缓存策略"><a href="#2-4-Lottie-的缓存策略" class="headerlink" title="2.4 Lottie 的缓存策略"></a>2.4 Lottie 的缓存策略</h3><p>你的应用程序中可能会有一些经常使用的动画，比如加载动画等等。为了避免每次加载文件和发序列化的开销，你可以在你的动画上设置一个缓存策略。上面所有的 <code>setAnimation</code> APIs都可以采用可选的第二个参数 <code>CacheStrategy</code>。在默认情况下，Lottie 将保存对动画的弱引用，这对于大多数情况来说应该足够了。但是，如果确定某个动画肯定会经常使用，那么请将其缓存策略更改为 <code>CacheStrategy.Strong</code>；或者如果确定某个动画很大而且不会经常使用，把缓存策略改成 <code>CacheStrategy.None</code>。</p><p><code>CacheStrategy</code> 可以是<code>None</code>、<code>Weak</code> 和 <code>Strong</code> 三种形式来让 <code>LottieAnimationView</code> 对加载和解析动画的使用强或弱引用的方式。弱或强表示缓存中组合的 GC 引用强度。</p><h3 id="2-5-直接使用-LottieDrawable"><a href="#2-5-直接使用-LottieDrawable" class="headerlink" title="2.5 直接使用 LottieDrawable"></a>2.5 直接使用 <code>LottieDrawable</code></h3><p>LottieAnimationView 是基于 <code>LottieDrawable</code> 的一个包装好的 <code>ImageView</code> 。LottieAnimationView 上的所有 API 都在 LottieDrawable 上进行镜像，因此可以创建自己的实例并在任何可以使用drawable的地方使用它，例如自定义 View 或菜单。</p><h3 id="2-6-使用-LottieComposition-去预加载动画"><a href="#2-6-使用-LottieComposition-去预加载动画" class="headerlink" title="2.6 使用 LottieComposition 去预加载动画"></a>2.6 使用 <code>LottieComposition</code> 去预加载动画</h3><p>动画的支持模型是 <code>LottieComposition</code>。在大多数情况下，在 <code>LottieAnimationView</code> 或 <code>LottieDrawable</code> 上调用 <code>setAnimation(…)</code> 便足够了。但是，如果要预加载动画以使其立即可用，则可以使用 <code>LottieComposition.Factory</code> API返回可以直接在 <code>LottieAnimationView</code> 或 <code>LottieDrawable</code> 设置的 <code>LottieComposition</code> 对象。同样，通常不需要自己添加管理 compositions 的开销。<code>LottieAnimationView</code> 中的默认缓存足以满足大多数用例的需要。</p><pre class=" language-java"><code class="language-java">LottieAnimationView animationView <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">;</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> Cancellable compositionLoader <span class="token operator">=</span> LottieComposition<span class="token punctuation">.</span>Factory<span class="token punctuation">.</span><span class="token function">fromJsonString</span><span class="token punctuation">(</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> jsonString<span class="token punctuation">,</span> <span class="token punctuation">(</span>composition<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>     animationView<span class="token punctuation">.</span><span class="token function">setComposition</span><span class="token punctuation">(</span>composition<span class="token punctuation">)</span><span class="token punctuation">;</span>     animationView<span class="token punctuation">.</span><span class="token function">playAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment" spellcheck="true">// Cancel to stop asynchronous loading of composition</span> <span class="token comment" spellcheck="true">// compositionCancellable.cancel();</span></code></pre><h3 id="2-7-动画监听"><a href="#2-7-动画监听" class="headerlink" title="2.7 动画监听"></a>2.7 动画监听</h3><pre class=" language-java"><code class="language-java">animationView<span class="token punctuation">.</span><span class="token function">addAnimatorUpdateListener</span><span class="token punctuation">(</span><span class="token punctuation">(</span>animation<span class="token punctuation">)</span> <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something.</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>animationView<span class="token punctuation">.</span><span class="token function">playAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">if</span> <span class="token punctuation">(</span>animationView<span class="token punctuation">.</span><span class="token function">isAnimating</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// do something.</span><span class="token punctuation">}</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>animationView<span class="token punctuation">.</span><span class="token function">setProgress</span><span class="token punctuation">(</span><span class="token number">0.5f</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><p>在更新侦听器回调中： </p><ul><li><code>animation.getAnimatedValue()</code> 将返回动画的播放进度，而不考虑当前设置的最小/最大帧[0,1]。</li><li><code>animation.getAnimatedFraction()</code> 将返回动画的播放进度，同时考虑设置的最小/最大帧[minFrame，maxFrame]。</li></ul><h3 id="2-8-控制-Lottie-动画执行的速度和时长"><a href="#2-8-控制-Lottie-动画执行的速度和时长" class="headerlink" title="2.8 控制 Lottie 动画执行的速度和时长"></a>2.8 控制 Lottie 动画执行的速度和时长</h3><p>尽管 <code>playAnimation()</code> 对于绝大多数用例来说已足够，但可以在更新回调中调用 <code>setProgress(...)</code> 方法为自己的动画设置进度。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// Custom animation speed or duration.</span>ValueAnimator animator <span class="token operator">=</span> ValueAnimator<span class="token punctuation">.</span><span class="token function">ofFloat</span><span class="token punctuation">(</span><span class="token number">0f</span><span class="token punctuation">,</span> <span class="token number">1f</span><span class="token punctuation">)</span><span class="token punctuation">;</span>animator<span class="token punctuation">.</span><span class="token function">addUpdateListener</span><span class="token punctuation">(</span>animation <span class="token operator">-</span><span class="token operator">></span> <span class="token punctuation">{</span>    animationView<span class="token punctuation">.</span><span class="token function">setProgress</span><span class="token punctuation">(</span>animation<span class="token punctuation">.</span><span class="token function">getAnimatedValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>animator<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span></code></pre><h3 id="2-9-循环播放"><a href="#2-9-循环播放" class="headerlink" title="2.9 循环播放"></a>2.9 循环播放</h3><p>可以像使用 <code>ValueAnimator</code> 一样通过 <code>setRepeatMode(...)</code> 或 <code>setRepeatCount(...)</code> 方法控制动画的循环播放，或者你直接在 <code>xml</code> 中使用 <code>lottie_loop=&quot;true&quot;</code> 开启循环播放。</p><h3 id="2-10-动画尺寸（px-vs-dp）"><a href="#2-10-动画尺寸（px-vs-dp）" class="headerlink" title="2.10 动画尺寸（px vs dp）"></a>2.10 动画尺寸（px vs dp）</h3><p><code>Lottie</code> 将 <code>After Effects</code> 中的所有 <code>px</code> 值转换为设备上的 <code>dps</code>，以便在设备上以相同的大小呈现所有内容。这意味着它不是在 After Effects 中制作1920x1080的动画，而是在After Effects中更像411x731px，它大致对应于当今大多数手机的dp屏幕尺寸。</p><p>但是，如果您的动画不是完美尺寸，则有两种选择：</p><h4 id="2-10-1-ImageView-scaleType"><a href="#2-10-1-ImageView-scaleType" class="headerlink" title="2.10.1 ImageView scaleType"></a>2.10.1 ImageView scaleType</h4><p><code>LottieAnimationView</code> 是一个包装好的 <code>ImageView</code>，它支持 <code>centerCrop</code> 和 <code>centerInside</code>，所以可以像使用其他 image 一样使用这两个工具方法。</p><h4 id="2-10-2-Lottie-setScale-…"><a href="#2-10-2-Lottie-setScale-…" class="headerlink" title="2.10.2 Lottie setScale(…)"></a>2.10.2 Lottie setScale(…)</h4><p><code>LottieAnimationView</code> 和 <code>LottieDrawable</code> 都有 <code>setScale(float)</code> API，可以使用它来手动放大或缩小动画。这很少有用，但可以在某些情况下使用。</p><p>如果动画执行缓慢，请务必查看有关<a href="http://airbnb.io/lottie/android/performance.html" target="_blank" rel="noopener">性能</a>的文档。但是，可以尝试使用 <code>scaleType</code> 缩放动画，这将减少 Lottie 每帧渲染的数量。如果你有大的 mask 和 mattes，这将特别有用。</p><h3 id="2-11-播放动画片段"><a href="#2-11-播放动画片段" class="headerlink" title="2.11 播放动画片段"></a>2.11 播放动画片段</h3><p>播放/循环动画的单个部分通常很方便。例如，动画的前半部分可能处于“开启”状态，下半部分处于“关闭”状态。LottieAnimationView 和 LottieDrawable 有用于控制当前段的 API：</p><pre class=" language-java"><code class="language-java"><span class="token function">setMinFrame</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token function">setMaxFrame</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token function">setMinProgress</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token function">setMaxProgress</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token function">setMinAndMaxFrame</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token function">setMinAndMaxProgress</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span></code></pre><p>循环API将遵循此处设置的最小/最大帧。</p><h2 id="3-原理介绍"><a href="#3-原理介绍" class="headerlink" title="3. 原理介绍"></a>3. 原理介绍</h2><h3 id="3-1-Lottie-动画-Json-文件结构"><a href="#3-1-Lottie-动画-Json-文件结构" class="headerlink" title="3.1 Lottie 动画 Json 文件结构"></a>3.1 Lottie 动画 Json 文件结构</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659ede1389454a3?w=1065&amp;h=600&amp;f=png&amp;s=334910" alt=""><br>Lottie动画Json结构分为4层：</p><ol><li><code>结构层</code>：可以读取到动画画布的宽高，帧数，背景色，时间，起始关键帧，结束帧等信息。</li><li><code>asset</code>：图片资源信息集合，这里放置的是 制作动画时引用的图片资源。</li><li><code>layers</code>：图层集合，这里可以获取到多少图层，每个图层的开始帧 结束帧等。</li><li><code>shapes</code>：元素集合，可以获取到每个图层都包含多个动画元素。</li></ol><h3 id="3-2-Lottie-分层渲染原理"><a href="#3-2-Lottie-分层渲染原理" class="headerlink" title="3.2 Lottie 分层渲染原理"></a>3.2 Lottie 分层渲染原理</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659edfff49e0778?w=1111&amp;h=500&amp;f=png&amp;s=98904" alt=""><br>LottieComposition 负责将 json 文件解析成数据对象， LottieDrawable 负责将 LottieComposition 解析的对象<br>绘制成 drawable 显示在 View 上。</p><h3 id="3-3-Lottie-动画运行流程图"><a href="#3-3-Lottie-动画运行流程图" class="headerlink" title="3.3 Lottie 动画运行流程图"></a>3.3 Lottie 动画运行流程图</h3><p><img src="https://user-gold-cdn.xitu.io/2018/9/3/1659ee0fe5632dd1?w=1286&amp;h=500&amp;f=png&amp;s=163927" alt=""></p><h2 id="4-使用准备"><a href="#4-使用准备" class="headerlink" title="4. 使用准备"></a>4. 使用准备</h2><h3 id="4-1-下载安装-After-Effects"><a href="#4-1-下载安装-After-Effects" class="headerlink" title="4.1 下载安装 After Effects"></a>4.1 下载安装 After Effects</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164fed05f09d92d4?w=642&amp;h=231&amp;f=png&amp;s=8448" alt="After Effects"><br>下载并安装最新版本的 Adobe After Effects。</p><blockquote><p>下载地址：<a href="https://www.adobe.com/cn/products/aftereffects.html" target="_blank" rel="noopener">https://www.adobe.com/cn/products/aftereffects.html</a></p></blockquote><h3 id="4-2-下载安装-Bodymovin"><a href="#4-2-下载安装-Bodymovin" class="headerlink" title="4.2 下载安装 Bodymovin"></a>4.2 下载安装 Bodymovin</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164fed1b660d93a9?w=642&amp;h=231&amp;f=png&amp;s=8448" alt="Bodymovin"><br>下载并安装最新版本的 After Effects Bodymovin Extension。</p><ol><li><p>如果打开，关闭 After Effects；</p></li><li><p>安装 ZXP Installer 安装程序；</p><blockquote><p>下载地址：<a href="http://aescripts.com/learn/zxp-installer/" target="_blank" rel="noopener">http://aescripts.com/learn/zxp-installer/</a></p></blockquote></li><li><p>下载最新的 bodymovin 扩展；</p><blockquote><p>下载地址：<a href="https://github.com/airbnb/lottie-web/blob/master/build/extension/bodymovin.zxp" target="_blank" rel="noopener">https://github.com/airbnb/lottie-web/blob/master/build/extension</a></p></blockquote></li></ol><p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164feda80ec2fe7b?w=2012&amp;h=620&amp;f=png&amp;s=96918" alt="bodymovin"></p><ol start="4"><li><p>打开 ZXP Installer 并将 bodymovin 扩展名拖到窗口中；</p></li><li><p>打开 After Effects。</p><p>在“Window&gt; Extensions”菜单下，您应该看到“Bodymovin”</p></li></ol><h3 id="4-3-Lottiefiles-示例应用程序"><a href="#4-3-Lottiefiles-示例应用程序" class="headerlink" title="4.3 Lottiefiles 示例应用程序"></a>4.3 Lottiefiles 示例应用程序</h3><p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164feda5074d00ef?w=642&amp;h=231&amp;f=png&amp;s=8448" alt="Lottiefiles"><br>可以自己构建示例应用程序，也可以从 <a href="https://play.google.com/store/apps/details?id=com.airbnb.lottie" target="_blank" rel="noopener">Google Play</a> 或 <a href="https://www.lottiefiles.com/ios" target="_blank" rel="noopener">App Store</a> 上下载 Lottie 示例应用程序。示例应用程序包含一些内置动画，但也允许您从内部存储或从 url 加载动画。 </p><p>在完成这三件事之后，请在 <a href="http://airbnb.io/lottie/after-effects/artwork-to-lottie-walkthrough.html" target="_blank" rel="noopener">SVG / Sketch 到 Lottie 演练</a> 或 <a href="http://airbnb.io/lottie/after-effects/illustrator-to-lottie-walkthrough.html" target="_blank" rel="noopener">Illustrator 到 Lottie 演练</a> 中查看一些工作流程概述。</p><h2 id="5-LottieFiles"><a href="#5-LottieFiles" class="headerlink" title="5 LottieFiles"></a>5 LottieFiles</h2><p> LottieFiles 提供了很多设计师上传的 Lottie 动画，并提供预览的效果，并且可以直接下载成 JSON ，或者生成二维码，可供 Lottie App 扫描看效果，非常的方便。</p><blockquote><p>LottieFiles：<a href="https://www.lottiefiles.com/" target="_blank" rel="noopener">https://www.lottiefiles.com/</a></p><p>Lottie-editor：<a href="https://github.com/sonaye/lottie-editor" target="_blank" rel="noopener">https://github.com/sonaye/lottie-editor</a></p></blockquote><p><img src="https://user-gold-cdn.xitu.io/2018/8/3/164feed2344ab30f?w=1338&amp;h=561&amp;f=png&amp;s=337889" alt="LottieFiles"></p><p><a href="https://www.lottiefiles.com/" target="_blank" rel="noopener">LottieFiles</a> 本身已经支持使用 <a href="https://editor.lottiefiles.com/" target="_blank" rel="noopener">Lottie-editor</a> 去编辑动画。如果需要对某个动画进行修改，只需要在动画的预览界面，点击右上角的 <strong>Customize with Bodymovin Editor</strong>，即可直接对该动画进行编辑。</p><h2 id="6-致谢"><a href="#6-致谢" class="headerlink" title="6. 致谢"></a>6. 致谢</h2><ol><li><a href="https://airbnb.io/lottie/" target="_blank" rel="noopener">airbnb.io/lottie</a></li><li><a href="https://juejin.im/post/5acc4162f265da23826e4dc0" target="_blank" rel="noopener">程序员也想改 Lottie 动画？是的！</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Lottie </tag>
            
            <tag> 动画 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Studio 让开发效率事半功倍的插件整理</title>
      <link href="/posts/2018/d09e4c2c.html"/>
      <url>/posts/2018/d09e4c2c.html</url>
      
        <content type="html"><![CDATA[<p>Google 在2013年5月的 I/O 开发者大会推出了基于 IntelliJ IDEA Java IDE 上的 Android Studio。Android Studio 是一个功能齐全的开发工具，还提供了对第三方插件的支持，让开发人员更快速更好的开发应用程序。</p><h2 id="插件安装"><a href="#插件安装" class="headerlink" title="插件安装"></a>插件安装</h2><p>首先通过导航栏 <strong>File | Settings</strong> 或是直接 <strong>Ctrl+Alt+S</strong> 打开设置对话框，选择 <strong>Plugins</strong>。找到需要的插件后点击右侧的 <strong>Install</strong> 按钮进行下载安装，安装完成后 <strong>Install</strong> 按钮会变成 <strong>Restart Android Studio</strong>，点击 <strong>Restart</strong> 重启 Android Studio 即可。</p><p>Android Studio 支持三种安装插件的方法：</p><ol><li><strong>Install JetBrains Plugins：</strong> 安装 JetBrains 的官方插件。官方插件种类非常丰富，包含辅助用户体验、语言支持等，稳定可靠，勤于更新。</li><li><strong>Browse repositories：</strong> 浏览官方仓库。官方仓库不仅有官方插件，还有来自社区的插件的第三方插件。</li><li><strong>Install plugin from disk：</strong> 从本地安装插件。IDEA 的插件打包之后，用此功能就可以安装，方便了小团体之间的插件开发和共享。</li></ol><h2 id="插件汇总"><a href="#插件汇总" class="headerlink" title="插件汇总"></a>插件汇总</h2><h3 id="ignore"><a href="#ignore" class="headerlink" title=".ignore"></a>.ignore</h3><p><a href="https://plugins.jetbrains.com/plugin/7495" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/hsz/idea-gitignore" target="_blank" rel="noopener">GitHub</a></p><p>.ignore 是一个快速生成 <code>.gitignore</code> (Git)、<code>.hgignore</code> (Mercurial)、<code>.npmignore</code> (NPM)、<code>.dockerignore</code> (Docker)、<code>.chefignore</code> (Chef)、<code>.cvsignore</code> (CVS)、<code>.bzrignore</code> (Bazaar)、<code>.boringignore</code> (Darcs)、<code>.mtn-ignore</code> (Monotone)、<code>ignore-glob</code> (Fossil)、<code>.jshintignore</code> (JSHint)、<code>.tfignore</code> (Team Foundation)、<code>.p4ignore</code> (Perforce)、<code>.flooignore</code> (Floobits)、<code>.eslintignore</code> (ESLint)、<code>.cfignore</code> (Cloud Foundry)、<code>.jpmignore</code> (Jetpack)、<code>.stylelintignore</code> (StyleLint)、<code>.stylintignore</code> (Stylint)、<code>.swagger-codegen-ignore</code> (Swagger Codegen)、<code>.helmignore</code> (Kubernetes Helm)、<code>.upignore</code> (Up)、<code>.prettierignore</code> (Prettier)、<code>.ebignore</code> (ElasticBeanstalk) 文件的插件。 它支持的 JetBrains IDE 有 <code>Android Studio</code>、<code>AppCode</code>、<code>CLion、IntelliJ IDEA</code>、<code>PhpStorm</code>、<code>PyCharm</code>、<code>RubyMine</code>、<code>WebStorm、DataGrip</code>。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665cd65b27f795c?w=1200&amp;h=887&amp;f=png&amp;s=468405" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665cd681bbde5c0?w=800&amp;h=594&amp;f=png&amp;s=180564" alt=""></p><h3 id="360-FireLine"><a href="#360-FireLine" class="headerlink" title="360 FireLine"></a>360 FireLine</h3><p><a href="https://plugins.jetbrains.com/plugin/9292" target="_blank" rel="noopener">Download</a> | <a href="http://magic.360.cn/" target="_blank" rel="noopener">WebSite</a></p><p>360 FireLine 是一款是免费的适用于 Android 和 Java 代码的代码静态分析插件。主打的安全检查规则是根据360业务多年技术沉淀而来。内存类检查的精确度业内领先。<br><img src="https://user-gold-cdn.xitu.io/2018/10/12/16666499c50c29e6?w=1038&amp;h=701&amp;f=png&amp;s=38265" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/12/1666649b61e69e9d?w=457&amp;h=764&amp;f=png&amp;s=54499" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/12/1666649cf43676ca?w=881&amp;h=389&amp;f=jpeg&amp;s=32588" alt=""></p><h3 id="ADB-Idea"><a href="#ADB-Idea" class="headerlink" title="ADB Idea"></a>ADB Idea</h3><p><a href="https://plugins.jetbrains.com/plugin/7380" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/pbreault/adb-idea" target="_blank" rel="noopener">GitHub</a></p><p>ADB Idea 是一款 ADB 调试工具，支持 Uninstall App、Kill App、Start App、Restart App、Clear App Data、Clear App Data and Restart 等操作的插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665cdf93e7be9dd?w=651&amp;h=410&amp;f=png&amp;s=44841" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665cdf47adb5048?w=316&amp;h=300&amp;f=png&amp;s=18753" alt=""></p><h3 id="ADB-WIFI"><a href="#ADB-WIFI" class="headerlink" title="ADB WIFI"></a>ADB WIFI</h3><p><a href="https://plugins.jetbrains.com/plugin/7856" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/layerlre/ADBWIFI" target="_blank" rel="noopener">GitHub</a></p><p>ADB WIFI 是一款无需 root 就可以通过 WiFi 调试 Android APP 的 Android Studio 插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665ce32d2ca1668?w=598&amp;h=92&amp;f=png&amp;s=10422" alt=""></p><h3 id="Alibaba-Java-Coding-Guidelines"><a href="#Alibaba-Java-Coding-Guidelines" class="headerlink" title="Alibaba Java Coding Guidelines"></a>Alibaba Java Coding Guidelines</h3><p><a href="https://plugins.jetbrains.com/plugin/10046" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/alibaba/p3c" target="_blank" rel="noopener">GitHub</a></p><p>Alibaba Java Coding Guidelines 是一款 Java 代码规约扫描插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665ceeb46a11f8c?w=469&amp;h=1133&amp;f=png&amp;s=75360" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665ceed24d82cd1?w=1082&amp;h=342&amp;f=png&amp;s=52811" alt=""></p><h3 id="Android-ButterKnife-Zelezny"><a href="#Android-ButterKnife-Zelezny" class="headerlink" title="Android ButterKnife Zelezny"></a>Android ButterKnife Zelezny</h3><p><a href="https://plugins.jetbrains.com/plugin/7369" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/avast/android-butterknife-zelezny" target="_blank" rel="noopener">GitHub</a></p><p>Android ButterKnife Zelezny 是一款用于根据 activities/fragments/adapters 选中的 xml 布局生成 ButterKnife 注入的插件。选中 activities/fragments/adapters 中引用的 xml 布局，点击 <strong>Generate</strong> 菜单或使用快捷键 <strong>Alt + Insert</strong>，然后选择 <strong>Generate ButterKnife Injections</strong> 即可。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665cf3ca52dd542?w=712&amp;h=591&amp;f=gif&amp;s=224045" alt=""></p><h3 id="Android-Code-Generator"><a href="#Android-Code-Generator" class="headerlink" title="Android Code Generator"></a>Android Code Generator</h3><p><a href="https://plugins.jetbrains.com/plugin/7595" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/tmorcinek/android-codegenerator-plugin-intellij" target="_blank" rel="noopener">GitHub</a></p><p>Android Code Generator 是一款根据布局文件快速生成对应的Activity、Fragment、Adapter、Menu 的插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d579274807b3?w=1152&amp;h=720&amp;f=gif&amp;s=1314525" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d58067ae589a?w=1152&amp;h=720&amp;f=gif&amp;s=1036291" alt=""></p><h3 id="Android-Methods-Count"><a href="#Android-Methods-Count" class="headerlink" title="Android Methods Count"></a>Android Methods Count</h3><p><a href="https://plugins.jetbrains.com/plugin/8076" target="_blank" rel="noopener">Download</a></p><p>Android Methods Count 是一款统计 Android 依赖库中方法的总个数的插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d0566e9e6342?w=650&amp;h=222&amp;f=gif&amp;s=196419" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d05853f75575?w=530&amp;h=81&amp;f=png&amp;s=19180" alt=""></p><h3 id="Android-Parcelable-code-generator"><a href="#Android-Parcelable-code-generator" class="headerlink" title="Android Parcelable code generator"></a>Android Parcelable code generator</h3><p><a href="https://plugins.jetbrains.com/plugin/7332" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/mcharmas/android-parcelable-intellij-plugin/" target="_blank" rel="noopener">GitHub</a></p><p>Android Parcelable code generator 是一款基于数据类中的字段快速实现 Parcelable 接口的插件。在编辑器中点击 <strong>Generate</strong> 菜单或使用快捷键 <strong>Alt + Insert</strong>，然后选择 <strong>Parcelable</strong> 即可。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d0eecd18e5e3?w=600&amp;h=601&amp;f=png&amp;s=85375" alt=""></p><h3 id="AndroidSourceViewer"><a href="#AndroidSourceViewer" class="headerlink" title="AndroidSourceViewer"></a>AndroidSourceViewer</h3><p><a href="https://plugins.jetbrains.com/plugin/10187" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/pengwei1024/AndroidSourceViewer" target="_blank" rel="noopener">GitHub</a></p><p>AndroidSourceViewer 是一款在 Android Studio 中在线查看 Android 和 Java 指定版本源码插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/12/16667115154a6478?w=310&amp;h=254&amp;f=png&amp;s=27812" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/12/1666711857bb2332?w=636&amp;h=512&amp;f=png&amp;s=134796" alt=""></p><h3 id="CheckStyle-IDEA"><a href="#CheckStyle-IDEA" class="headerlink" title="CheckStyle-IDEA"></a>CheckStyle-IDEA</h3><p><a href="https://plugins.jetbrains.com/plugin/1065" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/jshiell/checkstyle-idea" target="_blank" rel="noopener">GitHub</a></p><p>CheckStyle-IDEA 是一款帮助程序员编写符合编码标准的 Java 代码的插件。它可以自动执行检查 Java 代码的过程，从而使人类免于这项无聊但重要的任务，这使其成为希望实施编码标准的项目的理想选择。Checkstyle 具有高度可配置性，可以支持几乎任何编码标准。Checkstyle 提供了一个示例配置文件，支持 Sun Code Conventions 和 Google Java Style。<br><img src="https://user-gold-cdn.xitu.io/2018/10/12/16666ffdb6617ec3?w=1163&amp;h=935&amp;f=png&amp;s=79634" alt=""></p><h3 id="CodeGlance"><a href="#CodeGlance" class="headerlink" title="CodeGlance"></a>CodeGlance</h3><p><a href="https://plugins.jetbrains.com/plugin/7275" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/Vektah/CodeGlance" target="_blank" rel="noopener">GitHub</a></p><p>CodeGlance 是一款显示类似于 Sublime 中的代码小地图用于快速定位代码的插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d6137c651035?w=1282&amp;h=697&amp;f=png&amp;s=651937" alt=""></p><h3 id="EventBus3-Intellij-Plugin"><a href="#EventBus3-Intellij-Plugin" class="headerlink" title="EventBus3 Intellij Plugin"></a>EventBus3 Intellij Plugin</h3><p><a href="https://plugins.jetbrains.com/plugin/8603" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/likfe/eventbus3-intellij-plugin" target="_blank" rel="noopener">GitHub</a></p><p>EventBus3 Intellij Plugin 是一款为 EventBus 提供快速索引和跳转的插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/12/16666e36dbcea911?w=600&amp;h=400&amp;f=gif&amp;s=432363" alt=""></p><h3 id="FindBugs-IDEA"><a href="#FindBugs-IDEA" class="headerlink" title="FindBugs-IDEA"></a>FindBugs-IDEA</h3><p><a href="https://plugins.jetbrains.com/plugin/3847" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/andrepdo/findbugs-idea" target="_blank" rel="noopener">GitHub</a></p><p>FindBugs-IDEA 是一款通过提供静态字节码分析以从 IntelliJ IDEA 中查找 Java 代码中的 bug 的插件。FindBugs 是一个 Java 缺陷检测工具，它使用静态分析来查找超过200个错误模式，比如空指针取消引用、无限的递归循环、Java 库的糟糕使用和死锁。FindBugs 可以在大型应用程序中识别数百个严重缺陷(通常每1000-2000行非注释源语句中约有1个缺陷)。<br><img src="https://user-gold-cdn.xitu.io/2018/10/12/16666fa3883acb3e?w=1140&amp;h=534&amp;f=png&amp;s=98882" alt=""><br><img src="https://user-gold-cdn.xitu.io/2018/10/12/16666fa739970eae?w=1736&amp;h=1144&amp;f=png&amp;s=340743" alt=""></p><h3 id="GsonFormat"><a href="#GsonFormat" class="headerlink" title="GsonFormat"></a>GsonFormat</h3><p><a href="https://plugins.jetbrains.com/plugin/7654" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/zzz40500/GsonFormat" target="_blank" rel="noopener">GitHub</a></p><p>GsonFormat 是一款快速格式化 json 数据并自动生成实体类参数的插件。新建实体类并在编辑器中点击 <strong>Generate</strong> 菜单或使用快捷键 <strong>Alt + Insert</strong>，然后选择 <strong>GsonFormat</strong> 即可。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d1cf88706283?w=819&amp;h=652&amp;f=gif&amp;s=388525" alt=""></p><h3 id="Lifecycle-Sorter"><a href="#Lifecycle-Sorter" class="headerlink" title="Lifecycle Sorter"></a>Lifecycle Sorter</h3><p><a href="https://plugins.jetbrains.com/plugin/7742" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/armandAkop/Lifecycle-Sorter" target="_blank" rel="noopener">GitHub</a></p><p>Lifecycle Sorter 是一款可以对 Activity 或 Fragment 的生命周期方法按照它们在应用程序中的调用顺序进行排序的插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d28b507a852d?w=2080&amp;h=1613&amp;f=png&amp;s=555296" alt=""></p><h3 id="Markdown-Navigator"><a href="#Markdown-Navigator" class="headerlink" title="Markdown Navigator"></a>Markdown Navigator</h3><p><a href="https://plugins.jetbrains.com/plugin/7896" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/vsch/idea-multimarkdown" target="_blank" rel="noopener">GitHub</a></p><p>Markdown Navigator 是一款带有 GFM 和匹配的预览样式的的 Markdown 插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d3006d96b10b?w=1102&amp;h=596&amp;f=gif&amp;s=2159593" alt=""></p><h3 id="MVPHelper"><a href="#MVPHelper" class="headerlink" title="MVPHelper"></a>MVPHelper</h3><p><a href="https://plugins.jetbrains.com/plugin/8507" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/githubwing/MVPHelper" target="_blank" rel="noopener">GitHub</a></p><p>MVPHelper 是一款 Intellj IDEA 和 Android Studio 自动生成 MVP 模式所需接口以及实现类的插件。在 Contract 类或者 Presenter 类内部，点击 <strong>Generate</strong> 菜单或使用快捷键 <strong>Alt + Insert</strong>, 然后选择 <strong>Mvp Helper</strong> 即可生成对应文件.<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d351ee1a16df?w=958&amp;h=518&amp;f=gif&amp;s=286497" alt=""></p><h3 id="Remove-ButterKnife"><a href="#Remove-ButterKnife" class="headerlink" title="Remove ButterKnife"></a>Remove ButterKnife</h3><p><a href="https://plugins.jetbrains.com/plugin/8432" target="_blank" rel="noopener">Download</a> | <a href="https://github.com/u3shadow/RemoveButterKnife" target="_blank" rel="noopener">GitHub</a></p><p>Remove ButterKnife 是一款用于移除代码中对 ButterKnife 使用的插件。<br><img src="https://user-gold-cdn.xitu.io/2018/10/10/1665d384560cf98f?w=1452&amp;h=674&amp;f=gif&amp;s=458990" alt=""></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> Plugins </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android Studio 3.0 利用 Android Profiler 测量应用性能</title>
      <link href="/posts/2018/26cb225c.html"/>
      <url>/posts/2018/26cb225c.html</url>
      
        <content type="html"><![CDATA[<p>Android Studio 3.0 采用全新的 <code>Android Profiler</code> 窗口取代 <code>Android Monitor</code> 工具。 这些全新的分析工具能够提供关于应用 <code>CPU</code>、<code>内存</code>和<code>网络活动</code>的实时数据。 </p><p>您可以执行基于样本的函数跟踪来记录代码执行时间、采集堆转储数据、查看内存分配，以及查看网络传输文件的详情。</p><h2 id="Android-Profiler-的使用方法"><a href="#Android-Profiler-的使用方法" class="headerlink" title="Android Profiler 的使用方法"></a>Android Profiler 的使用方法</h2><h3 id="Android-Profiler-的打开步骤"><a href="#Android-Profiler-的打开步骤" class="headerlink" title="Android Profiler 的打开步骤"></a>Android Profiler 的打开步骤</h3><p>要打开 <strong>Android Profiler</strong> 窗口，请按以下步骤操作：</p><ol><li>点击 <strong>View &gt; Tool Windows &gt; Android Profiler</strong>（也可以点击工具栏中的 <strong>Android Profiler</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/6/1650e53ac183fbbb?w=24&h=24&f=png&s=1193" style="vertical-align:middle;">）。</li><li>从 Android Profiler 工具栏中选择您想要分析的设备和应用进程。 如果您通过 USB 连接了某个设备但该设备未在设备列表中列出，请确保您已<a href="https://developer.android.google.cn/studio/debug/dev-options.html#enable" target="_blank" rel="noopener">启用 USB 调试</a>（如果您使用的是 Android Emulator 或已取得 root 权限的设备，Android Profiler 将列出所有正在运行的进程，即使这些进程可能无法调试。 当您发布可调试应用时，将会默认选择此进程）。</li><li>在 <strong>Android Profiler</strong> 窗口顶部（如下图所示），选择您想要分析的设备和应用进程。</li></ol><p>Android Profiler 共享时间线的视图显示如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/6/1650e54e3a40d6da?w=1228&amp;h=960&amp;f=png&amp;s=519840" alt=""><br>Android Profiler 目前可显示共享时间线视图，可以在按钮①的位置选择设备，通过按钮②的位置选择想要的app进程，工具最底部显示了一个时间轴，其中包含了CPU、内存和网络使用的实时图。该窗口还包括时间轴缩放控制按钮③，一个跳转到实时更新的按钮④，以及显示活动状态、用户输入事件和屏幕旋转事件⑤的事件时间轴。</p><p>当您启动 Android Profiler 后，它会持续收集分析数据，直至您断开设备连接或点击 <strong>Close</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/6/1650e53d003e386b?w=24&h=24&f=png&s=986" style="vertical-align:middle;">。</p><p>此共享时间线视图只显示时间线图表。 要使用详细分析工具，请点击与您想查看的性能数据对应的图表。 例如，要使用工具查看堆数据和跟踪内存分配，可点击 <strong>MEMORY</strong> 图表。</p><p>但并不是所有分析数据均默认可见。 如果您看到一条消息，显示“Advanced profiling is unavailable for the selected process”，则需在运行配置中<a href="https://developer.android.google.cn/studio/profile/android-profiler#advanced-profiling" target="_blank" rel="noopener">启用高级分析</a>。</p><h3 id="启用高级分析"><a href="#启用高级分析" class="headerlink" title="启用高级分析"></a>启用高级分析</h3><p>要显示高级分析数据，Android Studio 必须在您编译后的应用中插入监控逻辑。高级分析工具提供的功能包括：</p><ul><li>Event 时间线（所有分析器窗口中均有）</li><li>分配对象数量（Memory Profiler 中）</li><li>垃圾回收 Event（Memory Profiler 中）</li><li>有关所有传输的文件的详情（Network Profiler 中）</li></ul><p>要启用高级分析，请按以下步骤操作：</p><ol><li>选择 <strong>Run &gt; Edit Configurations</strong>。</li><li>在左侧窗格中选择您的应用模块。</li><li>点击 <strong>Profiling</strong> 标签，然后勾选 <strong>Enable advanced profiling</strong>。</li></ol><p>现在重新构建并运行您的应用，即可获取完整的分析功能。但请注意，高级分析会减缓您的构建速度，所以仅当您想要开始分析应用时才启用此功能。</p><blockquote><p>注：对于原生代码，不可使用高级分析功能。 如果您的应用是纯原生应用（不含 Java <code>Activity</code> 类），则不可使用高级分析功能。 如果您的应用使用了 JNI，则可使用部分高级分析功能，例如 Event 时间线、GC Event、Java 分配对象和基于 Java 的网络活动，但不能检测基于原生的分配和网络活动。</p></blockquote><h2 id="使用-CPU-Profiler-检查-CPU-活动-和函数跟踪"><a href="#使用-CPU-Profiler-检查-CPU-活动-和函数跟踪" class="headerlink" title="使用 CPU Profiler 检查 CPU 活动 和函数跟踪"></a>使用 CPU Profiler 检查 CPU 活动 和函数跟踪</h2><p>使用 CPU Profiler 检查 CPU 活动 和函数跟踪 CPU Profiler 可帮助您实时检查应用的 CPU 使用率和线程活动，并记录函数跟踪，以便您可以优化和调试您的应用代码。点击 <strong>Android Profiler</strong> 窗口中的 <strong>CPU</strong> 时间线中的任意位置即可打开 <strong>CPU Profiler</strong>。</p><h3 id="为什么要分析-CPU-使用率"><a href="#为什么要分析-CPU-使用率" class="headerlink" title="为什么要分析 CPU 使用率"></a>为什么要分析 CPU 使用率</h3><p>最大限度减少应用的 CPU 使用率具有许多优势，如提供更快更顺畅的用户体验，以及延长设备电池续航时间。 它还可帮助应用在各种新旧设备上保持良好性能。 与应用交互时，您可以使用 CPU Profiler 监控 CPU 使用率和线程活动。 不过，如需了解应用如何执行其代码的详细信息，您应<a href="https://developer.android.google.cn/studio/profile/cpu-profiler#method_traces" target="_blank" rel="noopener">记录和检查函数跟踪</a>。</p><p>对于应用进程中的每个线程，您可以查看一段时间内执行了哪些函数，以及在其执行期间每个函数消耗的 CPU 资源。 您还可以使用函数跟踪来识别调用方和被调用方。 调用方指调用其他函数的函数，而被调用方是指被其他函数调用的函数。 您可以使用此信息确定哪些函数负责调用常常会消耗大量特定资源的任务，并尝试优化应用代码以避免不必要的工作。</p><p>如果您想收集可帮助您检查原生系统进程的详细系统级数据，并解决掉帧引起的界面卡顿，您应使用 <a href="https://developer.android.google.cn/studio/profile/systrace-commandline.html" target="_blank" rel="noopener">systrace</a>。</p><p>或者，如果您想导出您使用 <a href="https://developer.android.google.cn/reference/android/os/Debug.html" target="_blank" rel="noopener">Debug</a> 类捕获的 <code>.trace</code> 文件，您应使用 <a href="https://developer.android.google.cn/studio/profile/traceview.html" target="_blank" rel="noopener">Traceview</a>。</p><h3 id="CPU-Profiler-概览"><a href="#CPU-Profiler-概览" class="headerlink" title="CPU Profiler 概览"></a>CPU Profiler 概览</h3><p>当您打开 CPU Profiler 时，它将立即开始显示应用的 CPU 使用率和线程活动。CPU Profiler 的默认视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/165135123618ed9d?w=900&amp;h=546&amp;f=png&amp;s=174876" alt="CPU Profiler"></p><p>如图所示，CPU Profiler 的默认视图包括以下内容：</p><ol><li><strong>Event 时间线：</strong> 显示应用中在其生命周期不同状态间转换的活动，并表明用户与设备的交互，包括屏幕旋转 Event。 如需了解有关 Event 时间线的更多信息，包括如何启用它，请阅读 <a href="https://developer.android.google.cn/studio/profile/android-profiler.html#advanced-profiling" target="_blank" rel="noopener">启用高级分析</a>。</li><li><strong>CPU 时间线：</strong> 显示应用的实时 CPU 使用率（以占总可用 CPU 时间的百分比表示）以及应用使用的总线程数。 此时间线还显示其他进程的 CPU 使用率（如系统进程或其他应用），以便您可以将其与您的应用使用率进行对比。 通过沿时间线的水平轴移动鼠标，您还可以检查历史 CPU 使用率数据。</li><li><p><strong>线程活动时间线：</strong> 列出属于应用进程的每个线程并使用下面列出的颜色沿时间线标示它们的活动。 在您记录一个函数跟踪后，您可以从此时间线中选择一个线程以在跟踪窗格中检查其数据。</p><blockquote><ul><li><strong>绿色：</strong> 表示线程处于活动状态或准备使用 CPU。 即，它正在“运行中”或处于“可运行”状态。</li><li><strong>黄色：</strong> 表示线程处于活动状态，但它正在等待一个 I/O 操作（如磁盘或网络 I/O），然后才能完成它的工作。</li><li><strong>灰色：</strong> 表示线程正在休眠且没有消耗任何 CPU 时间。当线程需要访问尚不可用的资源时偶尔会发生这种情况。线程进入自主休眠或内核将此线程置于休眠状态，直到所需的资源可用。</li></ul></blockquote></li><li><p><strong>记录配置：</strong> 允许您选择以下选项之一以确定分析器记录函数跟踪的方式。</p><blockquote><ul><li><strong>Sampled：</strong> 一个默认配置，在应用执行期间频繁捕获应用的调用堆栈。 分析器比较捕获的数据集以推导与应用代码执行有关的时间和资源使用信息。 基于“Sampled”的跟踪的固有问题是，如果应用在捕获调用堆栈后进入一个函数并在下一次捕获前退出该函数，则分析器不会记录该函数调用。 如果您对此类生命周期很短的跟踪函数感兴趣，您应使用“Instrumented”跟踪。</li><li><strong>Instrumented：</strong> 一个默认配置，在运行时设置应用以在每个函数调用的开始和结束时记录时间戳。 它收集时间戳并进行比较，以生成函数跟踪数据，包括时间信息和 CPU 使用率。 请注意，与设置每个函数关联的开销会影响运行时性能，并可能会影响分析数据，对于生命周期相对较短的函数，这一点更为明显。 此外，如果应用短时间内执行大量函数，则分析器可能会迅速超出它的文件大小限制，且不能再记录更多跟踪数据。</li><li><strong>Edit configurations：</strong> 允许您更改上述“Sampled”和“Instrumented”记录配置的某些默认值，并将它们另存为自定义配置。 如需了解更多信息，请转到<a href="https://developer.android.google.cn/studio/profile/cpu-profiler#configurations" target="_blank" rel="noopener">创建记录配置</a>部分。</li></ul></blockquote></li><li><p><strong>记录按钮：</strong> 用于开始和停止记录函数跟踪。 如需了解更多信息，请转到<a href="https://developer.android.google.cn/studio/profile/cpu-profiler#method_traces" target="_blank" rel="noopener">记录和检查函数跟踪</a>部分。</p><blockquote><p>注： 分析器还会报告 Android Studio 和 Android 平台添加到您的应用进程（如 JDWP、Profile Saver、Studio:VMStats、Studio:Perfa 以及 Studio:Heartbeat，尽管它们在线程活动时间线中显示的确切名称可能有所不同）的线程 CPU 使用率。 这表示 CPU 时间线中应用的 CPU 使用率还可反映这些线程使用的 CPU 时间。 您可以在线程活动时间线中查看其中的一些线程并监控其活动。 （不过，由于分析器线程执行原生代码，因此，您无法为它们记录函数跟踪数据。）Android Studio 将报告此数据，以便当线程活动及 CPU 使用率实际上是由应用代码引发时，您可以轻松识别。</p></blockquote></li></ol><h3 id="记录和检查函数跟踪"><a href="#记录和检查函数跟踪" class="headerlink" title="记录和检查函数跟踪"></a>记录和检查函数跟踪</h3><p>要开始记录函数跟踪，从下拉菜单中选择 <strong>Sampled</strong> 或 <strong>Instrumented</strong> 记录配置，或选择您创建的<a href="https://developer.android.google.cn/studio/profile/cpu-profiler#configurations" target="_blank" rel="noopener">自定义记录配置</a>，然后点击 <strong>Record</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/6/1650e9376175da3f?w=24&h=24&f=png&s=704" style="vertical-align:middle;">。 与应用交互并在完成后点击 <strong>Stop recording</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/6/1650e938a6b85760?w=24&h=24&f=png&s=246" style="vertical-align:middle;">。 分析器将自动选择记录的时间范围，并在函数跟踪窗格中显示其跟踪信息。如果您想检查另一个线程的函数跟踪，只需从线程活动时间线中选中它。<br>记录函数跟踪后的 CPU Profiler 视图，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/16513522c74d5886?w=900&amp;h=519&amp;f=png&amp;s=287135" alt="CPU Profiler"><br>如图所示，记录函数跟踪后的 CPU Profiler 视图包括以下内容：</p><ol><li><strong>选择时间范围：</strong> 用于确定您要在跟踪窗格中检查所记录时间范围的哪一部分。 当您首次记录函数跟踪时，CPU Profiler 将在 CPU 时间线中自动选择您的记录的完整长度。 如果您想仅检查所记录时间范围一小部分的函数跟踪数据，您可以点击并拖动突出显示的区域边缘以修改其长度。</li><li><strong>时间戳：</strong> 用于表示所记录函数跟踪的开始和结束时间（相对于分析器从设备开始收集 CPU 使用率信息的时间）。 在选择时间范围时，您可以点击时间戳以自动选择完整记录，如果您有多个要进行切换的记录，则此做法尤其有用。</li><li><strong>跟踪窗格：</strong> 用于显示您所选的时间范围和线程的函数跟踪数据。 仅在您至少记录一个函数跟踪后此窗格才会显示。 在此窗格中，您可以选择想如何查看每个堆叠追踪（使用跟踪标签），以及如何测量执行时间（使用时间引用下拉菜单）。</li><li>选择后，可通过 <strong>Top Down</strong> 树、<strong>Bottom Up</strong> 树、<strong>调用图表</strong>或<strong>火焰图</strong>的形式显示您的函数跟踪。 您可以在下文中了解每个跟踪窗格标签的更多信息。</li><li>从下拉菜单中选择以下选项之一，以确定如何测量每个函数调用的时间信息：<blockquote><ul><li><strong>Wall clock time：</strong> 壁钟时间信息表示实际经过的时间。</li><li><strong>Thread time：</strong> 线程时间信息表示实际经过的时间减去线程没有消耗 CPU 资源的任意时间部分。对于任何给定函数，其线程时间始终少于或等于其壁钟时间。 使用线程时间可以让您更好地了解线程的实际 CPU 使用率中有多少是给定函数消耗的。</li></ul></blockquote></li></ol><h2 id="使用-Memory-Profiler-查看-Java-堆和内存分配"><a href="#使用-Memory-Profiler-查看-Java-堆和内存分配" class="headerlink" title="使用 Memory Profiler 查看 Java 堆和内存分配"></a>使用 Memory Profiler 查看 Java 堆和内存分配</h2><p>Memory Profiler 是 <a href="https://developer.android.google.cn/studio/preview/features/android-profiler.html" target="_blank" rel="noopener">Android Profiler</a> 中的一个组件，可帮助您识别导致应用卡顿、冻结甚至崩溃的内存泄漏和流失。 它显示一个应用内存使用量的实时图表，让您可以捕获堆转储、强制执行垃圾回收以及跟踪内存分配。点击 <strong>Android Profiler</strong> 窗口中的 <strong>MEMORY</strong> 时间线中的任意位置即可打开 <strong>Memory Profiler</strong>。或者，您可以在命令行中使用 <a href="https://developer.android.google.cn/studio/command-line/dumpsys.html" target="_blank" rel="noopener">dumpsys</a> 检查您的应用内存，同时<a href="https://developer.android.google.cn/studio/debug/am-logcat.html#memory-logs" target="_blank" rel="noopener">查看 logcat 中的 GC Event</a>。</p><h3 id="为什么应分析您的应用内存"><a href="#为什么应分析您的应用内存" class="headerlink" title="为什么应分析您的应用内存"></a>为什么应分析您的应用内存</h3><p>Android 提供一个<a href="https://developer.android.google.cn/topic/performance/memory-overview.html" target="_blank" rel="noopener">托管内存环境</a>—当它确定您的应用不再使用某些对象时，垃圾回收器会将未使用的内存释放回堆中。 虽然 Android 查找未使用内存的方式在不断改进，但对于所有 Android 版本，系统都必须在某个时间点短暂地暂停您的代码。 大多数情况下，这些暂停难以察觉。 不过，如果您的应用分配内存的速度比系统回收内存的速度快，则当收集器释放足够的内存以满足您的分配需要时，您的应用可能会延迟。 此延迟可能会导致您的应用跳帧，并使系统明显变慢。</p><p>尽管您的应用不会表现出变慢，但如果存在内存泄漏，则即使应用在后台运行也会保留该内存。 此行为会强制执行不必要的垃圾回收 Event，因而拖慢系统的内存性能。 最后，系统被迫终止您的应用进程以回收内存。 然后，当用户返回您的应用时，它必须完全重启。</p><p>为帮助防止这些问题，您应使用 Memory Profiler 执行以下操作：</p><ul><li>在时间线中查找可能会导致性能问题的不理想的内存分配模式。</li><li>转储 Java 堆以查看在任何给定时间哪些对象耗尽了使用内存。长时间进行多个堆转储可帮助识别内存泄漏。</li><li>记录正常用户交互和极端用户交互期间的内存分配以准确识别您的代码在何处短时间分配了过多对象，或分配了泄漏的对象。</li></ul><p>如需了解可减少应用内存使用的编程做法，请阅读<a href="https://developer.android.google.cn/topic/performance/memory.html" target="_blank" rel="noopener">管理您的应用内存</a>。</p><h3 id="Memory-Profiler-概览"><a href="#Memory-Profiler-概览" class="headerlink" title="Memory Profiler 概览"></a>Memory Profiler 概览</h3><p>当您首次打开 Memory Profiler 时，您将看到一条表示应用内存使用量的详细时间线，并可访问用于强制执行垃圾回收、捕捉堆转储和记录内存分配的各种工具。Memory Profiler 的默认视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/1651358b73ca33ff?w=900&amp;h=427&amp;f=png&amp;s=147425" alt="Memory Profiler"></p><p>如图所示，Memory Profiler 的默认视图包括以下各项：</p><ol><li>用于强制执行垃圾回收 Event 的按钮。</li><li><a href="https://developer.android.google.cn/studio/profile/memory-profiler#capture-heap-dump" target="_blank" rel="noopener">用于捕获堆转储的按钮</a>。</li><li><a href="https://developer.android.google.cn/studio/profile/memory-profiler#record-allocations" target="_blank" rel="noopener">用于记录内存分配情况的按钮</a>。 此按钮仅在连接至运行 Android 7.1 或更低版本的设备时才会显示。</li><li>用于放大/缩小时间线的按钮。</li><li>用于跳转至实时内存数据的按钮。</li><li>Event 时间线，其显示活动状态、用户输入 Event 和屏幕旋转 Event。</li><li>内存使用量时间线，其包含以下内容：<blockquote><ul><li>一个显示每个内存类别使用多少内存的堆叠图表，如左侧的 y 轴以及顶部的彩色键所示。</li><li>虚线表示分配的对象数，如右侧的 y 轴所示。</li><li>用于表示每个垃圾回收 Event 的图标。</li></ul></blockquote></li></ol><p>不过，如果您使用的是运行 Android 7.1 或更低版本的设备，则默认情况下，并不是所有分析数据均可见。 如果您看到一条消息，其显示“Advanced profiling is unavailable for the selected process”，则需要<a href="https://developer.android.google.cn/studio/preview/features/android-profiler.html#advanced-profiling" target="_blank" rel="noopener">启用高级分析</a>以查看下列内容：</p><ul><li>Event 时间线</li><li>分配的对象数</li><li>垃圾回收 Event</li></ul><p>在 Android 8.0 及更高版本上，始终为可调试应用启用高级分析。</p><h4 id="如何计算内存"><a href="#如何计算内存" class="headerlink" title="如何计算内存"></a>如何计算内存</h4><p>您在 Memory Profiler 顶部看到的数字取决于您的应用根据 Android 系统机制所提交的所有私有内存页面数。 此计数不包含与系统或其他应用共享的页面。<br>Memory Profiler 顶部的内存计数图例，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/16513597eb498e14?w=900&amp;h=26&amp;f=png&amp;s=22990" alt="Memory Profiler Counts"></p><p>内存计数中的类别如下所示：</p><ul><li><strong>Java：</strong> 从 Java 或 Kotlin 代码分配的对象内存。</li><li><p><strong>Native：</strong> 从 C 或 C++ 代码分配的对象内存。</p><blockquote><p>即使您的应用中不使用 C++，您也可能会看到此处使用的一些原生内存，因为 Android 框架使用原生内存代表您处理各种任务，如处理图像资源和其他图形时，即使您编写的代码采用 Java 或 Kotlin 语言。</p></blockquote></li><li><p><strong>Graphics：</strong> 图形缓冲区队列向屏幕显示像素（包括 GL 表面、GL 纹理等等）所使用的内存。（请注意，这是与 CPU 共享的内存，不是 GPU 专用内存。）</p></li><li><strong>Stack：</strong> 您的应用中的原生堆栈和 Java 堆栈使用的内存。 这通常与您的应用运行多少线程有关。</li><li><strong>Code：</strong> 您的应用用于处理代码和资源（如 dex 字节码、已优化或已编译的 dex 码、.so 库和字体）的内存。</li><li><strong>Other：</strong> 您的应用使用的系统不确定如何分类的内存。</li><li><strong>Allocated：</strong> 您的应用分配的 Java/Kotlin 对象数。 它没有计入 C 或 C++ 中分配的对象。</li></ul><p>当连接至运行 Android 7.1 及更低版本的设备时，此分配仅在 Memory Profiler 连接至您运行的应用时才开始计数。 因此，您开始分析之前分配的任何对象都不会被计入。 不过，Android 8.0 附带一个设备内置分析工具，该工具可记录所有分配，因此，在 Android 8.0 及更高版本上，此数字始终表示您的应用中待处理的 Java 对象总数。</p><p>与以前的 Android Monitor 工具中的内存计数相比，新的 Memory Profiler 以不同的方式记录您的内存，因此，您的内存使用量现在看上去可能会更高些。 Memory Profiler 监控的类别更多，这会增加总的内存使用量，但如果您仅关心 Java 堆内存，则“Java”项的数字应与以前工具中的数值相似。</p><p>然而，Java 数字可能与您在 Android Monitor 中看到的数字并非完全相同，这是因为应用的 Java 堆是从 Zygote 启动的，而新数字则计入了为它分配的所有物理内存页面。 因此，它可以准确反映您的应用实际使用了多少物理内存。</p><blockquote><p>注：目前，Memory Profiler 还会显示应用中的一些误报的原生内存使用量，而这些内存实际上是分析工具使用的。 对于大约 100000 个对象，最多会使报告的内存使用量增加 10MB。 在这些工具的未来版本中，这些数字将从您的数据中过滤掉。</p></blockquote><h3 id="查看内存分配"><a href="#查看内存分配" class="headerlink" title="查看内存分配"></a>查看内存分配</h3><p>内存分配显示内存中每个对象是如何分配的。 具体而言，Memory Profiler 可为您显示有关对象分配的以下信息：</p><ul><li>分配哪些类型的对象以及它们使用多少空间。</li><li>每个分配的堆叠追踪，包括在哪个线程中。</li><li>对象在何时被取消分配（仅当使用运行 Android 8.0 或更高版本的设备时）。</li></ul><p>如果您的设备运行 Android 8.0 或更高版本，您可以随时按照下述方法查看您的对象分配： 只需点击并按住时间线，并拖动选择您想要查看分配的区域。 不需要开始记录会话，因为 Android 8.0 及更高版本附带设备内置分析工具，可持续跟踪您的应用分配。如下如所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/20/1655579d3b39c0c8?w=800&amp;h=552&amp;f=gif&amp;s=2824291" alt=""></p><p>如果您的设备运行 Android 7.1 或更低版本，则在 Memory Profiler 工具栏中点击 <strong>Record memory allocations</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/6/1650e9376175da3f?w=24&h=24&f=png&s=704" style="vertical-align:middle;">。 记录时，Android Monitor 将跟踪您的应用中进行的所有分配。 操作完成后，点击 <strong>Stop recording</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/6/1650e938a6b85760?w=24&h=24&f=png&s=246" style="vertical-align:middle;">（同一个按钮）以查看分配。如下如所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/20/165557bab738c330?w=800&amp;h=552&amp;f=gif&amp;s=1907540" alt=""></p><p>在选择一个时间线区域后（或当您使用运行 Android 7.1 或更低版本的设备完成记录会话时），已分配对象的列表将显示在时间线下方，按类名称进行分组，并按其堆计数排序。</p><blockquote><p>注：在 Android 7.1 及更低版本上，您最多可以记录 65535 个分配。 如果您的记录会话超出此限值，则记录中仅保存最新的 65535 个分配。 （在 Android 8.0 及更高版本中，则没有实际的限制。）</p></blockquote><p>要检查分配记录，请按以下步骤操作：</p><ol><li>浏览列表以查找堆计数异常大且可能存在泄漏的对象。 为帮助查找已知类，点击 <strong>Class Name</strong> 列标题以按字母顺序排序。 然后点击一个类名称。 此时在右侧将出现 <strong>Instance View</strong> 窗格，显示该类的每个实例，如下图中所示。</li><li>在 <strong>Instance View</strong> 窗格中，点击一个实例。 此时下方将出现 <strong>Call Stack</strong> 标签，显示该实例被分配到何处以及哪个线程中。</li><li>在 <strong>Call Stack</strong> 标签中，点击任意行以在编辑器中跳转到该代码。<br>有关每个已分配对象的详情在右侧的 Instance View 中的显示，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/165135a30bccf7ad?w=900&amp;h=509&amp;f=png&amp;s=355818" alt="Memory Profiler Allocations Detail"></li></ol><p>默认情况下，左侧的分配列表按类名称排列。在列表顶部，您可以使用右侧的下拉列表在以下排列方式之间进行切换：</p><ul><li><strong>Arrange by class：</strong> 基于类名称对所有分配进行分组。</li><li><strong>Arrange by package：</strong> 基于软件包名称对所有分配进行分组。</li><li><strong>Arrange by callstack：</strong> 将所有分配分组到其对应的调用堆栈。</li></ul><h3 id="捕获堆转储"><a href="#捕获堆转储" class="headerlink" title="捕获堆转储"></a>捕获堆转储</h3><p>堆转储显示在您捕获堆转储时您的应用中哪些对象正在使用内存。 特别是在长时间的用户会话后，堆转储会显示您认为不应再位于内存中却仍在内存中的对象，从而帮助识别内存泄漏。 在捕获堆转储后，您可以查看以下信息：</p><ul><li>您的应用已分配哪些类型的对象，以及每个类型分配多少。</li><li>每个对象正在使用多少内存。</li><li>在代码中的何处仍在引用每个对象。</li><li>对象所分配到的调用堆栈（目前，如果您在记录分配时捕获堆转储，则只有在 Android 7.1 及更低版本中，堆转储才能使用调用堆栈）。</li></ul><p>要捕获堆转储，在 Memory Profiler 工具栏中点击 <strong>Dump Java heap</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/7/1651331695f5cd62?w=24&h=24&f=png&s=902" style="vertical-align:middle;">。 在转储堆期间，Java 内存量可能会暂时增加。 这很正常，因为堆转储与您的应用发生在同一进程中，并需要一些内存来收集数据。</p><p>堆转储显示在内存时间线下，显示堆中的所有类类型，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/165132c7acf3cd47?w=800&amp;h=556&amp;f=png&amp;s=258174" alt="Memory Profiler Dump"></p><blockquote><p>注：如果您需要更精确地了解转储的创建时间，可以通过调用 <a href="https://developer.android.google.cn/reference/android/os/Debug.html#dumpHprofData(java.lang.String" target="_blank" rel="noopener">dumpHprofData()</a>) 在应用代码的关键点创建堆转储。</p></blockquote><p>要检查您的堆，请按以下步骤操作：</p><ol><li>浏览列表以查找堆计数异常大且可能存在泄漏的对象。 为帮助查找已知类，点击 <strong>Class Name</strong> 列标题以按字母顺序排序。 然后点击一个类名称。此时在右侧将出现 <strong>Instance View</strong> 窗格，显示该类的每个实例，如下图中所示。</li><li>在 <strong>Instance View</strong> 窗格中，点击一个实例。此时下方将出现 <strong>References</strong>，显示该对象的每个引用。<br>或者，点击实例名称旁的箭头以查看其所有字段，然后点击一个字段名称查看其所有引用。 如果您要查看某个字段的实例详情，右键点击该字段并选择 <strong>Go to Instance</strong>。</li><li>在 <strong>References</strong> 标签中，如果您发现某个引用可能在泄漏内存，则右键点击它并选择 <strong>Go to Instance</strong>。 这将从堆转储中选择对应的实例，显示您自己的实例数据。</li></ol><p>默认情况下，堆转储不会向您显示每个已分配对象的堆叠追踪。 要获取堆叠追踪，在点击 Dump Java heap 之前，您必须先开始记录内存分配。然后，您可以在 Instance View 中选择一个实例，并查看 Call Stack 标签以及 References 标签，如下图所示。不过，在您开始记录分配之前，可能已分配一些对象，因此，调用堆栈不能用于这些对象。包含调用堆栈的实例在图标  上用一个“堆栈”标志表示。（遗憾的是，由于堆叠追踪需要您执行分配记录，因此，您目前无法在 Android 8.0 上查看堆转储的堆叠追踪。）</p><p>默认情况下，堆转储不会向您显示每个已分配对象的堆叠追踪。 要获取堆叠追踪，在点击 Dump Java heap 之前，您必须先开始记录内存分配。然后，您可以在 Instance View 中选择一个实例，并查看 Call Stack 标签以及 References 标签，如下图所示。不过，在您开始记录分配之前，可能已分配一些对象，因此，调用堆栈不能用于这些对象。包含调用堆栈的实例在图标 <img src="https://user-gold-cdn.xitu.io/2018/8/7/16513318e337e050?w=24&h=24&f=png&s=971" style="vertical-align:middle;"> 上用一个“堆栈”标志表示。（遗憾的是，由于堆叠追踪需要您执行分配记录，因此，您目前无法在 Android 8.0 上查看堆转储的堆叠追踪。）</p><p>在您的堆转储中，请注意由下列任意情况引起的内存泄漏：</p><ul><li>长时间引用 Activity、Context、View、Drawable 和其他对象，可能会保持对 Activity 或 Context 容器的引用。</li><li>可以保持 Activity 实例的非静态内部类，如 Runnable。</li><li>对象保持时间超出所需时间的缓存。</li></ul><p>捕获堆转储需要的持续时间标示在时间线中，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/1651337080c57ed4?w=900&amp;h=474&amp;f=png&amp;s=360396" alt="Memory Profiler Dump Stacktrace"></p><p>在类列表中，您可以查看以下信息：</p><ul><li><strong>Heap Count：</strong> 堆中的实例数。</li><li><strong>Shallow Size：</strong> 此堆中所有实例的总大小（以字节为单位）。</li><li><strong>Retained Size：</strong> 为此类的所有实例而保留的内存总大小（以字节为单位）。</li></ul><p>在类列表顶部，您可以使用左侧下拉列表在以下堆转储之间进行切换：</p><ul><li><strong>Default heap：</strong> 系统未指定堆时。</li><li><strong>App heap：</strong> 您的应用在其中分配内存的主堆。</li><li><strong>Image heap：</strong> 系统启动映像，包含启动期间预加载的类。 此处的分配保证绝不会移动或消失。</li><li><strong>Zygote heap：</strong> 写时复制堆，其中的应用进程是从 Android 系统中派生的。</li></ul><p>默认情况下，此堆中的对象列表按类名称排列。 您可以使用其他下拉列表在以下排列方式之间进行切换：</p><ul><li><strong>Arrange by class：</strong> 基于类名称对所有分配进行分组。</li><li><strong>Arrange by package：</strong> 基于软件包名称对所有分配进行分组。</li><li><strong>Arrange by callstack：</strong> 将所有分配分组到其对应的调用堆栈。此选项仅在记录分配期间捕获堆转储时才有效。即使如此，堆中的对象也很可能是在您开始记录之前分配的，因此这些分配会首先显示，且只按类名称列出。</li></ul><p>默认情况下，此列表按 <strong>Retained Size</strong> 列排序。 您可以点击任意列标题以更改列表的排序方式。</p><p>在 Instance View 中，每个实例都包含以下信息：</p><ul><li><strong>Depth：</strong> 从任意 GC 根到所选实例的最短 hop 数。</li><li><strong>Shallow Size：</strong> 此实例的大小。</li><li><strong>Retained Size：</strong> 此实例支配的内存大小（根据 <a href="https://en.wikipedia.org/wiki/Dominator_(graph_theory" target="_blank" rel="noopener">dominator 树</a>)）。</li></ul><h4 id="将堆转储另存为-HPROF"><a href="#将堆转储另存为-HPROF" class="headerlink" title="将堆转储另存为 HPROF"></a>将堆转储另存为 HPROF</h4><p>在捕获堆转储后，仅当分析器运行时才能在 Memory Profiler 中查看数据。 当您退出分析会话时，您将丢失堆转储。 因此，如果您要保存堆转储以供日后查看，可通过点击时间线下方工具栏中的 <strong>Export heap dump as HPROF file</strong> <img src="https://user-gold-cdn.xitu.io/2018/8/7/165133f23446e14d?w=24&h=24&f=png&s=1086" style="vertical-align:middle;">，将堆转储导出到一个 HPROF 文件中。 在显示的对话框中，确保使用 <code>.hprof</code> 后缀保存文件。</p><p>然后，通过将此文件拖到一个空的编辑器窗口（或将其拖到文件标签栏中），您可以在 Android Studio 中重新打开该文件。</p><p>要使用其他 HPROF 分析器（如 <a href="https://docs.oracle.com/javase/8/docs/technotes/tools/unix/jhat.html" target="_blank" rel="noopener">jhat</a>），您需要将 HPROF 文件从 Android 格式转换为 Java SE HPROF 格式。 您可以使用 <code>android_sdk/platform-tools/</code> 目录中提供的 <code>hprof-conv</code> 工具执行此操作。 运行包括以下两个参数的 <code>hprof-conv</code> 命令：原始 HPROF 文件和转换后 HPROF 文件的写入位置。 例如：</p><pre class=" language-shell"><code class="language-shell">hprof-conv heap-original.hprof heap-converted.hprof</code></pre><h3 id="分析内存的技巧"><a href="#分析内存的技巧" class="headerlink" title="分析内存的技巧"></a>分析内存的技巧</h3><p>使用 Memory Profiler 时，您应对应用代码施加压力并尝试强制内存泄漏。 在应用中引发内存泄漏的一种方式是，先让其运行一段时间，然后再检查堆。 泄漏在堆中可能逐渐汇聚到分配顶部。 不过，泄漏越小，您越需要运行更长时间的应用才能看到泄漏。</p><p>您还可以通过以下方式之一触发内存泄漏：</p><ul><li>将设备从纵向旋转为横向，然后在不同的 Activity 状态下反复操作多次。 旋转设备经常会导致应用泄漏 <a href="https://developer.android.google.cn/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity</a>、<a href="https://developer.android.google.cn/reference/android/content/Context.html" target="_blank" rel="noopener">Context</a> 或 <a href="https://developer.android.google.cn/reference/android/content/Context.html" target="_blank" rel="noopener">View</a> 对象，因为系统会重新创建 <a href="https://developer.android.google.cn/reference/android/app/Activity.html" target="_blank" rel="noopener">Activity</a>，而如果您的应用在其他地方保持对这些对象之一的引用，系统将无法对其进行垃圾回收。</li><li>处于不同的 Activity 状态时，在您的应用与另一个应用之间切换（导航到主屏幕，然后返回到您的应用）。</li></ul><blockquote><p>提示： 您还可以使用 <a href="https://developer.android.google.cn/tools/help/monkeyrunner_concepts.html" target="_blank" rel="noopener">monkeyrunner</a> 测试框架执行上述步骤。</p></blockquote><h2 id="利用-Network-Profiler-检查网络流量"><a href="#利用-Network-Profiler-检查网络流量" class="headerlink" title="利用 Network Profiler 检查网络流量"></a>利用 Network Profiler 检查网络流量</h2><p>Network Profiler 能够在时间线上显示实时网络活动，包括发送和接收的数据以及当前的连接数。 这便于您查看应用传输数据的方式和时间，并据此对底层代码进行适当优化。点击 <strong>Android Profiler</strong> 窗口中的 <strong>NETWORK</strong> 时间线中的任意位置即可打开 <strong>Network Profiler</strong>。</p><h3 id="为什么应分析应用的网络活动"><a href="#为什么应分析应用的网络活动" class="headerlink" title="为什么应分析应用的网络活动"></a>为什么应分析应用的网络活动</h3><p>当您的应用向网络发出请求时，设备必须使用高功耗的移动或 WLAN 无线装置来收发数据包。无线装置不仅要消耗电力来传输数据，还需要消耗额外的电力来开启并且不锁定屏幕。</p><p>使用 Network Profiler，您可以查找频繁出现的短时网络活动峰值，这意味着您的应用需要经常打开无线装置，或需要长时间不锁定屏幕以处理集中出现的大量短时请求。这种模式说明您可以通过批量处理网络请求，减少必须开启无线装置来发送或接收数据的次数，从而优化应用，改善电池续航表现。这种方式还能让无线装置调整到低能耗模式，延长批量处理请求之间的间隔时间，节省能耗。</p><p>要详细了解优化应用网络活动 的相关技巧，请参阅<a href="https://developer.android.google.cn/topic/performance/power/network/index.html" target="_blank" rel="noopener">减少网络耗电量</a>。</p><h3 id="Network-Profiler-概览"><a href="#Network-Profiler-概览" class="headerlink" title="Network Profiler 概览"></a>Network Profiler 概览</h3><p>Network Profiler 的默认视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/7/1651348d8674a836?w=900&amp;h=525&amp;f=png&amp;s=363578" alt="Network Profiler"><br>窗口的顶部的①处,可以看见wifi无线信号的强弱，在时间线上可以在②处点击和拖动一部分的时间线来检测流量，然后在窗口③中会显示所选时间段内收发的文件，包括文件名，大小，类型，状态和花费时间，你可以对窗口③的列表根据列来进行排序。还可以查看所选时间段的详细拆分，拆分的timeline可以显示文件是什么时候收发的，点击窗口3的其中一个文件，可以在窗口④中查看文件的详细信息。通过切换窗口④上方标签可以查看响应数据、标题信息和调用堆栈。</p><blockquote><p>注： 必须启用高级分析才能从时间线中选择要检查的片段，查看发送和接收的文件列表，或查看有关所发送或接收的选定文件的详细信息。 要启用高级分析，请参阅<a href="https://developer.android.google.cn/studio/profile/android-profiler.html#advanced-profiling" target="_blank" rel="noopener">启用高级分析</a>。</p></blockquote><h3 id="排查网络连接问题"><a href="#排查网络连接问题" class="headerlink" title="排查网络连接问题"></a>排查网络连接问题</h3><p>如果 Network Profiler 检测到流量值，但无法识别任何受支持的网络请求，您会收到以下错误消息：</p><p>“<strong>Network Profiling Data Unavailable:</strong> There is no information for the network traffic you’ve selected.”</p><p>Network Profiler 目前只支持 <a href="https://developer.android.google.cn/reference/java/net/HttpURLConnection.html" target="_blank" rel="noopener">HttpURLConnection</a> 和 <a href="http://square.github.io/okhttp/" target="_blank" rel="noopener">OkHttp</a> 网络连接库。如果您的应用使用的是其他网络连接库，则可能无法在 Network Profiler 中查看网络活动。 如果您收到这条错误消息，但您的应用确实使用了 HttpURLConnection 或 OkHttp，请<a href="https://developer.android.google.cn/studio/report-bugs.html" target="_blank" rel="noopener">报告错误</a>或<a href="https://issuetracker.google.com/issues?q=componentid:192708+" target="_blank" rel="noopener">搜索 Issue Tracker</a>，在与您的问题有关的现有报告中加入您的反馈。 此外，您还可以利用以下资源请求提供关于其他库的支持。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://developer.android.google.cn/studio/profile/android-profiler" target="_blank" rel="noopener">利用 Android Profiler 测量应用性能</a></p><p><a href="https://developer.android.com/studio/profile/android-profiler" target="_blank" rel="noopener">Measure app performance with Android Profiler</a></p>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Android Studio </tag>
            
            <tag> Android Profiler </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>IntelliJ IDEA 共享 IDE 设置</title>
      <link href="/posts/2018/6aff36ed.html"/>
      <url>/posts/2018/6aff36ed.html</url>
      
        <content type="html"><![CDATA[<p>IntelliJ IDEA 支持安装在不同计算机上的 IntelliJ IDEA（或其他基于 IntelliJ 平台的）产品的不同实例之间共享 IDE 设置。如果您使用不同的计算机工作，这可以帮助您重新创建一个舒适的工作环境，而且不会让你对事物的外观和行为感到厌烦。</p><p>您可以通过以下方式之一共享 IDE 设置：</p><ul><li><p>通过配置 <a href="https://www.jetbrains.com/help/idea/sharing-your-ide-settings.html#settings-repository" target="_blank" rel="noopener">Settings Repository</a>。这允许您同步任何可配置的组件（启用和禁用插件列表除外），但需要根据您想要共享的设置创建 Git 存储库。如果要在团队成员中实施相同的设置，此选项很有用。</p></li><li><p>通过使用 <a href="https://www.jetbrains.com/help/idea/sharing-your-ide-settings.html#IDE_settings_sync" target="_blank" rel="noopener">IDE Settings Sync</a> 插件。它使用了 JetBrains 服务器，因此不需要额外的配置。已同步的设置与您的 <a href="https://sales.jetbrains.com/hc/en-gb/articles/208459005-What-is-JetBrains-Account-" target="_blank" rel="noopener">JetBrains 帐户</a>相关联 ，因此其他用户无法使用这些设置。</p></li></ul><p>可以同步的设置包括：IDE 主题、键盘映射、配色方案、系统设置、UI设置，菜单和工具栏设置、项目视图设置，编辑器设置、代码完成设置、参数名称提示、实时模板、代码样式和列表启用和禁用插件。</p><h2 id="通过-Settings-Repository-共享设置"><a href="#通过-Settings-Repository-共享设置" class="headerlink" title="通过 Settings Repository 共享设置"></a>通过 Settings Repository 共享设置</h2><h3 id="使用条件"><a href="#使用条件" class="headerlink" title="使用条件"></a>使用条件</h3><p>在开始使用 Settings Repository 之前，请确保 <strong>Settings Repository</strong> 插件已启用。该插件与IntelliJ IDEA 捆绑在一起，默认情况下处于启用状态。如果该插件未启用，请在 <strong>Settings / Preferences Dialog</strong> 对话框的 <strong>Plugins</strong> 页上启用它。</p><h3 id="配置-Settings-Repository"><a href="#配置-Settings-Repository" class="headerlink" title="配置 Settings Repository"></a>配置 Settings Repository</h3><p>如果要共享 IDE 设置，请执行以下步骤：</p><ol><li>在任何托管服务上创建 Git 存储库，例如 <a href="https://bitbucket.org/" target="_blank" rel="noopener">Bitbucket</a> 或 <a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>。</li><li>在安装了要共享其设置的 IntelliJ IDEA 实例的计算机上，导航到 <strong>File | Settings Repository</strong>。指定创建的远程仓库的 URL，然后点击 <strong>Overwrite Remote</strong>。</li><li>在要应用设置的每台计算机上，在 <strong>Settings/Preferences dialog</strong> 对话框中，展开 <strong>Tools</strong> 节点并选择 <strong>Settings Repository</strong>，指定创建的远程仓库的 URL，然后点击 <strong>Overwrite Local</strong>。<br>如果想要储存库保留远程设置和本地设置的组合，可以点击 <strong>Merge</strong>。如果检测到任何冲突，将显示一个对话框，可以在其中解决这些冲突。如果要使用本地设置覆盖远程设置，请单击点击 <strong>Overwrite Remote</strong>。<blockquote><p>提示：如果选择使用 <a href="https://bitbucket.org/" target="_blank" rel="noopener">Bitbucket</a> 托管你的存储库，建议使用 <a href="https://bitbucket.org/account/admin/app-passwords" target="_blank" rel="noopener">App passwords</a> 进行身份验证。您需要为存储库设置读/写权限。</p></blockquote></li></ol><p>每次执行 <strong>Update Project</strong> 或 <strong>Push</strong> 操作时，或者当关闭项目或退出 IntelliJ IDEA 时，计算机的本地设置将自动与远程仓库中的设置同步。</p><p>在第一次同步时，系统将提示您指定用户名和密码。建议使用 <a href="https://help.github.com/articles/creating-a-personal-access-token-for-the-command-line/" target="_blank" rel="noopener">access token</a> 进行 GitHub 身份验证。如果由于某种原因，您想要使用用户名和密码而不是 access token，或者您的 Git 托管服务提供商不支持它，建议您配置 <a href="https://help.github.com/articles/caching-your-github-password-in-git/" target="_blank" rel="noopener">Git credentials helper</a>。</p><p>如果要禁用自动设置同步，请导航到 <strong>File | Settings | Tools | Settings Repository</strong> 并禁用 <strong>Auto Sync</strong> 选项。您可以通过从主菜单选择 <strong>VCS | Sync Settings</strong> 来手动更新设置。</p><blockquote><p>请注意：<a href="https://support.apple.com/kb/PH20093" target="_blank" rel="noopener">macOS Keychain</a> 是受支持的，这意味着您可以在所有基于IntelliJ 平台的产品之间共享凭据（如果原始 IDE 与请求方 IDE 不同，系统将提示您授予访问权限）。</p></blockquote><h3 id="通过其他只读存储库共享更多设置"><a href="#通过其他只读存储库共享更多设置" class="headerlink" title="通过其他只读存储库共享更多设置"></a>通过其他只读存储库共享更多设置</h3><p>除了 <strong>Settings Repository</strong>，还可以配置任意数量的其他存储库，其中包含要共享的任何类型的设置，包括实时模板、文件模板、方案、部署选项等。</p><p>这些存储库被称为<strong>只读源</strong>，因为它们不能被覆盖或合并，仅用作设置源。</p><p>要配置此类存储库，请执行以下操作：</p><ol><li>在 <strong>Settings / Preferences Dialog</strong> 对话框中，展开 <strong>Tools</strong> 节点，然后选择 <strong>Settings Repository</strong>。</li><li>单击“+”并添加包含要共享设置的 GitHub 仓库的 URL。</li></ol><p>与只读源中的设置进行同步的方法与 <strong>Settings Repository</strong> 的方式相同。</p><h2 id="通过-Settings-Sync-plugin-共享设置"><a href="#通过-Settings-Sync-plugin-共享设置" class="headerlink" title="通过 Settings Sync plugin 共享设置"></a>通过 Settings Sync plugin 共享设置</h2><h3 id="使用条件-1"><a href="#使用条件-1" class="headerlink" title="使用条件"></a>使用条件</h3><p>在开始使用 Settings Sync 之前，请确保 <strong>Settings Sync</strong> 插件已启用。如果该插件未启用，请在 <strong>Settings / Preferences Dialog</strong> 对话框的 <strong>Plugins</strong> 页上启用它。</p><h3 id="配置-Settings-Sync-plugin"><a href="#配置-Settings-Sync-plugin" class="headerlink" title="配置 Settings Sync plugin"></a>配置 Settings Sync plugin</h3><p>如果要共享 IDE 设置，请执行以下步骤：</p><ol><li>登录以下任一项：<ul><li>您的 IDE：从主菜单中选择 <strong>Help | Register</strong>，选择使用 <a href="https://sales.jetbrains.com/hc/en-gb/articles/208459005-What-is-JetBrains-Account-" target="_blank" rel="noopener">JetBrains 帐户</a> 激活您的许可证并输入您的凭据。</li><li><a href="https://www.jetbrains.com/toolbox/app/" target="_blank" rel="noopener">Toolbox App</a>：单击应用程序右上角的齿轮图标，然后选择 <strong>Settings</strong> 并单击 <strong>Log in</strong> 按钮。请注意，通过登录 Toolbox App，您将自动登录到您运行的所有 JetBrains 产品。</li></ul></li><li>在 IntelliJ IDEA 窗口的右下角，单击齿轮图标并选择 <strong>Enable Settings Sync</strong>。您的本地设置将导出到关联您的帐户的 JetBrains 存储库。</li><li>如果想要自动同步所有已启用和已禁用插件的列表，请选择 <strong>Sync plugins silently</strong> 选项。有关如何禁用手动同步插件的说明，请参阅 <a href="https://www.jetbrains.com/help/idea/sharing-your-ide-settings.html#sync-plugins" target="_blank" rel="noopener">Sync plugins</a>。</li><li>在要应用这些设置的其他计算机上，单击齿轮按钮并选择 <strong>Enable Sync</strong>。在打开的对话框中，单击 <strong>Get Settings from Account</strong> 以从存储库导入设置。如果要使用本地设置覆盖存储库，请单击 <strong>Keep and Sync Local Settings</strong>。</li></ol><p>每次运行不同的 IDE 实例时（或者在超过一小时不活动后激活它），或者当任何这些设置被修改并且已应用此更改时，本地设置将自动与存储在存储库中的设置同步。</p><h3 id="Sync-plugin"><a href="#Sync-plugin" class="headerlink" title="Sync plugin"></a>Sync plugin</h3><p>安装或卸载插件或更改其状态（启用/禁用）时，可以将这些更改应用于所有 IDE 安装。</p><p>如果想要在 IDE 实例之间自动同步插件，请在启用设置同步时选择 <strong>Sync plugins silently</strong> 选项。</p><p>手动同步插件的步骤：</p><ol><li>在 IntelliJ IDEA 窗口的右下角，单击齿轮图标并选择 <strong>Sync Plugins</strong>。</li><li>打开一个对话框，显示自上次同步以来修改的所有插件的列表。单击每个插件旁边的箭头按钮，然后选择修改插件的状态、将存储库状态应用于所有安装、在本地跳过此更改或跳过所有 IDE 实例。</li><li>在为每个插件选择了要执行的操作后，单击 <strong>Apply Changes</strong>。</li></ol><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><p><a href="https://www.jetbrains.com/help/idea/sharing-your-ide-settings.html" target="_blank" rel="noopener">Sharing IDE Settings</a></p>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android Studio </tag>
            
            <tag> IntelliJ IDEA </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Charles 功能介绍和使用教程</title>
      <link href="/posts/2018/da575840.html"/>
      <url>/posts/2018/da575840.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/22/165612f68b7753f0?w=658&amp;h=263&amp;f=png&amp;s=144254" alt=""></p><h2 id="Charles-简介"><a href="#Charles-简介" class="headerlink" title="Charles 简介"></a>Charles 简介</h2><p>Charles 是在 PC 端常用的网络封包截取工具，在做移动开发时，我们为了调试与服务器端的网络通讯协议，常常需要截取网络封包来分析。除了在做移动开发中调试端口外，Charles 也可以用于分析第三方应用的通讯协议。配合 Charles 的 SSL 功能，Charles 还可以分析 Https 协议。</p><p>Charles 通过将自己设置成系统的网络访问代理服务器，使得所有的网络访问请求都通过它来完成，从而实现了网络封包的截取和分析。</p><blockquote><p>Charles 是收费软件，可以免费试用 30 天。试用期过后，未付费的用户仍然可以继续使用，但是每次使用时间不能超过 30 分钟，并且启动时将会有 10 秒种的延时。因此，该付费方案对广大用户还是相当友好的，即使你长期不付费，也能使用完整的软件功能。只是当你需要长时间进行封包调试时，会因为 Charles 强制关闭而遇到影响。</p></blockquote><p> Charles 主要的功能包括：</p><ul><li>截取 Http 和 Https 网络封包。</li><li>支持重发网络请求，方便后端调试。</li><li>支持修改网络请求参数。</li><li>支持网络请求的截获并动态修改。</li><li>支持模拟慢速网络。</li></ul><h2 id="下载安装-Charles"><a href="#下载安装-Charles" class="headerlink" title="下载安装 Charles"></a>下载安装 Charles</h2><p><img src="https://user-gold-cdn.xitu.io/2018/8/20/16556d8a1d1b5c03?w=1100&amp;h=170&amp;f=png&amp;s=54882" alt=""><br>Charles 支持的操作系统包括：</p><ul><li>Windows 64 bit(msi)</li><li>Windows 32 bit(msi)</li><li>macOS(dmg)</li><li>Linux 64 bit(tar.gz)</li><li>Linux 32 bit(tar.gz)</li></ul><p>打开浏览器访问 <a href="https://www.charlesproxy.com/" target="_blank" rel="noopener">Charles 官网</a> ，下载相应系统的 <a href="https://www.charlesproxy.com/download/" target="_blank" rel="noopener">Charles 安装包</a>，然后安装即可：</p><ul><li><strong>Windows：</strong> 运行安装应用程序以在程序菜单中安装 Charles。</li><li><strong>Mac OS X：</strong> 通过双击解压缩下载文件，然后将 Charles 应用程序复制到 Applications 目录中。</li><li><strong>Linux：</strong> Charles 拥有 <a href="https://www.charlesproxy.com/documentation/installation/apt-repository/" target="_blank" rel="noopener">APT</a> 和 <a href="https://www.charlesproxy.com/documentation/installation/yum-repository/" target="_blank" rel="noopener">YUM</a> 存储库，如果你有基于 <code>Debian</code> 或基于 <code>Red Hat</code> 的 Linux 发行版，这是安装 Charles 的首选方法。否则，将 <code>tar.gz</code> 文件解压缩到适当的站点。如果您以前安装过 Charles 并且正在进行升级；首先确保 Charles 没有运行，然后安装或复制在以前安上。通过运行 <code>bin/charles</code> 脚本启动 Charles。</li></ul><blockquote><p>如果使用 Firefox，也可以下载 Firefox 插件。参考<a href="https://www.charlesproxy.com/documentation/configuration/browser-and-system-configuration/" target="_blank" rel="noopener">Firefox Add-On</a></p></blockquote><h2 id="Charles-主界面介绍"><a href="#Charles-主界面介绍" class="headerlink" title="Charles 主界面介绍"></a>Charles 主界面介绍</h2><p>Charles 的主界面视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560927ac9848ef?w=900&amp;h=713&amp;f=png&amp;s=80843" alt=""></p><h3 id="工具导航栏"><a href="#工具导航栏" class="headerlink" title="工具导航栏"></a>工具导航栏</h3><p>Charles 顶部为菜单导航栏，菜单导航栏下面为工具导航栏。视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560de1a421b600?w=453&amp;h=66&amp;f=png&amp;s=13217" alt=""><br>工具导航栏中提供了几种常用工具：</p><ul><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560dea3bdcfc14?w=42&h=36&f=png&s=1093" style="vertical-align:middle;"> ：清除捕获到的所有请求</li><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560df2fde58597?w=43&h=38&f=png&s=2015" style="vertical-align:middle;"> ：红点状态说明正在捕获请求，灰色状态说明目前没有捕获请求。</li><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560e008f96c3e6?w=41&h=35&f=png&s=1196" style="vertical-align:middle;"> ：灰色状态说明是没有开启网速节流，绿色状态说明开启了网速节流。<ul><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560e0542d18279?w=40&h=34&f=png&s=1182" style="vertical-align:middle;"> ：灰色状态说明是没有开启断点，绿色状态说明开启了断点。</li></ul></li><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560e0edf939b25?w=40&h=36&f=png&s=1024" style="vertical-align:middle;"> ：编辑修改请求，点击之后可以修改请求的内容。</li><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560e1399e3537d?w=37&h=32&f=png&s=1176" style="vertical-align:middle;"> ：重复发送请求，点击之后选中的请求会被再次发送。</li><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560e186e4c3278?w=44&h=34&f=png&s=888" style="vertical-align:middle;"> ：验证选中的请求的响应。</li><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560e1d8a265db0?w=41&h=40&f=png&s=1584" style="vertical-align:middle;"> ：常用功能，包含了 Tools 菜单中的常用功能。</li><li><img src="https://user-gold-cdn.xitu.io/2018/8/22/16560e21d127f1fc?w=42&h=33&f=png&s=1538" style="vertical-align:middle;"> ：常用设置，包含了 Proxy 菜单中的常用设置。</li></ul><h3 id="主界面视图"><a href="#主界面视图" class="headerlink" title="主界面视图"></a>主界面视图</h3><p>Charles 主要提供两种查看封包的视图，分别名为 <code>Structure</code> 和 <code>Sequence</code>。</p><ul><li><strong>Structure</strong>： 此视图将网络请求按访问的域名分类。</li><li><strong>Sequence</strong>： 此视图将网络请求按访问的时间排序。</li></ul><p>使用时可以根据具体的需要在这两种视图之前来回切换。请求多了有些时候会看不过来，Charles 提供了一个简单的 <code>Filter</code> 功能，可以输入关键字来快速筛选出 URL 中带指定关键字的网络请求。</p><blockquote><p>对于某一个具体的网络请求，你可以查看其详细的请求内容和响应内容。如果请求内容是 POST 的表单，Charles 会自动帮你将表单进行分项显示。如果响应内容是 JSON 格式的，那么 Charles 可以自动帮你将 JSON 内容格式化，方便你查看。如果响应内容是图片，那么 Charles 可以显示出图片的预览。</p></blockquote><h2 id="Charles-菜单介绍"><a href="#Charles-菜单介绍" class="headerlink" title="Charles 菜单介绍"></a>Charles 菜单介绍</h2><p>Charles 的主菜单包括：<code>File</code>、<code>Edit</code>、<code>View</code>、<code>Proxy</code>、<code>Tools</code>、<code>Window</code>、<code>Help</code>。用的最多的主菜单分别是 <code>Proxy</code> 和 <code>Tools</code>。</p><h3 id="Proxy-菜单"><a href="#Proxy-菜单" class="headerlink" title="Proxy 菜单"></a>Proxy 菜单</h3><p>Charles 是一个 HTTP 和 SOCKS 代理服务器。代理请求和响应使 Charles 能够在请求从客户端传递到服务器时检查和更改请求，以及从服务器传递到客户端时的响应。下面主要介绍 Charles 提供的一些代理功能。Proxy 菜单的视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655b588d3eb9714?w=900&amp;h=655&amp;f=png&amp;s=151101" alt=""></p><p>Proxy 菜单包含以下功能：</p><ul><li>Start/Stop Recording：开始/停止记录会话。</li><li>Start/Stop Throttling：开始/停止节流。</li><li>Enable/Disable Breakpoints：开启/关闭断点模式。</li><li>Recording Settings：记录会话设置。</li><li>Throttle Settings：节流设置。</li><li>Breakpoint Settings：断点设置。</li><li>Reverse Proxies Settings：反向代理设置。</li><li>Port Forwarding Settings：端口转发。</li><li>Windows Proxy：记录计算机上的所有请求。</li><li>Proxy Settings：代理设置。</li><li>SSL Proxying Settings：SSL 代理设置。</li><li>Access Control Settings：访问控制设置。</li><li>External Proxy Settings：外部代理设置。</li><li>Web Interface Settings：Web 界面设置。</li></ul><h4 id="Recording-Settings-记录会话设置"><a href="#Recording-Settings-记录会话设置" class="headerlink" title="Recording Settings(记录会话设置)"></a>Recording Settings(记录会话设置)</h4><p>Recording Settings 和 Start/Stop Recording 配合使用，在 Start Recording 的状态下，可以通过 Recording Settings 配置 Charles 的会话记录行为。Recording Settings 的视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655b593cefa68c7?w=600&amp;h=397&amp;f=png&amp;s=58392" alt=""><br>Recording Settings 有 <code>Options</code>、<code>Include</code>、<code>Exclude</code> 三个选项卡：</p><ul><li>Options：通过 Recording Size Limits 限制记录数据的大小。当 Charles 记录时，请求、响应头和响应体存储在内存中，或写入磁盘上的临时文件。有时，内存中的数据量可能会变得太多，Charles 会通知您并停止录制。在这种情况下，您应该清除 Charles 会话以释放内存，然后再次开始录制。在录制设置中，您可以限制 Charles 将记录的最大大小; 这根本不会影响你的浏览，Charles 仅会停止录制。<ul><li>Include：只有与配置的地址匹配的请求才会被录制。</li><li>Exclude：只有与配置的地址匹配的请求将不会被录制。</li></ul></li></ul><p><code>Include</code> 和 <code>Exclude</code> 选项卡的操作相同，选择 <code>Add</code>，然后填入需要监控的Procotol、Host 和 Port等信息，这样就达到了过滤的目的。如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655b874abb33809?w=500&amp;h=332&amp;f=png&amp;s=57178" alt=""><br>还有一种方法就是在一个请求网址上右击选择 <code>Focus</code>，然后其他的请求就会被放到一个叫 <code>Other Host</code> 的分类里面，这样也达到了过滤的目的。</p><h4 id="Throttle-Settings-节流设置"><a href="#Throttle-Settings-节流设置" class="headerlink" title="Throttle Settings(节流设置)"></a>Throttle Settings(节流设置)</h4><p>Throttle Settings 和 Start/Stop Throttling 配合使用，在 Start Throttling 的状态下，可以通过 Throttle Settings 配置 Charles 的网速模拟配置。Throttle Settings 的视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655b8f4b564f837?w=600&amp;h=683&amp;f=png&amp;s=118057" alt=""><br>勾选 Enable Throttling 启用网速模拟配置，在 Throttle Preset 下选择网络类型即可，具体设置可以根据实际情况自行设置。如果只想模拟指定网站的慢速网络，可以再勾选上图中的 <code>Only for selected hosts</code> 项，然后在对话框的下半部分设置中增加指定的 hosts 项即可。</p><p>Throttle Settings 视图中的选项含义如下：</p><ul><li>Bandwidth：带宽</li><li>Utilistation：利用百分比</li><li>Round-trip：往返延迟</li><li>MTU：字节</li></ul><h4 id="Breakpoint-Settings-断点设置"><a href="#Breakpoint-Settings-断点设置" class="headerlink" title="Breakpoint Settings(断点设置)"></a>Breakpoint Settings(断点设置)</h4><p>Breakpoint Settings 和 Enable/Disable Breakpoints 配合使用，在 Enable Breakpoints 的状态下，可以通过 Breakpoint Settings 配置 Charles 的断点模式。Breakpoint Settings 的视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655b972ead68cca?w=673&amp;h=430&amp;f=png&amp;s=21305" alt=""><br>勾选 Enable Breakpoints 启用断点模式，选择 <code>Add</code>，然后填入需要监控的Scheme、Procotol、Host 和 Port 等信息，这样就达到了设置断点的目的。然后可以来观察或者修改请求或者返回的内容，但是在这过程中需要注意请求的超时时间问题。或者可以在某个想要设置断点的请求网址上右击选择 Breakpoints 来设置断点。</p><h4 id="Reverse-Proxies-Settings-反向代理设置"><a href="#Reverse-Proxies-Settings-反向代理设置" class="headerlink" title="Reverse Proxies Settings(反向代理设置)"></a>Reverse Proxies Settings(反向代理设置)</h4><p>反向代理在本地端口上创建 Web 服务器，该端口透明地将请求代理给远程 Web 服务器。反向代理上的所有请求和响应都可以记录在 Charles 中。</p><p>如果您的客户端应用程序不支持使用 HTTP 代理，或者您希望避免将其配置为使用代理，那么反向代理很有用。创建原始目标 Web 服务器的反向代理，然后将客户端应用程序连接到本地端口； 反向代理对客户端应用程序是透明的，使您可以查看 Charles 以前可能无法访问的流量。</p><p>有关反向代理的更多信息，请访问 <a href="http://en.wikipedia.org/wiki/Reverse_proxy" target="_blank" rel="noopener">Reverse proxy</a></p><h4 id="Port-Forwarding-Settings-端口转发"><a href="#Port-Forwarding-Settings-端口转发" class="headerlink" title="Port Forwarding Settings(端口转发)"></a>Port Forwarding Settings(端口转发)</h4><p>可以将任何 <code>TCP/IP</code> 或 <code>UDP</code> 端口配置为使用 <code>Port Forwarding</code> 工具从 Charles 转发到远程主机。这样可以调试 Charles 中的任何协议。</p><p>在 Macromedia Flash 中调试 XMLSocket 连接时，这尤其有用。</p><p>还可以使用 Charles 作为 SOCKS 代理，因此无需设置端口转发。</p><h4 id="Windows-Proxy-记录计算机上的所有请求"><a href="#Windows-Proxy-记录计算机上的所有请求" class="headerlink" title="Windows Proxy(记录计算机上的所有请求)"></a>Windows Proxy(记录计算机上的所有请求)</h4><p>如果想要抓取电脑端的请求，勾选 Windows Proxy 选项即可；如果只需要抓取手机请求，则取消勾选这个选项。</p><h4 id="Proxy-Settings-代理设置"><a href="#Proxy-Settings-代理设置" class="headerlink" title="Proxy Settings(代理设置)"></a>Proxy Settings(代理设置)</h4><p>Proxy Settings 的视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655bbc155d038e4?w=600&amp;h=511&amp;f=png&amp;s=107248" alt=""><br>代理端口默认为 8888(可以修改)，并且勾上 <code>Enable transparent HTTP proxying</code> 就完成了在 Charles 上的代理设置。</p><h4 id="SSL-Proxy-Settings-SSL-代理设置"><a href="#SSL-Proxy-Settings-SSL-代理设置" class="headerlink" title="SSL Proxy Settings(SSL 代理设置)"></a>SSL Proxy Settings(SSL 代理设置)</h4><p>SSL Proxy Settings 的视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655bbfd5ffc683a?w=600&amp;h=453&amp;f=png&amp;s=105878" alt=""><br>勾上 <code>Enable SSL proxying</code> 就完成了在 Charles 上的 SSL 代理设置。之后也可以选择 <code>Add</code>，然后填入需要监控的 Host 和 Port 信息，这样就达到了针对某个域名启用 SSL 代理的目的。</p><h4 id="Access-Control-Settings-访问控制设置"><a href="#Access-Control-Settings-访问控制设置" class="headerlink" title="Access Control Settings(访问控制设置)"></a>Access Control Settings(访问控制设置)</h4><p>Access Control Settings 表示访问控制设置。访问控制列表确定谁可以使用此 Charles 实例。通常，您在自己的计算机上运行 Charles，并且您只打算自己使用它，因此 localhost 始终包含在访问控制列表中。也可以选择 <code>Add</code>，然后填入允许访问的 IP，这样就达到了允许某个 IP 访问 Charles 的目的。</p><h4 id="External-Proxy-Settings-外部代理设置"><a href="#External-Proxy-Settings-外部代理设置" class="headerlink" title="External Proxy Settings(外部代理设置)"></a>External Proxy Settings(外部代理设置)</h4><p>External Proxy Settings 表示外部代理设置。可能在网络上有一个代理服务器，必须使用该代理服务器才能访问 Internet。在这种情况下，需要将 Charles 配置为在尝试访问 Internet 时使用现有代理。</p><p>可以配置单独的代理地址和端口：</p><ul><li>HTTP</li><li>HTTPS</li><li>SOCKS</li></ul><blockquote><p>如果您有 SOCKS 代理，Charles 将把它用于所有非 HTTP(S) 流量，例如端口转发。</p></blockquote><h4 id="Web-Interface-Settings-Web-界面设置"><a href="#Web-Interface-Settings-Web-界面设置" class="headerlink" title="Web Interface Settings(Web 界面设置)"></a>Web Interface Settings(Web 界面设置)</h4><p>Web Interface Settings 表示 Web 界面设置。Charles 有一个 Web 界面，可以让您从浏览器控制 Charles，或使用 Web 界面作为 Web 服务使用外部程序。</p><p>在 External Proxy Settings 视图中勾选 <code>Enable the web interface</code> 选项启用 Web 界面。可以允许匿名访问，也可以配置用户名和密码。还可以通过在配置使用 Charles 作为其代理的 Web 浏览器中访问 <a href="http://control.charles/" target="_blank" rel="noopener"><code>http://control.charles/</code></a> 来访问 Web 界面。</p><p>Web界面提供对以下功能的访问：</p><ul><li>节流控制<ul><li>激活或停用任何已配置的限制预设</li></ul></li><li>录音控制<ul><li>开始和停止会话录制</li></ul></li><li>工具<ul><li>激活和停用工具</li></ul></li><li>会话控制<ul><li>清除当前会话</li><li>以任何支持的格式导出当前会话</li><li>以 Charles 的本机会话格式下载当前会话</li></ul></li><li>退出查尔斯</li></ul><p>通过检查 Web 界面 HTML ，您可以推导出如何将其用作 Web 服务来自动化 Charles。</p><h3 id="Tools-菜单"><a href="#Tools-菜单" class="headerlink" title="Tools 菜单"></a>Tools 菜单</h3><p>Charles 是一个 HTTP 和 SOCKS 代理服务器，所有的请求都会经过 Charles。下面主要介绍 Charles 提供的一些实用工具。Tools 菜单的视图如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/8/21/1655b590cbdfb345?w=900&amp;h=655&amp;f=png&amp;s=162816" alt=""></p><p>Tools 菜单包含以下功能：</p><ul><li>No Caching Settings：禁用缓存设置。</li><li>Block Cookies Settings：禁用 Cookie设置。</li><li>Map Remote Settings：远程映射设置。</li><li>Map Local Settings：本地映射设置。</li><li>Rewrite Settings：重写设置。</li><li>Black List Settings：黑名单设置。</li><li>White List Settings：白名单设置。</li><li>DNS Spoofing Settings：DNS 欺骗设置。</li><li>Mirror Settings：镜像设置。</li><li>Auto Save Settings：自动保存设置。</li><li>Client Process Settings：客户端进程设置。</li><li>Compose：编辑修改。</li><li>Repeat：重复发包。</li><li>Repeat Advanced：高级重复发包。</li><li>Validate：验证。</li><li>Publish Gist：发布要点。</li><li>Import/Export Settings：导入/导出设置。</li><li>Profiles：配置文件。</li><li>Publish Gist Settings：发布要点设置。</li></ul><h4 id="No-Caching-Settings-禁用缓存"><a href="#No-Caching-Settings-禁用缓存" class="headerlink" title="No Caching Settings(禁用缓存)"></a>No Caching Settings(禁用缓存)</h4><p>No Caching 工具可防止客户端应用程序（如 Web 浏览器）缓存任何资源。因此，始终向远程网站发出请求，您始终可以看到最新版本。</p><h5 id="适用范围"><a href="#适用范围" class="headerlink" title="适用范围"></a>适用范围</h5><p>该工具可以作用于每个请求(选中 <code>Enable No Caching</code> 即可)，也可以仅对你配置的请求启用(启用 No Caching 的同时，请选中 <code>Only for selected locations</code>)。当用于选定的请求时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和路径。</p><h5 id="工作原理"><a href="#工作原理" class="headerlink" title="工作原理"></a>工作原理</h5><p>No Caching 工具通过操纵控制响应缓存的 HTTP 请求头来防止缓存。从请求中删除 If-Modified-Since 和 If-None-Match 请求头，添加 Pragma：no-cache 和 Cache-control：no-cache。从响应中删除 Expires，Last-Modified 和ETag 请求头，添加 Expires：0 和 Cache-Control：no-cache。</p><h4 id="Block-Cookies-Settings-禁用-Cookie"><a href="#Block-Cookies-Settings-禁用-Cookie" class="headerlink" title="Block Cookies Settings(禁用 Cookie)"></a>Block Cookies Settings(禁用 Cookie)</h4><p>Block Cookies 工具阻止了 Cookie 的发送和接收。它可用于测试网站，就像在浏览器中禁用了 Cookie 一样。 请注意，网络爬虫（例如 Google）通常不支持 Cookie，因此该工具还可用于模拟网络爬虫网站的视图。</p><h5 id="适用范围-1"><a href="#适用范围-1" class="headerlink" title="适用范围"></a>适用范围</h5><p>该工具可以作用于每个请求(选中 <code>Enable Block Cookies</code> 即可)，也可以仅对你配置的请求启用(启用 Block Cookies 的同时，请选中 <code>Only for selected locations</code>)。当用于选定的请求时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和路径。</p><h5 id="工作原理-1"><a href="#工作原理-1" class="headerlink" title="工作原理"></a>工作原理</h5><p>Block Cookies 工具通过操纵控制响应 Cookies 的 HTTP 请求头来禁用 Cookies。从请求中移除 Cookie 请求头，防止 Cookie 值从客户端应用程序（例如 Web 浏览器）发送到远程服务器。从响应中删除 Set-Cookie 请求头，防止请求设置客户端应用程序从远程服务器接收的 Cookie。</p><h4 id="Map-Remote-Settings-远程映射"><a href="#Map-Remote-Settings-远程映射" class="headerlink" title="Map Remote Settings(远程映射)"></a>Map Remote Settings(远程映射)</h4><p>Map Remote 工具根据配置的映射更改请求站点，以便从新站点透明地提供响应，就好像这是原始请求一样。</p><p>通过此映射，您可以从另一个站点提供全部或部分站点。例如：</p><ul><li>可以把 xk72.com/charles/ 映射到 localhost/charlesdev/ 来为 xk72.com 提供一个子目录；</li><li>可以把 xk72.com/*.php 这种指定后缀的所有文件映射到 localhost/charlesdev/。</li></ul><h5 id="使用建议"><a href="#使用建议" class="headerlink" title="使用建议"></a>使用建议</h5><p>如果您拥有站点的开发版本并且希望能够通过开发提供的某些请求浏览实时站点，则 Map Remote 非常有用。例如，您可能希望从开发服务器提供 css 和 images 目录。使用 live.com/css/ 等映射到 dev.com/css/ 或 live.com/*.css 到 dev.com 。</p><h5 id="映射类型"><a href="#映射类型" class="headerlink" title="映射类型"></a>映射类型</h5><ul><li>可以将目录映射到目录，如 xk72.com/charles/ 映射到 localhost/charlesdev/；</li><li>可以将文件映射到文件，如 xk72.com/charles/download.php 映射到 abc.com/testing/test.html；</li><li>可以将带有文件模式的目录映射到目录，如 xk72.com/charles/*.php 到 localhost/charlesdev/；</li><li>如果在目标映射中未指定路径，则 URL 的路径部分将不会更改。如果要映射到根目录，请在目标路径字段中已 <code>/</code> 结尾。</li></ul><h5 id="HTTPS"><a href="#HTTPS" class="headerlink" title="HTTPS"></a>HTTPS</h5><p>Map Remote 工具可以将 HTTP 请求映射到 HTTPS 目标，反之亦然，因此您可以将 HTTP 或 HTTPS 站点映射到其对立面。</p><h5 id="站点匹配"><a href="#站点匹配" class="headerlink" title="站点匹配"></a>站点匹配</h5><p>每个站点匹配可能包含协议、主机、端口和路径模式，以匹配特定的 URL。站点可能包括通配符。当您向此工具添加新站点时，可能会找到有关创建站点匹配的更多帮助。</p><h4 id="Map-Local-Settings-本地映射"><a href="#Map-Local-Settings-本地映射" class="headerlink" title="Map Local Settings(本地映射)"></a>Map Local Settings(本地映射)</h4><p>Map Local 工具使您可以使用本地文件，就像它们是远程网站的一部分一样。您可以在本地开发文件，并像在线上一样测试它们。本地文件的内容将返回给客户端，就像它是正常的远程响应一样。</p><p>Map Local 可以大大加快开发和测试速度，否则您必须将文件上传到网站以测试结果。使用 Map Local，您可以在开发环境中安全地进行测试。</p><h5 id="动态文件"><a href="#动态文件" class="headerlink" title="动态文件"></a>动态文件</h5><p>动态文件（例如包含服务器端脚本的文件）不会由 Map Local 执行，因此如果文件中有任何脚本，脚本将按原样返回到浏览器，这可能不是预期的结果。如果您想使用动态文件，就好像它们是远程网站的一部分一样，请参阅 Map Remote 工具。</p><h5 id="工作原理-2"><a href="#工作原理-2" class="headerlink" title="工作原理"></a>工作原理</h5><p>当请求与 Map Local 映射匹配时，它会检查与路径匹配的本地文件。它不包括查询字符串（如果有）。如果在本地找到所请求的文件，则将其作为响应返回，就好像它是从远程站点加载的一样，因此它对客户端是透明的。如果在本地找不到所请求的文件，那么该请求会像平常一样由网站提供，返回由真正的服务器提供的数据。</p><h5 id="站点匹配-1"><a href="#站点匹配-1" class="headerlink" title="站点匹配"></a>站点匹配</h5><p>每个站点匹配可能包含协议、主机、端口和路径模式，以匹配特定的 URL。站点可能包括通配符。当您向此工具添加新站点时，可能会找到有关创建站点匹配的更多帮助。</p><h4 id="Rewrite-Settings-重写"><a href="#Rewrite-Settings-重写" class="headerlink" title="Rewrite Settings(重写)"></a>Rewrite Settings(重写)</h4><p>Rewrite 工具允许创建请求和响应在通过 Charles 时修改他们的规则。如：添加或更改头信息、搜索和替换响应内容中的某些文本等。</p><h5 id="重写集"><a href="#重写集" class="headerlink" title="重写集"></a>重写集</h5><p>重写集可以单独激活和停用。每个集合包含站点和规则的列表。这些站点选择规则将要运行的请求和响应。</p><h5 id="重写规则"><a href="#重写规则" class="headerlink" title="重写规则"></a>重写规则</h5><p>每个规则都描述了一次重写操作。规则可能会影响请求URL的 Header，正文或部分内容；它可以根据请求或响应来操作；它可以定义搜索、替换或者仅替换样式重写。</p><h5 id="站点匹配-2"><a href="#站点匹配-2" class="headerlink" title="站点匹配"></a>站点匹配</h5><p>每个站点匹配可能包含协议、主机、端口和路径模式，以匹配特定的 URL。站点可能包括通配符。当您向此工具添加新站点时，可能会找到有关创建站点匹配的更多帮助。</p><h5 id="调试"><a href="#调试" class="headerlink" title="调试"></a>调试</h5><p>当重写操作未按预期工作时，重写工具可能难以调试。如果您遇到问题，请尝试添加一个非常基本的规则，例如添加明显头信息的规则，以便您可以查看规则是否与请求完全匹配。同时打开错误日志中的调试，以获取从 Charles 中的 Window 菜单访问的错误日志中打印的一些调试信息。</p><h4 id="Black-List-Settings-黑名单"><a href="#Black-List-Settings-黑名单" class="headerlink" title="Black List Settings(黑名单)"></a>Black List Settings(黑名单)</h4><p>Black List 工具允许输入应该被阻止的域名。当 Web 浏览器尝试从被列入黑名单的域名请求任何页面时，该请求将被 Charles 阻止。您还可以输入通配符来阻止其子域名。</p><h4 id="White-List-Settings-白名单"><a href="#White-List-Settings-白名单" class="headerlink" title="White List Settings(白名单)"></a>White List Settings(白名单)</h4><p>Black List 工具允许输入仅仅被允许的域名。Black List 工具将阻止除被列入白名单的域名之外的所有请求。</p><blockquote><p>白名单工具用于仅允许指定的域名；黑名单工具，用于仅屏蔽指定的域名。 </p><p>如果一个请求与“黑名单”和“白名单”都匹配，则该请求会被阻止。</p></blockquote><h4 id="DNS-Spoofing-Settings-DNS-欺骗"><a href="#DNS-Spoofing-Settings-DNS-欺骗" class="headerlink" title="DNS Spoofing Settings(DNS 欺骗)"></a>DNS Spoofing Settings(DNS 欺骗)</h4><p>DNS Spoofing 工具允许通过将自己的主机名指定给远程地址映射来欺骗 DNS 查找。 当请求通过 Charles 时，您的 DNS 映射将优先。</p><p>Charles 包含配置的域名到 IP 地址映射的列表。当针对列出的域名发出请求时，Spoof DNS 插件会发现欺骗 IP 将请求重定向到该地址。主机HTTP标头保持不变，因此就像您的 DNS 服务器返回欺骗性 IP一样。</p><h5 id="虚拟主机"><a href="#虚拟主机" class="headerlink" title="虚拟主机"></a>虚拟主机</h5><p>虚拟主机是指单个IP地址上有多个站点，Web 服务器根据浏览器中键入的名称确定要请求的站点。更准确地说，它查看请求中发送的主机头。</p><p>如果没有为您的站点设置 DNS，那么您通常无法测试它，因为您不能只输入 IP 地址，因为服务器无法获取名称，因此无法将请求与网站。使用 DNS 欺骗工具来克服此问题。</p><h4 id="Mirror-Settings-镜像"><a href="#Mirror-Settings-镜像" class="headerlink" title="Mirror Settings(镜像)"></a>Mirror Settings(镜像)</h4><p>Mirror 工具会在浏览指定站点时，把接收到的响应内容克隆一份，并保存在磁盘上指定的路径下。</p><p>保存文件的路径会与浏览站点的目录结构相同，并且 Charles 会为主机名创建一个根目录。文件名从 URL 导出并转换为适合的数据进行保存。查询字符串包含在文件名中。如果收到相同 URL 的两个响应，则后面一个文件会覆盖前面的同名文件，因此保存在镜像中在的响应内容将始终为最新的。</p><h5 id="选定站点"><a href="#选定站点" class="headerlink" title="选定站点"></a>选定站点</h5><p>可以为每个请求启用该工具，也可以仅为指定站点启用该工具。当用于选定的站点时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和/或路径。</p><h5 id="副作用"><a href="#副作用" class="headerlink" title="副作用"></a>副作用</h5><p>如果为请求启用镜像工具，它将导致任何压缩或编码的响应被解码。因此，如果服务器提供了压缩响应，Charles 将在传递给客户端之前对其进行解压缩，这通常不会产生任何影响。但是如果您已经构建了自己的客户端，或者客户端希望得到压缩响应，此时将会产生影响。使用 web 浏览器则没有任何影响。</p><h4 id="Auto-Save-Settings-自动保存"><a href="#Auto-Save-Settings-自动保存" class="headerlink" title="Auto Save Settings(自动保存)"></a>Auto Save Settings(自动保存)</h4><p>Auto Save 工具会按设定的时间间隔自动保存和清除记录会话。</p><p>如果您让 Charles 长时间监控网络活动，并希望将记录分解为可管理的单元，或者避免因数据量过大而可能出现的内存不足情况，这将非常有用。</p><p>输入以分钟为单位的保存间隔以及保存会话文件的目录。您可以选择是否在每次运行 Charles 时启动 <code>Auto Save</code> 工具，否则在 Charles 启动时将始终禁用 <code>Auto Save</code> 工具。</p><p>会话文件的名称中保存时间戳，格式为 <code>yyyyMMddHHmm</code>，即年月日时分，以便按字母顺序排序时，它们以正确的顺序显示。</p><h4 id="Client-Process-Settings-客户端进程"><a href="#Client-Process-Settings-客户端进程" class="headerlink" title="Client Process Settings(客户端进程)"></a>Client Process Settings(客户端进程)</h4><p>Client Process 工具显示负责发出每个请求的本地客户端进程的名称。客户端进程通常是您的 Web 浏览器(例如 firefox.exe)，但客户端进程工具可以帮助您发现许多可能未知的 HTTP 客户端。</p><p>客户端进程名称显示在每个请求的 <code>Notes</code> 区域中。</p><p>如果您可以在 Charles 中看到不确定原始进程的请求，则客户端进程工具很有用。 它仅适用于在运行 Charles 的计算机上发出的请求。</p><p>在 Charles 接受每个连接之前，该工具将引入一个短暂的延迟。 延迟通常不明显或不显著。</p><h5 id="选定站点-1"><a href="#选定站点-1" class="headerlink" title="选定站点"></a>选定站点</h5><p>可以为每个请求启用该工具，也可以仅为指定站点启用该工具。当用于选定的站点时，可以使用简单但功能强大的模式匹配将工具的效果限制为指定的主机和/或路径。</p><h4 id="Compose-编辑修改"><a href="#Compose-编辑修改" class="headerlink" title="Compose(编辑修改)"></a>Compose(编辑修改)</h4><p>Compose 工具允许在原有的请求基础上修改。</p><h4 id="Repeat-重复"><a href="#Repeat-重复" class="headerlink" title="Repeat(重复)"></a>Repeat(重复)</h4><p>Repeat 工具允许选择一个请求并重复它。Charles 将请求重新发送到服务器，并将响应显示为新请求。如果您正在进行后端更改并希望在浏览器(或其他客户机)中重复请求的情况下测试这些更改，那么这将非常有用。特别是如果重新创建请求需要花费一些精力，例如在游戏中获得分数，这将节省大量精力。</p><p>重复请求是在 Charles 内部完成的，因此无法在浏览器或其他客户端中查看响应，响应只能在 Charles 中查看。</p><h4 id="Repeat-Advanced-高级重复"><a href="#Repeat-Advanced-高级重复" class="headerlink" title="Repeat Advanced(高级重复)"></a>Repeat Advanced(高级重复)</h4><p>Repeat Advanced 工具扩展了 Repeat 工具，提供了迭代次数和并发数的选项。这对于负载测试非常有用。</p><h4 id="Validate-验证"><a href="#Validate-验证" class="headerlink" title="Validate(验证)"></a>Validate(验证)</h4><p>Validate 工具允许 Charles 通过将它们发送到 W3C HTML 验证器、W3C CSS 验证器和 W3C Feed 验证器来验证记录的响应。</p><p>验证报告在 Charles 中显示，其中包含与响应源中相应行相关联的任何警告或错误（双击错误消息中的行号可以切换到源视图）。</p><p>因为 Charles 测试它记录的响应，所以它可以测试不易测试的场景，例如在提交表单后呈现错误消息。</p><h5 id="重新验证"><a href="#重新验证" class="headerlink" title="重新验证"></a>重新验证</h5><p>验证后，可以从验证结果中选择响应并 <code>Repeat</code>，重复原始请求，然后重新验证结果。</p><h4 id="Publish-Gist-发布要点"><a href="#Publish-Gist-发布要点" class="headerlink" title="Publish Gist(发布要点)"></a>Publish Gist(发布要点)</h4><p>Publish Gist 工具可以将将所选请求和响应作为要点发布。默认情况下，这个要点将匿名发布，这意味着你将无法做到<br>删除它。可以在 <code>Tools</code> 菜单的 <code>Publish Gist Settings</code> 中授权 Charles 使用您的 GitHub 帐户进行发布。</p><h4 id="Import-Export-Settings-导入-导出"><a href="#Import-Export-Settings-导入-导出" class="headerlink" title="Import/Export Settings(导入/导出)"></a>Import/Export Settings(导入/导出)</h4><p>Import/Export 工具允许导入/导出 Charles 的 <code>Proxy</code>、<code>Tools</code>、<code>Preferences</code> 等设置。</p><h4 id="Profiles-配置"><a href="#Profiles-配置" class="headerlink" title="Profiles(配置)"></a>Profiles(配置)</h4><p>Profiles 包含所有配置设置的完整副本。</p><p>每次更改当前设置时，系统都会更新当前活动的配置文件，当您更改活动配置文件时，所有设置都将恢复为上次使用该配置文件时的状态。</p><p>请注意，如果导入已保存的配置，则会覆盖当前配置文件的设置。建议使用导入/导出来备份或创建当前配置和配置文件的快照，以维护多个并行工作区。</p><h2 id="Charles-使用教程"><a href="#Charles-使用教程" class="headerlink" title="Charles 使用教程"></a>Charles 使用教程</h2><h3 id="通过-Charles-进行-PC-端抓包"><a href="#通过-Charles-进行-PC-端抓包" class="headerlink" title="通过 Charles 进行 PC 端抓包"></a>通过 Charles 进行 PC 端抓包</h3><p>Charles 会自动配置浏览器和工具的代理设置，所以说打开工具直接就已经是抓包状态了。只需要保证一下几点即可：</p><ol><li>确保 Charles 处于 Start Recording 状态。</li><li>勾选 <strong>Proxy | Windows Proxy</strong> 和 <strong>Proxy | Mozilla  FireFox Proxy</strong>。</li></ol><h3 id="通过-Charles-进行移动端抓包"><a href="#通过-Charles-进行移动端抓包" class="headerlink" title="通过 Charles 进行移动端抓包"></a>通过 Charles 进行移动端抓包</h3><p>手机抓包的原理，和 PC 类似，手机通过把网络委托给 Charles 进行代理与服务端进行对话。具体步骤如下：</p><ol><li>使手机和电脑在一个局域网内，不一定非要是一个 IP 段，只要是在同一个路由器下即可。</li><li>电脑端配置：<ul><li>关掉电脑端的防火墙（这点很重要）。</li><li>打开 Charles 的代理功能：通过主菜单打开 <strong>Proxy | Proxy Settings</strong> 弹窗，填入代理端口(端口默认为 <code>8888</code>，不用修改)，勾选 <code>Enable transparent HTTP proxying</code>。</li><li>如果不需要抓取电脑上的请求，可以取消勾选 <strong>Proxy | Windows Proxy</strong> 和 <strong>Proxy | Mozilla  FireFox Proxy</strong>。</li></ul></li><li><p>手机端配置：</p><ul><li>通过 Charles 的主菜单 <strong>Help | Local IP Address</strong> 或者通过命令行工具输入 <code>ipconfig</code> 查看本机的 IP 地址。</li><li>设置代理：打开手机端的 WIFI 代理设置，输入电脑 IP 和 Charles 的代理端口。</li></ul></li><li><p>设置好之后，我们打开手机上的任意需要网络请求的程序，就可以看到 Charles 弹出手机请求连接的确认菜单（只有首次弹出），点击 <strong>Allow</strong> 即可完成设置。</p></li><li>完成以上步骤，就可以进行抓包了。</li></ol><h3 id="通过-Charles-进行-HTTPS-抓包"><a href="#通过-Charles-进行-HTTPS-抓包" class="headerlink" title="通过 Charles 进行 HTTPS 抓包"></a>通过 Charles 进行 HTTPS 抓包</h3><p>HTTPS 的抓包需要在 HTTP 抓包基础上再进行设置。需要完成一下步骤：</p><ol><li>完成 HTTP 抓包配置。</li><li>电脑端安装 Charles 证书：通过 Charles 的主菜单 <strong>Help | SSL Proxying | Install Charles Root Certificate</strong> 安装证书。</li><li>设置 SSL 代理：通过主菜单打开 <strong>Proxy | SSL Proxy Settings</strong> 弹窗，勾选 <code>Enable SSL proxying</code>。</li><li>移动端安装 Charles 证书：通过 Charles 的主菜单 <strong>Help | SSL Proxying | Install Charles Root Certificate on a Mobile Device or Remote Browser</strong> 安装证书。</li><li>设置好之后，我们打开手机上的任意需要网络请求的程序，就可以看到 Charles 弹出手机请求连接的确认菜单（只有首次弹出），点击 <strong>Allow</strong> 即可完成设置。</li><li>完成以上步骤，就可以进行 HTTPS 抓包了。</li></ol><h2 id="Charles-License"><a href="#Charles-License" class="headerlink" title="Charles License"></a>Charles License</h2><ul><li>Registered Name: <code>https://zhile.io</code></li><li>License     Key: <code>48891cf209c6d32bf4</code></li></ul><p>注册码来自于网络，注册码 Windows 和 Mac 通用。</p><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><ul><li><a href="https://www.charlesproxy.com/documentation/" target="_blank" rel="noopener">Charles Documentation</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> Charles </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Git 介绍与常用命令</title>
      <link href="/posts/2018/515a2461.html"/>
      <url>/posts/2018/515a2461.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://henleylee.github.io/medias/git/git_header.jpg" alt=""></p><h2 id="一、Git-是什么？"><a href="#一、Git-是什么？" class="headerlink" title="一、Git 是什么？"></a>一、Git 是什么？</h2><ul><li>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。</li><li>Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</li><li>Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。</li></ul><h2 id="二、Git-与-SVN-区别"><a href="#二、Git-与-SVN-区别" class="headerlink" title="二、Git 与 SVN 区别"></a>二、Git 与 SVN 区别</h2><p>Git 不仅仅是个版本控制系统，它也是个内容管理系统(CMS),工作管理系统等。</p><p>如果你是一个具有使用 SVN 背景的人，你需要做一定的思想转换，来适应 Git 提供的一些概念和特征。<br>Git 与 SVN 区别点：</p><ol><li>Git 是分布式的，SVN不是：这是 Git 和其它非分布式的版本控制系统，例如SVN，CVS等，最核心的区别。</li><li>Git 把内容按元数据方式存储，而 SVN 是按文件：所有的资源控制系统都是把文件的元信息隐藏在一个类似 .svn、.cvs 等的文件夹里。</li><li>Git 分支和SVN的分支不同：分支在 SVN 中一点不特别，就是版本库中的另外的一个目录。</li><li>Git 没有一个全局的版本号，而 SVN 有：目前为止这是跟 SVN 相比 Git 缺少的最大的一个特征。</li><li>Git 的内容完整性要优于 SVN：Git 的内容存储使用的是 SHA-1 哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏。</li></ol><h2 id="三、Git-快速入门"><a href="#三、Git-快速入门" class="headerlink" title="三、Git 快速入门"></a>三、Git 快速入门</h2><h3 id="3-1-Git-相关网站"><a href="#3-1-Git-相关网站" class="headerlink" title="3.1 Git 相关网站"></a>3.1 Git 相关网站</h3><ul><li>Git 官网：<a href="https://git-scm.com/" target="_blank" rel="noopener">git-scm.com</a></li><li>Git 完整命令手册：<a href="https://git-scm.com/docs" target="_blank" rel="noopener">git-scm.com/docs</a></li><li>Git 命令手册(pdf版)：<a href="http://www.runoob.com/manual/github-git-cheat-sheet.pdf" target="_blank" rel="noopener">github-git-cheat-sheet.pdf</a></li><li>Git 简明指南：<a href="http://www.runoob.com/manual/git-guide/" target="_blank" rel="noopener">git-guide</a></li></ul><h3 id="3-2-Git-工作流程"><a href="#3-2-Git-工作流程" class="headerlink" title="3.2 Git 工作流程"></a>3.2 Git 工作流程</h3><p>Git 一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><p>下图展示了 Git 的工作流程：<br><img src="https://henleylee.github.io/medias/git/git_process.jpg" alt="Git 工作流程"></p><h3 id="3-3-Git-工作空间"><a href="#3-3-Git-工作空间" class="headerlink" title="3.3 Git 工作空间"></a>3.3 Git 工作空间</h3><p>Git 工作空间分为：</p><ul><li><strong><code>工作区(Working Directory)：</code></strong>在电脑里能看到的目录。</li><li><strong><code>版本库(Repository)：</code></strong>工作区有一个隐藏目录 <code>.git</code>，这个目录不算工作区，而是 Git 的版本库</li><li><strong><code>暂存区(Stage/Index)：</code></strong>一般存放在 <code>.git</code> 目录下的 <code>index</code> 文件(<code>.git/index</code>)中，所以我们把暂存区有时也叫作索引(index)。</li></ul><p>下面这个图展示了工作区、版本库中的暂存区和版本库之间的关系：<br><img src="https://henleylee.github.io/medias/git/git_workspace.jpg" alt="Git 工作空间"><br>图中左侧为工作区，右侧为版本库。在版本库中标记为 <code>index</code> 的区域是暂存区(stage/index)，标记为 <code>master</code> 的是 <code>master</code> 分支所代表的目录树。此时 <code>HEAD</code> 实际是指向 <code>master</code> 分支的一个“游标”，所以图示的命令中出现 <code>HEAD</code> 的地方可以用 <code>master</code> 来替换。图中的 <code>objects</code> 标识的区域为 git 的对象库，实际位于 <code>.git/objects</code> 目录下。 </p><ul><li>当对工作区修改（或新增）的文件执行 <code>git add</code> 命令时，暂存区的目录树会被更新，同时工作区修改（或新增）的文件内容会被写入到对象库中的一个新的对象中，而该对象的id被记录在暂存区的文件索引中。</li><li>当执行提交操作 <code>git commit</code> 时，暂存区的目录树会写到版本库（对象库）中，master 分支会做相应的更新，即 master 最新指向的目录树就是提交时原暂存区的目录树。</li><li>当执行 <code>git reset HEAD</code> 命令时，暂存区的目录树会被重写，会被 master 分支指向的目录树所替换，但是工作区不受影响。</li><li>当执行 <code>git rm --cached</code> 命令时，会直接从暂存区删除文件，工作区则不做出改变。</li><li>当执行 <code>git checkout .</code> 或 <code>git checkout --</code> 命令时，会用暂存区全部的文件或指定的文件替换工作区的文件。这个操作很危险，会清楚工作区中未添加到暂存区的改动。</li><li>当执行 <code>git checkout HEAD .</code> 或 <code>git checkout HEAD</code> 命令时，会用 HEAD 指向的 master 分支中的全部或部分文件替换暂存区和工作区中的文件。这个命令也是极度危险的。因为不但会清楚工作区中未提交的改动，也会清楚暂存区中未提交的改动。</li></ul><h3 id="3-4-Git-文件状态"><a href="#3-4-Git-文件状态" class="headerlink" title="3.4 Git 文件状态"></a>3.4 Git 文件状态</h3><p>Git 有三种状态，你的文件可能处于其中之一：</p><ul><li><strong><code>已提交(committed)：</code></strong>表示数据已经安全的保存在本地数据库中。</li><li><strong><code>已修改(modified)：</code></strong>表示修改了文件，但还没保存到数据库中。</li><li><strong><code>已暂存(staged)：</code></strong>表示对一个已修改文件的当前版本做了标记，使之包含在下次提交的快照中。</li></ul><h2 id="四、Git-安装"><a href="#四、Git-安装" class="headerlink" title="四、Git 安装"></a>四、Git 安装</h2><p>在使用 Git 前我们需要先安装 Git。Git 目前支持 Linux/Unix、Solaris、Mac和 Windows 平台上运行。<br>Git 各平台安装包下载地址为：<a href="https://git-scm.com/downloads" target="_blank" rel="noopener">git-scm.com/downloads</a></p><h3 id="4-1-在-Linux-上安装"><a href="#4-1-在-Linux-上安装" class="headerlink" title="4.1 在 Linux 上安装"></a>4.1 在 Linux 上安装</h3><p>如果要在 Linux 上用二进制安装程序来安装 Git，可以使用发行版包含的基础软件包管理工具来安装。如果以 <code>Fedora</code> 上为例，可以使用 <code>yum</code>：</p><pre class=" language-shell"><code class="language-shell">$ sudo yum install git</code></pre><p>如果在基于 <code>Debian</code> 的发行版上，请尝试用 <code>apt-get</code>：</p><pre class=" language-shell"><code class="language-shell">$ sudo apt-get install git</code></pre><p>要了解更多选择，Git 官方网站上有在各种 Unix 风格的系统上安装步骤，网址为 <a href="http://git-scm.com/download/linux" target="_blank" rel="noopener">git-scm.com/download/linux</a>。</p><h3 id="4-2-在-Mac-上安装"><a href="#4-2-在-Mac-上安装" class="headerlink" title="4.2 在 Mac 上安装"></a>4.2 在 Mac 上安装</h3><p>在 Mac 上安装 Git 有多种方式。最简单的方法是安装 <code>Xcode Command Line Tools</code>。Mavericks 10.9 或更高版本的系统中，在 Terminal 里尝试首次运行 git 命令即可。如果没有安装过命令行开发者工具，将会提示你安装。</p><p>如果想安装更新的版本，可以使用二进制安装程序。官方维护的 OSX Git 安装程序可以在 Git 官方网站下载，网址为 <a href="http://git-scm.com/download/mac" target="_blank" rel="noopener">git-scm.com/download/mac</a>。</p><p>也可以将 <code>Git OS X</code> 安装程序作为 GitHub for Mac 的一部分来安装。它们的图形化 Git 工具有一个安装命令行工具的选项。可以从 GitHub for Mac 网站下载该工具，网址为 <a href="http://mac.github.com" target="_blank" rel="noopener">mac.github.com</a>。</p><h3 id="4-3-在-Windows-上安装"><a href="#4-3-在-Windows-上安装" class="headerlink" title="4.3 在 Windows 上安装"></a>4.3 在 Windows 上安装</h3><p>在 Windows 上安装 Git 也有几种安装方法。官方版本可以在 Git 官方网站下载。打开 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">git-scm.com/download/win</a>，下载会自动开始。要注意这是一个名为 <code>Git for Windows</code> 的项目(也叫做 <code>msysGit</code>)，和 Git 是分别独立的项目；更多信息请访问 <a href="http://msysgit.github.io/" target="_blank" rel="noopener">msysgit.github.io</a>。</p><p>另一个简单的方法是安装 <code>GitHub for Windows</code>。该安装程序包含图形化和命令行版本的 Git。它也能支持 <code>Powershell</code>，提供了稳定的凭证缓存和健全的 <code>CRLF</code> 设置。可以在 GitHub for Windows 网站下载，网址为 <a href="http://windows.github.com" target="_blank" rel="noopener">windows.github.com</a>。</p><h3 id="4-4-从源代码安装"><a href="#4-4-从源代码安装" class="headerlink" title="4.4 从源代码安装"></a>4.4 从源代码安装</h3><p>有人觉得从源码安装 Git 更实用，因为可以得到最新的版本。二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。</p><p>如果想要从源码安装 Git，需要安装 Git 依赖的库：<code>curl</code>、<code>zlib</code>、<code>openssl</code>、<code>expat</code>，还有 <code>libiconv</code>。 如果你的系统上有 <code>yum</code>(如 Fedora)或者 <code>apt-get</code>(如基于 Debian 的系统)，可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p><pre class=" language-shell"><code class="language-shell">$ sudo yum install curl-devel expat-devel gettext-devel \  openssl-devel zlib-devel$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \  libz-dev libssl-dev</code></pre><p>为了能够添加更多格式的文档(如 doc, html, info)，需要安装以下的依赖包：</p><pre class=" language-shell"><code class="language-shell">$ sudo yum install asciidoc xmlto docbook2x$ sudo apt-get install asciidoc xmlto docbook2x</code></pre><p>当安装好所有的必要依赖，可以继续从几个地方来取得最新发布版本的 <code>tar</code> 包。可以从 <code>kernel.org</code> 网站获取，网址为 <a href="https://www.kernel.org/pub/software/scm/git" target="_blank" rel="noopener">www.kernel.org/pub/software/scm/git</a>，或从 GitHub 网站上的镜像来获得，网址为 <a href="https://github.com/git/git/releases" target="_blank" rel="noopener">github.com/git/git/releases</a>。通常在 GitHub 上的是最新版本，但 <code>kernel.org</code> 上包含有文件下载签名，如果想验证下载正确性的话会用到。</p><p>接着，编译并安装：</p><pre class=" language-shell"><code class="language-shell">$ tar -zxf git-2.0.0.tar.gz$ cd git-2.0.0$ make configure$ ./configure --prefix=/usr$ make all doc info$ sudo make install install-doc install-html install-info</code></pre><p>完成后，可以使用 Git 来获取 Git 的升级：</p><pre class=" language-shell"><code class="language-shell">$ git clone git://git.kernel.org/pub/scm/git/git.git</code></pre><h2 id="五、Git-配置"><a href="#五、Git-配置" class="headerlink" title="五、Git 配置"></a>五、Git 配置</h2><p>Git 提供了一个叫做 git config 的工具，专门用来配置或读取相应的工作环境变量。</p><h3 id="5-1-配置文件的存储位置"><a href="#5-1-配置文件的存储位置" class="headerlink" title="5.1 配置文件的存储位置"></a>5.1 配置文件的存储位置</h3><p>这些环境变量，决定了 Git 在各个环节的具体工作方式和行为。这些变量可以存放在以下三个不同的地方：</p><ul><li>/etc/gitconfig 文件：系统中对所有用户都普遍适用的配置。若使用 git config 时用 –system 选项，读写的就是这个文件。</li><li>~/.gitconfig 文件：用户目录下的配置文件只适用于该用户。若使用 git config 时用 –global 选项，读写的就是这个文件。</li><li>当前项目的 Git 目录中的配置文件（也就是工作目录中的 .git/config 文件）：这里的配置仅仅针对当前项目有效。每一个级别的配置都会覆盖上层的相同配置，所以 .git/config 里的配置会覆盖 /etc/gitconfig 中的同名变量。</li></ul><p>在 Windows 系统上，Git 会找寻用户主目录下的 .gitconfig 文件。主目录即 $HOME 变量指定的目录，一般都是 C:\Users\$USER。此外，Git 还会尝试找寻 /etc/gitconfig 文件，只不过看当初 Git 装在什么目录，就以此作为根目录来定位。 </p><h3 id="5-2-查看-git-的版本信息"><a href="#5-2-查看-git-的版本信息" class="headerlink" title="5.2 查看 git 的版本信息"></a>5.2 查看 git 的版本信息</h3><p>查看git的版本信息：</p><pre class=" language-shell"><code class="language-shell">git --version</code></pre><h3 id="5-3-配置用户信息"><a href="#5-3-配置用户信息" class="headerlink" title="5.3 配置用户信息"></a>5.3 配置用户信息</h3><p>当Git安装完成后首先要做的事情是配置个人的用户名称和电子邮件地址。这是非常重要的，因为每次Git提交都会使用该信息。它被永远的嵌入到了你的提交中：</p><pre class=" language-shell"><code class="language-shell">git config --global user.name 'user_name'git config --global user.email 'user_email'</code></pre><p>具体可参考 <a href="https://git-scm.com/book/en/v2/Customizing-Git-Git-Configuration" target="_blank" rel="noopener">Git Configuration</a></p><h3 id="5-4-配置文本编辑器"><a href="#5-4-配置文本编辑器" class="headerlink" title="5.4 配置文本编辑器"></a>5.4 配置文本编辑器</h3><p>设置Git默认使用的文本编辑器, 一般可能会是 Vi 或者 Vim。如果你有其他偏好，比如 Emacs 的话，可以重新设置：</p><pre class=" language-shell"><code class="language-shell">git config --global core.editor emacs</code></pre><h3 id="5-5-配置差异分析工具"><a href="#5-5-配置差异分析工具" class="headerlink" title="5.5 配置差异分析工具"></a>5.5 配置差异分析工具</h3><p>还有一个比较常用的是，在解决合并冲突时使用哪种差异分析工具。比如要改用 vimdiff 的话：</p><pre class=" language-shell"><code class="language-shell">git config --global merge.tool vimdiff</code></pre><h3 id="5-6-查看配置信息"><a href="#5-6-查看配置信息" class="headerlink" title="5.6 查看配置信息"></a>5.6 查看配置信息</h3><p>要检查已有的配置信息，可以使用 git config –list 命令：</p><pre class=" language-shell"><code class="language-shell">git config --list</code></pre><p>有时候会看到重复的变量名，这是因为Git从不同的的配置文件中(例如：/etc/gitconfig以及~/.gitconfig)读取相同的变量名。在这种情况下，对每个唯一的变量名，Git使用最后的那个值。</p><p>也可以直接查阅某个环境变量的设定，使用如下命令 git config {key}： </p><pre class=" language-shell"><code class="language-shell">git config user.name</code></pre><p>也可以直接查看某个配置文件的配置信息：</p><pre class=" language-shell"><code class="language-shell">git config --local  --listorgit config --global  --listorgit config --system --list</code></pre><p>上面的三个命令分别为：查看当前仓库配置信息、查看当前用户(global)配置信息、查看系统配置信息。</p><h3 id="5-7-git-配置文件"><a href="#5-7-git-配置文件" class="headerlink" title="5.7 git 配置文件"></a>5.7 git 配置文件</h3><ol><li>系统级文件 $(prefix)/etc/gitconfig，本文即 /usr/etc/gitconfig 文件。<br>git config –system 用来指定读写系统级文件。初始不存在，若不存在则无影响。</li><li>用户级文件 ~/.gitconfig<br>git config –global 指定只操作用户级文件。初始不存在，若不存在则无影响。</li><li>Repository 级文件 .git/config<br>git config –local 对写操作，则只写入 Repository 级文件（默认行为）；对读操作，则只从 Repository 级文件读。</li><li>git config –file config-file 则指定 config-file。</li></ol><h3 id="5-8-清除认证信息"><a href="#5-8-清除认证信息" class="headerlink" title="5.8 清除认证信息"></a>5.8 清除认证信息</h3><pre class=" language-shell"><code class="language-shell">git config --global --unset credential.helperorgit config --system --unset credential.helper</code></pre><p>上面的命令可以解决 <code>remote: HTTP Basic: Access denied</code> 错误。</p><h3 id="5-9-保存认证信息"><a href="#5-9-保存认证信息" class="headerlink" title="5.9 保存认证信息"></a>5.9 保存认证信息</h3><pre class=" language-shell"><code class="language-shell">git config --local credential.helper storeorgit config --system credential.helper store</code></pre><p>上面的命令可以解决每次提交都要输入用户名和密码的问题。具体可参考 <a href="https://git-scm.com/book/en/v2/Git-Tools-Credential-Storage" target="_blank" rel="noopener">Git Credential Storage</a></p><h2 id="六、Git-常用命令"><a href="#六、Git-常用命令" class="headerlink" title="六、Git 常用命令"></a>六、Git 常用命令</h2><h3 id="6-1-创建代码仓库"><a href="#6-1-创建代码仓库" class="headerlink" title="6.1 创建代码仓库"></a>6.1 创建代码仓库</h3><h4 id="6-1-1-git-init"><a href="#6-1-1-git-init" class="headerlink" title="6.1.1 git init"></a>6.1.1 git init</h4><p><code>git init</code> 的命令格式为：</p><pre class=" language-shell"><code class="language-shell">git init [-q | --quiet] [--bare] [--template=<template_directory>]      [--separate-git-dir <git dir>]      [--shared[=<permissions>]] [directory]</code></pre><p>第一步：创建一个代码仓库非常简单，首先，选择一个合适的地方，创建一个空目录：</p><pre class=" language-shell"><code class="language-shell">mkdir repositorycd repositorypwd</code></pre><p><code>mkdir</code>命令用于创建目录，<code>cd</code>命令用于进入目录，<code>pwd</code>命令用于显示当前目录。<br>第二步，通过<code>git init</code>命令把这个目录变成Git可以管理的仓库或者通过<code>git init &lt;directory&gt;</code>命令直接指定一个目录作为Gi仓库：</p><pre class=" language-shell"><code class="language-shell">git initgit init <directory></code></pre><p>Git瞬间就把仓库建好了，而且告诉你是一个空的仓库(empty Git repository)，细心的读者可以发现当前目录下多了一个<code>.git</code>的目录，这个目录是Git来跟踪管理版本库的，没事千万不要手动修改这个目录里面的文件，不然改乱了，就把Git仓库给破坏了。如果你没有看到<code>.git</code>目录，那是因为这个目录默认是隐藏的，用ls -ah命令就可以看见。</p><h4 id="6-1-2-git-clone"><a href="#6-1-2-git-clone" class="headerlink" title="6.1.2 git clone"></a>6.1.2 git clone</h4><p><code>git clone</code> 的命令格式为：</p><pre class=" language-shell"><code class="language-shell">git clone [--template=<template_directory>]      [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]      [-o <name>] [-b <name>] [-u <upload-pack>] [--reference <repository>]      [--dissociate] [--separate-git-dir <git dir>]      [--depth <depth>] [--[no-]single-branch]      [--recurse-submodules] [--[no-]shallow-submodules]      [--jobs <n>] [--] <repository> [<directory>]</code></pre><p>克隆到当前目录，可以使用以下命令格式：</p><pre class=" language-shell"><code class="language-shell">git clone <repository></code></pre><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><pre class=" language-shell"><code class="language-shell">git clone <repository> <directory></code></pre><p>参数说明：</p><ul><li><code>repository</code>:Git 仓库。</li><li><code>directory</code>:本地目录。</li></ul><h3 id="6-2-添加暂存区"><a href="#6-2-添加暂存区" class="headerlink" title="6.2 添加暂存区"></a>6.2 添加暂存区</h3><p><code>git add</code> 的命令格式为：</p><pre class=" language-shell"><code class="language-shell">git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]      [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]]      [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing]      [--chmod=(+|-)x] [--] [<pathspec>…​]</code></pre><p><code>git add</code>命令可以在提交之前多次执行。它只在运行<code>git add</code>命令时添加指定文件的内容; 如果希望随后的更改包含在下一个提交中，那么必须再次运行<code>git add</code>将新的内容添加到索引。默认情况下，<code>git add</code>命令不会添加忽略的文件。</p><h4 id="6-2-1-基本用法"><a href="#6-2-1-基本用法" class="headerlink" title="6.2.1 基本用法"></a>6.2.1 基本用法</h4><pre class=" language-shell"><code class="language-shell">git add [path]</code></pre><p>通常是通过<code>git add [path]</code>的形式把<code>[path]</code>添加到索引库中，<code>[path]</code>可以是文件也可以是目录。<br>git不仅能判断出<code>[path]</code>中，修改(不包括已删除)的文件，还能判断出新添的文件，并把它们的信息添加到索引库中。</p><h4 id="6-2-2-常用命令"><a href="#6-2-2-常用命令" class="headerlink" title="6.2.2 常用命令"></a>6.2.2 常用命令</h4><pre class=" language-shell"><code class="language-shell">git add .               # 将所有修改添加到暂存区git add *Presenter      # 将以Presenter结尾的文件的所有修改添加到暂存区git add Base*           # 将所有以Base开头的文件的修改添加到暂存区(例如:BaseActivity.java,BaseFragment.java)git add Model?          # 将以Model开头且后面只有一位的文件的修改添加到暂存区(例如:Model1.java,ModelA.java)git add model/*.java    # 将model目录及其子目录下所有 *.java 文件的修改添加到暂存区</code></pre><h3 id="6-3-代码提交"><a href="#6-3-代码提交" class="headerlink" title="6.3 代码提交"></a>6.3 代码提交</h3><p><code>git commit</code> 的命令格式为：</p><pre class=" language-shell"><code class="language-shell">git commit [-a | --interactive | --patch] [-s] [-v] [-u<mode>] [--amend]       [--dry-run] [(-c | -C | --fixup | --squash) <commit>]       [-F <file> | -m <msg>] [--reset-author] [--allow-empty]       [--allow-empty-message] [--no-verify] [-e] [--author=<author>]       [--date=<date>] [--cleanup=<mode>] [--[no-]status]       [-i | -o] [-S[<keyid>]] [--] [<file>…​]</code></pre><p><code>git commit</code>命令将索引的当前内容与描述更改的用户和日志消息一起存储在新的提交中。</p><h4 id="6-3-1-提交暂存区到本地仓库区"><a href="#6-3-1-提交暂存区到本地仓库区" class="headerlink" title="6.3.1 提交暂存区到本地仓库区"></a>6.3.1 提交暂存区到本地仓库区</h4><pre class=" language-shell"><code class="language-shell">git commit -m [message]</code></pre><h4 id="6-3-2-将未添加到暂存区的文件，同时提交到本地仓库区"><a href="#6-3-2-将未添加到暂存区的文件，同时提交到本地仓库区" class="headerlink" title="6.3.2 将未添加到暂存区的文件，同时提交到本地仓库区"></a>6.3.2 将未添加到暂存区的文件，同时提交到本地仓库区</h4><pre class=" language-shell"><code class="language-shell">git commit –am <message>git commit –a –m <message></code></pre><h4 id="6-3-3-提交暂存区的指定文件到仓库区"><a href="#6-3-3-提交暂存区的指定文件到仓库区" class="headerlink" title="6.3.3 提交暂存区的指定文件到仓库区"></a>6.3.3 提交暂存区的指定文件到仓库区</h4><pre class=" language-shell"><code class="language-shell">git commit <file1> <file2> ... -m <message></code></pre><h4 id="6-3-4-提交时显示所有diff信息"><a href="#6-3-4-提交时显示所有diff信息" class="headerlink" title="6.3.4 提交时显示所有diff信息"></a>6.3.4 提交时显示所有diff信息</h4><pre class=" language-shell"><code class="language-shell">git commit -v</code></pre><h4 id="6-3-5-修改最近一次提交"><a href="#6-3-5-修改最近一次提交" class="headerlink" title="6.3.5 修改最近一次提交"></a>6.3.5 修改最近一次提交</h4><pre class=" language-shell"><code class="language-shell">git commit --amend</code></pre><h4 id="6-3-6-修改最近一次提交，并改写上一次commit的提交信息"><a href="#6-3-6-修改最近一次提交，并改写上一次commit的提交信息" class="headerlink" title="6.3.6 修改最近一次提交，并改写上一次commit的提交信息"></a>6.3.6 修改最近一次提交，并改写上一次commit的提交信息</h4><pre class=" language-shell"><code class="language-shell">git commit --amend -m <message></code></pre><h3 id="6-4-分支管理"><a href="#6-4-分支管理" class="headerlink" title="6.4 分支管理"></a>6.4 分支管理</h3><p><code>git branch</code> 的命令格式为：</p><pre class=" language-shell"><code class="language-shell">git branch [--color[=<when>] | --no-color] [-r | -a]    [--list] [-v [--abbrev=<length> | --no-abbrev]]    [--column[=<options>] | --no-column] [--sort=<key>]    [(--merged | --no-merged) [<commit>]]    [--contains [<commit]] [--no-contains [<commit>]]    [--points-at <object>] [--format=<format>] [<pattern>…​]git branch [--set-upstream | --track | --no-track] [-l] [-f] <branchname> [<start-point>]git branch (--set-upstream-to=<upstream> | -u <upstream>) [<branchname>]git branch --unset-upstream [<branchname>]git branch (-m | -M) [<oldbranch>] <newbranch>git branch (-d | -D) [-r] <branchname>…git branch --edit-description [<branchname>]</code></pre><p><code>git branch</code>命令用于列出，创建或删除分支。</p><h4 id="6-4-1-列出所有本地分支"><a href="#6-4-1-列出所有本地分支" class="headerlink" title="6.4.1 列出所有本地分支"></a>6.4.1 列出所有本地分支</h4><pre class=" language-shell"><code class="language-shell">git branch</code></pre><h4 id="6-4-2-列出所有远程分支"><a href="#6-4-2-列出所有远程分支" class="headerlink" title="6.4.2 列出所有远程分支"></a>6.4.2 列出所有远程分支</h4><pre class=" language-shell"><code class="language-shell">git branch -r</code></pre><h4 id="6-4-3-列出所有本地分支和远程分支"><a href="#6-4-3-列出所有本地分支和远程分支" class="headerlink" title="6.4.3 列出所有本地分支和远程分支"></a>6.4.3 列出所有本地分支和远程分支</h4><pre class=" language-shell"><code class="language-shell">git branch -a</code></pre><h4 id="6-4-4-新建一个分支，但依然停留在当前分支"><a href="#6-4-4-新建一个分支，但依然停留在当前分支" class="headerlink" title="6.4.4 新建一个分支，但依然停留在当前分支"></a>6.4.4 新建一个分支，但依然停留在当前分支</h4><pre class=" language-shell"><code class="language-shell">git branch <branch-name></code></pre><h4 id="6-4-5-新建一个分支，并切换到该分支"><a href="#6-4-5-新建一个分支，并切换到该分支" class="headerlink" title="6.4.5 新建一个分支，并切换到该分支"></a>6.4.5 新建一个分支，并切换到该分支</h4><pre class=" language-shell"><code class="language-shell">git checkout -b <branch-name></code></pre><p><code>git checkout</code> 命令加上 <code>-b</code> 参数表示创建并切换，相当于以下两条命令：</p><pre class=" language-shell"><code class="language-shell">git branch <branch-name>git checkout <branch-name></code></pre><h4 id="6-4-6-新建一个分支，指向指定-commit"><a href="#6-4-6-新建一个分支，指向指定-commit" class="headerlink" title="6.4.6 新建一个分支，指向指定 commit"></a>6.4.6 新建一个分支，指向指定 commit</h4><pre class=" language-shell"><code class="language-shell">git branch <branch> <commit></code></pre><h4 id="6-4-7-新建一个分支，与指定的远程分支建立追踪关系"><a href="#6-4-7-新建一个分支，与指定的远程分支建立追踪关系" class="headerlink" title="6.4.7 新建一个分支，与指定的远程分支建立追踪关系"></a>6.4.7 新建一个分支，与指定的远程分支建立追踪关系</h4><pre class=" language-shell"><code class="language-shell">git branch --track <branch> <remote-branch></code></pre><h4 id="6-4-8-切换到指定分支，并更新工作区"><a href="#6-4-8-切换到指定分支，并更新工作区" class="headerlink" title="6.4.8 切换到指定分支，并更新工作区"></a>6.4.8 切换到指定分支，并更新工作区</h4><pre class=" language-shell"><code class="language-shell">git checkout <branch-name></code></pre><h4 id="6-4-9-切换到上一个分支"><a href="#6-4-9-切换到上一个分支" class="headerlink" title="6.4.9 切换到上一个分支"></a>6.4.9 切换到上一个分支</h4><pre class=" language-shell"><code class="language-shell">git checkout -</code></pre><h4 id="6-4-10-建立追踪关系，在现有分支与指定的远程分支之间"><a href="#6-4-10-建立追踪关系，在现有分支与指定的远程分支之间" class="headerlink" title="6.4.10 建立追踪关系，在现有分支与指定的远程分支之间"></a>6.4.10 建立追踪关系，在现有分支与指定的远程分支之间</h4><pre class=" language-shell"><code class="language-shell">git branch --set-upstream <branch> <remote-branch></code></pre><h4 id="6-4-11-合并指定分支到当前分支"><a href="#6-4-11-合并指定分支到当前分支" class="headerlink" title="6.4.11 合并指定分支到当前分支"></a>6.4.11 合并指定分支到当前分支</h4><pre class=" language-shell"><code class="language-shell">git merge <branch></code></pre><h4 id="6-4-12-选择一个-commit，合并进当前分支"><a href="#6-4-12-选择一个-commit，合并进当前分支" class="headerlink" title="6.4.12 选择一个 commit，合并进当前分支"></a>6.4.12 选择一个 commit，合并进当前分支</h4><pre class=" language-shell"><code class="language-shell">git cherry-pick <commit></code></pre><h4 id="6-4-13-删除本地分支"><a href="#6-4-13-删除本地分支" class="headerlink" title="6.4.13 删除本地分支"></a>6.4.13 删除本地分支</h4><pre class=" language-shell"><code class="language-shell">git branch -d <branch-name></code></pre><h4 id="6-4-14-删除远程分支"><a href="#6-4-14-删除远程分支" class="headerlink" title="6.4.14 删除远程分支"></a>6.4.14 删除远程分支</h4><pre class=" language-shell"><code class="language-shell">git push origin :<branch-name>或git push origin --delete <branch-name></code></pre><h3 id="6-5-标签管理"><a href="#6-5-标签管理" class="headerlink" title="6.5 标签管理"></a>6.5 标签管理</h3><p><code>git tag</code> 的命令格式为：</p><pre class=" language-shell"><code class="language-shell">git tag [-a | -s | -u <keyid>] [-f] [-m <msg> | -F <file>]    <tagname> [<commit> | <object>]git tag -d <tagname>…git tag [-n[<num>]] -l [--contains <commit>] [--no-contains <commit>]    [--points-at <object>] [--column[=<options>] | --no-column]    [--create-reflog] [--sort=<key>] [--format=<format>]    [--[no-]merged [<commit>]] [<pattern>…]git tag -v [--format=<format>] <tagname>…</code></pre><p><code>git tag</code>命令用于创建，列出，删除或验证使用GPG签名的标签对象。</p><h4 id="6-5-1-列出所有标签"><a href="#6-5-1-列出所有标签" class="headerlink" title="6.5.1 列出所有标签"></a>6.5.1 列出所有标签</h4><pre class=" language-shell"><code class="language-shell">git tag</code></pre><h4 id="6-5-2-新建一个标签在当前-commit"><a href="#6-5-2-新建一个标签在当前-commit" class="headerlink" title="6.5.2 新建一个标签在当前 commit"></a>6.5.2 新建一个标签在当前 commit</h4><pre class=" language-shell"><code class="language-shell">git tag <tag-name></code></pre><h4 id="6-5-3-新建一个标签在指定-commit"><a href="#6-5-3-新建一个标签在指定-commit" class="headerlink" title="6.5.3 新建一个标签在指定 commit"></a>6.5.3 新建一个标签在指定 commit</h4><pre class=" language-shell"><code class="language-shell">git tag <tag-name> <commit></code></pre><h4 id="6-5-4-新建一个带标签信息的标签在当前-commit"><a href="#6-5-4-新建一个带标签信息的标签在当前-commit" class="headerlink" title="6.5.4 新建一个带标签信息的标签在当前 commit"></a>6.5.4 新建一个带标签信息的标签在当前 commit</h4><pre class=" language-shell"><code class="language-shell">git tag -a <tag-name> -m [message]</code></pre><h4 id="6-5-5-删除本地标签"><a href="#6-5-5-删除本地标签" class="headerlink" title="6.5.5 删除本地标签"></a>6.5.5 删除本地标签</h4><pre class=" language-shell"><code class="language-shell">git tag -d <tag-name></code></pre><h4 id="6-5-6-删除远程标签"><a href="#6-5-6-删除远程标签" class="headerlink" title="6.5.6 删除远程标签"></a>6.5.6 删除远程标签</h4><p>方法一：直接删除远程标签：</p><pre class=" language-shell"><code class="language-shell">git push origin --delete tag <tag-name></code></pre><p>方法二：先删除本地标签，再删除远程标签：</p><pre class=" language-shell"><code class="language-shell">git tag -d <tag-name>git push origin :refs/tags/<tag-name></code></pre><h4 id="6-5-7-查看标签信息"><a href="#6-5-7-查看标签信息" class="headerlink" title="6.5.7 查看标签信息"></a>6.5.7 查看标签信息</h4><pre class=" language-shell"><code class="language-shell">git show <tag-name></code></pre><h4 id="6-5-8-推送某个标签到远程"><a href="#6-5-8-推送某个标签到远程" class="headerlink" title="6.5.8 推送某个标签到远程"></a>6.5.8 推送某个标签到远程</h4><pre class=" language-shell"><code class="language-shell">git push origin <tag-name></code></pre><h4 id="6-5-9-一次性推送所有尚未推送到远程的本地标签"><a href="#6-5-9-一次性推送所有尚未推送到远程的本地标签" class="headerlink" title="6.5.9 一次性推送所有尚未推送到远程的本地标签"></a>6.5.9 一次性推送所有尚未推送到远程的本地标签</h4><pre class=" language-shell"><code class="language-shell">git push origin --tags</code></pre><h3 id="6-6-查看信息"><a href="#6-6-查看信息" class="headerlink" title="6.6 查看信息"></a>6.6 查看信息</h3><h4 id="6-6-1-查看Git版本号"><a href="#6-6-1-查看Git版本号" class="headerlink" title="6.6.1 查看Git版本号"></a>6.6.1 查看Git版本号</h4><pre class=" language-shell"><code class="language-shell">git --version</code></pre><h4 id="6-6-2-显示有变更的文件"><a href="#6-6-2-显示有变更的文件" class="headerlink" title="6.6.2 显示有变更的文件"></a>6.6.2 显示有变更的文件</h4><pre class=" language-shell"><code class="language-shell">git status</code></pre><h4 id="6-6-3-显示当前分支的提交历史记录"><a href="#6-6-3-显示当前分支的提交历史记录" class="headerlink" title="6.6.3 显示当前分支的提交历史记录"></a>6.6.3 显示当前分支的提交历史记录</h4><p>下表介绍了一些 git log 命令支持的一些常用的选项及其释义：</p><table><thead><tr><th>选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>-p</td><td style="text-align:left">按补丁格式显示每个更新之间的差异。</td></tr><tr><td>–word-diff</td><td style="text-align:left">按 word diff 格式显示差异。</td></tr><tr><td>–stat</td><td style="text-align:left">显示每次更新的文件修改统计信息。</td></tr><tr><td>–shortstat</td><td style="text-align:left">只显示 –stat 中最后的行数修改添加移除统计。</td></tr><tr><td>–name-only</td><td style="text-align:left">仅在提交信息后显示已修改的文件清单。</td></tr><tr><td>–name-status</td><td style="text-align:left">显示新增、修改、删除的文件清单。</td></tr><tr><td>–abbrev-commit</td><td style="text-align:left">仅显示 SHA-1 的前几个字符，而非所有的 40 个字符。</td></tr><tr><td>–relative-date</td><td style="text-align:left">使用较短的相对时间显示(比如，“2 weeks ago”)。</td></tr><tr><td>–graph</td><td style="text-align:left">显示 ASCII 图形表示的分支合并历史。</td></tr><tr><td>–pretty</td><td style="text-align:left">使用其他格式显示历史提交信息。可用的选项包括 oneline，short，full，fuller 和 format(后跟指定格式)。</td></tr><tr><td>–oneline</td><td style="text-align:left">–pretty=oneline –abbrev-commit 的简化用法。</td></tr></tbody></table><p>默认不用任何参数的话，<code>git log</code> 会按提交时间列出所有的更新，最近的更新排在最上面。可以看到，每次更新都有一个 SHA-1 校验和、作者的名字和电子邮件地址、提交时间，最后缩进一个段落显示提交说明。</p><pre class=" language-shell"><code class="language-shell">git log</code></pre><p><code>git log</code> 有许多选项可以帮助你搜寻感兴趣的提交，接下来我们介绍些最常用的。</p><p>我们常用 <code>-p</code> 选项展开显示每次提交的内容差异，用 <code>-&lt;n&gt;</code> 则仅显示最近的两次更新：</p><pre class=" language-shell"><code class="language-shell">git log -p -2</code></pre><p>该选项除了显示基本信息之外，还在附带了每次 commit 的变化。当进行代码审查，或者快速浏览某个搭档提交的 commit 的变化的时候，这个参数就非常有用了。</p><p><code>--stat</code>，仅显示简要的增改行数统计。</p><pre class=" language-shell"><code class="language-shell">git log --stat</code></pre><p><code>--pretty</code> 选项，可以指定使用完全不同于默认格式的方式展示提交历史。比如用 <code>oneline</code> 将每个提交放在一行显示，这在提交数很大时非常有用。另外还有 <code>short</code>，<code>full</code> 和 <code>fuller</code> 可以用，展示的信息或多或少有些不同，后面也可以指定提交历史的次数(比如：<code>-&lt;n&gt;</code> )，具体展示效果请自己动手实践一下。</p><pre class=" language-shell"><code class="language-shell">git log --pretty=oneline</code></pre><p> <code>format</code>选项，可以定制要显示的记录格式，这样的输出便于后期编程提取分析。</p><pre class=" language-shell"><code class="language-shell">git log --pretty=format:"%h - %an, %ar : %s"</code></pre><p>下表列出了常用的格式占位符写法及其代表的意义：</p><table><thead><tr><th>选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>%H</td><td style="text-align:left">提交对象(commit)的完整哈希字串</td></tr><tr><td>%h</td><td style="text-align:left">提交对象的简短哈希字串</td></tr><tr><td>%T</td><td style="text-align:left">树对象(tree)的完整哈希字串</td></tr><tr><td>%t</td><td style="text-align:left">树对象的简短哈希字串</td></tr><tr><td>%P</td><td style="text-align:left">父对象(parent)的完整哈希字串</td></tr><tr><td>%p</td><td style="text-align:left">父对象的简短哈希字串</td></tr><tr><td>%an</td><td style="text-align:left">作者(author)的名字</td></tr><tr><td>%ae</td><td style="text-align:left">作者的电子邮件地址</td></tr><tr><td>%ad</td><td style="text-align:left">作者修订日期(–date= 制定的格式)</td></tr><tr><td>%aD</td><td style="text-align:left">作者修订日期(RFC2822格式)</td></tr><tr><td>%ar</td><td style="text-align:left">作者修订日期(相对格式，如：1 day ago)</td></tr><tr><td>%at</td><td style="text-align:left">作者修订日期(UNIX timestamp)</td></tr><tr><td>%ai</td><td style="text-align:left">作者修订日期(ISO 8601 格式)</td></tr><tr><td>%cn</td><td style="text-align:left">提交者(committer)的名字</td></tr><tr><td>%ce</td><td style="text-align:left">提交者的电子邮件地址</td></tr><tr><td>%cd</td><td style="text-align:left">提交日期 (–date= 制定的格式)</td></tr><tr><td>%cD</td><td style="text-align:left">提交日期(RFC2822格式)</td></tr><tr><td>%cr</td><td style="text-align:left">提交日期(相对格式，如：1 day ago)</td></tr><tr><td>%ct</td><td style="text-align:left">提交日期(UNIX timestamp)</td></tr><tr><td>%ci</td><td style="text-align:left">提交日期(ISO 8601 格式)</td></tr><tr><td>%s</td><td style="text-align:left">提交说明</td></tr></tbody></table><p>除了定制输出格式的选项之外，<code>git log</code> 还有许多非常实用的限制输出长度的选项，也就是只输出部分提交信息。用 –since 和 –until选项显示按照时间作限制的提交，比如说具体的某一天（“2008-01-15”），或者是多久以前（“2 years 1 day 3 minutes ago”）。用 –author 选项显示指定作者的提交，用 –grep 选项搜索提交说明中的关键字。<br>下表还列出了其他常用的类似选项：</p><table><thead><tr><th>选项</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td>-(n)</td><td style="text-align:left">仅显示最近的 n 条提交</td></tr><tr><td>–since, –after</td><td style="text-align:left">仅显示指定时间之后的提交</td></tr><tr><td>–until, –before</td><td style="text-align:left">仅显示指定时间之前的提交</td></tr><tr><td>–author</td><td style="text-align:left">仅显示指定作者相关的提交</td></tr><tr><td>–committer</td><td style="text-align:left">仅显示指定提交者相关的提交</td></tr></tbody></table><h3 id="6-7-远程同步"><a href="#6-7-远程同步" class="headerlink" title="6.7 远程同步"></a>6.7 远程同步</h3><h4 id="6-7-1-显示所有远程仓库"><a href="#6-7-1-显示所有远程仓库" class="headerlink" title="6.7.1 显示所有远程仓库"></a>6.7.1 显示所有远程仓库</h4><pre class=" language-shell"><code class="language-shell">git remote -v</code></pre><h4 id="6-7-2-获取某个远程主机的全部更新"><a href="#6-7-2-获取某个远程主机的全部更新" class="headerlink" title="6.7.2 获取某个远程主机的全部更新"></a>6.7.2 获取某个远程主机的全部更新</h4><pre class=" language-shell"><code class="language-shell">git fetch <remote></code></pre><h4 id="6-7-3-获取某个远程主机的某个分支的更新"><a href="#6-7-3-获取某个远程主机的某个分支的更新" class="headerlink" title="6.7.3 获取某个远程主机的某个分支的更新"></a>6.7.3 获取某个远程主机的某个分支的更新</h4><pre class=" language-shell"><code class="language-shell">git fetch <remote> <branch></code></pre><p>比如，取回origin主机的master分支的更新：</p><pre class=" language-shell"><code class="language-shell">git fetch origin master</code></pre><h4 id="6-7-4-显示某个远程仓库的信息"><a href="#6-7-4-显示某个远程仓库的信息" class="headerlink" title="6.7.4 显示某个远程仓库的信息"></a>6.7.4 显示某个远程仓库的信息</h4><pre class=" language-shell"><code class="language-shell">git remote show <remote></code></pre><h4 id="6-7-5-获取某个远程主机的某个分支的更新与当前分支合并"><a href="#6-7-5-获取某个远程主机的某个分支的更新与当前分支合并" class="headerlink" title="6.7.5 获取某个远程主机的某个分支的更新与当前分支合并"></a>6.7.5 获取某个远程主机的某个分支的更新与当前分支合并</h4><pre class=" language-shell"><code class="language-shell">git pull <remote> <remote-branch></code></pre><p>比如，要取回origin主机的dev分支，与当前分支合并：</p><pre class=" language-shell"><code class="language-shell">git pull origin dev</code></pre><p>上面命令表示，取回origin/dev分支，再与当前分支合并。实质上，这等同于先做git fetch，再执行git merge。</p><pre class=" language-shell"><code class="language-shell">git fetch origingit merge origin/dev</code></pre><h4 id="6-7-6-获取某个远程主机的某个分支的更新与本地的某个分支合并"><a href="#6-7-6-获取某个远程主机的某个分支的更新与本地的某个分支合并" class="headerlink" title="6.7.6 获取某个远程主机的某个分支的更新与本地的某个分支合并"></a>6.7.6 获取某个远程主机的某个分支的更新与本地的某个分支合并</h4><pre class=" language-shell"><code class="language-shell">git pull <remote> <remote-branch>:<local-branch></code></pre><p>比如，要取回origin主机的dev分支，与本地的master分支合并：</p><pre class=" language-shell"><code class="language-shell">git pull origin dev:master</code></pre><h4 id="6-7-7-将本地的当前分支自动与对应的远程主机”追踪分支”进行合并"><a href="#6-7-7-将本地的当前分支自动与对应的远程主机”追踪分支”进行合并" class="headerlink" title="6.7.7 将本地的当前分支自动与对应的远程主机”追踪分支”进行合并"></a>6.7.7 将本地的当前分支自动与对应的远程主机”追踪分支”进行合并</h4><pre class=" language-shell"><code class="language-shell">git pull <remote></code></pre><h4 id="6-7-8-将当前分支推送到远程主机的对应分支"><a href="#6-7-8-将当前分支推送到远程主机的对应分支" class="headerlink" title="6.7.8 将当前分支推送到远程主机的对应分支"></a>6.7.8 将当前分支推送到远程主机的对应分支</h4><pre class=" language-shell"><code class="language-shell">git push</code></pre><h4 id="6-7-9-将当前分支到远程主机的对应分支"><a href="#6-7-9-将当前分支到远程主机的对应分支" class="headerlink" title="6.7.9 将当前分支到远程主机的对应分支"></a>6.7.9 将当前分支到远程主机的对应分支</h4><pre class=" language-shell"><code class="language-shell">git push <remote></code></pre><h4 id="6-7-10-将本地指定分支到远程主机的对应分支"><a href="#6-7-10-将本地指定分支到远程主机的对应分支" class="headerlink" title="6.7.10 将本地指定分支到远程主机的对应分支"></a>6.7.10 将本地指定分支到远程主机的对应分支</h4><pre class=" language-shell"><code class="language-shell">git push <remote> <branch></code></pre><h4 id="6-7-11-强行推送当前分支到远程主机的对应分支-忽略冲突"><a href="#6-7-11-强行推送当前分支到远程主机的对应分支-忽略冲突" class="headerlink" title="6.7.11 强行推送当前分支到远程主机的对应分支(忽略冲突)"></a>6.7.11 强行推送当前分支到远程主机的对应分支(忽略冲突)</h4><pre class=" language-shell"><code class="language-shell">git push <remote> --force</code></pre><h4 id="6-7-12-推送所有分支到远程仓库"><a href="#6-7-12-推送所有分支到远程仓库" class="headerlink" title="6.7.12 推送所有分支到远程仓库"></a>6.7.12 推送所有分支到远程仓库</h4><pre class=" language-shell"><code class="language-shell">git push <remote> --all</code></pre><h3 id="6-8-代码回滚"><a href="#6-8-代码回滚" class="headerlink" title="6.8 代码回滚"></a>6.8 代码回滚</h3><h4 id="6-8-1-恢复暂存区的指定文件到工作区"><a href="#6-8-1-恢复暂存区的指定文件到工作区" class="headerlink" title="6.8.1 恢复暂存区的指定文件到工作区"></a>6.8.1 恢复暂存区的指定文件到工作区</h4><pre class=" language-shell"><code class="language-shell">git checkout <file-name></code></pre><h4 id="6-8-2-恢复某个commit的指定文件到暂存区和工作区"><a href="#6-8-2-恢复某个commit的指定文件到暂存区和工作区" class="headerlink" title="6.8.2 恢复某个commit的指定文件到暂存区和工作区"></a>6.8.2 恢复某个commit的指定文件到暂存区和工作区</h4><pre class=" language-shell"><code class="language-shell">git checkout <commit> <file-name></code></pre><h4 id="6-8-3-恢复暂存区的所有文件到工作区"><a href="#6-8-3-恢复暂存区的所有文件到工作区" class="headerlink" title="6.8.3 恢复暂存区的所有文件到工作区"></a>6.8.3 恢复暂存区的所有文件到工作区</h4><pre class=" language-shell"><code class="language-shell">git checkout .</code></pre><h4 id="6-8-4-回滚添加操作"><a href="#6-8-4-回滚添加操作" class="headerlink" title="6.8.4 回滚添加操作"></a>6.8.4 回滚添加操作</h4><pre class=" language-shell"><code class="language-shell">git reset</code></pre><h4 id="6-8-5-回滚最近一次提交"><a href="#6-8-5-回滚最近一次提交" class="headerlink" title="6.8.5 回滚最近一次提交"></a>6.8.5 回滚最近一次提交</h4><pre class=" language-shell"><code class="language-shell">git reset --soft HEAD^</code></pre><h4 id="6-8-6-永久删除最后几个提交"><a href="#6-8-6-永久删除最后几个提交" class="headerlink" title="6.8.6 永久删除最后几个提交"></a>6.8.6 永久删除最后几个提交</h4><pre class=" language-shell"><code class="language-shell">git reset --hard HEAD~3</code></pre><h2 id="七、-Command-line-instructions"><a href="#七、-Command-line-instructions" class="headerlink" title="七、 Command line instructions"></a>七、 Command line instructions</h2><h3 id="7-1-Git-global-setup"><a href="#7-1-Git-global-setup" class="headerlink" title="7.1 Git global setup"></a>7.1 Git global setup</h3><pre class=" language-shell"><code class="language-shell">git config --global user.name "user-name"git config --global user.email "user-email"</code></pre><h3 id="7-2-Create-a-new-repository"><a href="#7-2-Create-a-new-repository" class="headerlink" title="7.2 Create a new repository"></a>7.2 Create a new repository</h3><pre class=" language-shell"><code class="language-shell">git clone <remote-repository>cd <directory>touch README.mdgit add README.mdgit commit -m "add README"git push -u origin master</code></pre><h3 id="7-3-Existing-folder"><a href="#7-3-Existing-folder" class="headerlink" title="7.3 Existing folder"></a>7.3 Existing folder</h3><pre class=" language-shell"><code class="language-shell">cd <existing-folder>git initgit remote add origin <remote-repository>git add .git commit -m "Initial commit"git push -u origin master</code></pre><h3 id="7-4-Existing-Git-repository"><a href="#7-4-Existing-Git-repository" class="headerlink" title="7.4 Existing Git repository"></a>7.4 Existing Git repository</h3><pre class=" language-shell"><code class="language-shell">cd <existing-repository>git remote rename origin old-origingit remote add origin <remote-repository>git push -u origin --allgit push -u origin --tags</code></pre><h2 id="八、致谢"><a href="#八、致谢" class="headerlink" title="八、致谢"></a>八、致谢</h2><ol><li><a href="https://git-scm.com/book/zh/" target="_blank" rel="noopener">Git 教程</a></li><li><a href="https://www.yiibai.com/git/" target="_blank" rel="noopener">易百教程</a></li><li><a href="http://www.runoob.com/git/git-tutorial.html" target="_blank" rel="noopener">菜鸟教程</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
            <tag> 工具 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>ADB 操作命令详解及用法大全</title>
      <link href="/posts/2018/a91f712a.html"/>
      <url>/posts/2018/a91f712a.html</url>
      
        <content type="html"><![CDATA[<p><img src="https://user-gold-cdn.xitu.io/2018/8/10/16522b67d2e66dfc?w=287&amp;h=138&amp;f=jpeg&amp;s=10250" alt=""></p><h2 id="一、ADB是什么？"><a href="#一、ADB是什么？" class="headerlink" title="一、ADB是什么？"></a>一、ADB是什么？</h2><p>ADB，即 <a href="https://developer.android.com/studio/command-line/adb.html" target="_blank" rel="noopener">Android Debug Bridge</a> 是一种允许模拟器或已连接的 Android 设备进行通信的命令行工具，它可为各种设备操作提供便利，如安装和调试应用，并提供对 <code>Unix shell</code>（可用来在模拟器或连接的设备上运行各种命令）的访问。可以在<code>Android SDK/platform-tools</code>中找到 <code>adb</code> 工具或下载 <a href="http://adbshell.com/downloads" target="_blank" rel="noopener">ADB Kits</a> 。</p><p><strong>注：</strong> 有部分命令的支持情况可能与 Android 系统版本及定制 ROM 的实现有关。</p><h2 id="二、ADB有什么作用？"><a href="#二、ADB有什么作用？" class="headerlink" title="二、ADB有什么作用？"></a>二、ADB有什么作用？</h2><p><code>ADB</code> 是 <code>Android SDK</code> 里的一个工具, 用这个工具可以直接操作管理Android模拟器或者真实的Android设备。它的主要功能有:</p><ul><li>在设备上运行Shell命令；</li><li>将本地APK软件安装至模拟器或Android设备；</li><li>管理设备或手机模拟器上的预定端口；</li><li>在设备或手机模拟器上复制或粘贴文件。</li></ul><p><code>ADB</code> 是一个<code>客户端-服务器程序</code>程序，包括三个组件：</p><ul><li><strong>客户端</strong>：该组件发送命令。客户端在开发计算机上运行。您可以通过发出 adb 命令从命令行终端调用客户端。</li><li><strong>后台程序</strong>：该组件在设备上运行命令。后台程序在每个模拟器或设备实例上作为后台进程运行。</li><li><strong>服务器</strong>：该组件管理客户端和后台程序之间的通信。服务器在开发计算机上作为后台进程运行。</li></ul><h2 id="三、ADB命令语法"><a href="#三、ADB命令语法" class="headerlink" title="三、ADB命令语法"></a>三、ADB命令语法</h2><p>adb 命令的基本语法如下：</p><pre class=" language-shell"><code class="language-shell">adb [-d|-e|-s <serial-number>] <command></code></pre><h3 id="单一设备-模拟器连接"><a href="#单一设备-模拟器连接" class="headerlink" title="单一设备/模拟器连接"></a>单一设备/模拟器连接</h3><p>如果只有一个设备/模拟器连接时，可以省略掉 <code>[-d|-e|-s &lt;serial-number&gt;]</code> 这一部分，直接使用 <code>adb &lt;command&gt;</code>。</p><h3 id="多个设备-模拟器连接"><a href="#多个设备-模拟器连接" class="headerlink" title="多个设备/模拟器连接"></a>多个设备/模拟器连接</h3><p>如果有多个设备/模拟器连接，则需要为命令指定目标设备，下表是指定目标设备的命令选项：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-d</td><td>指定当前唯一通过 USB 连接的 Android 设备为命令目标</td></tr><tr><td>-e</td><td>指定当前唯一运行的模拟器为命令目标</td></tr><tr><td><code>-s &lt;serial-number&gt;</code></td><td>指定相应设备序列号的设备/模拟器为命令目标</td></tr></tbody></table><p>在多个设备/模拟器连接的情况下较常用的是 <code>-s &lt;serial-number&gt;</code> 参数，<code>serial-number</code>是指设备的设备序列号，可以通过 <code>adb devices</code> 命令获取。</p><h2 id="四、ADB常用命令"><a href="#四、ADB常用命令" class="headerlink" title="四、ADB常用命令"></a>四、ADB常用命令</h2><h3 id="4-1-基本命令"><a href="#4-1-基本命令" class="headerlink" title="4.1 基本命令"></a>4.1 基本命令</h3><h4 id="4-1-1-查看adb的版本信息"><a href="#4-1-1-查看adb的版本信息" class="headerlink" title="4.1.1 查看adb的版本信息"></a>4.1.1 查看adb的版本信息</h4><pre class=" language-shell"><code class="language-shell">adb version</code></pre><h4 id="4-1-2-启动adb"><a href="#4-1-2-启动adb" class="headerlink" title="4.1.2 启动adb"></a>4.1.2 启动adb</h4><pre class=" language-shell"><code class="language-shell">adb start-server</code></pre><p>一般无需手动执行此命令，在运行 adb 命令时若发现 adb server 没有启动会自动调起。</p><h4 id="4-1-3-停止adb"><a href="#4-1-3-停止adb" class="headerlink" title="4.1.3 停止adb"></a>4.1.3 停止adb</h4><pre class=" language-shell"><code class="language-shell">adb kill-server</code></pre><h4 id="4-1-4-以-root-权限运行-adbd"><a href="#4-1-4-以-root-权限运行-adbd" class="headerlink" title="4.1.4 以 root 权限运行 adbd"></a>4.1.4 以 root 权限运行 adbd</h4><pre class=" language-shell"><code class="language-shell">adb root</code></pre><h4 id="4-1-5-指定-adb-server-的网络端口"><a href="#4-1-5-指定-adb-server-的网络端口" class="headerlink" title="4.1.5 指定 adb server 的网络端口"></a>4.1.5 指定 adb server 的网络端口</h4><pre class=" language-shell"><code class="language-shell">adb -P <port> start-server</code></pre><p>ADB的默认端口为 5037。</p><h4 id="4-1-5-查询已连接的设备-模拟器列表"><a href="#4-1-5-查询已连接的设备-模拟器列表" class="headerlink" title="4.1.5 查询已连接的设备/模拟器列表"></a>4.1.5 查询已连接的设备/模拟器列表</h4><pre class=" language-shell"><code class="language-shell">adb devices</code></pre><h3 id="4-2-设备连接管理"><a href="#4-2-设备连接管理" class="headerlink" title="4.2 设备连接管理"></a>4.2 设备连接管理</h3><h4 id="4-2-1-USB-连接"><a href="#4-2-1-USB-连接" class="headerlink" title="4.2.1 USB 连接"></a>4.2.1 USB 连接</h4><p>通过 USB 连接来正常使用 adb 需要以下步骤：</p><ol><li>确认硬件状态正常(包括 Android 设备处于正常开机状态，USB 连接线和各种接口完好)。</li><li>Android 设备的开发者选项和 USB 调试模式已开启(可以在「设置」-「开发者选项」-「USB调试」打开USB调试)。</li><li>确认设备驱动状态正常(安装ADB驱动程序)。</li><li>通过 USB 线连接好电脑和设备后确认状态。</li><li>通过 <code>adb devices</code> 命令查看设备连接情况。</li></ol><h4 id="4-2-2-WLAN-连接（需要-USB-线）"><a href="#4-2-2-WLAN-连接（需要-USB-线）" class="headerlink" title="4.2.2 WLAN 连接（需要 USB 线）"></a>4.2.2 WLAN 连接（需要 USB 线）</h4><p>借助 USB 通过 WiFi 连接来正常使用 adb 需要以下步骤：<br>操作步骤：</p><ol><li>将 Android 设备与要运行 adb 的电脑连接到同一个 WiFi。</li><li>将设备与电脑通过 USB 线连接(可通过 <code>adb devices</code> 命令查看设备连接情况)。</li><li>通过 <code>adb tcpip 5555</code> 命令让设备在 5555 端口监听 TCP/IP 连接。</li><li>断开 USB 连接。</li><li>找到设备的 IP 地址(可以在「设置」-「关于手机」-「状态信息」-「IP地址」查看 IP 地址)。</li><li>通过 <code>adb connect &lt;device-ip-address&gt;</code> 命令使用 IP 地址将 Android 设备与电脑连接。</li><li>通过 <code>adb devices</code> 命令查看设备连接情况。</li><li>使用完毕后可通过 <code>adb disconnect &lt;device-ip-address&gt;</code> 命令断开无线连接。</li></ol><h4 id="4-2-3-WLAN-连接（无需借助-USB-线）"><a href="#4-2-3-WLAN-连接（无需借助-USB-线）" class="headerlink" title="4.2.3 WLAN 连接（无需借助 USB 线）"></a>4.2.3 WLAN 连接（无需借助 USB 线）</h4><p><strong>注：需要 root 权限。</strong><br>不借助 USB 通过 WiFi 连接来正常使用 adb 需要以下步骤：</p><ol><li>在 Android 设备上安装一个终端模拟器(可通过<a href="https://jackpal.github.io/Android-Terminal-Emulator/" target="_blank" rel="noopener">Terminal Emulator for Android Downloads</a>下载)。</li><li>将 Android 设备与要运行 adb 的电脑连接到同一个 WiFi。</li><li>打开 Android 设备上的终端模拟器，在里面依次运行命令：<pre class=" language-shell"><code class="language-shell">susetprop service.adb.tcp.port 5555</code></pre></li><li>找到设备的 IP 地址(可以在「设置」-「关于手机」-「状态信息」-「IP地址」查看 IP 地址)。</li><li>通过 <code>adb connect &lt;device-ip-address&gt;</code> 命令使用 IP 地址将 Android 设备与电脑连接。</li><li>通过 <code>adb devices</code> 命令查看设备连接情况。</li></ol><h4 id="4-2-4-WiFi-连接转为-USB-连接"><a href="#4-2-4-WiFi-连接转为-USB-连接" class="headerlink" title="4.2.4 WiFi 连接转为 USB 连接"></a>4.2.4 WiFi 连接转为 USB 连接</h4><p>通过<code>adb usb</code>命令以USB模式重新启动ADB：</p><pre class=" language-shell"><code class="language-shell">adb usb</code></pre><h3 id="4-3-应用管理"><a href="#4-3-应用管理" class="headerlink" title="4.3 应用管理"></a>4.3 应用管理</h3><h4 id="4-3-1-查看应用列表"><a href="#4-3-1-查看应用列表" class="headerlink" title="4.3.1 查看应用列表"></a>4.3.1 查看应用列表</h4><p>查看应用列表的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb shell pm list packages [-f] [-d] [-e] [-s] [-3] [-i] [-u] [--user USER_ID] [FILTER]</code></pre><p><code>adb shell pm list packages</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p><table><thead><tr><th>参数</th><th>显示列表</th></tr></thead><tbody><tr><td>无</td><td>所有应用</td></tr><tr><td>-f</td><td>显示应用关联的 apk 文件</td></tr><tr><td>-d</td><td>只显示 disabled 的应用</td></tr><tr><td>-e</td><td>只显示 enabled 的应用</td></tr><tr><td>-s</td><td>只显示系统应用</td></tr><tr><td>-3</td><td>只显示第三方应用</td></tr><tr><td>-i</td><td>显示应用的 installer</td></tr><tr><td>-u</td><td>包含已卸载应用</td></tr><tr><td><code>&lt;filter&gt;</code></td><td>包名包含 <code>&lt;filter&gt;</code> 字符串</td></tr></tbody></table><h5 id="4-3-1-1-查看所有应用"><a href="#4-3-1-1-查看所有应用" class="headerlink" title="4.3.1.1 查看所有应用"></a>4.3.1.1 查看所有应用</h5><pre class=" language-shell"><code class="language-shell">adb shell pm list packages</code></pre><h5 id="4-3-1-2-查看系统应用"><a href="#4-3-1-2-查看系统应用" class="headerlink" title="4.3.1.2 查看系统应用"></a>4.3.1.2 查看系统应用</h5><pre class=" language-shell"><code class="language-shell">adb shell pm list packages -s</code></pre><h5 id="4-3-1-3-查看第三方应用"><a href="#4-3-1-3-查看第三方应用" class="headerlink" title="4.3.1.3 查看第三方应用"></a>4.3.1.3 查看第三方应用</h5><pre class=" language-shell"><code class="language-shell">adb shell pm list packages -3</code></pre><h5 id="4-3-1-4-包名包含某字符串的应用"><a href="#4-3-1-4-包名包含某字符串的应用" class="headerlink" title="4.3.1.4 包名包含某字符串的应用"></a>4.3.1.4 包名包含某字符串的应用</h5><p>比如要查看包名包含字符串 <code>huawei</code> 的应用列表，命令：</p><pre class=" language-shell"><code class="language-shell">adb shell pm list packages huawei</code></pre><h4 id="4-3-2-安装应用"><a href="#4-3-2-安装应用" class="headerlink" title="4.3.2 安装应用"></a>4.3.2 安装应用</h4><p>安装应用的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb install [-l] [-r] [-t] [-s] [-d] [-g] <apk-file></code></pre><p><code>adb install</code> 后面可以跟一些可选参数来控制安装 APK 的行为，可用参数及含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-l</td><td>将应用安装到保护目录 /mnt/asec</td></tr><tr><td>-r</td><td>允许覆盖安装</td></tr><tr><td>-t</td><td>允许安装 AndroidManifest.xml 里 application 指定 <code>android:testOnly=&quot;true&quot;</code> 的应用</td></tr><tr><td>-s</td><td>将应用安装到 sdcard</td></tr><tr><td>-d</td><td>允许降级覆盖安装</td></tr><tr><td>-g</td><td>授予所有运行时权限</td></tr></tbody></table><p>运行命令后可以看到输出内容，包含安装进度和状态，安装状态如下：</p><ul><li><code>Success</code>：代表安装成功。</li><li><code>Failure</code>：代表安装失败。<br>APK 安装失败的情况有很多，<code>Failure</code>状态之后有安装失败输出代码。常见安装失败输出代码、含义及可能的解决办法如下：</li></ul><table><thead><tr><th>输出代码</th><th>含义</th><th>解决办法</th></tr></thead><tbody><tr><td>INSTALL_FAILED_ALREADY_EXISTS</td><td>应用已经存在，或卸载了但没卸载干净</td><td><code>adb install</code> 时使用 <code>-r</code> 参数，或者先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td></tr><tr><td>INSTALL_FAILED_INVALID_APK</td><td>无效的 APK 文件</td><td></td></tr><tr><td>INSTALL_FAILED_INVALID_URI</td><td>无效的 APK 文件名</td><td>确保 APK 文件名里无中文</td></tr><tr><td>INSTALL_FAILED_INSUFFICIENT_STORAGE</td><td>空间不足</td><td>清理空间</td></tr><tr><td>INSTALL_FAILED_DUPLICATE_PACKAGE</td><td>已经存在同名程序</td><td></td></tr><tr><td>INSTALL_FAILED_NO_SHARED_USER</td><td>请求的共享用户不存在</td><td></td></tr><tr><td>INSTALL_FAILED_UPDATE_INCOMPATIBLE</td><td>以前安装过同名应用，但卸载时数据没有移除；或者已安装该应用，但签名不一致</td><td>先 <code>adb uninstall &lt;packagename&gt;</code> 再安装</td></tr><tr><td>INSTALL_FAILED_SHARED_USER_INCOMPATIBLE</td><td>请求的共享用户存在但签名不一致</td><td></td></tr><tr><td>INSTALL_FAILED_MISSING_SHARED_LIBRARY</td><td>安装包使用了设备上不可用的共享库</td><td></td></tr><tr><td>INSTALL_FAILED_REPLACE_COULDNT_DELETE</td><td>替换时无法删除</td><td></td></tr><tr><td>INSTALL_FAILED_DEXOPT</td><td>dex 优化验证失败或空间不足</td><td></td></tr><tr><td>INSTALL_FAILED_OLDER_SDK</td><td>设备系统版本低于应用要求</td><td></td></tr><tr><td>INSTALL_FAILED_CONFLICTING_PROVIDER</td><td>设备里已经存在与应用里同名的 content provider</td><td></td></tr><tr><td>INSTALL_FAILED_NEWER_SDK</td><td>设备系统版本高于应用要求</td><td></td></tr><tr><td>INSTALL_FAILED_TEST_ONLY</td><td>应用是 test-only 的，但安装时没有指定 <code>-t</code> 参数</td><td></td></tr><tr><td>INSTALL_FAILED_CPU_ABI_INCOMPATIBLE</td><td>包含不兼容设备 CPU 应用程序二进制接口的 native code</td><td></td></tr><tr><td>INSTALL_FAILED_MISSING_FEATURE</td><td>应用使用了设备不可用的功能</td><td></td></tr><tr><td>INSTALL_FAILED_CONTAINER_ERROR</td><td>1. sdcard 访问失败;<br>2. 应用签名与 ROM 签名一致，被当作内置应用。</td><td>1. 确认 sdcard 可用，或者安装到内置存储;<br>2. 打包时不与 ROM 使用相同签名。</td></tr><tr><td>INSTALL_FAILED_INVALID_INSTALL_LOCATION</td><td>1. 不能安装到指定位置;<br>2. 应用签名与 ROM 签名一致，被当作内置应用。</td><td>1. 切换安装位置，添加或删除 <code>-s</code> 参数;<br>2. 打包时不与 ROM 使用相同签名。</td></tr><tr><td>INSTALL_FAILED_MEDIA_UNAVAILABLE</td><td>安装位置不可用</td><td>一般为 sdcard，确认 sdcard 可用或安装到内置存储</td></tr><tr><td>INSTALL_FAILED_VERIFICATION_TIMEOUT</td><td>验证安装包超时</td><td></td></tr><tr><td>INSTALL_FAILED_VERIFICATION_FAILURE</td><td>验证安装包失败</td><td></td></tr><tr><td>INSTALL_FAILED_PACKAGE_CHANGED</td><td>应用与调用程序期望的不一致</td><td></td></tr><tr><td>INSTALL_FAILED_UID_CHANGED</td><td>以前安装过该应用，与本次分配的 UID 不一致</td><td>清除以前安装过的残留文件</td></tr><tr><td>INSTALL_FAILED_VERSION_DOWNGRADE</td><td>已经安装了该应用更高版本</td><td>使用 <code>-d</code> 参数</td></tr><tr><td>INSTALL_FAILED_PERMISSION_MODEL_DOWNGRADE</td><td>已安装 target SDK 支持运行时权限的同名应用，要安装的版本不支持运行时权限</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_NOT_APK</td><td>指定路径不是文件，或不是以 <code>.apk</code> 结尾</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_BAD_MANIFEST</td><td>无法解析的 AndroidManifest.xml 文件</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_UNEXPECTED_EXCEPTION</td><td>解析器遇到异常</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_NO_CERTIFICATES</td><td>安装包没有签名</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_INCONSISTENT_CERTIFICATES</td><td>已安装该应用，且签名与 APK 文件不一致</td><td>先卸载设备上的该应用，再安装</td></tr><tr><td>INSTALL_PARSE_FAILED_CERTIFICATE_ENCODING</td><td>解析 APK 文件时遇到 <code>CertificateEncodingException</code></td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_BAD_PACKAGE_NAME</td><td>manifest 文件里没有或者使用了无效的包名</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_BAD_SHARED_USER_ID</td><td>manifest 文件里指定了无效的共享用户 ID</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_MANIFEST_MALFORMED</td><td>解析 manifest 文件时遇到结构性错误</td><td></td></tr><tr><td>INSTALL_PARSE_FAILED_MANIFEST_EMPTY</td><td>在 manifest 文件里找不到找可操作标签（instrumentation 或 application）</td><td></td></tr><tr><td>INSTALL_FAILED_INTERNAL_ERROR</td><td>因系统问题安装失败</td><td></td></tr><tr><td>INSTALL_FAILED_USER_RESTRICTED</td><td>用户被限制安装应用</td><td></td></tr><tr><td>INSTALL_FAILED_DUPLICATE_PERMISSION</td><td>应用尝试定义一个已经存在的权限名称</td><td></td></tr><tr><td>INSTALL_FAILED_NO_MATCHING_ABIS</td><td>应用包含设备的应用程序二进制接口不支持的 native code</td><td></td></tr><tr><td>INSTALL_CANCELED_BY_USER</td><td>应用安装需要在设备上确认，但未操作设备或点了取消</td><td>在设备上同意安装</td></tr><tr><td>INSTALL_FAILED_ACWF_INCOMPATIBLE</td><td>应用程序与设备不兼容</td><td></td></tr><tr><td>INSTALL_FAILED_TEST_ONLY</td><td>APK 文件是使用 Android Studio 直接 RUN 编译出来的文件</td><td>通过 Gradle 的 assembleDebug 或 assembleRelease 重新编译，或者 Generate Signed APK</td></tr><tr><td>does not contain AndroidManifest.xml</td><td>无效的 APK 文件</td><td></td></tr><tr><td>is not a valid zip file</td><td>无效的 APK 文件</td><td></td></tr><tr><td>Offline</td><td>设备未连接成功</td><td>先将设备与 adb 连接成功</td></tr><tr><td>unauthorized</td><td>设备未授权允许调试</td><td></td></tr><tr><td>error: device not found</td><td>没有连接成功的设备</td><td>先将设备与 adb 连接成功</td></tr><tr><td>protocol failure</td><td>设备已断开连接</td><td>先将设备与 adb 连接成功</td></tr><tr><td>Unknown option: -s</td><td>Android 2.2 以下不支持安装到 sdcard</td><td>不使用 <code>-s</code> 参数</td></tr><tr><td>No space left on device</td><td>空间不足</td><td>清理空间</td></tr><tr><td>Permission denied … sdcard …</td><td>sdcard 不可用</td><td></td></tr><tr><td>signatures do not match the previously installed version; ignoring!</td><td>已安装该应用且签名不一致</td><td>先卸载设备上的该应用，再安装</td></tr></tbody></table><p>参考：<a href="https://github.com/android/platform_frameworks_base/blob/master/core%2Fjava%2Fandroid%2Fcontent%2Fpm%2FPackageManager.java" target="_blank" rel="noopener">PackageManager.java</a></p><p><code>adb install</code> 实际是分三步完成：</p><ol><li>push apk 文件到 /data/local/tmp。</li><li>调用 pm install 安装。</li><li>删除 /data/local/tmp 下的对应 apk 文件。</li></ol><h4 id="4-3-3-卸载应用"><a href="#4-3-3-卸载应用" class="headerlink" title="4.3.3 卸载应用"></a>4.3.3 卸载应用</h4><p>卸载应用的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb uninstall [-k] <package-name></code></pre><p><code>&lt;package-name&gt;</code> 表示应用的包名，<code>-k</code> 参数可选，表示卸载应用但保留数据和缓存目录。</p><h4 id="4-3-4-清除应用数据与缓存"><a href="#4-3-4-清除应用数据与缓存" class="headerlink" title="4.3.4 清除应用数据与缓存"></a>4.3.4 清除应用数据与缓存</h4><pre class=" language-shell"><code class="language-shell">adb shell pm clear <package-name></code></pre><p><code>&lt;package-name&gt;</code> 表示应用名包，这条命令的效果相当于在设置里的应用信息界面点击了「清除缓存」和「清除数据」。</p><h4 id="4-3-5-查看前台-Activity"><a href="#4-3-5-查看前台-Activity" class="headerlink" title="4.3.5 查看前台 Activity"></a>4.3.5 查看前台 Activity</h4><pre class=" language-shell"><code class="language-shell">adb shell dumpsys activity activities | grep mFocusedActivity</code></pre><h4 id="4-3-6-查看正在运行的-Services"><a href="#4-3-6-查看正在运行的-Services" class="headerlink" title="4.3.6 查看正在运行的 Services"></a>4.3.6 查看正在运行的 Services</h4><pre class=" language-shell"><code class="language-shell">adb shell dumpsys activity services [<package-name>]</code></pre><p><code>&lt;package-name&gt;</code> 参数不是必须的，指定 <code>&lt;package-name&gt;</code> 表示查看与某个包名相关的 Services，不指定表示查看所有 Services。<code>&lt;package-name&gt;</code> 不一定要给出完整的包名，可以只给一部分，那么所给包名相关的 Services 都会列出来。</p><h4 id="4-3-7-查看应用详细信息"><a href="#4-3-7-查看应用详细信息" class="headerlink" title="4.3.7 查看应用详细信息"></a>4.3.7 查看应用详细信息</h4><pre class=" language-shell"><code class="language-shell">adb shell dumpsys package <package-name></code></pre><p><code>&lt;package-name&gt;</code> 表示应用包名。运行次命令的输出中包含很多信息，包括 Activity Resolver Table、Registered ContentProviders、包名、userId、安装后的文件资源代码等路径、版本信息、权限信息和授予状态、签名版本信息等。</p><h4 id="4-3-7-查看应用安装路径"><a href="#4-3-7-查看应用安装路径" class="headerlink" title="4.3.7 查看应用安装路径"></a>4.3.7 查看应用安装路径</h4><pre><code>adb shell pm path &lt;package-name&gt;</code></pre><h3 id="4-4-与应用交互"><a href="#4-4-与应用交互" class="headerlink" title="4.4 与应用交互"></a>4.4 与应用交互</h3><p>与应用交互主要是使用 <code>am &lt;command&gt;</code> 命令，常用的 <code>&lt;command&gt;</code> 如下：</p><table><thead><tr><th>command</th><th>用途</th></tr></thead><tbody><tr><td><code>start [options] &lt;intent&gt;</code></td><td>启动 <code>&lt;intent&gt;</code> 指定的 Activity</td></tr><tr><td><code>startservice [options] &lt;intent&gt;</code></td><td>启动 <code>&lt;intent&gt;</code> 指定的 Service</td></tr><tr><td><code>broadcast [options] &lt;intent&gt;</code></td><td>发送 <code>&lt;intent&gt;</code> 指定的广播</td></tr><tr><td><code>force-stop &lt;package-name&gt;</code></td><td>停止 <code>&lt;package-name&gt;</code> 相关的进程</td></tr></tbody></table><p><code>&lt;intent&gt;</code> 参数很灵活，和写 Android 程序时代码里的 Intent 相对应。</p><p>用于决定 intent 对象的选项如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>-a &lt;action&gt;</code></td><td>指定 action，比如 <code>android.intent.action.VIEW</code></td></tr><tr><td><code>-c &lt;category&gt;</code></td><td>指定 category，比如 <code>android.intent.category.APP_CONTACTS</code></td></tr><tr><td><code>-n &lt;component&gt;</code></td><td>指定完整 component 名，用于明确指定启动哪个 Activity</td></tr></tbody></table><p><code>&lt;intent&gt;</code> 里还能带数据，就像写代码时的 Bundle 一样：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td><code>--esn &lt;extra-key&gt;</code></td><td>null 值(只有 key 名)</td></tr><tr><td><code>--es &lt;extra-key&gt; &lt;extra-string-value&gt;</code></td><td>string 值</td></tr><tr><td><code>--ez &lt;extra-key&gt; &lt;extra-boolean-value&gt;</code></td><td>boolean 值</td></tr><tr><td><code>--ei &lt;extra-key&gt; &lt;extra-int-value&gt;</code></td><td>integer 值</td></tr><tr><td><code>--el &lt;extra-key&gt; &lt;extra-long-value&gt;</code></td><td>long 值</td></tr><tr><td><code>--ef &lt;extra-key&gt; &lt;extra-float-value&gt;</code></td><td>float 值</td></tr><tr><td><code>--eu &lt;extra-key&gt; &lt;extra-uri-value&gt;</code></td><td>URI</td></tr><tr><td><code>--ecn &lt;extra-key&gt; &lt;extra-component-name-value&gt;</code></td><td>component name</td></tr><tr><td><code>--eia &lt;extra-key&gt; &lt;extra-int-value&gt;[,&lt;extra-int-value...]</code></td><td>integer 数组</td></tr><tr><td><code>--ela &lt;extra-key&gt; &lt;extra-long-value&gt;[,&lt;extra-long-value...]</code></td><td>long 数组</td></tr></tbody></table><h4 id="4-4-1-启动应用-调起-Activity"><a href="#4-4-1-启动应用-调起-Activity" class="headerlink" title="4.4.1 启动应用/ 调起 Activity"></a>4.4.1 启动应用/ 调起 Activity</h4><pre class=" language-shell"><code class="language-shell">adb shell am start [options] <intent></code></pre><p>例如：</p><pre class=" language-shell"><code class="language-shell">adb shell am start -a android.settings.SETTINGS                   # 打开系统设置页面adb shell am start -a android.intent.action.DIAL -d tel:10086     # 打开拨号页面adb shell am start -n com.android.mms/.ui.ConversationList        # 打开短信会话列表</code></pre><p>options 是一些改变其行为的选项，支持的可选参数及含义如下：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-D</td><td>启用调试</td></tr><tr><td>-W</td><td>等待启动完成</td></tr><tr><td>–start-profiler <code>file</code></td><td>启动分析器并将结果发送到 <code>file</code></td></tr><tr><td>-P <code>file</code></td><td>类似于 –start-profiler，但当应用进入空闲状态时分析停止</td></tr><tr><td>-R <code>count</code></td><td>重复 Activity 启动次数</td></tr><tr><td>-S</td><td>启动 Activity 前强行停止目标应用</td></tr><tr><td>–opengl-trace</td><td>启用 OpenGL 函数的跟踪</td></tr><tr><td>–user <code>user_id</code> &#124; current</td><td>指定要作为哪个用户运行；如果未指定，则作为当前用户运行</td></tr></tbody></table><h4 id="4-4-2-调起-Service"><a href="#4-4-2-调起-Service" class="headerlink" title="4.4.2 调起 Service"></a>4.4.2 调起 Service</h4><pre class=" language-shell"><code class="language-shell">adb shell am startservice [options] <intent></code></pre><p>一个典型的用例是如果设备上原本应该显示虚拟按键但是没有显示，可以试试这个：</p><pre class=" language-shell"><code class="language-shell">adb shell am startservice -n com.android.systemui/.SystemUIService</code></pre><h4 id="4-4-3-停止-Service"><a href="#4-4-3-停止-Service" class="headerlink" title="4.4.3 停止 Service"></a>4.4.3 停止 Service</h4><pre class=" language-shell"><code class="language-shell">adb shell am stopservice [options] <intent></code></pre><h4 id="4-4-4-发送广播"><a href="#4-4-4-发送广播" class="headerlink" title="4.4.4 发送广播"></a>4.4.4 发送广播</h4><pre class=" language-shell"><code class="language-shell">adb shell am broadcast [options] <INTENT></code></pre><p>可以向所有组件广播，也可以只向指定组件广播。</p><p>例如，向所有组件广播 <code>BOOT_COMPLETED</code>：</p><pre class=" language-shell"><code class="language-shell">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED</code></pre><p>又例如，只向 <code>com.android.receiver.test/.BootCompletedReceiver</code> 广播 <code>BOOT_COMPLETED</code>：</p><pre class=" language-shell"><code class="language-shell">adb shell am broadcast -a android.intent.action.BOOT_COMPLETED -n com.android.receiver.test/.BootCompletedReceiver</code></pre><p>这类用法在测试的时候很实用，比如某个广播的场景很难制造，可以考虑通过这种方式来发送广播。</p><p>既能发送系统预定义的广播，也能发送自定义广播。如下是部分系统预定义广播及正常触发时机：</p><table><thead><tr><th>action</th><th>触发时机</th></tr></thead><tbody><tr><td>android.net.conn.CONNECTIVITY_CHANGE</td><td>网络连接发生变化</td></tr><tr><td>android.intent.action.SCREEN_ON</td><td>屏幕点亮</td></tr><tr><td>android.intent.action.SCREEN_OFF</td><td>屏幕熄灭</td></tr><tr><td>android.intent.action.BATTERY_LOW</td><td>电量低，会弹出电量低提示框</td></tr><tr><td>android.intent.action.BATTERY_OKAY</td><td>电量恢复了</td></tr><tr><td>android.intent.action.BOOT_COMPLETED</td><td>设备启动完毕</td></tr><tr><td>android.intent.action.DEVICE_STORAGE_LOW</td><td>存储空间过低</td></tr><tr><td>android.intent.action.DEVICE_STORAGE_OK</td><td>存储空间恢复</td></tr><tr><td>android.intent.action.PACKAGE_ADDED</td><td>安装了新的应用</td></tr><tr><td>android.net.wifi.STATE_CHANGE</td><td>WiFi连接状态发生变化</td></tr><tr><td>android.net.wifi.WIFI_STATE_CHANGED</td><td>WiFi状态变为启用/关闭/正在启动/正在关闭/未知</td></tr><tr><td>android.intent.action.BATTERY_CHANGED</td><td>电池电量发生变化</td></tr><tr><td>android.intent.action.INPUT_METHOD_CHANGED</td><td>系统输入法发生变化</td></tr><tr><td>android.intent.action.ACTION_POWER_CONNECTED</td><td>外部电源连接</td></tr><tr><td>android.intent.action.ACTION_POWER_DISCONNECTED</td><td>外部电源断开连接</td></tr><tr><td>android.intent.action.DREAMING_STARTED</td><td>系统开始休眠</td></tr><tr><td>android.intent.action.DREAMING_STOPPED</td><td>系统停止休眠</td></tr><tr><td>android.intent.action.WALLPAPER_CHANGED</td><td>壁纸发生变化</td></tr><tr><td>android.intent.action.HEADSET_PLUG</td><td>插入耳机</td></tr><tr><td>android.intent.action.MEDIA_UNMOUNTED</td><td>卸载外部介质</td></tr><tr><td>android.intent.action.MEDIA_MOUNTED</td><td>挂载外部介质</td></tr><tr><td>android.os.action.POWER_SAVE_MODE_CHANGED</td><td>省电模式开启</td></tr></tbody></table><blockquote><p>以上广播均可使用 adb 触发</p></blockquote><h4 id="4-4-5-强制停止应用"><a href="#4-4-5-强制停止应用" class="headerlink" title="4.4.5 强制停止应用"></a>4.4.5 强制停止应用</h4><pre class=" language-shell"><code class="language-shell">adb shell am force-stop <packagename></code></pre><h4 id="4-4-6-收紧内存"><a href="#4-4-6-收紧内存" class="headerlink" title="4.4.6 收紧内存"></a>4.4.6 收紧内存</h4><pre class=" language-shell"><code class="language-shell">adb shell am send-trim-memory  <pid> <level></code></pre><p>参数说明：</p><ul><li><code>pid</code>: 进程 ID</li><li><code>level</code>:HIDDEN、RUNNING_MODERATE、BACKGROUND、RUNNING_LOW、MODERATE、RUNNING_CRITICAL、COMPLETE</li></ul><h3 id="4-5-文件管理"><a href="#4-5-文件管理" class="headerlink" title="4.5 文件管理"></a>4.5 文件管理</h3><h4 id="4-5-1-从模拟器-设备下载指定的文件到计算机"><a href="#4-5-1-从模拟器-设备下载指定的文件到计算机" class="headerlink" title="4.5.1 从模拟器/设备下载指定的文件到计算机"></a>4.5.1 从模拟器/设备下载指定的文件到计算机</h4><p>从模拟器/设备下载指定的文件到计算机的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb pull <remote> [local]</code></pre><p>参数说明：</p><ul><li><code>remote</code>: 模拟器/设备里的文件路径</li><li><code>local</code>:计算机上的目录，参数可以省略，默认复制到当前目录</li></ul><p>例如，将 /sdcard/music.mp4 下载到计算机的当前目录：</p><pre class=" language-shell"><code class="language-shell">adb pull /sdcard/music.mp4</code></pre><p>将 /sdcard/music.mp4 下载到计算机的当前目录(目录需存在)：</p><pre class=" language-shell"><code class="language-shell">adb pull /sdcard/music.mp4 D:\Download</code></pre><h4 id="4-5-2-将指定的文件从计算机上传到模拟器-设备"><a href="#4-5-2-将指定的文件从计算机上传到模拟器-设备" class="headerlink" title="4.5.2 将指定的文件从计算机上传到模拟器/设备"></a>4.5.2 将指定的文件从计算机上传到模拟器/设备</h4><p>将指定的文件从计算机上传到模拟器/设备的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb push <local> <remote></code></pre><p>参数说明：</p><ul><li><code>local</code>:计算机上的文件路径</li><li><code>remote</code>: 模拟器/设备里的目录</li></ul><p>例如，将 D:\Download\music.mp4 下载到设备的/sdcard/music/目录：</p><pre class=" language-shell"><code class="language-shell">adb push D:\Download\music.mp4 /sdcard/music/</code></pre><h4 id="4-5-4-列出指定目录的内容"><a href="#4-5-4-列出指定目录的内容" class="headerlink" title="4.5.4 列出指定目录的内容"></a>4.5.4 列出指定目录的内容</h4><p>列出模拟器/设备上指定目录的内容的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb shell ls [options] <directory></code></pre><p><code>&lt;directory&gt;</code> 表示指定目录，可以省略，表示列出根目录下的所有文件和目录。<br><code>adb shell ls</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p><table><thead><tr><th>参数</th><th>显示列表</th></tr></thead><tbody><tr><td>无</td><td>列出目录下的所有文件和目录</td></tr><tr><td>-a</td><td>列出目录下的所有文件(包括隐藏的)</td></tr><tr><td>-i</td><td>列出目录下的所有文件和索引编号</td></tr><tr><td>-s</td><td>列出目录下的所有文件和文件大小</td></tr><tr><td>-n</td><td>列出目录下的所有文件及其 UID和 GID</td></tr><tr><td>-R</td><td>列出目录下的所有子目录中的文件</td></tr></tbody></table><h4 id="4-5-5-切换到目标目录"><a href="#4-5-5-切换到目标目录" class="headerlink" title="4.5.5 切换到目标目录"></a>4.5.5 切换到目标目录</h4><pre class=" language-shell"><code class="language-shell">adb shell cd <directory></code></pre><p>第一步：执行<code>adb shell</code>命令；<br>第二步：执行<code>cd &lt;directory&gt;</code>命令切换到目标目录。</p><h4 id="4-5-6-删除文件或目录"><a href="#4-5-6-删除文件或目录" class="headerlink" title="4.5.6 删除文件或目录"></a>4.5.6 删除文件或目录</h4><pre class=" language-shell"><code class="language-shell">adb shell rm [options] <files or directory></code></pre><p>第一步：执行<code>adb shell</code>命令；<br>第二步：执行<code>rm [options] &lt;files or directory&gt;</code>命令删除文件或目录。</p><p><code>rm</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>无</td><td>删除文件</td></tr><tr><td>-f</td><td>强制删除文件，系统不提示</td></tr><tr><td>-r</td><td>强制删除指定目录中的所有文件和子目录</td></tr><tr><td>-d</td><td>删除指定目录，即使它是一个非空目录</td></tr><tr><td>-i</td><td>交互式删除，删除前提示</td></tr></tbody></table><p><code>rm -d</code> 等同于 <code>rmdir</code> 命令，有些版本不包含<code>-d</code> 参数。</p><h4 id="4-5-7-创建目录"><a href="#4-5-7-创建目录" class="headerlink" title="4.5.7 创建目录"></a>4.5.7 创建目录</h4><pre class=" language-shell"><code class="language-shell">adb shell mkdir [options] <directory-name></code></pre><p>第一步：执行<code>adb shell</code>命令；<br>第二步：执行<code>mkdir [options] &lt;directory-name&gt;</code>命令创建目录。<br><code>mkdir</code> 后面可以跟一些可选参数进行不同的操作，可用参数及含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>无</td><td>创建指定目录</td></tr><tr><td>-m</td><td>创建指定目录并赋予读写权限</td></tr><tr><td>-p</td><td>创建指定目录及其父目录</td></tr></tbody></table><h4 id="4-5-8-创建空文件或改变文件时间戳"><a href="#4-5-8-创建空文件或改变文件时间戳" class="headerlink" title="4.5.8 创建空文件或改变文件时间戳"></a>4.5.8 创建空文件或改变文件时间戳</h4><pre class=" language-shell"><code class="language-shell">adb shell touch [options] <file></code></pre><p>第一步：执行<code>adb shell</code>命令；<br>第二步：执行<code>touch [options] &lt;file&gt;</code>命令创建空文件或改变文件时间戳。</p><p>可通过<code>ls -n &lt;directory&gt;</code> 命令查看文件的时间。</p><h4 id="4-5-9-输出当前目录路径"><a href="#4-5-9-输出当前目录路径" class="headerlink" title="4.5.9 输出当前目录路径"></a>4.5.9 输出当前目录路径</h4><pre class=" language-shell"><code class="language-shell">adb shell pwd</code></pre><p>第一步：执行<code>adb shell</code>命令；<br>第二步：执行<code>pwd</code>命令输出当前目录路径。</p><h4 id="4-5-10-复制文件和目录"><a href="#4-5-10-复制文件和目录" class="headerlink" title="4.5.10 复制文件和目录"></a>4.5.10 复制文件和目录</h4><pre class=" language-shell"><code class="language-shell">adb shell cp [options] <source> <dest></code></pre><p>第一步：执行<code>adb shell</code>命令；<br>第二步：执行<code>cp [options] &lt;source&gt; &lt;dest&gt;</code>命令复制文件和目录。<br>参数说明：</p><ul><li><code>source</code>:源文件路径</li><li><code>dest</code>: 目标文件路径</li></ul><h4 id="4-5-11-移动或重命名文件"><a href="#4-5-11-移动或重命名文件" class="headerlink" title="4.5.11 移动或重命名文件"></a>4.5.11 移动或重命名文件</h4><pre class=" language-shell"><code class="language-shell">adb shell mv [options] <source> <dest></code></pre><p>第一步：执行<code>adb shell</code>命令；<br>第二步：执行<code>mv [options] &lt;source&gt; &lt;dest&gt;</code>命令移动或重命名文件。<br>参数说明：</p><ul><li><code>source</code>:源文件路径</li><li><code>dest</code>: 目标文件路径</li></ul><h3 id="4-6-网络管理"><a href="#4-6-网络管理" class="headerlink" title="4.6 网络管理"></a>4.6 网络管理</h3><h4 id="4-6-1-查看网络统计信息"><a href="#4-6-1-查看网络统计信息" class="headerlink" title="4.6.1 查看网络统计信息"></a>4.6.1 查看网络统计信息</h4><pre class=" language-shell"><code class="language-shell">adb shell netstat</code></pre><p>也可以将网络统计信息输出到指定文件：</p><pre class=" language-shell"><code class="language-shell">adb shell netstat><file-path></code></pre><p>例如，可以通过 <code>adb shell netstat&gt;D:\netstat.log</code> 将日志输出到 <code>D:\netstat.log</code> 中。</p><h4 id="4-6-2-测试两个网络间的连接和延迟"><a href="#4-6-2-测试两个网络间的连接和延迟" class="headerlink" title="4.6.2 测试两个网络间的连接和延迟"></a>4.6.2 测试两个网络间的连接和延迟</h4><p><code>ping</code> 命令的格式如下：</p><pre class=" language-shell"><code class="language-shell">adb shell ping [-aAbBdDfhLnOqrRUvV] [-c count] [-i interval] [-I interface][-m mark] [-M pmtudisc_option] [-l preload] [-p pattern] [-Q tos][-s packetsize] [-S sndbuf] [-t ttl] [-T timestamp_option][-w deadline] [-W timeout] [hop1 ...] destination</code></pre><p>例如，ping一个域名：</p><pre class=" language-shell"><code class="language-shell">adb shell ping www.google.com</code></pre><p>不结束的话会一直ping下去，可以按 <code>Ctrl + C</code> 停止ping操作。</p><p>也可以指定ping的次数：</p><pre class=" language-shell"><code class="language-shell">adb shell ping -c 4 www.google.com</code></pre><h4 id="4-6-3-通过配置文件配置和管理网络连接"><a href="#4-6-3-通过配置文件配置和管理网络连接" class="headerlink" title="4.6.3 通过配置文件配置和管理网络连接"></a>4.6.3 通过配置文件配置和管理网络连接</h4><p><code>netcfg</code> 命令的格式如下：</p><pre class=" language-shell"><code class="language-shell">adb shell netcfg [<interface> {dhcp|up|down}]</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">rmnet_ims10 DOWN                                   0.0.0.0/0   0x00001002rmnet_ims00 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun04 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun03 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun02 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun01 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun00 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun14 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun13 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun12 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun11 DOWN                                   0.0.0.0/0   0x00001002rmnet_tun10 DOWN                                   0.0.0.0/0   0x00001002rmnet1   DOWN                                   0.0.0.0/0   0x00001002rmnet0   DOWN                                   0.0.0.0/0   0x00001002rmnet4   DOWN                                   0.0.0.0/0   0x00001002rmnet3   DOWN                                   0.0.0.0/0   0x00001002rmnet2   DOWN                                   0.0.0.0/0   0x00001002rmnet6   DOWN                                   0.0.0.0/0   0x00001002rmnet5   DOWN                                   0.0.0.0/0   0x00001002dummy0   UP                                     0.0.0.0/0   0x000000c3rmnet_r_ims10 DOWN                                   0.0.0.0/0   0x00001002rmnet_r_ims00 DOWN                                   0.0.0.0/0   0x00001002rmnet_emc0 DOWN                                   0.0.0.0/0   0x00001002lo       UP                                   127.0.0.1/8   0x00000049sit0     DOWN                                   0.0.0.0/0   0x00000080wlan0    UP                                 10.0.38.176/23  0x00001043</code></pre><h4 id="4-6-4-显示、操作路由、设备、策略路由和隧道"><a href="#4-6-4-显示、操作路由、设备、策略路由和隧道" class="headerlink" title="4.6.4 显示、操作路由、设备、策略路由和隧道"></a>4.6.4 显示、操作路由、设备、策略路由和隧道</h4><p><code>ip</code> 命令的格式如下：</p><pre class=" language-shell"><code class="language-shell">adb shell ip [ options ] object</code></pre><ul><li><p>options := { -V[ersion] | -s[tatistics] | -d[etails] | -r[esolve] |-f[amily] { inet | inet6 | ipx | dnet | link } |-l[oops] { maximum-addr-flush-attempts } |-o[neline] | -t[imestamp] | -b[atch] [filename] |-rc[vbuf] [size]}</p></li><li><p>object := { link | addr | addrlabel | route | rule | neigh | ntable |tunnel | tuntap | maddr | mroute | mrule | monitor | xfrm |netns | l2tp }</p></li></ul><p><code>options</code> 是一些修改ip行为或者改变其输出的选项。所有的选项都是以-字符开头，分为长、短两种形式，支持的可选参数及含义如下：</p><table><thead><tr><th>选项</th><th>含义</th></tr></thead><tbody><tr><td>-V,-Version</td><td>打印ip的版本并退出</td></tr><tr><td>-s,-stats,-statistics</td><td>输出更为详尽的信息(如果这个选项出现两次或者多次，输出的信息将更为详尽)</td></tr><tr><td>-f,-family</td><td>强调使用的协议种类(包括：inet、inet6或者link)</td></tr><tr><td>-4</td><td>是-family inet的简写</td></tr><tr><td>-6</td><td>是-family inet6的简写</td></tr><tr><td>-0</td><td>是-family link的简写</td></tr><tr><td>-o,-oneline</td><td>对每行记录都使用单行输出，回行用字符代替</td></tr><tr><td>-r,-resolve</td><td>查询域名解析系统，用获得的主机名代替主机IP地址</td></tr></tbody></table><p><code>object</code> 是你要管理或者获取信息的对象。目前ip认识的对象包括：</p><table><thead><tr><th>参数</th><th>显示列表</th></tr></thead><tbody><tr><td>link</td><td>网络设备</td></tr><tr><td>address</td><td>一个设备的协议(IP或者IPV6)地址</td></tr><tr><td>neighbour</td><td>ARP或者NDISC缓冲区条目</td></tr><tr><td>route</td><td>路由表条目</td></tr><tr><td>rule</td><td>路由策略数据库中的规则</td></tr><tr><td>maddress</td><td>多播地址</td></tr><tr><td>mroute</td><td>多播路由缓冲区条目</td></tr><tr><td>tuntap</td><td>管理 TUN/TAP 设备</td></tr><tr><td>netns</td><td>管理网络空间</td></tr></tbody></table><p>例如，查看 <code>WiFi IP</code> 地址：</p><pre class=" language-shell"><code class="language-shell">adb shell ip -f inet addr show wlan0</code></pre><h3 id="4-7-模拟按键-输入"><a href="#4-7-模拟按键-输入" class="headerlink" title="4.7 模拟按键/输入"></a>4.7 模拟按键/输入</h3><p>在 <code>adb shell</code> 里有个很实用的命令叫 <code>input</code>，通过它可以做一些有趣的事情。<br>可以执行<code>adb shell input</code>命令查看完整 help 信息如下：</p><pre class=" language-shell"><code class="language-shell">Usage: input [<source>] <command> [<arg>...]The sources are:      dpad      keyboard      mouse      touchpad      gamepad      touchnavigation      joystick      touchscreen      stylus      trackballThe commands and default sources are:      text <string> (Default: touchscreen)      keyevent [--longpress] <key code number or name> ... (Default: keyboard)      tap <x> <y> (Default: touchscreen)      swipe <x1> <y1> <x2> <y2> [duration(ms)] (Default: touchscreen)      draganddrop <x1> <y1> <x2> <y2> [duration(ms)] (Default: touchscreen)      press (Default: trackball)      roll <dx> <dy> (Default: trackball)</code></pre><p>比如使用 <code>adb shell input keyevent &lt;keycode&gt;</code> 命令，不同的 keycode 能实现不同的功能，完整的 keycode 列表详见 <a href="https://developer.android.com/reference/android/view/KeyEvent.html" target="_blank" rel="noopener">KeyEvent</a>，摘引部分我觉得有意思的如下：</p><table><thead><tr><th>KeyCode</th><th>含义</th></tr></thead><tbody><tr><td>3</td><td>HOME 键</td></tr><tr><td>4</td><td>返回键</td></tr><tr><td>5</td><td>打开拨号应用</td></tr><tr><td>6</td><td>挂断电话</td></tr><tr><td>24</td><td>增加音量</td></tr><tr><td>25</td><td>降低音量</td></tr><tr><td>26</td><td>电源键</td></tr><tr><td>27</td><td>拍照（需要在相机应用里）</td></tr><tr><td>64</td><td>打开浏览器</td></tr><tr><td>82</td><td>菜单键</td></tr><tr><td>85</td><td>播放/暂停</td></tr><tr><td>86</td><td>停止播放</td></tr><tr><td>87</td><td>播放下一首</td></tr><tr><td>88</td><td>播放上一首</td></tr><tr><td>122</td><td>移动光标到行首或列表顶部</td></tr><tr><td>123</td><td>移动光标到行末或列表底部</td></tr><tr><td>126</td><td>恢复播放</td></tr><tr><td>127</td><td>暂停播放</td></tr><tr><td>164</td><td>静音</td></tr><tr><td>176</td><td>打开系统设置</td></tr><tr><td>187</td><td>切换应用</td></tr><tr><td>207</td><td>打开联系人</td></tr><tr><td>208</td><td>打开日历</td></tr><tr><td>209</td><td>打开音乐</td></tr><tr><td>210</td><td>打开计算器</td></tr><tr><td>220</td><td>降低屏幕亮度</td></tr><tr><td>221</td><td>提高屏幕亮度</td></tr><tr><td>223</td><td>系统休眠</td></tr><tr><td>224</td><td>点亮屏幕</td></tr><tr><td>231</td><td>打开语音助手</td></tr><tr><td>276</td><td>如果没有 wakelock 则让系统休眠</td></tr></tbody></table><p>下面是 <code>input</code> 命令的一些用法举例。</p><h4 id="4-7-1-电源键"><a href="#4-7-1-电源键" class="headerlink" title="4.7.1 电源键"></a>4.7.1 电源键</h4><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 26</code></pre><p>执行效果相当于按电源键。</p><h4 id="4-7-2-菜单键"><a href="#4-7-2-菜单键" class="headerlink" title="4.7.2 菜单键"></a>4.7.2 菜单键</h4><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 82</code></pre><h4 id="4-7-3-HOME-键"><a href="#4-7-3-HOME-键" class="headerlink" title="4.7.3 HOME 键"></a>4.7.3 HOME 键</h4><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 3</code></pre><h4 id="4-7-4-返回键"><a href="#4-7-4-返回键" class="headerlink" title="4.7.4 返回键"></a>4.7.4 返回键</h4><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 4</code></pre><h4 id="4-7-5-音量控制"><a href="#4-7-5-音量控制" class="headerlink" title="4.7.5 音量控制"></a>4.7.5 音量控制</h4><ul><li><p>增加音量：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 24</code></pre></li><li><p>降低音量：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 25</code></pre></li></ul><ul><li>静音：</li></ul><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 164</code></pre><h4 id="4-7-6-媒体控制"><a href="#4-7-6-媒体控制" class="headerlink" title="4.7.6 媒体控制"></a>4.7.6 媒体控制</h4><ul><li><p>播放/暂停：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 85</code></pre></li><li><p>停止播放：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 86</code></pre></li><li><p>播放下一首：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 87</code></pre></li><li><p>播放上一首：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 88</code></pre></li><li><p>恢复播放：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 126</code></pre></li><li><p>暂停播放：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 127</code></pre></li></ul><h4 id="4-7-7-点亮-熄灭屏幕"><a href="#4-7-7-点亮-熄灭屏幕" class="headerlink" title="4.7.7 点亮/熄灭屏幕"></a>4.7.7 点亮/熄灭屏幕</h4><ul><li><p>点亮屏幕：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 224</code></pre></li><li><p>熄灭屏幕：</p><pre class=" language-shell"><code class="language-shell">adb shell input keyevent 223</code></pre></li></ul><h4 id="4-7-8-滑动解锁"><a href="#4-7-8-滑动解锁" class="headerlink" title="4.7.8 滑动解锁"></a>4.7.8 滑动解锁</h4><p>如果锁屏没有密码，是通过滑动手势解锁，那么可以通过 <code>input swipe</code> 来解锁。<br>命令（参数以机型 Nexus 5，向上滑动手势解锁举例）：</p><pre class=" language-shell"><code class="language-shell">adb shell input swipe 300 1000 300 500</code></pre><p>参数 <code>300 1000 300 500</code> 分别表示<code>起始点x坐标 起始点y坐标 结束点x坐标 结束点y坐标</code>。</p><h4 id="4-7-9-输入文本"><a href="#4-7-9-输入文本" class="headerlink" title="4.7.9 输入文本"></a>4.7.9 输入文本</h4><p>在焦点处于某文本框时，可以通过 <code>input</code> 命令来输入文本。</p><pre class=" language-shell"><code class="language-shell">adb shell input text hello</code></pre><h3 id="4-8-日志打印"><a href="#4-8-日志打印" class="headerlink" title="4.8 日志打印"></a>4.8 日志打印</h3><p>Android 系统的日志分为两部分，底层的 Linux 内核日志输出到 /proc/kmsg，Android 的日志输出到 /dev/log。</p><h4 id="4-8-1-Android-日志"><a href="#4-8-1-Android-日志" class="headerlink" title="4.8.1 Android 日志"></a>4.8.1 Android 日志</h4><p>查看 Android 设备系统属性的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb logcat [option] [filter-specs]</code></pre><p>如果需要停止 <code>logcat</code> 日志打印，可以按 <code>Ctrl + C</code> 停止日志监控。</p><h5 id="4-8-1-1-按级别过滤日志"><a href="#4-8-1-1-按级别过滤日志" class="headerlink" title="4.8.1.1 按级别过滤日志"></a>4.8.1.1 按级别过滤日志</h5><p>按级别过滤日志的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb logcat [filter-specs]</code></pre><p>Android 的日志分为如下几个优先级（priority）：</p><table><thead><tr><th>级别</th><th>含义</th></tr></thead><tbody><tr><td>*:V</td><td>过滤只显示 Verbose 及以上级别(优先级最低)</td></tr><tr><td>*:D</td><td>过滤只显示 Debug 及以上级别</td></tr><tr><td>*:I</td><td>过滤只显示 Info 及以上级别</td></tr><tr><td>*:W</td><td>过滤只显示 Warning 及以上级别</td></tr><tr><td>*:E</td><td>过滤只显示 Error 及以上级别</td></tr><tr><td>*:F</td><td>过滤只显示 Fatal 及以上级别</td></tr><tr><td>*:S</td><td>过滤只显示 Silent 及以上级别(优先级最高，什么也不输出)</td></tr></tbody></table><p>按某级别过滤日志则会将该级别及以上的日志输出。</p><p>比如，命令：</p><pre class=" language-shell"><code class="language-shell">adb logcat *:W</code></pre><p>会将 Warning、Error、Fatal 和 Silent 日志输出。</p><p>（<strong>注：</strong> 在 macOS 下需要给 <code>*:W</code> 这样以 <code>*</code> 作为 tag 的参数加双引号，如 <code>adb logcat &quot;*:W&quot;</code>，不然会报错 <code>no matches found: *:W</code>。）</p><h5 id="4-8-1-2-按-tag-和级别过滤日志"><a href="#4-8-1-2-按-tag-和级别过滤日志" class="headerlink" title="4.8.1.2 按 tag 和级别过滤日志"></a>4.8.1.2 按 tag 和级别过滤日志</h5><p>按 tag 和级别过滤日志的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb logcat [tag:level] [tag:level] ...</code></pre><p>比如，命令：</p><pre class=" language-shell"><code class="language-shell">adb logcat ActivityManager:I MyApp:D *:S</code></pre><p>表示输出 tag <code>ActivityManager</code> 的 Info 以上级别日志，输出 tag <code>MyApp</code> 的 Debug 以上级别日志，及其它 tag 的 Silent 级别日志（即屏蔽其它 tag 日志）。</p><h5 id="4-8-1-3-将日志格式化输出"><a href="#4-8-1-3-将日志格式化输出" class="headerlink" title="4.8.1.3 将日志格式化输出"></a>4.8.1.3 将日志格式化输出</h5><p>可以用 <code>adb logcat -v &lt;format&gt;</code> 选项指定日志输出格式。</p><p>日志支持按以下几种 <code>&lt;format&gt;</code>：</p><table><thead><tr><th>参数</th><th>显示格式</th></tr></thead><tbody><tr><td>brief</td><td><code>&lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</code></td></tr><tr><td>process</td><td><code>&lt;priority&gt;(&lt;pid&gt;) &lt;message&gt;</code></td></tr><tr><td>tag</td><td><code>&lt;priority&gt;/&lt;tag&gt;: &lt;message&gt;</code></td></tr><tr><td>raw</td><td><code>&lt;message&gt;</code></td></tr><tr><td>time</td><td><code>&lt;datetime&gt; &lt;priority&gt;/&lt;tag&gt;(&lt;pid&gt;): &lt;message&gt;</code></td></tr><tr><td>threadtime</td><td><code>&lt;datetime&gt; &lt;pid&gt; &lt;tid&gt; &lt;priority&gt; &lt;tag&gt;: &lt;message&gt;</code></td></tr><tr><td>long</td><td><code>[ &lt;datetime&gt; &lt;pid&gt;:&lt;tid&gt; &lt;priority&gt;/&lt;tag&gt; ] &lt;message&gt;</code></td></tr></tbody></table><p>日志格式默认为 <code>brief</code>，指定格式可与上面的过滤同时使用。比如：</p><pre class=" language-shell"><code class="language-shell">adb logcat -v long ActivityManager:I *:S</code></pre><h5 id="4-8-1-3-清空已存在的日志"><a href="#4-8-1-3-清空已存在的日志" class="headerlink" title="4.8.1.3 清空已存在的日志"></a>4.8.1.3 清空已存在的日志</h5><pre class=" language-shell"><code class="language-shell">adb logcat -c</code></pre><h5 id="4-8-1-4-将日志显示在控制台"><a href="#4-8-1-4-将日志显示在控制台" class="headerlink" title="4.8.1.4 将日志显示在控制台"></a>4.8.1.4 将日志显示在控制台</h5><pre class=" language-shell"><code class="language-shell">adb logcat -d</code></pre><h5 id="4-8-1-5-将日志输出到文件"><a href="#4-8-1-5-将日志输出到文件" class="headerlink" title="4.8.1.5 将日志输出到文件"></a>4.8.1.5 将日志输出到文件</h5><pre class=" language-shell"><code class="language-shell">adb logcat -f <file-path></code></pre><h5 id="4-8-1-6-加载一个可使用的日志缓冲区供查看"><a href="#4-8-1-6-加载一个可使用的日志缓冲区供查看" class="headerlink" title="4.8.1.6 加载一个可使用的日志缓冲区供查看"></a>4.8.1.6 加载一个可使用的日志缓冲区供查看</h5><pre class=" language-shell"><code class="language-shell">adb logcat -b <Buffer></code></pre><p><code>Android log</code> 输出量巨大，特别是通信系统的log，因此，Android把log输出到不同的缓冲区中，目前定义了四个log缓冲区：</p><table><thead><tr><th>缓冲区</th><th>含义</th></tr></thead><tbody><tr><td>Radio</td><td>输出通信系统的 log</td></tr><tr><td>System</td><td>输出系统组件的 log</td></tr><tr><td>Event</td><td>输出 event 模块的 log</td></tr><tr><td>Main</td><td>所有 java 层的 log 以及不属于上面3层的 log</td></tr></tbody></table><p>缓冲区主要给系统组件使用，一般的应用不需要关心，应用的log都输出到main缓冲区中。默认log输出（不指定缓冲区的情况下）是输出System和Main缓冲区的log。</p><h5 id="4-8-1-7-打印指定日志缓冲区的大小"><a href="#4-8-1-7-打印指定日志缓冲区的大小" class="headerlink" title="4.8.1.7 打印指定日志缓冲区的大小"></a>4.8.1.7 打印指定日志缓冲区的大小</h5><pre class=" language-shell"><code class="language-shell">adb logcat -g</code></pre><h4 id="4-8-2-内核日志"><a href="#4-8-2-内核日志" class="headerlink" title="4.8.2 内核日志"></a>4.8.2 内核日志</h4><pre class=" language-shell"><code class="language-shell">adb shell dmesg</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell"><6>[14201.684016] PM: noirq resume of devices complete after 0.982 msecs<6>[14201.685525] PM: early resume of devices complete after 0.838 msecs<6>[14201.753642] PM: resume of devices complete after 68.106 msecs<4>[14201.755954] Restarting tasks ... done.<6>[14201.771229] PM: suspend exit 2016-08-28 13:31:32.679217193 UTC<6>[14201.872373] PM: suspend entry 2016-08-28 13:31:32.780363596 UTC<6>[14201.872498] PM: Syncing filesystems ... done.</code></pre><p>中括号里的 <code>[14201.684016]</code> 代表内核开始启动后的时间，单位为秒。</p><p>通过内核日志我们可以做一些事情，比如衡量内核启动时间，在系统启动完毕后的内核日志里找到 <code>Freeing init memory</code> 那一行前面的时间就是。</p><h3 id="4-9-查看-Android-设备系统属性"><a href="#4-9-查看-Android-设备系统属性" class="headerlink" title="4.9 查看 Android 设备系统属性"></a>4.9 查看 Android 设备系统属性</h3><p>查看 Android 设备系统属性的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb shell getprop [options]</code></pre><p>除了可以查看 Android 设备系统属性之外，还可以设置系统属性，设置系统属性的基本命令格式是：</p><pre class=" language-shell"><code class="language-shell">adb shell setprop <key> <value></code></pre><h4 id="4-9-1-查看设备型号"><a href="#4-9-1-查看设备型号" class="headerlink" title="4.9.1 查看设备型号"></a>4.9.1 查看设备型号</h4><pre class=" language-shell"><code class="language-shell">adb shell getprop ro.product.model</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">Nexus 5</code></pre><h4 id="4-9-2-查看设备电池状况"><a href="#4-9-2-查看设备电池状况" class="headerlink" title="4.9.2 查看设备电池状况"></a>4.9.2 查看设备电池状况</h4><pre class=" language-shell"><code class="language-shell">adb shell dumpsys battery</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">Current Battery Service state:  AC powered: false  USB powered: true  Wireless powered: false  status: 2  health: 2  present: true  level: 44  scale: 100  voltage: 3872  temperature: 280  technology: Li-poly</code></pre><p>其中 <code>scale</code> 代表最大电量，<code>level</code> 代表当前电量。上面的输出表示还剩下 44% 的电量。</p><h4 id="4-9-3-查看设备屏幕分辨率"><a href="#4-9-3-查看设备屏幕分辨率" class="headerlink" title="4.9.3 查看设备屏幕分辨率"></a>4.9.3 查看设备屏幕分辨率</h4><pre class=" language-shell"><code class="language-shell">adb shell wm size</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">Physical size: 1080x1920</code></pre><p>该设备屏幕分辨率为 1080px * 1920px。</p><p>如果使用命令修改过，那输出可能是：</p><pre class=" language-shell"><code class="language-shell">Physical size: 1080x1920Override size: 480x1024</code></pre><p>表明设备的屏幕分辨率原本是 1080px <em> 1920px，当前被修改为 480px </em> 1024px。</p><h4 id="4-9-4-查看设备屏幕密度"><a href="#4-9-4-查看设备屏幕密度" class="headerlink" title="4.9.4 查看设备屏幕密度"></a>4.9.4 查看设备屏幕密度</h4><pre class=" language-shell"><code class="language-shell">adb shell wm density</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">Physical density: 420</code></pre><p>该设备屏幕密度为 420dpi。</p><p>如果使用命令修改过，那输出可能是：</p><pre class=" language-shell"><code class="language-shell">Physical density: 480Override density: 160</code></pre><p>表明设备的屏幕密度原来是 480dpi，当前被修改为 160dpi。</p><h4 id="4-9-5-查看设备显示屏参数"><a href="#4-9-5-查看设备显示屏参数" class="headerlink" title="4.9.5 查看设备显示屏参数"></a>4.9.5 查看设备显示屏参数</h4><pre class=" language-shell"><code class="language-shell">adb shell dumpsys window displays</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays)  Display: mDisplayId=0    init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1810x1731    deferred=false layoutNeeded=false</code></pre><p>其中 <code>mDisplayId</code> 为 显示屏编号，<code>init</code> 是初始分辨率和屏幕密度，<code>app</code> 的高度比 <code>init</code> 里的要小，表示屏幕底部有虚拟按键，高度为 1920 - 1794 = 126px 合 42dp。</p><h4 id="4-9-6-查看设备-android-id"><a href="#4-9-6-查看设备-android-id" class="headerlink" title="4.9.6 查看设备 android_id"></a>4.9.6 查看设备 android_id</h4><pre class=" language-shell"><code class="language-shell">adb shell settings get secure android_id</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">51b6be48bac8c569</code></pre><h4 id="4-9-7-查看设备IMEI"><a href="#4-9-7-查看设备IMEI" class="headerlink" title="4.9.7 查看设备IMEI"></a>4.9.7 查看设备IMEI</h4><p>在 Android 4.4 及以下版本可通过如下命令获取 IMEI：</p><pre class=" language-shell"><code class="language-shell">adb shell dumpsys iphonesubinfo</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">Phone Subscriber Info:  Phone Type = GSM  Device ID = 860955027785041</code></pre><p>其中的 <code>Device ID</code> 就是 IMEI。</p><p>而在 Android 5.0 及以上版本里这个命令输出为空，得通过其它方式获取了（需要 root 权限）：</p><pre class=" language-shell"><code class="language-shell">adb shellsuservice call iphonesubinfo 1</code></pre><p>把里面的有效内容提取出来就是 IMEI 了，比如这里的是 <code>860955027785041</code>。</p><p>参考：<a href="http://stackoverflow.com/questions/27002663/adb-shell-dumpsys-iphonesubinfo-not-working-since-android-5-0-lollipop" target="_blank" rel="noopener">adb shell dumpsys iphonesubinfo not working since Android 5.0 Lollipop</a></p><h4 id="4-9-8-查看设备-Android-系统版本"><a href="#4-9-8-查看设备-Android-系统版本" class="headerlink" title="4.9.8 查看设备 Android 系统版本"></a>4.9.8 查看设备 Android 系统版本</h4><pre class=" language-shell"><code class="language-shell">adb shell getprop ro.build.version.release</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">5.0.2</code></pre><h4 id="4-9-9-查看设备-IP-地址"><a href="#4-9-9-查看设备-IP-地址" class="headerlink" title="4.9.9 查看设备 IP 地址"></a>4.9.9 查看设备 IP 地址</h4><pre class=" language-shell"><code class="language-shell">adb shell ifconfig | grep Mask</code></pre><p>在有的设备上这个命令没有输出，如果设备连着 WiFi，可以使用如下命令来查看局域网 IP：</p><pre class=" language-shell"><code class="language-shell">adb shell ifconfig wlan0</code></pre><p>如果以上命令仍然不能得到期望的信息，那可以试试以下命令（部分系统版本里可用）：</p><pre class=" language-shell"><code class="language-shell">adb shell netcfg</code></pre><h4 id="4-9-10-查看设备-Mac-地址"><a href="#4-9-10-查看设备-Mac-地址" class="headerlink" title="4.9.10 查看设备 Mac 地址"></a>4.9.10 查看设备 Mac 地址</h4><pre class=" language-shell"><code class="language-shell">adb shell cat /sys/class/net/wlan0/address</code></pre><p>输出示例：</p><pre class=" language-shell"><code class="language-shell">f8:a9:d0:17:42:4d</code></pre><p>这查看的是局域网 Mac 地址，移动网络或其它连接的信息可以通过前面的小节「IP 地址」里提到的 <code>adb shell netcfg</code> 命令来查看。</p><h4 id="4-9-11-查看设备-CPU-信息"><a href="#4-9-11-查看设备-CPU-信息" class="headerlink" title="4.9.11 查看设备 CPU 信息"></a>4.9.11 查看设备 CPU 信息</h4><pre class=" language-shell"><code class="language-shell">adb shell cat /proc/cpuinfo</code></pre><h4 id="4-9-12-查看设备内存信息"><a href="#4-9-12-查看设备内存信息" class="headerlink" title="4.9.12 查看设备内存信息"></a>4.9.12 查看设备内存信息</h4><pre class=" language-shell"><code class="language-shell">adb shell cat /proc/meminfo</code></pre><h4 id="4-9-13-查看设备更多硬件与系统属性"><a href="#4-9-13-查看设备更多硬件与系统属性" class="headerlink" title="4.9.13 查看设备更多硬件与系统属性"></a>4.9.13 查看设备更多硬件与系统属性</h4><p>设备的更多硬件与系统属性可以通过如下命令查看：</p><pre class=" language-shell"><code class="language-shell">adb shell cat /system/build.prop</code></pre><p>这会输出很多信息，包括前面几个小节提到的「型号」和「Android 系统版本」等。</p><p>输出里还包括一些其它有用的信息，它们也可通过 <code>adb shell getprop &lt;属性名&gt;</code> 命令单独查看，列举一部分属性如下：</p><table><thead><tr><th>属性名</th><th>含义</th></tr></thead><tbody><tr><td>ro.build.version.sdk</td><td>SDK 版本</td></tr><tr><td>ro.build.version.release</td><td>Android 系统版本</td></tr><tr><td>ro.build.version.security_patch</td><td>Android 安全补丁程序级别</td></tr><tr><td>ro.product.model</td><td>型号</td></tr><tr><td>ro.product.brand</td><td>品牌</td></tr><tr><td>ro.product.name</td><td>设备名</td></tr><tr><td>ro.product.board</td><td>处理器型号</td></tr><tr><td>ro.product.cpu.abilist</td><td>CPU 支持的 abi 列表</td></tr><tr><td>persist.sys.isUsbOtgEnabled</td><td>是否支持 OTG</td></tr><tr><td>dalvik.vm.heapsize</td><td>每个应用程序的内存上限</td></tr><tr><td>ro.sf.lcd_density</td><td>屏幕密度</td></tr></tbody></table><p><em>节注一：</em></p><p>一些小厂定制的 ROM 可能修改过 CPU 支持的 abi 列表的属性名，如果用 <code>ro.product.cpu.abilist</code> 属性名查找不到，可以这样试试：</p><pre class=" language-shell"><code class="language-shell">adb shell cat /system/build.prop | grep ro.product.cpu.abi</code></pre><p>示例输出：</p><pre class=" language-shell"><code class="language-shell">ro.product.cpu.abi=armeabi-v7aro.product.cpu.abi2=armeabi</code></pre><h3 id="4-10-修改设置"><a href="#4-10-修改设置" class="headerlink" title="4.10 修改设置"></a>4.10 修改设置</h3><p><strong>注：</strong> 修改设置之后，运行恢复命令有可能显示仍然不太正常，可以运行 <code>adb reboot</code> 重启设备，或手动重启。</p><p>修改设置的原理主要是通过 settings 命令修改 /data/data/com.android.providers.settings/databases/settings.db 里存放的设置值。</p><h4 id="4-10-1-修改分辨率"><a href="#4-10-1-修改分辨率" class="headerlink" title="4.10.1 修改分辨率"></a>4.10.1 修改分辨率</h4><pre class=" language-shell"><code class="language-shell">adb shell wm size 480x1024</code></pre><p>表示将分辨率修改为 480px * 1024px。</p><p>恢复原分辨率命令：</p><pre class=" language-shell"><code class="language-shell">adb shell wm size reset</code></pre><h4 id="4-10-2-修改屏幕密度"><a href="#4-10-2-修改屏幕密度" class="headerlink" title="4.10.2 修改屏幕密度"></a>4.10.2 修改屏幕密度</h4><pre class=" language-shell"><code class="language-shell">adb shell wm density 160</code></pre><p>表示将屏幕密度修改为 160dpi。</p><p>恢复原屏幕密度命令：</p><pre class=" language-shell"><code class="language-shell">adb shell wm density reset</code></pre><h4 id="4-10-3-修改显示区域"><a href="#4-10-3-修改显示区域" class="headerlink" title="4.10.3 修改显示区域"></a>4.10.3 修改显示区域</h4><pre class=" language-shell"><code class="language-shell">adb shell wm overscan 0,0,0,200</code></pre><p>四个数字分别表示距离左、上、右、下边缘的留白像素，以上命令表示将屏幕底部 200px 留白。</p><p>恢复原显示区域命令：</p><pre class=" language-shell"><code class="language-shell">adb shell wm overscan reset</code></pre><h4 id="4-10-4-修改关闭-USB-调试模式"><a href="#4-10-4-修改关闭-USB-调试模式" class="headerlink" title="4.10.4 修改关闭 USB 调试模式"></a>4.10.4 修改关闭 USB 调试模式</h4><pre class=" language-shell"><code class="language-shell">adb shell settings put global adb_enabled 0</code></pre><p>用命令恢复不了了，毕竟关闭了 USB 调试 adb 就连接不上 Android 设备了。<br>去设备上手动恢复吧：「设置」-「开发者选项」-「Android 调试」。</p><h4 id="4-10-5-修改允许-禁止访问非-SDK-API"><a href="#4-10-5-修改允许-禁止访问非-SDK-API" class="headerlink" title="4.10.5 修改允许/禁止访问非 SDK API"></a>4.10.5 修改允许/禁止访问非 SDK API</h4><p>允许访问非 SDK API：</p><pre class=" language-shell"><code class="language-shell">adb shell settings put global hidden_api_policy_pre_p_apps 1adb shell settings put global hidden_api_policy_p_apps 1</code></pre><p>禁止访问非 SDK API：</p><pre class=" language-shell"><code class="language-shell">adb shell settings delete global hidden_api_policy_pre_p_appsadb shell settings delete global hidden_api_policy_p_apps</code></pre><p>不需要设备获得 Root 权限。</p><p>命令最后的数字的含义：</p><table><thead><tr><th>值</th><th>含义</th></tr></thead><tbody><tr><td>0</td><td>禁止检测非 SDK 接口的调用。该情况下，日志记录功能被禁用，并且令 strict mode API，即 detectNonSdkApiUsage() 无效。不推荐。</td></tr><tr><td>1</td><td>仅警告——允许访问所有非 SDK 接口，但保留日志中的警告信息，可继续使用 strick mode API。</td></tr><tr><td>2</td><td>禁止调用深灰名单和黑名单中的接口。</td></tr><tr><td>3</td><td>禁止调用黑名单中的接口，但允许调用深灰名单中的接口。</td></tr></tbody></table><h4 id="4-10-6-修改状态栏和导航栏的显示隐藏"><a href="#4-10-6-修改状态栏和导航栏的显示隐藏" class="headerlink" title="4.10.6 修改状态栏和导航栏的显示隐藏"></a>4.10.6 修改状态栏和导航栏的显示隐藏</h4><pre class=" language-shell"><code class="language-shell">adb shell settings put global policy_control <key-values></code></pre><p><code>&lt;key-values&gt;</code> 可由如下几种键及其对应的值组成，格式为 <code>&lt;key1&gt;=&lt;value1&gt;:&lt;key2&gt;=&lt;value2&gt;</code>。</p><table><thead><tr><th>key</th><th>含义</th></tr></thead><tbody><tr><td>immersive.full</td><td>同时隐藏</td></tr><tr><td>immersive.status</td><td>隐藏状态栏</td></tr><tr><td>immersive.navigation</td><td>隐藏导航栏</td></tr><tr><td>immersive.preconfirms</td><td>?</td></tr></tbody></table><p>这些键对应的值可则如下值用逗号组合：</p><table><thead><tr><th>value</th><th>含义</th></tr></thead><tbody><tr><td><code>apps</code></td><td>所有应用</td></tr><tr><td><code>*</code></td><td>所有界面</td></tr><tr><td><code>package-name</code></td><td>指定应用</td></tr><tr><td><code>-package-name</code></td><td>排除指定应用</td></tr></tbody></table><p>例如：</p><pre class=" language-shell"><code class="language-shell">adb shell settings put global policy_control immersive.full=*</code></pre><p>表示设置在所有界面下都同时隐藏状态栏和导航栏。</p><pre class=" language-shell"><code class="language-shell">adb shell settings put global policy_control immersive.status=com.package1,com.package2:immersive.navigation=apps,-com.package3</code></pre><p>表示设置在包名为 <code>com.package1</code> 和 <code>com.package2</code> 的应用里隐藏状态栏，在除了包名为 <code>com.package3</code> 的所有应用里隐藏导航栏。</p><h3 id="4-11-实用功能"><a href="#4-11-实用功能" class="headerlink" title="4.11 实用功能"></a>4.11 实用功能</h3><h4 id="4-11-1-屏幕截图"><a href="#4-11-1-屏幕截图" class="headerlink" title="4.11.1 屏幕截图"></a>4.11.1 屏幕截图</h4><p>截图保存到电脑：</p><pre class=" language-shell"><code class="language-shell">adb exec-out screencap -p > sc.png</code></pre><p>如果 adb 版本较老，无法使用 <code>exec-out</code> 命令，这时候建议更新 adb 版本。无法更新的话可以使用以下麻烦点的办法：</p><p>先截图保存到设备里：</p><pre class=" language-shell"><code class="language-shell">adb shell screencap -p /sdcard/sc.png</code></pre><p>然后将 png 文件导出到电脑：</p><pre class=" language-shell"><code class="language-shell">adb pull /sdcard/sc.png</code></pre><p>可以使用 <code>adb shell screencap -h</code> 查看 <code>screencap</code> 命令的帮助信息，下面是两个有意义的参数及含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-p</td><td>指定保存文件为 png 格式</td></tr><tr><td>-d display-id</td><td>指定截图的显示屏编号(有多显示屏的情况下)</td></tr></tbody></table><p>实测如果指定文件名以 <code>.png</code> 结尾时可以省略 -p 参数；否则需要使用 -p 参数。如果不指定文件名，截图文件的内容将直接输出到 stdout。</p><p>另外一种一行命令截图并保存到电脑的方法：<br><em>Linux 和 Windows</em></p><pre class=" language-shell"><code class="language-shell">adb shell screencap -p | sed "s/\r$//" > sc.png</code></pre><p><em>Mac OS X</em></p><pre class=" language-shell"><code class="language-shell">adb shell screencap -p | gsed "s/\r$//" > sc.png</code></pre><p>这个方法需要用到 gnu sed 命令，在 Linux 下直接就有，在 Windows 下 Git 安装目录的 bin 文件夹下也有。如果确实找不到该命令，可以下载 <a href="http://gnuwin32.sourceforge.net/packages/sed.htm" target="_blank" rel="noopener">sed for Windows</a> 并将 sed.exe 所在文件夹添加到 PATH 环境变量里。</p><p>而在 Mac 下使用系统自带的 sed 命令会报错：</p><pre class=" language-shell"><code class="language-shell">sed: RE error: illegal byte sequence</code></pre><p>需要安装 gnu-sed，然后使用 gsed 命令：</p><pre class=" language-shell"><code class="language-shell">brew install gnu-sed</code></pre><h4 id="4-11-2-录制屏幕"><a href="#4-11-2-录制屏幕" class="headerlink" title="4.11.2 录制屏幕"></a>4.11.2 录制屏幕</h4><p>录制屏幕以 mp4 格式保存到 /sdcard：</p><pre class=" language-shell"><code class="language-shell">adb shell screenrecord /sdcard/filename.mp4</code></pre><p>需要停止时按 <kbd>Ctrl-C</kbd>，默认录制时间和最长录制时间都是 180 秒。</p><p>如果需要导出到电脑：</p><pre class=" language-shell"><code class="language-shell">adb pull /sdcard/filename.mp4</code></pre><p>可以使用 <code>adb shell screenrecord --help</code> 查看 <code>screenrecord</code> 命令的帮助信息，下面是常见参数及含义：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>–size WIDTHxHEIGHT</td><td>视频的尺寸，比如 <code>1280x720</code>，默认是屏幕分辨率。</td></tr><tr><td>–bit-rate RATE</td><td>视频的比特率，默认是 4Mbps。</td></tr><tr><td>–time-limit TIME</td><td>录制时长，单位秒。</td></tr><tr><td>–verbose</td><td>输出更多信息。</td></tr></tbody></table><h4 id="4-11-3-查看连接过的-WiFi-密码"><a href="#4-11-3-查看连接过的-WiFi-密码" class="headerlink" title="4.11.3 查看连接过的 WiFi 密码"></a>4.11.3 查看连接过的 WiFi 密码</h4><p><strong>注：需要 root 权限。</strong></p><pre class=" language-shell"><code class="language-shell">adb shellsucat /data/misc/wifi/*.conf</code></pre><h4 id="4-11-4-设置系统日期和时间"><a href="#4-11-4-设置系统日期和时间" class="headerlink" title="4.11.4 设置系统日期和时间"></a>4.11.4 设置系统日期和时间</h4><p><strong>注：需要 root 权限。</strong></p><pre class=" language-shell"><code class="language-shell">adb shellsudate -s 20160823.131500</code></pre><p>表示将系统日期和时间更改为 2016 年 08 月 23 日 13 点 15 分 00 秒。</p><h4 id="4-11-5-重启手机"><a href="#4-11-5-重启手机" class="headerlink" title="4.11.5 重启手机"></a>4.11.5 重启手机</h4><pre class=" language-shell"><code class="language-shell">adb reboot</code></pre><h4 id="4-11-6-检测设备是否已-root"><a href="#4-11-6-检测设备是否已-root" class="headerlink" title="4.11.6 检测设备是否已 root"></a>4.11.6 检测设备是否已 root</h4><pre class=" language-shell"><code class="language-shell">adb shellsu</code></pre><p>此时命令行提示符是 <code>$</code> 则表示没有 root 权限，是 <code>#</code> 则表示已 root。</p><h4 id="4-11-7-使用-Monkey-进行压力测试"><a href="#4-11-7-使用-Monkey-进行压力测试" class="headerlink" title="4.11.7 使用 Monkey 进行压力测试"></a>4.11.7 使用 Monkey 进行压力测试</h4><p>Monkey 可以生成伪随机用户事件来模拟单击、触摸、手势等操作，可以对正在开发中的程序进行随机压力测试。</p><p>简单用法：</p><pre class=" language-shell"><code class="language-shell">adb shell monkey -p <packagename> -v 500</code></pre><p>表示向 <code>&lt;packagename&gt;</code> 指定的应用程序发送 500 个伪随机事件。<br>Monkey 的详细用法参考 <a href="https://developer.android.com/studio/test/monkey.html" target="_blank" rel="noopener">官方文档</a>。</p><h4 id="4-11-8-开启-关闭-WiFi"><a href="#4-11-8-开启-关闭-WiFi" class="headerlink" title="4.11.8 开启/关闭 WiFi"></a>4.11.8 开启/关闭 WiFi</h4><p><strong>注：需要 root 权限。</strong></p><ul><li><p>开启 WiFi：</p><pre class=" language-shell"><code class="language-shell">adb rootadb shell svc wifi enable</code></pre></li><li><p>关闭 WiFi：</p><pre class=" language-shell"><code class="language-shell">adb rootadb shell svc wifi disable</code></pre><p>若执行成功，输出为空；若未取得 root 权限执行此命令，将执行失败，输出 <code>Killed</code>。</p></li></ul><h3 id="4-12-刷机相关命令"><a href="#4-12-刷机相关命令" class="headerlink" title="4.12 刷机相关命令"></a>4.12 刷机相关命令</h3><h4 id="4-12-1-重启到-Recovery-模式"><a href="#4-12-1-重启到-Recovery-模式" class="headerlink" title="4.12.1 重启到 Recovery 模式"></a>4.12.1 重启到 Recovery 模式</h4><pre class=" language-shell"><code class="language-shell">adb reboot recovery</code></pre><h4 id="4-12-2-从-Recovery-重启到-Android"><a href="#4-12-2-从-Recovery-重启到-Android" class="headerlink" title="4.12.2 从 Recovery 重启到 Android"></a>4.12.2 从 Recovery 重启到 Android</h4><pre class=" language-shell"><code class="language-shell">adb reboot</code></pre><h4 id="4-12-2-重启到-Fastboot-模式"><a href="#4-12-2-重启到-Fastboot-模式" class="headerlink" title="4.12.2 重启到 Fastboot 模式"></a>4.12.2 重启到 Fastboot 模式</h4><pre class=" language-shell"><code class="language-shell">adb reboot bootloader</code></pre><h4 id="4-12-4-通过-sideload-更新系统"><a href="#4-12-4-通过-sideload-更新系统" class="headerlink" title="4.12.4 通过 sideload 更新系统"></a>4.12.4 通过 sideload 更新系统</h4><p>如果我们下载了 Android 设备对应的系统更新包到电脑上，那么也可以通过 adb 来完成更新。</p><p>以 Recovery 模式下更新为例：</p><ol><li><p>重启到 Recovery 模式。</p><pre class=" language-shell"><code class="language-shell">adb reboot recovery</code></pre></li><li><p>在设备的 Recovery 界面上操作进入 <code>Apply update</code>-<code>Apply from ADB</code>。<br>注：不同的 Recovery 菜单可能与此有差异，有的是一级菜单就有 <code>Apply update from ADB</code>。</p></li><li><p>通过 adb 上传和更新系统。</p><pre class=" language-shell"><code class="language-shell">adb sideload <path-to-update.zip></code></pre></li></ol><h3 id="4-13-安全相关命令"><a href="#4-13-安全相关命令" class="headerlink" title="4.13 安全相关命令"></a>4.13 安全相关命令</h3><h4 id="4-13-1-启用-禁用-SELinux"><a href="#4-13-1-启用-禁用-SELinux" class="headerlink" title="4.13.1 启用/禁用 SELinux"></a>4.13.1 启用/禁用 SELinux</h4><p>启用 SELinux</p><pre class=" language-shell"><code class="language-shell">adb rootadb shell setenforce 1</code></pre><p>禁用 SELinux</p><pre class=" language-shell"><code class="language-shell">adb rootadb shell setenforce 0</code></pre><h4 id="4-13-2-启用-禁用-dm-verity"><a href="#4-13-2-启用-禁用-dm-verity" class="headerlink" title="4.13.2 启用/禁用 dm_verity"></a>4.13.2 启用/禁用 dm_verity</h4><p>启用 dm_verity</p><pre class=" language-shell"><code class="language-shell">adb rootadb enable-verity</code></pre><p>禁用 dm_verity</p><pre class=" language-shell"><code class="language-shell">adb rootadb disable-verity</code></pre><h3 id="4-14-更多-adb-shell-命令"><a href="#4-14-更多-adb-shell-命令" class="headerlink" title="4.14 更多 adb shell 命令"></a>4.14 更多 adb shell 命令</h3><p>Android 系统是基于 Linux 内核的，所以 Linux 里的很多命令在 Android 里也有相同或类似的实现，在 <code>adb shell</code> 里可以调用。本文档前面的部分内容已经用到了 <code>adb shell</code> 命令。</p><h4 id="4-14-1-查看进程状态"><a href="#4-14-1-查看进程状态" class="headerlink" title="4.14.1 查看进程状态"></a>4.14.1 查看进程状态</h4><pre class=" language-shell"><code class="language-shell">adb shell ps</code></pre><p>输出信息各列含义：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>USER</td><td>所属用户</td></tr><tr><td>PID</td><td>进程 ID</td></tr><tr><td>PPID</td><td>父进程 ID</td></tr><tr><td>NAME</td><td>进程名</td></tr></tbody></table><h4 id="4-14-2-查看处理器实时状态"><a href="#4-14-2-查看处理器实时状态" class="headerlink" title="4.14.2 查看处理器实时状态"></a>4.14.2 查看处理器实时状态</h4><pre class=" language-shell"><code class="language-shell">adb shell top [-m max_procs] [-n iterations] [-d delay] [-s sort_column] [-t] [-h]</code></pre><p><code>adb shell top</code> 后面可以跟一些可选参数进行过滤查看不同的列表，可用参数及含义如下：</p><table><thead><tr><th>参数</th><th>含义</th></tr></thead><tbody><tr><td>-m</td><td>最多显示多少个进程</td></tr><tr><td>-n</td><td>刷新多少次后退出</td></tr><tr><td>-d</td><td>刷新时间间隔(单位秒，默认值5)</td></tr><tr><td>-s</td><td>按某列排序(可用col值：cpu, vss, rss, thr)</td></tr><tr><td>-t</td><td>显示线程信息</td></tr><tr><td>-h</td><td>显示帮助文档</td></tr></tbody></table><p>输出信息各列含义：</p><table><thead><tr><th>列名</th><th>含义</th></tr></thead><tbody><tr><td>PID</td><td>进程 ID</td></tr><tr><td>PR</td><td>优先级</td></tr><tr><td>CPU%</td><td>当前瞬间占用 CPU 百分比</td></tr><tr><td>S</td><td>进程状态（R=运行，S=睡眠，T=跟踪/停止，Z=僵尸进程）</td></tr><tr><td>#THR</td><td>线程数</td></tr><tr><td>VSS</td><td>Virtual Set Size 虚拟耗用内存（包含共享库占用的内存）</td></tr><tr><td>RSS</td><td>Resident Set Size 实际使用物理内存（包含共享库占用的内存）</td></tr><tr><td>PCY</td><td>调度策略优先级，SP_BACKGROUND/SPFOREGROUND</td></tr><tr><td>UID</td><td>进程所有者的用户 ID</td></tr><tr><td>NAME</td><td>进程名</td></tr></tbody></table><h4 id="4-14-3-查看进程-UID"><a href="#4-14-3-查看进程-UID" class="headerlink" title="4.14.3 查看进程 UID"></a>4.14.3 查看进程 UID</h4><p>有两种方案：</p><ol><li><p><code>adb shell dumpsys package &lt;packagename&gt; | grep userId=</code><br>如：</p><pre class=" language-shell"><code class="language-shell">adb shell dumpsys package org.mazhuang.guanggoo | grep userId=userId=10394</code></pre></li><li><p>通过 ps 命令找到对应进程的 pid 之后 <code>adb shell cat /proc/&lt;pid&gt;/status | grep Uid</code><br>如：</p><pre class=" language-shell"><code class="language-shell">adb shellgemini:/ $ ps | grep org.mazhuang.guanggoou0_a394   28635 770   1795812 78736 SyS_epoll_ 0000000000 S org.mazhuang.guanggoogemini:/ $ cat /proc/28635/status | grep UidUid:    10394   10394   10394   10394gemini:/ $</code></pre></li></ol><h2 id="五、致谢"><a href="#五、致谢" class="headerlink" title="五、致谢"></a>五、致谢</h2><ol><li><a href="http://adbshell.com/" target="_blank" rel="noopener">ADB Shell</a></li><li><a href="https://github.com/mzlogin/awesome-adb" target="_blank" rel="noopener">Awesome Adb</a></li><li><a href="https://developer.android.com/studio/command-line/adb" target="_blank" rel="noopener">Android Debug Bridge</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 工具 </tag>
            
            <tag> ADB </tag>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 内存分配和内存泄漏</title>
      <link href="/posts/2018/20774213.html"/>
      <url>/posts/2018/20774213.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-内存分配"><a href="#1-内存分配" class="headerlink" title="1. 内存分配"></a>1. 内存分配</h2><p><code>Java 虚拟机</code>在执行 <code>Java</code> 程序的过程中会把它所管理的内存划分为若干个不同的数据区域。这些区域都有各自的用途、创建和销毁的时间，有一些是随虚拟机的启动而创建，随虚拟机的退出而销毁，有些则是与线程一一对应，随线程的开始和结束而创建和销毁。</p><p><code>Java 虚拟机</code>所管理的内存将会包括以下几个运行时数据区域，如下图（图片来自网络）：<br><img src="https://user-gold-cdn.xitu.io/2018/8/2/164f93ea24c894a0" alt="Java 虚拟机内存区域"></p><h3 id="1-1-程序计数器（Program-Counter-Register）"><a href="#1-1-程序计数器（Program-Counter-Register）" class="headerlink" title="1.1 程序计数器（Program Counter Register）"></a>1.1 程序计数器（Program Counter Register）</h3><p>程序计数器是一块较小的内存空间，它的作用可以看做是当前线程所执行的字节码的信号指示器。字节码解释器就是通过改变该计数器的值来选取下一条需要执行的字节码指令，分支、循环、跳转、异常处理、线程恢复等基础功能都需依赖计数器来完成。</p><p>每一个JVM线程都有独立的程序计数器，各线程间的计数器互不影响，独立存储，确保线程切换后能够恢复到正确的执行位置。</p><p>在任意时刻，一条JVM线程只会执行一个方法的代码。该方法称为该线程的当前方法（Current Method），如果该方法是Java方法，那计数器保存JVM正在执行的字节码指令的地址；如果该方法是Native，那PC寄存器的值为空（Undefined）。</p><p>此内存区域是唯一一个在Java虚拟机规范中没有规定任何OutOfMemoryError情况的区域。</p><h3 id="1-2-Java虚拟机栈（Java-Virtual-Machine-Stack）"><a href="#1-2-Java虚拟机栈（Java-Virtual-Machine-Stack）" class="headerlink" title="1.2 Java虚拟机栈（Java Virtual Machine Stack）"></a>1.2 Java虚拟机栈（Java Virtual Machine Stack）</h3><p>Java虚拟机栈与程序计数器一样，也是线程私有的，其生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法被执行的时候都会同时创建一个栈帧（Stack Frame）用于存储局部变量表、操作数栈、动态链接、方法出口等信息。每一个方法被调用直至执行完成的过程就对应着一个栈帧在虚拟机栈中从入栈到出栈的过程。</p><p>局部变量表存放了编译期可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型）和returnAddress类型（指向了一条字节码指令的地址）。其中64位长度的long和double会占用2个局部变量空间（Slot），其余数据类型只占用1个。局部变量表所需的空间在编译期间完成分配，当进入一个方法时，其需要在帧中分配多大的局部变量空间是确定的，方法运行期间不会改变局部变量表的大小。</p><p>Java虚拟机规范中对该区域规定了两种异常情况：</p><ul><li>如线程请求的深度大于虚拟机所允许的深度，抛出StackOverflowError异常。</li><li>虚拟机栈动态扩展无法申请到足够的内存时，抛出OutOfMemoryError异常。</li></ul><h3 id="1-3-本地方法栈（Native-Method-Stack）"><a href="#1-3-本地方法栈（Native-Method-Stack）" class="headerlink" title="1.3 本地方法栈（Native Method Stack）"></a>1.3 本地方法栈（Native Method Stack）</h3><p>Java虚拟机可能会使用到传统的栈来支持native方法（使用Java语言以外的其它语言编写的方法）的执行，这个栈就是本地方法栈（Native Method Stack）。本地方法栈与虚拟机栈非常类似，区别是虚拟机栈为虚拟机执行Java方法（也就是字节码）服务，二本地方法栈则为虚拟机使用到的Native方法服务。虚拟机规范对本地方法栈中的方法是用语言、使用方式与数据结构没强制规定，因此虚拟机可以自由实现，如Sun HotSpot虚拟机直接把本地方法栈和虚拟机栈合二为一。</p><p>Java虚拟机规范中对该区域规定了两种异常情况：</p><ul><li>如线程请求的深度大于虚拟机所允许的深度，抛出StackOverflowError异常。</li><li>虚拟机栈动态扩展无法申请到足够的内存时，抛出OutOfMemoryError异常。</li></ul><h3 id="1-4-Java堆（Java-Heap）"><a href="#1-4-Java堆（Java-Heap）" class="headerlink" title="1.4 Java堆（Java Heap）"></a>1.4 Java堆（Java Heap）</h3><p>Java堆是Java虚拟机管理内存中最大的一块，是所有线程共享的内存区域，随虚拟机的启动而创建。该区域唯一目的是存放对象实例，几乎所有对象的实例都在堆里面分配。Java堆是垃圾收集器管理的主要区域，被称作“GC堆”。</p><p>Java虚拟机规范规定，Java堆可以出于物理上物理上不连续的内存空间中，只要逻辑上连续即可，如同磁盘空间一样，既可以实现成固定大小，也可以是扩展的，当前主流虚拟机都是按照扩展来实现的（通过-Xmx和-Xms控制）。</p><p>Java虚拟机规范中对该区域规定了OutOfMemoryError异常：如果堆中没有内存完成实例分配，并且堆无法再扩展则抛出OutOfMemoryError异常。</p><h3 id="1-5-方法区（Method-Area）"><a href="#1-5-方法区（Method-Area）" class="headerlink" title="1.5 方法区（Method Area）"></a>1.5 方法区（Method Area）</h3><p>方法区与Java堆一样，是各个线程共享的内存区域，用于存储一杯虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。Java虚拟机对这个区域的限制非常宽松，处理和Java对一样不需要连续的内存和可以选择固定大小或者可扩展外，还可以选择不实现垃圾收集。</p><p>Java虚拟机规范中对该区域规定了OutOfMemoryError异常： 如果方法区的内存空间不能满足内存分配请求，那Java虚拟机将抛出一个OutOfMemoryError异常。</p><h3 id="1-6-运行时常量池（Runtime-Constant-Pool）"><a href="#1-6-运行时常量池（Runtime-Constant-Pool）" class="headerlink" title="1.6 运行时常量池（Runtime Constant Pool）"></a>1.6 运行时常量池（Runtime Constant Pool）</h3><p>运行时常量池是方法区的一部分。Class文件中除了有类的版本、字段、方法、接口等信息外，还有一项信息是常量池，用于存放编译期生成的各种字面常量和符号引用，这部分内容在类加载后存放到方法区的常量池中。</p><p>Java虚拟机规范中对该区域规定了OutOfMemoryError异常： 当常量池无法申请到内存时抛出OutOfMemoryError异常。</p><h3 id="1-7-直接内存（Direct-Memory）"><a href="#1-7-直接内存（Direct-Memory）" class="headerlink" title="1.7 直接内存（Direct Memory）"></a>1.7 直接内存（Direct Memory）</h3><p>直接内存并不是虚拟机运行时数据区域的一部分，也不是Java虚拟规范中定义的内存区域，但这部分内存也被频繁使用，并且可能导致OutOfMemoryError异常出现。<br>Java虚拟机需要根据实际内存的大小来设置-Xmx等参数信息，如果忽略了直接内存，使得各个内存区域的总和大于物理内存限制，从而导致动态扩展时抛出OutOfMemoryError异常。</p><h2 id="2-内存优化"><a href="#2-内存优化" class="headerlink" title="2. 内存优化"></a>2. 内存优化</h2><p>内存优化的目的就是让我们在开发中有效的避免应用出现内存泄漏的问题。内存泄漏大家都不陌生了，简单粗俗的讲，就是该被释放的对象没有释放，一直被某个或某些实例所持有却不再被使用导致 GC 不能回收。</p><p>像 Java 这样具有垃圾回收功能的语言的好处之一，就是程序员无需手动管理内存分配。这减少了段错误（Segmentation fault，即访问的内存超出了系统所给这个程序的内存空间）导致的闪退，也减少了内存泄漏导致的堆空间膨胀，让编写的代码更加安全。然而，Java中依然有可能发生内存泄漏。所以你的 APP 依然有可能浪费了大量的内存，甚至由于内存耗尽（OOM）导致闪退，内存优化也就至关重要。</p><h2 id="3-内存泄漏"><a href="#3-内存泄漏" class="headerlink" title="3. 内存泄漏"></a>3. 内存泄漏</h2><p>传统的内存泄漏是由忘记释放分配的内存导致的，而逻辑上的内存泄漏则是由于忘记在对象不再被使用的时候释放对其的引用导致的。如果一个对象仍然存在强引用，垃圾回收器就无法对其进行垃圾回收。</p><p>Android程序开发中，如果一个对象已经不需要被使用了，本该被回收时，而这时另一个对象还在持有对该对象的引用，这样就会导致无法被GC回收，就会出现内存泄漏的情况。内存泄漏时Android程序中出现OOM问题的主要原因之一。所以我们在编写代码时，一定要细心处理好这一类的问题。下面介绍一下Android开发中最常见的内存泄漏问题：</p><h3 id="3-1-单例设计模式导致内存泄漏"><a href="#3-1-单例设计模式导致内存泄漏" class="headerlink" title="3.1 单例设计模式导致内存泄漏"></a>3.1 单例设计模式导致内存泄漏</h3><p>单例设计模式的静态特性会使他的生命周期和应用程序的生命周期一样长，这就说明了如果一个对象不在使用了，而这时单例对象还在持有该对象的引用，这时GC就会无法回收该对象，造成了内存泄露的情况。</p><p>下面是错误的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppManager</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> AppManager sInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> Context context<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token function">AppManager</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>context <span class="token operator">=</span> context<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> AppManager <span class="token function">getInstance</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>sInstance <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AppManager</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> sInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><p>这是一个普通的单例模式，当创建这个单例的时候，由于需要传入一个 <code>Context</code> ，所以这个 <code>Context</code> 的生命周期的长短至关重要：</p><ul><li>如果此时传入的是 <code>Application</code> 的 Context，因为 Application 的生命周期就是整个应用的生命周期，所以这将没有任何问题。</li><li>如果此时传入的是 <code>Activity</code> 的 Context，当这个 Context 所对应的 Activity 退出时，由于该 Context 的引用被单例对象所持有，其生命周期等于整个应用程序的生命周期，所以当前 Activity 退出时它的内存并不会被回收，这就造成泄漏了。</li></ul><p>解决方案：可以通过 <code>this.context = context.getApplicationContext()</code> 获取 <code>Application</code> 的 <code>Context</code>，这样就不会造成内存泄漏了。</p><h3 id="3-2-非静态内部类-匿名内部类导致内存泄漏"><a href="#3-2-非静态内部类-匿名内部类导致内存泄漏" class="headerlink" title="3.2 非静态内部类/匿名内部类导致内存泄漏"></a>3.2 非静态内部类/匿名内部类导致内存泄漏</h3><p>在 Java 中，非静态内部类和匿名内部类都会隐式的持有外部类的引用，而且它们的生命周期甚至比外部类更长，这便埋下了内存泄露的隐患。</p><p>下面是错误的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Outer</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> outerValue <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">class</span> <span class="token class-name">Inner</span> <span class="token punctuation">{</span>        <span class="token keyword">void</span> <span class="token function">innerMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> innerValue <span class="token operator">=</span> outerValue<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解决方案：尽量使用静态内部类来替代内部类。</p><h3 id="3-3-Thread-AsyncTask导致内存泄漏"><a href="#3-3-Thread-AsyncTask导致内存泄漏" class="headerlink" title="3.3 Thread/AsyncTask导致内存泄漏"></a>3.3 Thread/AsyncTask导致内存泄漏</h3><p>直接创建一个Thread/AsyncTask对象执行耗时任务，这种方式新建的子线程Thread和AsyncTask都是匿名内部类对象，默认就隐式的持有外部 Activity 的引用，外部 Activity 销毁时耗时任务如果还没有执行完毕，Activity 实例不会被销毁了，于是导致内存泄漏。</p><p>下面是错误的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// 模拟耗时操作</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    Thread<span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解决方案：尽量使用静态内部类来替代内部类，同时避免让长期运行的任务（ 线程 ）持有 <code>Activity</code> 的引用。</p><h3 id="3-4-Timer和TimerTask导致内存泄露"><a href="#3-4-Timer和TimerTask导致内存泄露" class="headerlink" title="3.4 Timer和TimerTask导致内存泄露"></a>3.4 Timer和TimerTask导致内存泄露</h3><p>Timer和 TimerTask 在Android中通常会被用来做一些计时或循环任务，当 Activity 销毁时，有可能 Timer 还在继续等待执行 TimerTask，它持有 Activity 的引用不能被回收：</p><p>下面是错误的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">executeTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        Timer timer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Timer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        timer<span class="token punctuation">.</span><span class="token function">schedule</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// do something ...</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解决方案：Activity 销毁的时候要立即 cancel 掉 Timer 和 TimerTask，以避免发生内存泄漏。</p><h3 id="3-5-Handler-造成的内存泄漏"><a href="#3-5-Handler-造成的内存泄漏" class="headerlink" title="3.5 Handler 造成的内存泄漏"></a>3.5 Handler 造成的内存泄漏</h3><p>定义匿名的 Handler ，用匿名类 Handler 执行匿名的 Runnable。Runnable 内部类会持有外部类的隐式强引用，被传递到 Handler 的消息队列 MessageQueue 中，在 Message 消息没有被处理之前， Activity 实例不会被销毁了，于是导致内存泄漏。</p><p>下面是错误的示例：</p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> Handler mHandler <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Handler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">handleMessage</span><span class="token punctuation">(</span>Message msg<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">handleMessage</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// do something ...</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler<span class="token punctuation">.</span><span class="token function">postDelayed</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Runnable</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// do something ...</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        mHandler<span class="token punctuation">.</span><span class="token function">sendMessageDelayed</span><span class="token punctuation">(</span>Message<span class="token punctuation">.</span><span class="token function">obtain</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解决方案：采用静态内部类来替代非静态内部类，并且使用 <code>WeakReference</code> 来引用外部类对象，如果对象只存在弱引用的话，GC 是会回收这部分内存的。</p><h3 id="3-6-静态变量导致内存泄露"><a href="#3-6-静态变量导致内存泄露" class="headerlink" title="3.6 静态变量导致内存泄露"></a>3.6 静态变量导致内存泄露</h3><p>有的时候我们可能会在启动频繁的Activity中，为了避免重复创建相同的数据资源，或者为了使某个变量在别的类中也可以使用，可能会出现这种写法： </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> Context mContext<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> AppInfo mAppInfo<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        mContext <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mAppInfo <span class="token operator">==</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>            mAppInfo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AppInfo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> <span class="token keyword">class</span> <span class="token class-name">AppInfo</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">// ...</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span></code></pre><p>解决方案：尽量少地使用静态持有的变量，在适当的时候讲静态量重置为null，使其不再持有引用，这样也可以避免内存泄露。</p><h3 id="3-7-未取消注册或回调导致内存泄露"><a href="#3-7-未取消注册或回调导致内存泄露" class="headerlink" title="3.7 未取消注册或回调导致内存泄露"></a>3.7 未取消注册或回调导致内存泄露</h3><p>在开发中我们可能需要使用到 <code>BroadcastReceiver</code> 或 <code>EventBus</code>，如果注册了之后，在 <code>Activity/Fragment</code> 销毁时没有反注册，<code>Activity/Fragment</code> 实例不会被销毁了，于是导致内存泄漏。： </p><pre class=" language-java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MainActivity</span> <span class="token keyword">extends</span> <span class="token class-name">AppCompatActivity</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">onCreate</span><span class="token punctuation">(</span><span class="token annotation punctuation">@Nullable</span> Bundle savedInstanceState<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">onCreate</span><span class="token punctuation">(</span>savedInstanceState<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">setContentView</span><span class="token punctuation">(</span>R<span class="token punctuation">.</span>layout<span class="token punctuation">.</span>activity_main<span class="token punctuation">)</span><span class="token punctuation">;</span>        IntentFilter intentFilter <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">IntentFilter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        intentFilter<span class="token punctuation">.</span><span class="token function">addAction</span><span class="token punctuation">(</span>ConnectivityManager<span class="token punctuation">.</span>CONNECTIVITY_ACTION<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">registerReceiver</span><span class="token punctuation">(</span>mReceiver<span class="token punctuation">,</span> intentFilter<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">private</span> BroadcastReceiver mReceiver <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">BroadcastReceiver</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Override</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">onReceive</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> Intent intent<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>ConnectivityManager<span class="token punctuation">.</span>CONNECTIVITY_ACTION<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>intent<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment" spellcheck="true">// do something ...</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>解决方案：在使用<code>BroadcastReceiver</code> 或 <code>EventBus</code>时，一定要及得在<code>Activity/Fragment</code> 被销毁时发注册。</p><h3 id="3-7-集合中的对象未清理导致内存泄露"><a href="#3-7-集合中的对象未清理导致内存泄露" class="headerlink" title="3.7 集合中的对象未清理导致内存泄露"></a>3.7 集合中的对象未清理导致内存泄露</h3><p>如果一个对象放入到 <code>ArrayList</code>、<code>HashSet</code> 等集合中，这个集合就会持有该对象的引用。当我们不再需要这个对象时，也并没有将它从集合中移除，这样只要集合还在使用（而此对象已经无用了），这个对象就造成了内存泄露。并且如果集合被静态引用的话，集合里面那些没有用的对象就会造成内存泄。</p><p>解决方案：在使用集合时要及时将不用的对象从集合 remove，或者 clear 集合，从而避免内存泄露。</p><h3 id="3-8-资源未关闭或释放导致内存泄露"><a href="#3-8-资源未关闭或释放导致内存泄露" class="headerlink" title="3.8 资源未关闭或释放导致内存泄露"></a>3.8 资源未关闭或释放导致内存泄露</h3><p>在使用<code>IO流</code>、<code>File</code> 流或者 <code>Sqlite</code>、<code>Cursor</code> 等资源时要及时关闭。这些资源在进行读写操作时通常都使用了缓冲，如果及时不关闭，这些缓冲对象就会一直被占用而得不到释放，以致发生内存泄露。</p><p>解决方案：在不需要使用<code>IO流</code>、<code>File</code> 流或者 <code>Sqlite</code>、<code>Cursor</code> 等资源时要及时关闭，以便缓冲能及时得到释放，从而避免内存泄露。</p><h3 id="3-9-WebView-导致内存泄露"><a href="#3-9-WebView-导致内存泄露" class="headerlink" title="3.9 WebView 导致内存泄露"></a>3.9 WebView 导致内存泄露</h3><p>Android 混合开发时经常用到 <code>WebView</code> 加载 <code>html</code> 等页面，而 <code>WebView</code> 的内存泄漏就是最经常遇到的问题，尤其是当项目中需要用 <code>WebView</code>加载的页面比较多时。</p><p>解决方案：</p><ul><li>通过 <code>WebView webView = new WebView(getApplicationContext())</code> 动态创建 <code>WebView</code> 代替在 <code>xml</code> 中定义。</li><li>页面销毁时先将 <code>WebView</code> 从父容器中移除，然后再销毁 <code>WebView</code> 。<pre class=" language-java"><code class="language-java"> <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">destroyWebView</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>webView <span class="token operator">!=</span> null<span class="token punctuation">)</span> <span class="token punctuation">{</span>         ViewParent parent <span class="token operator">=</span> webView<span class="token punctuation">.</span><span class="token function">getParent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>parent <span class="token operator">!=</span> null <span class="token operator">&amp;&amp;</span> parent <span class="token keyword">instanceof</span> <span class="token class-name">ViewGroup</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token punctuation">(</span><span class="token punctuation">(</span>ViewGroup<span class="token punctuation">)</span> parent<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">removeView</span><span class="token punctuation">(</span>webView<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>         webView<span class="token punctuation">.</span><span class="token function">stopLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token comment" spellcheck="true">// 停止加载</span>         webView<span class="token punctuation">.</span><span class="token function">clearMatches</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 清除创建的高亮显示文本匹配</span>         webView<span class="token punctuation">.</span><span class="token function">clearHistory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token comment" spellcheck="true">// 清除历史记录</span>         webView<span class="token punctuation">.</span><span class="token function">clearFormData</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment" spellcheck="true">// 清除表单数据</span>         webView<span class="token punctuation">.</span><span class="token function">clearAnimation</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 取消视图动画</span>         webView<span class="token punctuation">.</span><span class="token function">removeAllViews</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token comment" spellcheck="true">// 移除子视图</span>         webView<span class="token punctuation">.</span><span class="token function">destroy</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment" spellcheck="true">// 销毁WebView</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span></code></pre></li></ul><h2 id="4-内存泄漏检测"><a href="#4-内存泄漏检测" class="headerlink" title="4. 内存泄漏检测"></a>4. 内存泄漏检测</h2><h3 id="4-1-Android-Profiler"><a href="#4-1-Android-Profiler" class="headerlink" title="4.1 Android Profiler"></a>4.1 Android Profiler</h3><p><code>Android Studio 3.0</code> 采用全新的 <code>Android Profiler</code> 窗口取代 <code>Android Monitor</code> 工具。 这些全新的分析工具能够提供关于应用 <code>CPU</code>、<code>内存</code>和<code>网络</code> Activity 的实时数据。<a href="https://developer.android.google.cn/studio/profile/android-profiler" target="_blank" rel="noopener">参考</a></p><h3 id="4-2-Android-Lint"><a href="#4-2-Android-Lint" class="headerlink" title="4.2 Android Lint"></a>4.2 Android Lint</h3><p><code>Android Studio</code> 提供一个名为 <code>Lint</code> 的代码扫描工具，可帮助您发现并纠正代码结构质量的问题，而无需实际执行该应用，也不必编写测试用例。该工具会报告其检测到的每个问题并提供该问题的描述消息和严重级别，以便您可以快速确定需要优先进行哪些关键改进。此外，您可以调低问题的严重级别，忽略与项目无关的问题，也可以调高严重级别，以突出特定问题。<a href="https://developer.android.google.cn/studio/write/lint" target="_blank" rel="noopener">参考</a></p><h3 id="4-3-StrictMode"><a href="#4-3-StrictMode" class="headerlink" title="4.3 StrictMode"></a>4.3 StrictMode</h3><p><code>StrictMode</code> 是 Android 系统提供的 <code>API</code> ，在开发环境下引入可以更早的暴露发现问题，能够动态的检测内存泄露。<a href="https://developer.android.google.cn/reference/android/os/StrictMode" target="_blank" rel="noopener">参考</a></p><h3 id="4-4-LeakCanary"><a href="#4-4-LeakCanary" class="headerlink" title="4.4 LeakCanary"></a>4.4 LeakCanary</h3><p><code>LeakCanary</code> 是 Android 查找内存泄漏的主要工具，由 Square 公司开发，可以直接在手机端查看内存泄露的工具。<a href="https://github.com/square/leakcanary" target="_blank" rel="noopener">参考</a></p><h2 id="5-参考"><a href="#5-参考" class="headerlink" title="5. 参考"></a>5. 参考</h2><ol><li><a href="https://blog.csdn.net/nms312/article/details/37361121" target="_blank" rel="noopener">Java虚拟机运行时数据区域</a></li><li><a href="https://www.jianshu.com/p/ab4a7e353076" target="_blank" rel="noopener">Android内存优化——常见内存泄露及优化方案</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 中的窗口坐标体系和屏幕的触控事件</title>
      <link href="/posts/2018/74e7e0b3.html"/>
      <url>/posts/2018/74e7e0b3.html</url>
      
        <content type="html"><![CDATA[<h2 id="Android坐标系"><a href="#Android坐标系" class="headerlink" title="Android坐标系"></a>Android坐标系</h2><p>在物理学中，要描述一个物体的运动，就必须选定一个参考系。所谓滑动，正是相对于参考系的运动。<br>在 Android 中，将屏幕最左上角的顶点作为 Android 坐标系的原点，从这个点向右是 X 轴正方向，从这个点向下是 Y 轴的正方向，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ab1ab97865a55?w=439&amp;h=447&amp;f=png&amp;s=3300" alt="Android坐标系"></p><p>系统提供了 <code>getLocationOnScreen(int location[])</code> 这样的方法来获取 Android 坐标系中点的位置，即该视图左上角在 Android 坐标系的坐标。<br>另外，在触控事件中使用 <code>getRawX()</code>、<code>getRawY()</code> 方法所获得的坐标同样是 Android 坐标系中的坐标。</p><h2 id="视图坐标系"><a href="#视图坐标系" class="headerlink" title="视图坐标系"></a>视图坐标系</h2><p>Android 中除了上面所说的这种坐标系之外，还有一个视图坐标系，它描述了子视图在父视图中的位置关系。<br>这两种坐标系并不矛盾也不复杂，他们的作用是相辅相成的。与 Android 坐标系类似，视图坐标系同样是以原点向右为 X 轴正方向，以原点向下为 Y 轴正方向，<br>只不过在视图坐标系中，原点不再是 Android 坐标系中的屏幕最左上角，而是以父视图左上角为坐标原点，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ab1c1d333de4b?w=426&amp;h=461&amp;f=png&amp;s=3554" alt="视图坐标系"></p><p>在触控事件中，通过 <code>getX()</code>、<code>getY()</code> 所获得的坐标就是视图坐标系中的坐标。</p><h2 id="触控事件——MotionEvent"><a href="#触控事件——MotionEvent" class="headerlink" title="触控事件——MotionEvent"></a>触控事件——MotionEvent</h2><p>触控事件 MotionEvent 在用户交互中，站着举足轻重的地位，学好触控事件是掌握后序内容的基础。<br>首先，来看看 MotionEvent 中封装的一些常用的事件常量，它定义了触控事件的不同类型。</p><pre class=" language-java"><code class="language-java"><span class="token comment" spellcheck="true">// 单点触摸按下动作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ACTION_DOWN             <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 单点触摸离开动作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ACTION_UP               <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 触摸点移动动作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ACTION_MOVE             <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 触摸动作取消</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ACTION_CANCEL           <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 触摸动作超出边界</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ACTION_OUTSIDE          <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 多点触摸按下动作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ACTION_POINTER_DOWN     <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 多点离开动作</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> ACTION_POINTER_UP       <span class="token operator">=</span> <span class="token number">6</span><span class="token punctuation">;</span> </code></pre><p>通常情况下，我们会在 <code>onTouchEvent(MotionEvent event)</code> 方法中通过 <code>event.getAction()</code> 方法来获取触控事件的类型，并使用 <code>switch-case</code> 方法来进行筛选，这个代码的模式基本固定，如下所示：</p><pre class=" language-java"><code class="language-java"><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">onTouchEvent</span><span class="token punctuation">(</span>MotionEvent event<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment" spellcheck="true">// 获取当前输入点的X、Y坐标(视图坐标)</span>    <span class="token keyword">int</span> x <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> event<span class="token punctuation">.</span><span class="token function">getX</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> y <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> event<span class="token punctuation">.</span><span class="token function">getY</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">switch</span> <span class="token punctuation">(</span>event<span class="token punctuation">.</span><span class="token function">getAction</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">case</span> MotionEvent<span class="token punctuation">.</span>ACTION_DOWN<span class="token operator">:</span>            <span class="token comment" spellcheck="true">// 处理输入的按下事件</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> MotionEvent<span class="token punctuation">.</span>ACTION_MOVE<span class="token operator">:</span>            <span class="token comment" spellcheck="true">// 处理输入的移动事件</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token keyword">case</span> MotionEvent<span class="token punctuation">.</span>ACTION_UP<span class="token operator">:</span>            <span class="token comment" spellcheck="true">// 处理输入的离开事件</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token punctuation">}</span></code></pre><p>在不涉及多点操作的情况下，通常可以使用以上代码来完成触控事件的监听，不过这里只是一个代码模板，后面我们会在触控事件中完成具体的逻辑。</p><p>在 Android 中，系统提供了非常多的方法来获取坐标值、相对距离等。方法丰富固然好，但也给初学者带来了很多困惑，不知道在什么情况下使用什么方法，下面总结了一些 API，结合 Android 坐标系来看看该如何使用它们，如下图所示：<br><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ab1f3899e3552?w=463&amp;h=459&amp;f=png&amp;s=5353" alt="获取坐标值、相对距离"></p><p>获取坐标值、相对距离的方法可以分成如下两个类别：</p><ul><li><p>View提供的获取坐标方法</p><ul><li>getTop()：获取到的是View自身的顶部到其父View顶部的距离。</li><li>getLeft()：获取到的是View自身的左侧到其父View左侧的距离。</li><li>getRight()：获取到的是View自身的右侧到其父View左侧的距离。</li><li>getBottom()：获取到的是View自身的底部到其父View顶部的距离。</li></ul></li><li><p>MotionEvent提供的方法</p><ul><li>getX()：获取触摸点距离View左侧的距离，即视图坐标。</li><li>getY()：获取触摸点距离View顶部的距离，即视图坐标。</li><li>getRawX()：获取触摸点距离整个屏幕左侧的距离，即绝对坐标。</li><li>getRawY()：获取触摸点距离整个屏幕顶部的距离，即绝对坐标。</li></ul></li></ul><blockquote><p>注意：View的坐标系统是相对于父控件而言的。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Google Guava 类库简介</title>
      <link href="/posts/2018/9a2ecb86.html"/>
      <url>/posts/2018/9a2ecb86.html</url>
      
        <content type="html"><![CDATA[<h2 id="一-Guava-简介"><a href="#一-Guava-简介" class="headerlink" title="一. Guava 简介"></a>一. Guava 简介</h2><p>　　Guava 是一个 Google 开发的 基于 Java 的类库集合的扩展项目，包括<code>集合[collections]</code>、<code>缓存[caching]</code>、<code>原生类型支持[primitives support]</code>、<code>并发库[concurrency libraries]</code>、<code>通用注解[common annotations]</code>、<code>字符串处理 [string processing]</code>、<code>I/O</code> 等等。这些高质量的 API 可以使 Java 代码更加优雅，更加简洁，让工作更加轻松愉悦。下面就简单的介绍一下 Guava 的大致的功能！</p><p>　　Guava 项目托管在 <a href="https://github.com/google/guava" target="_blank" rel="noopener">Github</a> 上，可以使用 <code>git clone https://github.com/google/guava.git</code> 下载 Guava 源码，从源码可以看到，Guava 主要有下面的几个包：</p><ul><li>com.google.common.annotations：普通注解类型。</li><li>com.google.common.base：基本工具类库和接口。</li><li>com.google.common.cache：缓存工具包，非常简单易用且功能强大的 JVM 内缓存。</li><li>com.google.common.collect：带泛型的集合接口扩展和实现，以及工具类。</li><li>com.google.common.escape：转义工具。</li><li>com.google.common.eventbus：发布订阅风格的事件总线。</li><li>com.google.common.graph：处理基于图的数据结构。</li><li>com.google.common.hash： 哈希工具包 。</li><li>com.google.common.html：Html 字符串转义。</li><li>com.google.common.io：I/O 工具包。</li><li>com.google.common.math：原始算术类型和超大数的运算工具包。</li><li>com.google.common.net：网络工具包。</li><li>com.google.common.primitives：八种原始类型和无符号类型的静态工具包。</li><li>com.google.common.reflect：反射工具包。</li><li>com.google.common.util.concurrent：多线程工具。</li><li>com.google.common.xml：xml 字符串转义。</li></ul><h2 id="二-Guava-的使用"><a href="#二-Guava-的使用" class="headerlink" title="二. Guava 的使用"></a>二. Guava 的使用</h2><h3 id="1-基本工具-Basic-utilities"><a href="#1-基本工具-Basic-utilities" class="headerlink" title="1. 基本工具 [Basic utilities]"></a>1. 基本工具 [Basic utilities]</h3><p>让使用 Java 语言变得更舒适。</p><p>1.1 使用和避免 null：null 有语言歧义， 会产生令人费解的错误， 反正他总是让人不爽。很多 Guava 的工具类在遇到 null 时会直接拒绝或出错，而不是默默地接受他们。</p><p>1.2 前置条件: 让方法中的条件检查更简单。</p><p>1.3 常见 Object 方法: 简化了 Object 常用方法的实现， 如 hashCode() 和 toString()。</p><p>1.4 排序: Guava 强大的 “fluent Comparator”比较器， 提供多关键字排序。</p><p>1.5 Throwables：简化了异常检查和错误传播。</p><h3 id="2-集合-Collections"><a href="#2-集合-Collections" class="headerlink" title="2. 集合[Collections]"></a>2. 集合[Collections]</h3><p>Guava 对 JDK 集合的扩展，这是 Guava 最成熟和为人所知的部分。<br>2.1 Immutable collections(不可变集合): 用不变的集合进行防御性编程和性能提升。</p><p>2.2 New collection types(新集合类型): JDK collections 没有的一些集合类型，主要有：multisets、multimaps、tables、bidirectional maps 等。</p><p>2.3 Powerful collection utilities(强大的集合工具类): 提供 java.util.Collections 中未包含的集合工具。</p><p>2.4 Extension utilities(扩展工具类)：让实现和扩展集合类变得更容易，比如创建 Collection 的装饰器，或实现迭代器。</p><h3 id="3-缓存-Caches"><a href="#3-缓存-Caches" class="headerlink" title="3. 缓存[Caches]"></a>3. 缓存[Caches]</h3><p>Guava Cache：本地缓存，可以很方便的操作缓存对象，支持多种缓存过期策略。</p><h3 id="4-函数式编程-Functional-idioms"><a href="#4-函数式编程-Functional-idioms" class="headerlink" title="4. 函数式编程[Functional idioms]"></a>4. 函数式编程[Functional idioms]</h3><p>Guava实现了Java的函数式编程，可以显著简化代码。</p><h3 id="5-并发-Concurrency"><a href="#5-并发-Concurrency" class="headerlink" title="5. 并发[Concurrency]"></a>5. 并发[Concurrency]</h3><p>强大而简单的抽象，让编写正确的并发代码更简单。</p><p>5.1 ListenableFuture(可监听的Future)：Futures，用于异步完成的回调。</p><p>5.2 Service框架：抽象可开启和关闭的服务，帮助你维护服务的状态逻辑。</p><h3 id="6-字符串处理-Strings"><a href="#6-字符串处理-Strings" class="headerlink" title="6. 字符串处理[Strings]"></a>6. 字符串处理[Strings]</h3><p>一个非常非常有用的字符串工具类: 提供 splitting(分割)、joining(连接)、padding(填充) 等操作。</p><h3 id="7-原生类型-Primitives"><a href="#7-原生类型-Primitives" class="headerlink" title="7. 原生类型[Primitives]"></a>7. 原生类型[Primitives]</h3><p>扩展 JDK 中未提供的对原生类型（如int、char等）的操作， 包括某些类型的无符号的变量。</p><h3 id="8-区间-Ranges"><a href="#8-区间-Ranges" class="headerlink" title="8. 区间[Ranges]"></a>8. 区间[Ranges]</h3><p>Guava 提供的一个强大的Comparable(可比较) 类型的区间 API， 包括连续和离散类型。</p><h3 id="9-I-O"><a href="#9-I-O" class="headerlink" title="9. I/O"></a>9. I/O</h3><p>简化 I/O 操作，特别是对 I/O 流和文件的操作，针对 Java5 和 Java6 版本。</p><h3 id="10-散列-Hash"><a href="#10-散列-Hash" class="headerlink" title="10. 散列[Hash]"></a>10. 散列[Hash]</h3><p>提供比 Object.hashCode() 更复杂的 散列(hash)实现, 提供 Bloom filters(布鲁姆过滤器)的实现。</p><h3 id="11-事件总线-EventBus"><a href="#11-事件总线-EventBus" class="headerlink" title="11. 事件总线[EventBus]"></a>11. 事件总线[EventBus]</h3><p>基于发布-订阅模式的组件通信，但是不需要显式地注册在委托对象中。</p><h3 id="12-数学运算-Math"><a href="#12-数学运算-Math" class="headerlink" title="12. 数学运算[Math]"></a>12. 数学运算[Math]</h3><p>优化的、充分测试的数学运算工具类。</p><h3 id="13-反射-Reflection"><a href="#13-反射-Reflection" class="headerlink" title="13. 反射[Reflection]"></a>13. 反射[Reflection]</h3><p>Guava 的 Java 反射机制工具类。</p><h2 id="三-Guava-教程"><a href="#三-Guava-教程" class="headerlink" title="三. Guava 教程"></a>三. Guava 教程</h2><ol><li><a href="https://www.yiibai.com/guava/" target="_blank" rel="noopener">易百教程</a></li><li><a href="http://ifeve.com/google-guava/" target="_blank" rel="noopener">并发编程网</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Google </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 在APP内打开指定的QQ、QQ群</title>
      <link href="/posts/2018/d699dc76.html"/>
      <url>/posts/2018/d699dc76.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-判断是否安装-QQ-客户端"><a href="#1-判断是否安装-QQ-客户端" class="headerlink" title="1.判断是否安装 QQ 客户端"></a>1.判断是否安装 QQ 客户端</h2><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * QQ包名     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">final</span> String PACKAGENAME_QQ <span class="token operator">=</span> <span class="token string">"com.tencent.mobileqq"</span><span class="token punctuation">;</span>    <span class="token comment" spellcheck="true">/**     * 判断应用是否已安装     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">checkApkInstalled</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> String packageName<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>TextUtils<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span>packageName<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            ApplicationInfo info <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getPackageManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getApplicationInfo</span><span class="token punctuation">(</span>packageName<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> info <span class="token operator">!=</span> null<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">PackageManager<span class="token punctuation">.</span>NameNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><h2 id="2-打开指定的-QQ-聊天页面"><a href="#2-打开指定的-QQ-聊天页面" class="headerlink" title="2.打开指定的 QQ 聊天页面"></a>2.打开指定的 QQ 聊天页面</h2><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 打开指定的QQ聊天页面     *     * @param context 上下文     * @param QQ      QQ号码     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">openQQChat</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> String QQ<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            String url <span class="token operator">=</span> <span class="token string">"mqqwpa://im/chat?chat_type=wpa&amp;uin="</span> <span class="token operator">+</span> QQ<span class="token punctuation">;</span>            Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>ACTION_VIEW<span class="token punctuation">,</span> Uri<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            context<span class="token punctuation">.</span><span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ActivityNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>注意：该方法指定的 QQ 号码如果没有添加为好友，此 QQ 号码需要在 <a href="http://wp.qq.com/set.html" target="_blank" rel="noopener">QQ 推广官网</a> 开通 QQ 推广功能，否则向此 QQ 号发送临时消息会发送失败。</p></blockquote><h2 id="3-打开指定的-QQ-群"><a href="#3-打开指定的-QQ-群" class="headerlink" title="3.打开指定的 QQ 群"></a>3.打开指定的 QQ 群</h2><h3 id="方法一："><a href="#方法一：" class="headerlink" title="方法一："></a>方法一：</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 打开指定的QQ群聊天页面     *     * @param context 上下文     * @param group   QQ群号码     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">openQQGroup</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> String group<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            String url <span class="token operator">=</span> <span class="token string">"mqqwpa://im/chat?chat_type=group&amp;uin="</span> <span class="token operator">+</span> group<span class="token punctuation">;</span>            Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span>Intent<span class="token punctuation">.</span>ACTION_VIEW<span class="token punctuation">,</span> Uri<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            context<span class="token punctuation">.</span><span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ActivityNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>注意：该方法只能打开已经加入的 QQ 群。</p></blockquote><h3 id="方法二："><a href="#方法二：" class="headerlink" title="方法二："></a>方法二：</h3><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 打开指定的QQ群聊天页面     *     * @param context 上下文     * @param key     由QQ官网生成的Key     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">joinQQGroup</span><span class="token punctuation">(</span>Context context<span class="token punctuation">,</span> String key<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            String url <span class="token operator">=</span> <span class="token string">"mqqopensdkapi://bizAgent/qm/qr?url=http%3A%2F%2Fqm.qq.com%2Fcgi-bin%2Fqm%2Fqr%3Ffrom%3Dapp%26p%3Dandroid%26k%3D"</span> <span class="token operator">+</span> key<span class="token punctuation">;</span>            Intent intent <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Intent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            intent<span class="token punctuation">.</span><span class="token function">setData</span><span class="token punctuation">(</span>Uri<span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment" spellcheck="true">// 此Flag可根据具体产品需要自定义，如设置，则在加群界面按返回，返回手Q主界面，不设置，按返回会返回到呼起产品界面</span>            <span class="token comment" spellcheck="true">// intent.addFlags(Intent.FLAG_ACTIVITY_NEW_TASK);</span>            context<span class="token punctuation">.</span><span class="token function">startActivity</span><span class="token punctuation">(</span>intent<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ActivityNotFoundException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span></code></pre><blockquote><p>注意：打开指定的 QQ 群需要的 <code>Key</code> 可以在 <a href="https://qun.qq.com/join.html" target="_blank" rel="noopener">QQ群官网</a> 选择需要的 QQ 群生成对应的 Key。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 状态栏、导航栏相关</title>
      <link href="/posts/2018/30124932.html"/>
      <url>/posts/2018/30124932.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-状态栏"><a href="#1-状态栏" class="headerlink" title="1.状态栏"></a>1.状态栏</h2><h4 id="1-获取状态栏高度"><a href="#1-获取状态栏高度" class="headerlink" title="1.获取状态栏高度"></a>1.获取状态栏高度</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 获得状态栏的高度(单位：px)     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getStatusBarHeight</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Resources resources <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> resourceId <span class="token operator">=</span> resources<span class="token punctuation">.</span><span class="token function">getIdentifier</span><span class="token punctuation">(</span><span class="token string">"status_bar_height"</span><span class="token punctuation">,</span> <span class="token string">"dimen"</span><span class="token punctuation">,</span> <span class="token string">"android"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resources<span class="token punctuation">.</span><span class="token function">getDimensionPixelSize</span><span class="token punctuation">(</span>resourceId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h2 id="2-导航栏"><a href="#2-导航栏" class="headerlink" title="2.导航栏"></a>2.导航栏</h2><h4 id="2-1-判断是否存在导航栏"><a href="#2-1-判断是否存在导航栏" class="headerlink" title="2.1.判断是否存在导航栏"></a>2.1.判断是否存在导航栏</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 检测设备是否有底部导航栏     */</span>    <span class="token annotation punctuation">@TargetApi</span><span class="token punctuation">(</span>Build<span class="token punctuation">.</span>VERSION_CODES<span class="token punctuation">.</span>ICE_CREAM_SANDWICH<span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">boolean</span> <span class="token function">hasNavigationBar</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment" spellcheck="true">//通过判断设备是否有返回键、菜单键(不是虚拟键,是手机屏幕外的按键)来确定是否有navigation bar</span>        <span class="token keyword">boolean</span> hasMenuKey <span class="token operator">=</span> ViewConfiguration<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>context<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">hasPermanentMenuKey</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">boolean</span> hasBackKey <span class="token operator">=</span> KeyCharacterMap<span class="token punctuation">.</span><span class="token function">deviceHasKey</span><span class="token punctuation">(</span>KeyEvent<span class="token punctuation">.</span>KEYCODE_BACK<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>hasMenuKey <span class="token operator">&amp;&amp;</span> <span class="token operator">!</span>hasBackKey<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">// 做任何你需要做的,这个设备有一个导航栏</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre><h4 id="2-2-获取导航栏高度"><a href="#2-2-获取导航栏高度" class="headerlink" title="2.2.获取导航栏高度"></a>2.2.获取导航栏高度</h4><pre class=" language-java"><code class="language-java">    <span class="token comment" spellcheck="true">/**     * 获得导航栏的高度(单位：px)     */</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">getNavigationBarHeight</span><span class="token punctuation">(</span>Context context<span class="token punctuation">)</span> <span class="token punctuation">{</span>        Resources resources <span class="token operator">=</span> context<span class="token punctuation">.</span><span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> resourceId <span class="token operator">=</span> resources<span class="token punctuation">.</span><span class="token function">getIdentifier</span><span class="token punctuation">(</span><span class="token string">"navigation_bar_height"</span><span class="token punctuation">,</span> <span class="token string">"dimen"</span><span class="token punctuation">,</span> <span class="token string">"android"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> resources<span class="token punctuation">.</span><span class="token function">getDimensionPixelSize</span><span class="token punctuation">(</span>resourceId<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span></code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 布局中的空格以及占一个汉字宽度的空格的实现</title>
      <link href="/posts/2018/6d0c8cdf.html"/>
      <url>/posts/2018/6d0c8cdf.html</url>
      
        <content type="html"><![CDATA[<p>空格的替代符号有以下几种：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">编号</th><th style="text-align:left">描述</th></tr></thead><tbody><tr><td style="text-align:center"><code>&amp;nbsp;</code></td><td style="text-align:center"><code>&amp;#160;</code></td><td style="text-align:left">不断行的空白(1个字符宽度)</td></tr><tr><td style="text-align:center"><code>&amp;ensp;</code></td><td style="text-align:center"><code>&amp;#8194;</code></td><td style="text-align:left">半个空白(1个字符宽度)</td></tr><tr><td style="text-align:center"><code>&amp;emsp;</code></td><td style="text-align:center"><code>&amp;#8195;</code></td><td style="text-align:left">一个空白(2个字符宽度)</td></tr><tr><td style="text-align:center"><code>&amp;thinsp;</code></td><td style="text-align:center"><code>&amp;#8201;</code></td><td style="text-align:left">窄空白(小于1个字符宽度)</td></tr></tbody></table><p>可以用名称或编号作为空格的替代符号，名称必须小写，末尾的 <code>;</code> 不能省略。</p><p>在Android布局中进行使用到空格，以便实现文字的对齐。那么在Android中如何表示一个空格呢？</p><ul><li>空格：<code>&amp;#160;</code></li><li>窄空格：<code>&amp;#8201;</code></li></ul><p>一个汉字宽度的空格：<code>&amp;#160;&amp;#160;&amp;#8201;</code>【用两个空格(<code>&amp;#160;&amp;#160;</code>)占一个汉字的宽度时，两个空格比一个汉字略窄，三个空格(<code>&amp;#160;&amp;#160;&amp;#160;</code>)比一个汉字略宽】</p><p>在实际使用中需要灵活使用 <code>&amp;#160;</code> 和 <code>&amp;#8201;</code> 的组合。</p><pre class=" language-xml"><code class="language-xml">android:text="真实姓名:"         </code></pre><pre class=" language-xml"><code class="language-xml">android:text="身<span class="token entity" title="&#160;">&amp;#160;</span><span class="token entity" title="&#160;">&amp;#160;</span>份<span class="token entity" title="&#160;">&amp;#160;</span><span class="token entity" title="&#160;">&amp;#160;</span>证:"</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ab2682bfdfa83?w=80&amp;h=80&amp;f=png&amp;s=2866" alt=""></p><pre class=" language-xml"><code class="language-xml">android:text="姓<span class="token entity" title="&#160;">&amp;#160;</span><span class="token entity" title="&#160;">&amp;#160;</span><span class="token entity" title="&#8210;">&amp;#8210;</span>名:"        </code></pre><pre class=" language-xml"><code class="language-xml">android:text="身份证:"</code></pre><p><img src="https://user-gold-cdn.xitu.io/2018/7/18/164ab26a8cf1f7c8?w=63&amp;h=82&amp;f=png&amp;s=2264" alt=""></p><p>TextView实现首行缩进的方法：</p><ul><li>在string资源文件中，在文字的前面加入 <code>\u3000\u3000</code> 即可实现首行缩进</li><li>在Java代码中，使用setText(“\u3000\u3000” + xxxxx);</li></ul>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 自动化测试之 Monkey</title>
      <link href="/posts/2018/dd9cc5eb.html"/>
      <url>/posts/2018/dd9cc5eb.html</url>
      
        <content type="html"><![CDATA[<h2 id="Monkey-简介"><a href="#Monkey-简介" class="headerlink" title="Monkey 简介"></a>Monkey 简介</h2><h3 id="Monkey-介绍"><a href="#Monkey-介绍" class="headerlink" title="Monkey 介绍"></a>Monkey 介绍</h3><p>Monkey 是一个命令行工具，可以运行在模拟器里或实际设备中。它向系统发送伪随机的用户事件流，实现对正在开发的应用程序进行压力测试。</p><p>Monkey 测试也有人叫做搞怪测试。就是用一些稀奇古怪的操作方式去测试被测试系统，以测试系统的稳定性。</p><p>Monkey 测试是 Android 自动化测试的一种手段，Monkey 测试本身非常简单，就是模拟用户的按键输入，触摸屏输入，手势输入等，看设备多长时间会出异常。</p><p>当 Monkey 程序在模拟器或设备运行的时候，如果用户触发了比如点击，触摸，手势或一些系统级别的事件的时候，它就会产生随机脉冲，所以可以用 Monkey 用随机重复的方法去负荷测试你开发的软件。</p><p>Monkey 包括许多选项，它们大致分为四大类：</p><ul><li>基本配置 选项，如设置尝试的事件数量。</li><li>运行约束选项，如设置只对单独的一个包进行测试。</li><li>事件类型和频率。</li><li>调试选项。</li></ul><p>在 Monkey 运行的时候，它生成事件，并把它们发给系统。同时，Monkey 还对测试中的系统进行监测，对下列三种情况进行特殊处理：</p><ul><li>如果限定了 Monkey 运行在一个或几个特定的包上，那么它会监测试图转到其它包的操作，并对其进行阻止。</li><li>如果应用程序崩溃或接收到任何失控异常，Monkey 将停止并报错。</li><li>如果应用程序产生了应用程序不响应(application not responding)的错误，Monkey 将会停止并报错。</li></ul><p>按照选定的不同级别的反馈信息，在 Monkey 中还可以看到其执行过程报告和生成的事件。谈到 Monkey，必须介绍一下 ADB。</p><p>ADB 是 Android SDK 里的一个工具，用这个工具可以直接操作管理 Android 模拟器或者真实的 Android 设备。它的主要功能有：</p><ul><li>运行设备的shell(命令行)</li><li>管理模拟器或设备的端口映射</li><li>计算机和设备之间上传/下载文件</li><li>将本地 APK 软件安装至模拟器或 Android 设备</li><li>ADB 是一个客户端-服务器端程序，其中客户端是你用来操作的电脑，服务器端是 Android 设备。</li></ul><h3 id="ADB-的常用命令"><a href="#ADB-的常用命令" class="headerlink" title="ADB 的常用命令"></a>ADB 的常用命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>adb devices</code></td><td>获取所有连接ADB的模拟器或者真机</td></tr><tr><td><code>adb install c:/xxx.apk</code></td><td>安装自己的apk到设备上</td></tr><tr><td><code>adb uninstall &lt;package-name&gt;</code></td><td>从设备上卸载apk</td></tr><tr><td><code>adb shell pm list packages</code></td><td>获取所有应用的包名</td></tr><tr><td><code>adb -s emulator-5556 uninstall &lt;package-name&gt;</code></td><td>指定某设备卸载apk</td></tr><tr><td><code>adb start-server</code></td><td>重启adb</td></tr><tr><td><code>adb kill-server</code></td><td>杀死adb</td></tr></tbody></table><h3 id="Monkey-的常用命令"><a href="#Monkey-的常用命令" class="headerlink" title="Monkey 的常用命令"></a>Monkey 的常用命令</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>adb shell monkey –help</code></td><td>获取帮助命令</td></tr><tr><td><code>adb shell monkey &lt;count&gt;</code></td><td>随机执行 <code>count</code> 个模拟事件</td></tr><tr><td><code>adb shell monkey -p &lt;package-name&gt; &lt;count&gt;</code></td><td>指定某个应用随机执行 <code>count</code> 个模拟事件</td></tr><tr><td><code>adb shell monkey [options] &lt;count&gt;</code></td><td>带参数执行 <code>count</code> 个模拟事件</td></tr></tbody></table><h2 id="Monkey-参数介绍"><a href="#Monkey-参数介绍" class="headerlink" title="Monkey 参数介绍"></a>Monkey 参数介绍</h2><h3 id="基本参数"><a href="#基本参数" class="headerlink" title="基本参数"></a>基本参数</h3><table><thead><tr><th>命令</th><th>作用</th><th>注意</th></tr></thead><tbody><tr><td><code>-v</code></td><td>日志详细程度</td><td>每一个-v将增加反馈信息的级别。Level 0(缺省值)除启动提示、测试完成和最终结果之外，提供较少信息。Level 1提供较为详细的测试信息，如逐个发送到Activity的事件。Level 2提供更加详细的设置信息，如测试中被选中的或未被选中的Activity。</td></tr><tr><td><code>-s</code></td><td>伪随机数生成器的seed值</td><td>如果用相同的seed值再次运行Monkey， 两次monkey测试将生成相同的事件序列。</td></tr><tr><td><code>--throttle</code></td><td>两次事件的时间间隔，单位是毫秒</td><td>通过这个选项可以减缓Monkey的执行速度。如果不指定该选项，Monkey将 不会被延迟，事件将尽可能快地被产成。</td></tr></tbody></table><h3 id="发送事件的类型"><a href="#发送事件的类型" class="headerlink" title="发送事件的类型"></a>发送事件的类型</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>--pct-touch &lt;percent&gt;</code></td><td>指定触摸事件百分比，一个点上先后有按下和抬起的操作。</td></tr><tr><td><code>--pct-motion &lt;percent&gt;</code></td><td>指定滑动事件百分比，先按下，滑动一段距离，然后抬起。</td></tr><tr><td><code>--pct-trackball &lt;percent&gt;</code></td><td>轨迹球事件百分比，一系列的随机移动和单击操作。</td></tr><tr><td><code>--pct-nav &lt;percent&gt;</code></td><td>基本导航事件百分比(硬件)，设置基本的导航事件(上/下/左/右导航键)的生成比例。</td></tr><tr><td><code>--pct-majornav &lt;percent&gt;</code></td><td>主要导航事件百分比，会导致UI产生回馈的事件，如单击5个方向键中的中间按钮，单击后退键或者菜单键。</td></tr><tr><td><code>--pct-syskeys &lt;percent&gt;</code></td><td>系统按键事件百分比(Home、Back、startCall、endCall、volumeControl)。</td></tr><tr><td><code>--pct-appswitch &lt;percent&gt;</code></td><td>指定启动Activity的百分比。在随机间隔里，Monkey将执行一个startActivity()调用，作为最大程度覆盖包中全部Activity的一种方法。</td></tr><tr><td><code>--pct-anyevent &lt;percent&gt;</code></td><td>指定其他事件百分比,普通的按键消息，设备上一些不常用的按钮事件。</td></tr></tbody></table><h3 id="约束条件"><a href="#约束条件" class="headerlink" title="约束条件"></a>约束条件</h3><table><thead><tr><th>命令</th><th>作用</th><th>注意</th></tr></thead><tbody><tr><td><code>-p &lt;allowed-package-name&gt;</code></td><td>如果用此参数指定了一个或几个包，Monkey将只允许系统启动这些包里的Activity。 如果你的应用程序还需要访问其它包里的Activity(如选择取一个联系人)，那些包也需要在此 同时指定。如果不指定任何包，Monkey将允许系统启动全部包里的Activity。</td><td>要指定多个包，需要使用多个-p选项，每个-p选项只能用于一个包。</td></tr><tr><td><code>-c &lt;main-category&gt;</code></td><td>如果用此参数指定了一个或几个类别，Monkey将只允许系统启动被这些类别中的某个类别列出的Activity。 如果不指定任何类别，Monkey将选 择下列类别中列出的Activity： Intent.CATEGORY_LAUNCHER或Intent.CATEGORY_MONKEY。</td><td>要指定多个类别，需要使用多个-c选项，每个-c选项只能用于一个类别。</td></tr></tbody></table><h3 id="调试选项"><a href="#调试选项" class="headerlink" title="调试选项"></a>调试选项</h3><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td><code>--dbg-no-events</code></td><td>指定了此选项，monkey会启动待测应用，但不发送任何消息，建议与-v,-p,-throttle一起使用。</td></tr><tr><td><code>--hprof</code></td><td>指定此选项，monkey会在发送事件前后生成性能报告(即内存的快照文件)，一般在设备的/data/misc目录下生成一个5M左右的文件。</td></tr><tr><td><code>--ignore-crashes</code></td><td>指定了此选项，待测应用崩溃或发生异常时，继续发送系统消息，直到指定个数的消息全部发送完毕，否则停止运行。</td></tr><tr><td><code>--ignore-timeouts</code></td><td>指定了此选项，待测应用停止响应(如弹出“应用无响应”对话框)时，继续发送系统消息，直到指定个数的消息全部发送完毕，否则停止运行。</td></tr><tr><td><code>--ignore-security-exceptions</code></td><td>指定了此选项，待测应用碰到权限方面的错误时，继续发送系统消息，直到指定个数的消息全部发送完毕，否则停止运行。</td></tr><tr><td><code>--kill-process-after-error</code></td><td>一般情况下，当monkey因为某个错误指定运行时，出问题的应用会留在系统上继续执行，这个选项通知系统当错误发生时杀掉进程。</td></tr><tr><td><code>--monitor-native-crashes</code></td><td>监视由Android C/C++代码部分(cpu计算部分)引起的崩溃，此时如果设置了“–kill-process-after-error”，整个系统会关机。</td></tr><tr><td><code>--wait-dbg</code></td><td>停止执行中的Monkey，直到有调试器和它相连接。</td></tr></tbody></table><h2 id="Monkey-测试命令"><a href="#Monkey-测试命令" class="headerlink" title="Monkey 测试命令"></a>Monkey 测试命令</h2><h3 id="不输出日志"><a href="#不输出日志" class="headerlink" title="不输出日志"></a>不输出日志</h3><pre class=" language-shell"><code class="language-shell">adb shell monkey -v --throttle 300 --pct-touch 30 --pct-motion 20 --pct-nav 20 --pct-majornav 15 --pct-appswitch 5 --pct-anyevent 5 --pct-trackball 0 --pct-syskeys 0 -p <package-name> 1000</code></pre><h3 id="输出日志"><a href="#输出日志" class="headerlink" title="输出日志"></a>输出日志</h3><pre class=" language-shell"><code class="language-shell">adb shell monkey -v --throttle 300 --pct-touch 30 --pct-motion 20 --pct-nav 20 --pct-majornav 15 --pct-appswitch 5 --pct-anyevent 5 --pct-trackball 0 --pct-syskeys 0 -p <package-name> 1000>D:\Monkey\log.txt</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Monkey </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 代码混淆规则</title>
      <link href="/posts/2018/64dda27b.html"/>
      <url>/posts/2018/64dda27b.html</url>
      
        <content type="html"><![CDATA[<h2 id="1-Proguard介绍"><a href="#1-Proguard介绍" class="headerlink" title="1. Proguard介绍"></a>1. Proguard介绍</h2><p>Android SDK自带了混淆工具<code>Proguard</code>。它位于SDK根目录<code>\tools\proguard</code>下面。<br><code>ProGuard</code>是一个免费的Java类文件收缩，优化，混淆和预校验器。它可以检测并删除未使用的类，字段，方法和属性。它可以优化字节码，并删除未使用的指令。它可以将类、字段和方法使用短无意义的名称进行重命名。最后，预校验的Java6或针对Java MicroEdition的所述处理后的码。<br>如果开启了混淆，<code>Proguard</code>默认情况下会对所有代码，包括第三方包都进行混淆，可是有些代码或者第三方包是不能混淆的，这就需要我们手动编写混淆规则来保持不能被混淆的部分。</p><h2 id="2-Proguard作用"><a href="#2-Proguard作用" class="headerlink" title="2. Proguard作用"></a>2. Proguard作用</h2><p>Android中的“混淆”可以分为两部分，一部分是 Java 代码的优化与混淆，依靠 <code>proguard</code> 混淆器来实现；另一部分是资源压缩，将移除项目及依赖的库中未被使用的资源(资源压缩严格意义上跟混淆没啥关系，但一般我们都会放一起讲)。</p><h4 id="2-1-代码混淆"><a href="#2-1-代码混淆" class="headerlink" title="2.1 代码混淆"></a>2.1 代码混淆</h4><p><strong>压缩(Shrinking)</strong>：默认开启，用以减小应用体积，移除未被使用的类和成员，并且会在优化动作执行之后再次执行（因为优化后可能会再次暴露一些未被使用的类和成员）。</p><pre><code>    -dontshrink 关闭压缩</code></pre><p><strong>优化(Optimization)</strong>：默认开启，在字节码级别执行优化，让应用运行的更快。</p><pre><code>    -dontoptimize  关闭优化    -optimizationpasses n 表示proguard对代码进行迭代优化的次数，Android一般为5</code></pre><p><strong>混淆(Obfuscation)</strong>：默认开启，增大反编译难度，类、函数、变量名会被随机命名成无意义的代号形如：a,b,c…之类的，除非用keep保护。</p><pre><code>    -dontobfuscate 关闭混淆</code></pre><p>上面这几个功能都是默认打开的，要关闭他们只需配置对应的规则即可。<br>混淆后默认会在工程目录<code>app/build/outputs/mapping/release</code>下生成一个<code>mapping.txt</code>文件，这就是混淆规则，我们可以根据这个文件把混淆后的代码反推回源本的代码，所以这个文件很重要，注意保护好。原则上，代码混淆后越乱越无规律越好，但有些地方我们是要避免混淆的，否则程序运行就会出错。</p><h4 id="2-2-资源压缩"><a href="#2-2-资源压缩" class="headerlink" title="2.2 资源压缩"></a>2.2 资源压缩</h4><p>资源压缩将移除项目及依赖的库中未被使用的资源，这在减少 apk 包体积上会有不错的效果，一般建议开启。具体做法是在 <code>build.grade</code> 文件中，将 <code>shrinkResources</code> 属性设置为 <code>true</code>。需要注意的是，只有在用<code>minifyEnabled true</code>开启了代码压缩后，资源压缩才会生效。<br>资源压缩包含了“合并资源”和“移除资源”两个流程。<br>“合并资源”流程中，名称相同的资源被视为重复资源会被合并。需要注意的是，这一流程不受<code>shrinkResources</code>属性控制，也无法被禁止， gradle 必然会做这项工作，因为假如不同项目中存在相同名称的资源将导致错误。gradle 在四处地方寻找重复资源：</p><ul><li><code>src/main/res/</code> 路径</li><li>不同的构建类型（debug、release等等）</li><li>不同的构建渠道</li><li>项目依赖的第三方库<br>合并资源时按照如下优先级顺序：<pre><code> 依赖 -&gt; main -&gt; 渠道 -&gt; 构建类型</code></pre>举个例子，假如重复资源同时存在于<code>main</code>文件夹和不同渠道中，gradle 会选择保留渠道中的资源。<br>同时，如果重复资源在同一层次出现，比如<code>src/main/res/</code> 和 <code>src/main/res2/</code>，则 <code>gradle</code> 无法完成资源合并，这时会报资源合并错误。<br>“移除资源”流程则见名知意，需要注意的是，类似代码，混淆资源移除也可以定义哪些资源需要被保留，这点在下文给出。</li></ul><h2 id="3-Proguard规则"><a href="#3-Proguard规则" class="headerlink" title="3. Proguard规则"></a>3. Proguard规则</h2><h4 id="3-1-基本指令"><a href="#3-1-基本指令" class="headerlink" title="3.1 基本指令"></a>3.1 基本指令</h4><ul><li><strong>-ignorewarning</strong>：是否忽略警告</li><li><strong>-optimizationpasses n</strong>：指定代码的压缩级别(在0~7之间，默认为5)</li><li><strong>-dontusemixedcaseclassnames</strong>：是否使用大小写混合(windows大小写不敏感，建议加入)</li><li><strong>-dontskipnonpubliclibraryclasses</strong>：是否混淆非公共的库的类</li><li><strong>-dontskipnonpubliclibraryclassmembers</strong>：是否混淆非公共的库的类的成员</li><li><strong>-dontpreverify</strong>：混淆时是否做预校验(Android不需要预校验，去掉可以加快混淆速度)</li><li><strong>-verbose</strong>：混淆时是否记录日志(混淆后会生成映射文件)</li><li><strong>-obfuscationdictionary dictionary_path</strong>：指定外部模糊字典</li><li><strong>-classobfuscationdictionary dictionary_path</strong>：指定class模糊字典</li><li><strong>-packageobfuscationdictionary dictionary_path</strong>：指定package模糊字典</li><li><strong>-optimizations !code/simplification/arithmetic,!field/<em>,!class/merging/</em>,!code/allocation/variable</strong>：混淆时所采用的算法(谷歌推荐算法)</li><li><strong>-libraryjars libs(*.jar;)</strong>:添加支持的jar(引入libs下的所有jar包)</li><li><strong>-renamesourcefileattribute SourceFile</strong>：将文件来源重命名为“SourceFile”字符串</li><li><strong>-keepattributes <em>Annotation</em></strong>：保持注解不被混淆</li><li><strong>-keep class <em> extends java.lang.annotation.Annotation {</em>;}</strong>：保持注解不被混淆</li><li><strong>-keep interface <em> extends java.lang.annotation.Annotation { </em>; }</strong>：保持注解不被混淆</li><li><strong>-keepattributes Signature</strong>：保持泛型不被混淆</li><li><strong>-keepattributes EnclosingMethod</strong>：保持反射不被混淆</li><li><strong>-keepattributes Exceptions</strong>：保持异常不被混淆</li><li><strong>-keepattributes InnerClasses</strong>：保持内部类不被混淆</li><li><strong>-keepattributes SourceFile,LineNumberTable</strong>：抛出异常时保留代码行号<h4 id="3-2-保留选项"><a href="#3-2-保留选项" class="headerlink" title="3.2 保留选项"></a>3.2 保留选项</h4></li><li><strong>-keep [,modifier，…] class_specification</strong>：指定需要保留的类和类成员（作为公共类库，应该保留所有可公开访问的public方法）</li><li><strong>-keepclassmembers [,modifier，…] class_specification</strong>：指定需要保留的类成员:变量或者方法</li><li><strong>-keepclasseswithmembers [,modifier，…] class_specification</strong>：指定保留的类和类成员，条件是所指定的类成员都存在（既在压缩阶段没有被删除的成员，效果和keep差不多）</li><li><strong>-keepnames class_specification</strong>:指定要保留名称的类和类成员，前提是在压缩阶段未被删除，仅用于模糊处理。[-keep allowshrinking class_specification 的简写]</li><li><strong>-keepclassmembernames class_specification</strong>：指定要保留名称的类成员，前提是在压缩阶段未被删除，仅用于模糊处理。[-keepclassmembers allowshrinking class_specification 的简写]</li><li><strong>-keepclasseswithmembernames class_specification</strong>：指定要保留名称的类成员，前提是在压缩阶段后所指定的类成员都存在，仅用于模糊处理。[-keepclasseswithmembers allowshrinking class_specification 的简写]</li><li><strong>-printseeds [filename]</strong>：指定详尽列出由各种-keep选项匹配的类和类成员。列表打印到标准输出或给定文件。 该列表可用于验证是否真的找到了预期的类成员，特别是如果您使用通配符。</li></ul><h2 id="4-Keep命令说明"><a href="#4-Keep命令说明" class="headerlink" title="4. Keep命令说明"></a>4. Keep命令说明</h2><table><thead><tr><th>命令</th><th>作用</th></tr></thead><tbody><tr><td>-keep</td><td>保持类和类成员，防止被移除或者被重命名</td></tr><tr><td>-keepnames</td><td>保持类和类成员，防止被重命名</td></tr><tr><td>-keepclassmembers</td><td>保持类成员，防止被移除或者被重命名</td></tr><tr><td>-keepclassmembernames</td><td>保持类成员，防止被重命名</td></tr><tr><td>-keepclasseswithmembers</td><td>保持拥有该成员的类和成员，防止被移除或者被重命名</td></tr><tr><td>-keepclasseswithmembernames</td><td>保持拥有该成员的类和成员，防止被重命名</td></tr></tbody></table><p>保持元素不参与混淆的规则的命令格式：</p><pre><code>[保持命令] [类] {    [成员]}</code></pre><p>“类”代表类相关的限定条件，它将最终定位到某些符合该限定条件的类。它的内容可以使用：</p><ul><li>具体的类</li><li>访问修饰符（<code>public、protected、private</code>）</li><li>通配符<code>*</code>，匹配任意长度字符，但不含包名分隔符(.)</li><li>通配符<code>**</code>，匹配任意长度字符，并且包含包名分隔符(.)</li><li><code>extends</code>，即可以指定类的基类</li><li><code>implement</code>，匹配实现了某接口的类</li><li><code>$</code>，内部类<br>“成员”代表类成员相关的限定条件，它将最终定位到某些符合该限定条件的类成员。它的内容可以使用：</li><li><code>&lt;init&gt;</code> 匹配所有构造器</li><li><code>&lt;fields&gt;</code> 匹配所有域</li><li><code>&lt;methods&gt;</code> 匹配所有方法</li><li>通配符<code>*</code>，匹配任意长度字符，但不含包名分隔符(.)</li><li>通配符<code>**</code>，匹配任意长度字符，并且包含包名分隔符(.)</li><li>通配符<code>***</code>，匹配任意参数类型</li><li><code>…</code>，匹配任意长度的任意类型参数。比如void test(…)就能匹配任意 void test(String a) 或者是 void test(int a, String b) 这些方法。</li><li>访问修饰符（<code>public、protected、private</code>）</li></ul><h4 id="4-1-不混淆某个类"><a href="#4-1-不混淆某个类" class="headerlink" title="4.1 不混淆某个类"></a>4.1 不混淆某个类</h4><pre><code>    -keep public class com.android.proguard.example.Test { *; }</code></pre><h4 id="4-2-不混淆某个包所有的类"><a href="#4-2-不混淆某个包所有的类" class="headerlink" title="4.2 不混淆某个包所有的类"></a>4.2 不混淆某个包所有的类</h4><pre><code>    -keep class com.android.proguard.example.** { *; }</code></pre><h4 id="4-3-不混淆某个类的子类"><a href="#4-3-不混淆某个类的子类" class="headerlink" title="4.3 不混淆某个类的子类"></a>4.3 不混淆某个类的子类</h4><pre><code>    -keep public class * extends com.android.proguard.example.Test { *; }</code></pre><h4 id="4-4-不混淆所有类名中包含了“model”的类及其成员"><a href="#4-4-不混淆所有类名中包含了“model”的类及其成员" class="headerlink" title="4.4 不混淆所有类名中包含了“model”的类及其成员"></a>4.4 不混淆所有类名中包含了“model”的类及其成员</h4><pre><code>    -keep public class **.*model*.** {*;}</code></pre><h4 id="4-5-不混淆某个接口的实现"><a href="#4-5-不混淆某个接口的实现" class="headerlink" title="4.5 不混淆某个接口的实现"></a>4.5 不混淆某个接口的实现</h4><pre><code>    -keep class * implements com.android.proguard.example.TestInterface { *; }</code></pre><h4 id="4-6-不混淆某个类的构造方法"><a href="#4-6-不混淆某个类的构造方法" class="headerlink" title="4.6 不混淆某个类的构造方法"></a>4.6 不混淆某个类的构造方法</h4><pre><code>    -keepclassmembers class com.android.proguard.example.Test {        public &lt;init&gt;();    }</code></pre><h4 id="4-7-不混淆某个类的特定的方法"><a href="#4-7-不混淆某个类的特定的方法" class="headerlink" title="4.7 不混淆某个类的特定的方法"></a>4.7 不混淆某个类的特定的方法</h4><pre><code>    -keepclassmembers class com.android.proguard.example.Test {        public void test(java.lang.String);    }</code></pre><h4 id="4-8-不混淆某个类的内部类"><a href="#4-8-不混淆某个类的内部类" class="headerlink" title="4.8 不混淆某个类的内部类"></a>4.8 不混淆某个类的内部类</h4><pre><code>    -keep class com.android.proguard.example.Test$* {            *;     }</code></pre><h2 id="5-Proguard注意事项"><a href="#5-Proguard注意事项" class="headerlink" title="5. Proguard注意事项"></a>5. Proguard注意事项</h2><h4 id="5-1-保持基本组件不被混淆"><a href="#5-1-保持基本组件不被混淆" class="headerlink" title="5.1 保持基本组件不被混淆"></a>5.1 保持基本组件不被混淆</h4><pre><code>    -keep public class * extends android.app.Fragment    -keep public class * extends android.app.Activity    -keep public class * extends android.app.Application    -keep public class * extends android.app.Service    -keep public class * extends android.content.BroadcastReceiver    -keep public class * extends android.content.ContentProvider    -keep public class * extends android.app.backup.BackupAgentHelper    -keep public class * extends android.preference.Preference</code></pre><h4 id="5-2-保持-Google-原生服务需要的类不被混淆"><a href="#5-2-保持-Google-原生服务需要的类不被混淆" class="headerlink" title="5.2 保持 Google 原生服务需要的类不被混淆"></a>5.2 保持 Google 原生服务需要的类不被混淆</h4><pre><code>    -keep public class com.google.vending.licensing.ILicensingService    -keep public class com.android.vending.licensing.ILicensingService</code></pre><h4 id="5-3-Support包规则"><a href="#5-3-Support包规则" class="headerlink" title="5.3 Support包规则"></a>5.3 Support包规则</h4><pre><code>    -dontwarn android.support.**    -keep public class * extends android.support.v4.**    -keep public class * extends android.support.v7.**    -keep public class * extends android.support.annotation.**</code></pre><h4 id="5-4-保持-native-方法不被混淆"><a href="#5-4-保持-native-方法不被混淆" class="headerlink" title="5.4 保持 native 方法不被混淆"></a>5.4 保持 native 方法不被混淆</h4><pre><code>    -keepclasseswithmembernames class * { ####        native &lt;methods&gt;;    }</code></pre><h4 id="5-5-保留自定义控件-继承自View-不被混淆"><a href="#5-5-保留自定义控件-继承自View-不被混淆" class="headerlink" title="5.5 保留自定义控件(继承自View)不被混淆"></a>5.5 保留自定义控件(继承自View)不被混淆</h4><pre><code>    -keep public class * extends android.view.View { ####        *** get*();        void set*(***);        public &lt;init&gt;(android.content.Context);        public &lt;init&gt;(android.content.Context, android.util.AttributeSet);        public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);    }</code></pre><h4 id="5-6-保留指定格式的构造方法不被混淆"><a href="#5-6-保留指定格式的构造方法不被混淆" class="headerlink" title="5.6 保留指定格式的构造方法不被混淆"></a>5.6 保留指定格式的构造方法不被混淆</h4><pre><code>    -keepclasseswithmembers class * {        public &lt;init&gt;(android.content.Context, android.util.AttributeSet);        public &lt;init&gt;(android.content.Context, android.util.AttributeSet, int);    }</code></pre><h4 id="5-7-保留在Activity中的方法参数是view的方法-避免布局文件里面onClick被影响"><a href="#5-7-保留在Activity中的方法参数是view的方法-避免布局文件里面onClick被影响" class="headerlink" title="5.7 保留在Activity中的方法参数是view的方法(避免布局文件里面onClick被影响)"></a>5.7 保留在Activity中的方法参数是view的方法(避免布局文件里面onClick被影响)</h4><pre><code>    -keepclassmembers class * extends android.app.Activity {        public void *(android.view.View);    }</code></pre><h4 id="5-8-保持枚举-enum-类不被混淆"><a href="#5-8-保持枚举-enum-类不被混淆" class="headerlink" title="5.8 保持枚举 enum 类不被混淆"></a>5.8 保持枚举 enum 类不被混淆</h4><pre><code>    -keepclassmembers enum * {        public static **[] values();        public static ** valueOf(java.lang.String);    }</code></pre><h4 id="5-9-保持R-资源-下的所有类及其方法不能被混淆"><a href="#5-9-保持R-资源-下的所有类及其方法不能被混淆" class="headerlink" title="5.9 保持R(资源)下的所有类及其方法不能被混淆"></a>5.9 保持R(资源)下的所有类及其方法不能被混淆</h4><pre><code>    -keep class **.R$* { *; }</code></pre><h4 id="5-10-保持-Parcelable-序列化的类不被混淆-注：aidl文件不能去混淆"><a href="#5-10-保持-Parcelable-序列化的类不被混淆-注：aidl文件不能去混淆" class="headerlink" title="5.10 保持 Parcelable 序列化的类不被混淆(注：aidl文件不能去混淆)"></a>5.10 保持 Parcelable 序列化的类不被混淆(注：aidl文件不能去混淆)</h4><pre><code>    -keep class * implements android.os.Parcelable {        public static final android.os.Parcelable$Creator *;    }</code></pre><h4 id="5-11-需要序列化和反序列化的类不能被混淆-注：Java反射用到的类也不能被混淆"><a href="#5-11-需要序列化和反序列化的类不能被混淆-注：Java反射用到的类也不能被混淆" class="headerlink" title="5.11 需要序列化和反序列化的类不能被混淆(注：Java反射用到的类也不能被混淆)"></a>5.11 需要序列化和反序列化的类不能被混淆(注：Java反射用到的类也不能被混淆)</h4><pre><code>    -keepnames class * implements java.io.Serializable</code></pre><h4 id="5-12-保持-Serializable-序列化的类成员不被混淆"><a href="#5-12-保持-Serializable-序列化的类成员不被混淆" class="headerlink" title="5.12 保持 Serializable 序列化的类成员不被混淆"></a>5.12 保持 Serializable 序列化的类成员不被混淆</h4><pre><code>    -keepclassmembers class * implements java.io.Serializable {        static final long serialVersionUID;        private static final java.io.ObjectStreamField[] serialPersistentFields;        !static !transient &lt;fields&gt;;        !private &lt;fields&gt;;        !private &lt;methods&gt;;        private void writeObject(java.io.ObjectOutputStream);        private void readObject(java.io.ObjectInputStream);        java.lang.Object writeReplace();        java.lang.Object readResolve();    }</code></pre><h4 id="5-13-保持-BaseAdapter-类不被混淆"><a href="#5-13-保持-BaseAdapter-类不被混淆" class="headerlink" title="5.13 保持 BaseAdapter 类不被混淆"></a>5.13 保持 BaseAdapter 类不被混淆</h4><pre><code>    -keep public class * extends android.widget.BaseAdapter { *; }</code></pre><h4 id="5-14-保持-CusorAdapter-类不被混淆"><a href="#5-14-保持-CusorAdapter-类不被混淆" class="headerlink" title="5.14 保持 CusorAdapter 类不被混淆"></a>5.14 保持 CusorAdapter 类不被混淆</h4><pre><code>    -keep public class * extends android.widget.CusorAdapter{ *; }</code></pre><h4 id="5-15-保持反射用到的类和与JavaScript进行交互的类不被混淆"><a href="#5-15-保持反射用到的类和与JavaScript进行交互的类不被混淆" class="headerlink" title="5.15 保持反射用到的类和与JavaScript进行交互的类不被混淆"></a>5.15 保持反射用到的类和与JavaScript进行交互的类不被混淆</h4><h2 id="6-自定义资源保持规则"><a href="#6-自定义资源保持规则" class="headerlink" title="6. 自定义资源保持规则"></a>6. 自定义资源保持规则</h2><h4 id="6-1-keep-xml"><a href="#6-1-keep-xml" class="headerlink" title="6.1 keep.xml"></a>6.1 keep.xml</h4><p>用<code>shrinkResources true</code>开启资源压缩后，所有未被使用的资源默认被移除。假如你需要定义哪些资源必须被保留，在<code>res/raw/</code>路径下创建一个xml文件，例如<code>keep.xml</code>。<br>通过一些属性的设置可以实现定义资源保持的需求，可配置的属性有：</p><ul><li><code>tools:keep</code> 定义哪些资源需要被保留（资源之间用“,”隔开）</li><li><code>tools:discard</code> 定义哪些资源需要被移除（资源之间用“,”隔开）</li><li><code>tools:shrinkMode</code> 开启严格模式<br>当代码中通过 <code>Resources.getIdentifier()</code> 用动态的字符串来获取并使用资源时，普通的资源引用检查就可能会有问题。例如，如下代码会导致所有以“img_”开头的资源都被标记为已使用。<pre class=" language-java"><code class="language-java"> String name <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"img_%1d"</span><span class="token punctuation">,</span> angle <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> res <span class="token operator">=</span> <span class="token function">getResources</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getIdentifier</span><span class="token punctuation">(</span>name<span class="token punctuation">,</span> <span class="token string">"drawable"</span><span class="token punctuation">,</span> <span class="token function">getPackageName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre>我们可以设置 <code>tools:shrinkMode</code> 为 <code>strict</code> 来开启严格模式，使只有确实被使用的资源被保留。<br>以上就是自定义资源保持规则相关的配置，举个例子：<pre class=" language-xml"><code class="language-xml"> <span class="token prolog">&lt;?xml version="1.0" encoding="utf-8"?></span> <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>resources</span> <span class="token attr-name"><span class="token namespace">xmlns:</span>tools</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>http://schemas.android.com/tools<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">tools:</span>keep</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@drawable/img_*,@drawable/ic_launcher,@layout/layout_used*<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">tools:</span>discard</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>@layout/layout_unused<span class="token punctuation">"</span></span>     <span class="token attr-name"><span class="token namespace">tools:</span>shrinkMode</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>strict<span class="token punctuation">"</span></span><span class="token punctuation">/></span></span></code></pre></li></ul><h4 id="6-2-移除替代资源"><a href="#6-2-移除替代资源" class="headerlink" title="6.2 移除替代资源"></a>6.2 移除替代资源</h4><p>一些替代资源，例如多语言支持的 <code>strings.xml</code>，多分辨率支持的 <code>layout.xml</code> 等，在我们不需要使用又不想删除掉时，可以使用资源压缩将它们移除。<br>我们使用 <code>resConfig</code> 属性来指定需要支持的属性，例如</p><pre class=" language-gradle"><code class="language-gradle">    android {        defaultConfig {            ...            resConfigs "en", "zh"        }    }</code></pre><p>其他未显式声明的语言资源将被移除。</p><h2 id="7-Proguard使用"><a href="#7-Proguard使用" class="headerlink" title="7. Proguard使用"></a>7. Proguard使用</h2><h4 id="7-1-开启混淆"><a href="#7-1-开启混淆" class="headerlink" title="7.1 开启混淆"></a>7.1 开启混淆</h4><p>在项目的可执行工程Module中打开<code>build.gradle</code>文件进行编辑：</p><pre class=" language-gradle"><code class="language-gradle">android {    ......    defaultConfig {        ......    }    buildTypes {        release {            minifyEnabled true      // 开启代码混淆            zipAlignEnabled true    // 开启Zip压缩优化            shrinkResources true    // 移除未被使用的资源            proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'        }    }    ......}</code></pre><ul><li>minifyEnabled：是否进行代码混淆</li><li>zipAlignEnabled：是否进行Zip压缩优化</li><li>shrinkResources：是否移除未被使用的资源</li><li>proguardFiles：混淆规则配置文件<ul><li>proguard-android.txt：AndroidStudio默认自动导入的规则，这个文件位于Android SDK根目录\tools\proguard\proguard-android.txt。这里面是一些比较常规的不能被混淆的代码规则。</li><li>proguard-rules.pro：针对自己的项目需要特别定义的混淆规则，它位于项目每个Module的根目录下面，里面的内容需要我们自己编写。</li></ul></li></ul><h4 id="7-2-编写混淆规则"><a href="#7-2-编写混淆规则" class="headerlink" title="7.2 编写混淆规则"></a>7.2 编写混淆规则</h4><pre class=" language-pro"><code class="language-pro"># --------------------------------------------基本指令区--------------------------------------------#-ignorewarning                                      # 是否忽略警告-optimizationpasses 5                               # 指定代码的压缩级别(在0~7之间，默认为5)-dontusemixedcaseclassnames                         # 是否使用大小写混合(windows大小写不敏感，建议加入)-dontskipnonpubliclibraryclasses                    # 是否混淆非公共的库的类-dontskipnonpubliclibraryclassmembers               # 是否混淆非公共的库的类的成员-dontpreverify                                      # 混淆时是否做预校验(Android不需要预校验，去掉可以加快混淆速度)-verbose                                            # 混淆时是否记录日志(混淆后会生成映射文件)#指定外部模糊字典-obfuscationdictionary dictionary1.txt#指定class模糊字典-classobfuscationdictionary dictionary1.txt#指定package模糊字典-packageobfuscationdictionary dictionary2.txt# 混淆时所采用的算法(谷歌推荐算法)-optimizations !code/simplification/arithmetic,!field/*,!class/merging/*,!code/allocation/variable# 添加支持的jar(引入libs下的所有jar包)-libraryjars libs(*.jar;)# 将文件来源重命名为“SourceFile”字符串-renamesourcefileattribute SourceFile# 保持注解不被混淆-keepattributes *Annotation*-keep class * extends java.lang.annotation.Annotation {*;}# 保持泛型不被混淆-keepattributes Signature# 保持反射不被混淆-keepattributes EnclosingMethod# 保持异常不被混淆-keepattributes Exceptions# 保持内部类不被混淆-keepattributes Exceptions,InnerClasses# 抛出异常时保留代码行号-keepattributes SourceFile,LineNumberTable# --------------------------------------------默认保留区--------------------------------------------## 保持基本组件不被混淆-keep public class * extends android.app.Fragment-keep public class * extends android.app.Activity-keep public class * extends android.app.Application-keep public class * extends android.app.Service-keep public class * extends android.content.BroadcastReceiver-keep public class * extends android.content.ContentProvider-keep public class * extends android.app.backup.BackupAgentHelper-keep public class * extends android.preference.Preference# 保持 Google 原生服务需要的类不被混淆-keep public class com.google.vending.licensing.ILicensingService-keep public class com.android.vending.licensing.ILicensingService# Support包规则-dontwarn android.support.**-keep public class * extends android.support.v4.**-keep public class * extends android.support.v7.**-keep public class * extends android.support.annotation.**# 保持 native 方法不被混淆-keepclasseswithmembernames class * {    native <methods>;}# 保留自定义控件(继承自View)不被混淆-keep public class * extends android.view.View {    *** get*();    void set*(***);    public <init>(android.content.Context);    public <init>(android.content.Context, android.util.AttributeSet);    public <init>(android.content.Context, android.util.AttributeSet, int);}# 保留指定格式的构造方法不被混淆-keepclasseswithmembers class * {    public <init>(android.content.Context, android.util.AttributeSet);    public <init>(android.content.Context, android.util.AttributeSet, int);}# 保留在Activity中的方法参数是view的方法(避免布局文件里面onClick被影响)-keepclassmembers class * extends android.app.Activity {    public void *(android.view.View);}# 保持枚举 enum 类不被混淆-keepclassmembers enum * {    public static **[] values();    public static ** valueOf(java.lang.String);}# 保持R(资源)下的所有类及其方法不能被混淆-keep class **.R$* { *; }# 保持 Parcelable 序列化的类不被混淆(注：aidl文件不能去混淆)-keep class * implements android.os.Parcelable {    public static final android.os.Parcelable$Creator *;}# 需要序列化和反序列化的类不能被混淆(注：Java反射用到的类也不能被混淆)-keepnames class * implements java.io.Serializable# 保持 Serializable 序列化的类成员不被混淆-keepclassmembers class * implements java.io.Serializable {    static final long serialVersionUID;    private static final java.io.ObjectStreamField[] serialPersistentFields;    !static !transient <fields>;    !private <fields>;    !private <methods>;    private void writeObject(java.io.ObjectOutputStream);    private void readObject(java.io.ObjectInputStream);    java.lang.Object writeReplace();    java.lang.Object readResolve();}# 保持 BaseAdapter 类不被混淆-keep public class * extends android.widget.BaseAdapter { *; }# 保持 CusorAdapter 类不被混淆-keep public class * extends android.widget.CusorAdapter{ *; }# --------------------------------------------webView区--------------------------------------------## WebView处理，项目中没有使用到webView忽略即可# 保持Android与JavaScript进行交互的类不被混淆-keep class **.AndroidJavaScript { *; }-keepclassmembers class * extends android.webkit.WebViewClient {     public void *(android.webkit.WebView,java.lang.String,android.graphics.Bitmap);     public boolean *(android.webkit.WebView,java.lang.String);}-keepclassmembers class * extends android.webkit.WebChromeClient {     public void *(android.webkit.WebView,java.lang.String);}# 网络请求相关-keep public class android.net.http.SslError# --------------------------------------------删除代码区--------------------------------------------## 删除代码中Log相关的代码-assumenosideeffects class android.util.Log {    public static boolean isLoggable(java.lang.String, int);    public static int v(...);    public static int i(...);    public static int w(...);    public static int d(...);    public static int e(...);}# --------------------------------------------可定制化区--------------------------------------------##---------------------------------1.实体类---------------------------------#--------------------------------------------------------------------------#---------------------------------2.与JS交互的类-----------------------------#--------------------------------------------------------------------------#---------------------------------3.反射相关的类和方法-----------------------#--------------------------------------------------------------------------#---------------------------------2.第三方依赖--------------------------------#--------------------------------------------------------------------------</code></pre>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> Proguard </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>国内各大互联网公司技术团队站点</title>
      <link href="/posts/2018/b36d7096.html"/>
      <url>/posts/2018/b36d7096.html</url>
      
        <content type="html"><![CDATA[<p>利用闲暇时间整理了一份国内各大互联网公司的相关技术站点，希望能够对大家有所帮助，也欢迎各位帮忙补充。</p><h2 id="1-腾讯系列"><a href="#1-腾讯系列" class="headerlink" title="1.腾讯系列"></a>1.腾讯系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>财付通设计中心TID</td><td>地址：<a href="http://fitdesign.tencent.com/" target="_blank" rel="noopener">http://fitdesign.tencent.com/</a></td></tr><tr><td>QQ邮箱博客</td><td>地址：<a href="http://blog.mail.qq.com/" target="_blank" rel="noopener">http://blog.mail.qq.com/</a></td></tr><tr><td>腾讯用户研究与体验设计部CDC</td><td>地址：<a href="http://cdc.tencent.com/" target="_blank" rel="noopener">http://cdc.tencent.com/</a></td></tr><tr><td>腾讯游戏官方设计团队TGideas</td><td>地址：<a href="http://tgideas.qq.com/" target="_blank" rel="noopener">http://tgideas.qq.com/</a></td></tr><tr><td>腾讯移动互联网设计团队MXD</td><td>地址：<a href="http://mxd.tencent.com/" target="_blank" rel="noopener">http://mxd.tencent.com/</a></td></tr><tr><td>腾讯社交用户体验设计部ISUX</td><td>地址：<a href="https://isux.tencent.com/" target="_blank" rel="noopener">https://isux.tencent.com/</a></td></tr><tr><td>腾讯大讲堂</td><td>地址：<a href="http://djt.qq.com/" target="_blank" rel="noopener">http://djt.qq.com/</a></td></tr><tr><td>腾讯Web前端Alloy团队Blog</td><td>地址：<a href="http://www.alloyteam.com/" target="_blank" rel="noopener">http://www.alloyteam.com/</a></td></tr><tr><td>腾讯Web前端IMWEB团队</td><td>地址：<a href="http://imweb.github.io/" target="_blank" rel="noopener">http://imweb.github.io/</a></td></tr><tr><td>腾讯大讲堂</td><td>地址：<a href="http://djt.qq.com/" target="_blank" rel="noopener">http://djt.qq.com/</a></td></tr><tr><td>腾讯大讲堂</td><td>地址：<a href="http://djt.qq.com/" target="_blank" rel="noopener">http://djt.qq.com/</a></td></tr><tr><td>腾讯大讲堂</td><td>地址：<a href="http://djt.qq.com/" target="_blank" rel="noopener">http://djt.qq.com/</a></td></tr></tbody></table><h2 id="2-阿里系列"><a href="#2-阿里系列" class="headerlink" title="2.阿里系列"></a>2.阿里系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>阿里巴巴中国站用户体验设计部UED</td><td>地址：<a href="http://www.aliued.cn/" target="_blank" rel="noopener">http://www.aliued.cn/</a></td></tr><tr><td>阿里巴巴国际站UED团队</td><td>地址：<a href="http://www.aliued.com/" target="_blank" rel="noopener">http://www.aliued.com/</a></td></tr><tr><td>阿里妈妈MUX</td><td>地址：<a href="http://mux.alimama.com/" target="_blank" rel="noopener">http://mux.alimama.com/</a></td></tr><tr><td>阿里中间件团队博客</td><td>地址：<a href="http://jm.taobao.org/" target="_blank" rel="noopener">http://jm.taobao.org/</a></td></tr><tr><td>淘宝前端团队FED</td><td>地址：<a href="http://taobaofed.org/" target="_blank" rel="noopener">http://taobaofed.org/</a></td></tr></tbody></table><h2 id="3-百度系列"><a href="#3-百度系列" class="headerlink" title="3.百度系列"></a>3.百度系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>百度Web前端研发部FEX</td><td>地址：<a href="http://fex.baidu.com/" target="_blank" rel="noopener">http://fex.baidu.com/</a></td></tr><tr><td>百度移动用户体验部MUX</td><td>地址：<a href="http://mux.baidu.com/" target="_blank" rel="noopener">http://mux.baidu.com/</a></td></tr><tr><td>百度用户体验中心SUX</td><td>地址：<a href="http://ued.baidu.com/#/home" target="_blank" rel="noopener">http://ued.baidu.com/#/home</a></td></tr><tr><td>百度EFE(Excellent FrontEnd)</td><td>地址：<a href="http://efe.baidu.com/" target="_blank" rel="noopener">http://efe.baidu.com/</a></td></tr><tr><td>百度企业产品用户体验中心EUX</td><td>地址：<a href="http://eux.baidu.com/" target="_blank" rel="noopener">http://eux.baidu.com/</a></td></tr></tbody></table><h2 id="4-搜狐系列"><a href="#4-搜狐系列" class="headerlink" title="4.搜狐系列"></a>4.搜狐系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>搜狐畅游视觉设计中心团队VC</td><td>地址：<a href="http://vc.changyou.com/index.shtml" target="_blank" rel="noopener">http://vc.changyou.com/index.shtml</a></td></tr></tbody></table><h2 id="5-新浪系列"><a href="#5-新浪系列" class="headerlink" title="5.新浪系列"></a>5.新浪系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>新浪UED</td><td>地址：<a href="http://ued.sina.com/" target="_blank" rel="noopener">http://ued.sina.com/</a></td></tr></tbody></table><h2 id="6-360系列"><a href="#6-360系列" class="headerlink" title="6.360系列"></a>6.360系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>360奇舞团前端团队75Team</td><td>地址：<a href="https://75team.com/" target="_blank" rel="noopener">https://75team.com/</a></td></tr><tr><td>360UXC用户体验设计中心</td><td>地址：<a href="http://uxc.360.cn/" target="_blank" rel="noopener">http://uxc.360.cn/</a></td></tr></tbody></table><h2 id="7-网易系列"><a href="#7-网易系列" class="headerlink" title="7.网易系列"></a>7.网易系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>网易用户体验设计中心UEDC</td><td>地址：<a href="http://uedc.163.com/" target="_blank" rel="noopener">http://uedc.163.com/</a></td></tr><tr><td>网易云课堂</td><td>地址：<a href="http://study.163.com/" target="_blank" rel="noopener">http://study.163.com/</a></td></tr></tbody></table><h2 id="8-美团系列"><a href="#8-美团系列" class="headerlink" title="8.美团系列"></a>8.美团系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>美团技术团队博客</td><td>地址：<a href="http://tech.meituan.com/" target="_blank" rel="noopener">http://tech.meituan.com/</a></td></tr></tbody></table><h2 id="9-京东系列"><a href="#9-京东系列" class="headerlink" title="9.京东系列"></a>9.京东系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>京东设计中心JDC</td><td>地址：<a href="http://jdc.jd.com/" target="_blank" rel="noopener">http://jdc.jd.com/</a></td></tr></tbody></table><h2 id="10-携程系列"><a href="#10-携程系列" class="headerlink" title="10.携程系列"></a>10.携程系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>携程设计委员会</td><td>地址：<a href="http://ued.ctrip.com/" target="_blank" rel="noopener">http://ued.ctrip.com/</a></td></tr></tbody></table><h2 id="11-蘑菇街系列"><a href="#11-蘑菇街系列" class="headerlink" title="11.蘑菇街系列"></a>11.蘑菇街系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>蘑菇街技术博客</td><td>地址：<a href="https://tech.meili-inc.com/" target="_blank" rel="noopener">https://tech.meili-inc.com/</a></td></tr></tbody></table><h2 id="12-迅雷系列"><a href="#12-迅雷系列" class="headerlink" title="12.迅雷系列"></a>12.迅雷系列</h2><table><thead><tr><th>名称</th><th>地址</th></tr></thead><tbody><tr><td>迅雷用户体验设计中心CUED</td><td>地址：<a href="http://cued.xunlei.com/" target="_blank" rel="noopener">http://cued.xunlei.com/</a></td></tr></tbody></table><h2 id="致谢"><a href="#致谢" class="headerlink" title="致谢"></a>致谢</h2><p><a href="https://www.cnblogs.com/IT-Bear/p/5566506.html" target="_blank" rel="noopener">IT-Bear</a></p>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Android 学习文档整理收集</title>
      <link href="/posts/2018/902f4e00.html"/>
      <url>/posts/2018/902f4e00.html</url>
      
        <content type="html"><![CDATA[<p>利用闲暇时间整理了一份 <code>Android</code> 学习文档整理收集，希望能够对大家有所帮助，也欢迎各位帮忙补充。</p><h2 id="Android"><a href="#Android" class="headerlink" title="Android"></a>Android</h2><ul><li><a href="http://www.runoob.com/w3cnote/android-tutorial-contents.html" target="_blank" rel="noopener">Android基础入门教程</a></li><li><a href="https://so.csdn.net/so/search/s.do?q=android" target="_blank" rel="noopener">CSDN主题Android专栏</a></li><li><a href="http://www.runoob.com/w3cnote/android-tutorial-contents.html" target="_blank" rel="noopener">极客头条Android开发者</a></li><li><a href="http://www.android-studio.org/" target="_blank" rel="noopener">Android Studio中文社区</a></li><li><a href="https://developer.android.com/" target="_blank" rel="noopener">Android Developers</a></li><li><a href="https://developer.android.google.cn/" target="_blank" rel="noopener">Android Developers(中文)</a></li><li><a href="https://android-developers.googleblog.com/" target="_blank" rel="noopener">Android Developers Blog</a></li><li><a href="http://www.runoob.com/w3cnote/android-tutorial-contents.html" target="_blank" rel="noopener">AndroidDevTools</a></li><li><a href="https://www.androidweekly.cn/" target="_blank" rel="noopener">Android 开发技术周报</a></li><li><a href="http://www.androidblog.cn/" target="_blank" rel="noopener">Android Blog 周刊</a></li><li><a href="http://www.androidchina.net/" target="_blank" rel="noopener">Android 开发中文站</a></li><li><a href="http://androidblog.cn/tools/" target="_blank" rel="noopener">Android 工具汇总</a></li><li><a href="http://www.androidblog.cn/index.php/Source/index/p/1" target="_blank" rel="noopener">Android 最新源码汇总</a></li><li><a href="https://www.androidos.net.cn/sourcecode" target="_blank" rel="noopener">Android 源码阅读</a></li><li><a href="http://www.embeddedlinux.org.cn/androidapi/" target="_blank" rel="noopener">Android API 中文版</a></li><li><a href="http://hukai.me/android-training-course-in-chinese/index.html" target="_blank" rel="noopener">Android 官方培训课程中文版</a></li><li><a href="https://chinagdg.org/" target="_blank" rel="noopener">Google 中国开发者社区</a></li><li><a href="http://www.hawstein.com/posts/google-java-style.html" target="_blank" rel="noopener">Google Java编程风格指南中文版</a></li><li><a href="https://gradle.org/" target="_blank" rel="noopener">Gradle Build Tool</a></li><li><a href="https://services.gradle.org/distributions/" target="_blank" rel="noopener">Gradle 各版本下载</a></li><li><a href="http://avatarqing.github.io/Gradle-Plugin-User-Guide-Chinese-Verision/index.html" target="_blank" rel="noopener">Gradle 插件使用指南中文版</a></li><li><a href="https://bintray.com/" target="_blank" rel="noopener">Bintray</a></li><li><a href="https://mvnrepository.com/" target="_blank" rel="noopener">Maven Repository</a></li><li><a href="http://www.runoob.com/sqlite/sqlite-tutorial.html" target="_blank" rel="noopener">SQLite教程</a></li><li><a href="http://www.runoob.com/json/json-tutorial.html" target="_blank" rel="noopener">JSON教程</a></li><li><a href="http://www.runoob.com/xml/xml-tutorial.html" target="_blank" rel="noopener">XML教程</a></li></ul><h2 id="学习网站"><a href="#学习网站" class="headerlink" title="学习网站"></a>学习网站</h2><ul><li><a href="https://juejin.im/timeline" target="_blank" rel="noopener">掘金</a></li><li><a href="https://www.jianshu.com/" target="_blank" rel="noopener">简书</a></li><li><a href="https://www.csdn.net/" target="_blank" rel="noopener">CSDN</a></li><li><a href="https://www.v2ex.com/" target="_blank" rel="noopener">V2EX</a></li><li><a href="http://www.trinea.cn/" target="_blank" rel="noopener">Trinea</a></li><li><a href="http://p.codekk.com/" target="_blank" rel="noopener">codeKK</a></li><li><a href="https://sdk.cn/" target="_blank" rel="noopener">SDK.CN</a></li><li><a href="http://blog.51cto.com/android" target="_blank" rel="noopener">51CTO</a></li><li><a href="http://www.codeceo.com/" target="_blank" rel="noopener">码农网</a></li><li><a href="https://www.imooc.com/" target="_blank" rel="noopener">慕课网</a></li><li><a href="https://www.yiibai.com/" target="_blank" rel="noopener">易百教程</a></li><li><a href="http://www.apkbus.com/" target="_blank" rel="noopener">安卓巴士</a></li><li><a href="http://www.jikedaohang.com/" target="_blank" rel="noopener">极客导航</a></li><li><a href="https://www.jikexueyuan.com/" target="_blank" rel="noopener">极客学院</a></li><li><a href="https://gank.io/" target="_blank" rel="noopener">干货集中营</a></li><li><a href="http://www.jcodecraeer.com/" target="_blank" rel="noopener">泡在网上的日子</a></li><li><a href="https://www.oschina.net/" target="_blank" rel="noopener">开源中国社区</a></li><li><a href="https://tool.oschina.net/" target="_blank" rel="noopener">在线工具</a></li><li><a href="http://tool.chinaz.com/" target="_blank" rel="noopener">站长工具</a></li><li><a href="https://stackoverflow.com/" target="_blank" rel="noopener">Stack Overflow</a></li><li><a href="https://android-arsenal.com/" target="_blank" rel="noopener">Android Arsenal</a></li><li><a href="http://alamkanak.github.io/android-libraries-and-resources/" target="_blank" rel="noopener">Android Libraries and Resources</a></li></ul><h2 id="CSDN知识库"><a href="#CSDN知识库" class="headerlink" title="CSDN知识库"></a>CSDN知识库</h2><ul><li><a href="http://lib.csdn.net/base/android" target="_blank" rel="noopener">Android知识库</a></li><li><a href="http://lib.csdn.net/base/java" target="_blank" rel="noopener">Java语言</a></li><li><a href="http://lib.csdn.net/base/c" target="_blank" rel="noopener">C语言</a></li><li><a href="http://lib.csdn.net/base/cplusplus" target="_blank" rel="noopener">C++语言</a></li><li><a href="http://lib.csdn.net/base/ai" target="_blank" rel="noopener">人工智能基础</a></li><li><a href="http://lib.csdn.net/base/aiframework" target="_blank" rel="noopener">人工智能开发框架</a></li><li><a href="http://lib.csdn.net/base/aimachinelearning" target="_blank" rel="noopener">人工智能机器学习</a></li><li><a href="http://lib.csdn.net/base/machinelearning" target="_blank" rel="noopener">机器学习</a></li><li><a href="http://lib.csdn.net/base/vras" target="_blank" rel="noopener">语音识别与合成</a></li><li><a href="http://lib.csdn.net/base/vr" target="_blank" rel="noopener">虚拟现实(VR)</a></li><li><a href="http://lib.csdn.net/base/reactnative" target="_blank" rel="noopener">React Native</a></li><li><a href="http://lib.csdn.net/base/git" target="_blank" rel="noopener">Git</a></li><li><a href="http://lib.csdn.net/base/softwaretest" target="_blank" rel="noopener">软件测试</a></li><li><a href="http://lib.csdn.net/base/html5" target="_blank" rel="noopener">Html5</a></li></ul><h2 id="Kotlin"><a href="#Kotlin" class="headerlink" title="Kotlin"></a>Kotlin</h2><ul><li><a href="http://kotlinlang.org/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://www.kotlincn.net/" target="_blank" rel="noopener">官方网站(中文)</a></li><li><a href="http://try.kotlinlang.org/" target="_blank" rel="noopener">在线示例</a></li><li><a href="http://www.runoob.com/kotlin/kotlin-tutorial.html" target="_blank" rel="noopener">Kotlin 教程</a></li><li><a href="https://www.kotliner.cn/" target="_blank" rel="noopener">Kotlin 博客</a></li><li><a href="https://discuss.kotliner.cn/" target="_blank" rel="noopener">Kotlin 论坛</a></li><li><a href="https://www.kotlincn.net/community/" target="_blank" rel="noopener">Kotlin 社区</a></li><li><a href="https://c.runoob.com/compile/2960" target="_blank" rel="noopener">Kotlin 在线工具</a></li><li><a href="https://github.com/android/android-ktx/" target="_blank" rel="noopener">Android KTX</a></li><li><a href="https://github.com/xitu/awesome-kotlin-cn" target="_blank" rel="noopener">Kotlin 资源大全</a></li><li><a href="https://github.com/JetBrains/kotlin" target="_blank" rel="noopener">Kotlin on GitHub</a></li></ul><h2 id="Flutter"><a href="#Flutter" class="headerlink" title="Flutter"></a>Flutter</h2><ul><li><a href="https://flutter.io/" target="_blank" rel="noopener">官方网站</a></li><li><a href="http://doc.flutter-dev.cn/" target="_blank" rel="noopener">官方网站(中文)</a></li><li><a href="https://flutterchina.club/" target="_blank" rel="noopener">Flutter 中文网</a></li><li><a href="https://www.aliyun.com/jiaocheng/topic_3593.html" target="_blank" rel="noopener">Flutter 教程</a></li><li><a href="https://github.com/flutter" target="_blank" rel="noopener">Flutter on GitHub</a></li><li><a href="https://flutter-io.cn/" target="_blank" rel="noopener">Flutter 社区中文资源</a></li><li><a href="http://flutter-dev.cn/" target="_blank" rel="noopener">Flutter 中文开发者论坛</a></li><li><a href="https://github.com/flutter-dev" target="_blank" rel="noopener">Flutter 中文开发者(GitHub)</a></li><li><a href="https://twitter.com/flutterio" target="_blank" rel="noopener">Flutter(Twitter)</a></li><li><a href="https://material.io/develop/flutter/" target="_blank" rel="noopener">Develop for Flutter(Material.io)</a></li></ul><h2 id="快应用"><a href="#快应用" class="headerlink" title="快应用"></a>快应用</h2><ul><li><a href="https://www.quickapp.cn/" target="_blank" rel="noopener">官方网站</a></li><li><a href="https://doc.quickapp.cn/" target="_blank" rel="noopener">开发文档</a></li><li><a href="https://bbs.quickapp.cn/" target="_blank" rel="noopener">官方论坛</a></li><li><a href="https://quickapp.dcloud.io/" target="_blank" rel="noopener">工具服务</a></li></ul><h2 id="小程序"><a href="#小程序" class="headerlink" title="小程序"></a>小程序</h2><ul><li><a href="https://developers.weixin.qq.com/ebook?action=get_post_info&amp;book=miniprogram&amp;docid=0008aeea9a8978ab0086a685851c0a" target="_blank" rel="noopener">小程序开发指南</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/index.html" target="_blank" rel="noopener">小程序开发教程</a></li><li><a href="https://developers.weixin.qq.com/miniprogram/dev/api/" target="_blank" rel="noopener">小程序接口文档</a></li><li><a href="https://developers.weixin.qq.com/home?action=get_specific_blog_list&amp;blogcategory=512" target="_blank" rel="noopener">小程序故事</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 学习笔记 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
            <tag> 学习笔记 </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>使用 Hexo + GitHub Pages 搭建个人博客</title>
      <link href="/posts/2018/26c3db75.html"/>
      <url>/posts/2018/26c3db75.html</url>
      
        <content type="html"><![CDATA[<h2 id="搭建-Node-js-环境"><a href="#搭建-Node-js-环境" class="headerlink" title="搭建 Node.js 环境"></a>搭建 Node.js 环境</h2><p>Node.js 是一个基于 Chrome V8 引擎的 JavaScript 运行环境。Node.js 使用了一个事件驱动、非阻塞式 I/O 的模型，使其轻量又高效。Node.js 可以在非浏览器环境下，解释运行 JS 代码。</p><p>在 <a href="https://nodejs.org/en/" target="_blank" rel="noopener">Node.js 官网</a> 下载安装包，保持默认设置，一路 Next 即可快速完成安装。</p><p>安装完成后打开命令提示符，输入 <code>node -v</code>、<code>npm -v</code>，正确输出版本号则说明 Node.js 环境配置成功！</p><blockquote><p>为什么要搭建 Node.js 环境？ - 因为 Hexo 博客系统是基于 Node.js 编写的。</p></blockquote><h2 id="搭建-Git-环境"><a href="#搭建-Git-环境" class="headerlink" title="搭建 Git 环境"></a>搭建 Git 环境</h2><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。</p><p>在 <a href="https://git-scm.com/" target="_blank" rel="noopener">Git 官网</a> 下载安装包，保持默认设置，一路 Next 即可快速完成安装。</p><p>安装完成后在电脑桌面点击右键，打开 <code>Git Bush Here</code>，输入 <code>git --version</code>，正确输出版本号则说明 Git 环境配置成功！</p><blockquote><p>为什么要搭建 Git 环境？ - 因为需要把本地的网页和文章等提交到 GitHub 上。</p></blockquote><h2 id="创建-GitHub-配置"><a href="#创建-GitHub-配置" class="headerlink" title="创建 GitHub 配置"></a>创建 GitHub 配置</h2><p>GitHub 是一个面向开源及私有软件项目的托管平台，因为只支持 Git 作为唯一的版本库格式进行托管，故名 GitHub。</p><p>GitHub Pages 本用于介绍托管在GitHub的项目，不过，由于他的空间免费稳定，用来做搭建一个博客再好不过了。</p><h3 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h3><p>在 <a href="https://github.com/" target="_blank" rel="noopener">GitHub 官网</a> 注册一个账号，完成注册后，在我们的 GitHub 上面右上角的 <code>New repository</code> 来创建一个仓库。</p><blockquote><p><strong>注意：</strong> 仓库名必须遵守相应格式：<code>username.github.io</code>，这样子在访问主页的时候直接用 <code>username.github.io</code> 就能访问。<code>username</code> 是你注册的 GitHub 用户名。</p></blockquote><h3 id="GitHub-Pages"><a href="#GitHub-Pages" class="headerlink" title="GitHub Pages"></a>GitHub Pages</h3><p>仓库创建完成后，开始设置我们的 GitHub Pages。打开我们刚刚创建的仓库，然后点开 <code>Settings</code>，移到 <code>GitHub Pages</code>，点击 <code>Choose a theme</code> 进入主题选择页面，选择一个主题，然后点击 <code>Select theme</code> 即可。</p><p>完成上面的配置后，访问 <code>your_username.github.io</code>，如果可以正常访问，那么 Github 的配置已经结束了。。</p><h2 id="安装配置-Hexo"><a href="#安装配置-Hexo" class="headerlink" title="安装配置 Hexo"></a>安装配置 Hexo</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="https://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。</p><p>Hexo 详细介绍请阅读 <a href="./hello-hexo/">Hello Hexo</a> 或 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo 官网</a> 。</p><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><p>安装完成后打开 <code>Git Bush Here</code>，输入 <code>hexo version</code>，正确输出版本号则说明 Hexo 环境配置成功！</p><h3 id="初始化-Hexo"><a href="#初始化-Hexo" class="headerlink" title="初始化 Hexo"></a>初始化 Hexo</h3><p>安装 Hexo 完成后，请执行下列命令来初始化 Hexo，Hexo 将会在指定文件夹中新建所需要的文件：</p><pre class=" language-bash"><code class="language-bash">$ hexo init Blog$ <span class="token function">cd</span> Blog$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>也可以直接 <code>clone</code> 前面所创建的 <code>your_username.github.io</code> 替代 <code>Blog</code> 目录。</p><p>完成上面的初始化工作后，指定文件夹的目录如下：</p><pre><code>.├── .deploy             # 需要部署的文件├── node_modules        # Hexo插件├── public              # 生成的静态网页文件├── scaffolds           # 模板├── source              # 博客正文和其他源文件，404、favicon、CNAME 都应该放在这里| ├── _drafts           # 草稿| └── _posts            # 文章├── themes              # 主题├── _config.yml         # 全局配置文件└── package.json        # npm 依赖等</code></pre><h3 id="运行本地-Hexo-服务"><a href="#运行本地-Hexo-服务" class="headerlink" title="运行本地 Hexo 服务"></a>运行本地 Hexo 服务</h3><pre class=" language-bash"><code class="language-bash">$ hexo serveror$ hexo s</code></pre><p>通过 <code>hexo server</code> 命令启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。如果 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 能够正常访问，则说明 Hexo 本地博客已经搭建起来了，只是本地哦，别人看不到的。</p><h2 id="修改-Hexo-配置"><a href="#修改-Hexo-配置" class="headerlink" title="修改 Hexo 配置"></a>修改 Hexo 配置</h2><p>您可以在站点主目录的 <code>_config.yml</code> 文件中修改大部份的配置。</p><h3 id="Site"><a href="#Site" class="headerlink" title="Site"></a>Site</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：<code>America/New_York</code>、 <code>Japan</code> 和 <code>UTC</code> 。</td></tr></tbody></table><p>其中，<code>description</code> 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code> 参数用于主题显示文章的作者。</p><h3 id="URL"><a href="#URL" class="headerlink" title="URL"></a>URL</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td><td></td></tr><tr><td><code>root</code></td><td>网站根目录</td><td></td></tr><tr><td><code>permalink</code></td><td>文章的 <a href="https://hexo.io/docs/permalinks" target="_blank" rel="noopener">永久链接</a> 格式</td><td><code>:year/:month/:day/:title/</code></td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr></tbody></table><blockquote><p>   如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。建议 <code>permalink</code> 后面跟着的内容最好不要超过两个斜杠，影响爬虫爬取，因为一般搜索引擎爬虫不爬取深度超过三层的内容。</p></blockquote><h3 id="Directory"><a href="#Directory" class="headerlink" title="Directory"></a>Directory</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>source_dir</code></td><td>资源文件夹，这个文件夹用来存放内容。</td><td><code>source</code></td></tr><tr><td><code>public_dir</code></td><td>公共文件夹，这个文件夹用于存放生成的站点文件。</td><td><code>public</code></td></tr><tr><td><code>tag_dir</code></td><td>标签文件夹</td><td><code>tags</code></td></tr><tr><td><code>archive_dir</code></td><td>归档文件夹</td><td><code>archives</code></td></tr><tr><td><code>category_dir</code></td><td>分类文件夹</td><td><code>categories</code></td></tr><tr><td><code>code_dir</code></td><td>Include code 文件夹</td><td><code>downloads/code</code></td></tr><tr><td><code>i18n_dir</code></td><td>国际化（i18n）文件夹</td><td><code>:lang</code></td></tr><tr><td><code>skip_render</code></td><td>跳过指定文件的渲染，您可使用 <a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob 表达式</a>来匹配路径。</td></tr></tbody></table><blockquote><p>   提示：如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h3 id="Writing"><a href="#Writing" class="headerlink" title="Writing"></a>Writing</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>new_post_name</code></td><td>新文章的文件名称</td><td>:title.md</td></tr><tr><td><code>default_layout</code></td><td>预设布局</td><td>post</td></tr><tr><td><code>auto_spacing</code></td><td>在中文和英文之间加入空格</td><td>false</td></tr><tr><td><code>titlecase</code></td><td>把标题转换为 title case</td><td>false</td></tr><tr><td><code>external_link</code></td><td>在新标签中打开链接</td><td>true</td></tr><tr><td><code>filename_case</code></td><td>把文件名称转换为 (1) 小写或 (2) 大写</td><td>0</td></tr><tr><td><code>render_drafts</code></td><td>显示草稿</td><td>false</td></tr><tr><td><code>post_asset_folder</code></td><td>启动 Asset 文件夹</td><td>false</td></tr><tr><td><code>relative_link</code></td><td>把链接改为与根目录的相对位址</td><td>false</td></tr><tr><td><code>future</code></td><td>显示未来的文章</td><td>true</td></tr><tr><td><code>highlight</code></td><td>代码块的设置</td></tr></tbody></table><blockquote><p>   默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>，您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是绝对于域名的。<br>   相对链接像这样：`/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h3 id="Category-amp-Tag"><a href="#Category-amp-Tag" class="headerlink" title="Category &amp; Tag"></a>Category &amp; Tag</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>default_category</code></td><td>默认分类</td><td>uncategorized</td></tr><tr><td><code>category_map</code></td><td>分类别名</td><td></td></tr><tr><td><code>tag_map</code></td><td>标签别名</td></tr></tbody></table><h3 id="Date-Time-format"><a href="#Date-Time-format" class="headerlink" title="Date / Time format"></a>Date / Time format</h3><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>date_format</code></td><td>日期格式</td><td>YYYY-MM-DD</td></tr><tr><td><code>time_format</code></td><td>时间格式</td><td>H:mm:ss</td></tr></tbody></table><h3 id="Pagination"><a href="#Pagination" class="headerlink" title="Pagination"></a>Pagination</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>per_page</code></td><td>每页显示的文章量 (0 = 关闭分页功能)</td><td>10</td></tr><tr><td><code>pagination_dir</code></td><td>分页目录</td><td>page</td></tr></tbody></table><h3 id="Extensions"><a href="#Extensions" class="headerlink" title="Extensions"></a>Extensions</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>theme</code></td><td>当前主题名称。值为 <code>false</code> 时禁用主题</td></tr><tr><td><code>deploy</code></td><td>部署部分的设置</td></tr></tbody></table><h2 id="更改-Hexo-主题"><a href="#更改-Hexo-主题" class="headerlink" title="更改 Hexo 主题"></a>更改 Hexo 主题</h2><p>官方主题库：<a href="https://hexo.io/themes/" target="_blank" rel="noopener">https://hexo.io/themes/</a></p><p>Hexo 主题非常多，推荐使用 <a href="https://github.com/iissnan/theme-next-docs" target="_blank" rel="noopener"><code>NexT</code></a> 为主题，请阅读 NexT 的官方文档(<a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">http://theme-next.iissnan.com/</a>) ，5 分钟快速安装。</p><h3 id="下载主题"><a href="#下载主题" class="headerlink" title="下载主题"></a>下载主题</h3><p>在终端窗口下，定位到 Hexo 站点主目录下。使用 <code>Git</code> checkout 代码：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">cd</span> your-hexo-site$ <span class="token function">git</span> clone https://github.com/iissnan/hexo-theme-next themes/next</code></pre><h3 id="启用主题"><a href="#启用主题" class="headerlink" title="启用主题"></a>启用主题</h3><p>与所有 Hexo 主题启用的模式一样。当克隆/下载完成后，打开站点主目录下的 <code>_config.yml</code> 文件，找到 <code>theme</code> 字段，并将其值更改为 <code>next</code>。</p><pre class=" language-yml"><code class="language-yml">theme: next</code></pre><p>到此，NexT 主题安装完成。下一步我们将验证主题是否正确启用。在切换主题之后、验证之前， 我们最好使用 <code>hexo clean</code> 来清除 Hexo 的缓存。</p><h3 id="验证主题"><a href="#验证主题" class="headerlink" title="验证主题"></a>验证主题</h3><p>首先启动 Hexo 本地站点，并开启调试模式（即加上 <code>--debug</code>），整个命令是 <code>hexo s --debug</code>。 在服务启动的过程，注意观察命令行输出是否有任何异常信息，如果你碰到问题，这些信息将帮助他人更好的定位错误。 当命令行输出中提示出：</p><pre class=" language-bash"><code class="language-bash">INFO  Start processingINFO  Hexo is running at http://localhost:4000 <span class="token keyword">.</span> Press Ctrl+C to stop.</code></pre><p>此时即可使用浏览器访问 <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> ，检查站点是否正确运行。</p><blockquote><p> 当你看到站点的外观与下图所示类似时即说明你已成功安装 <code>NexT</code> 主题。这是 NexT 默认的 Scheme —— Muse。更的信息请查看 <a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">NexT 文档</a></p></blockquote><p>本人的博客是使用的 <a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank" rel="noopener">Matery</a> 主题。</p><h2 id="安装-Hexo-插件"><a href="#安装-Hexo-插件" class="headerlink" title="安装 Hexo 插件"></a>安装 Hexo 插件</h2><p>Hexo 有强大的<a href="https://hexo.io/plugins/" target="_blank" rel="noopener">插件</a>系统，使您能轻松扩展功能而不用修改核心模块的源码。</p><h3 id="代码高亮"><a href="#代码高亮" class="headerlink" title="代码高亮"></a>代码高亮</h3><p>由于 Hexo 自带的代码高亮主题显示不好看，所以主题中使用到了 <a href="https://github.com/ele828/hexo-prism-plugin" target="_blank" rel="noopener">hexo-prism-plugin</a> 的 Hexo 插件来做代码高亮，安装命令如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> i -S hexo-prism-plugin</code></pre><p>然后，修改 Hexo 根目录下<code>_config.yml</code>文件中<code>highlight.enable</code>的值为<code>false</code>，并新增<code>prism</code>插件相关的配置，主要配置如下：</p><pre class=" language-yml"><code class="language-yml">highlight:  enable: falseprism_plugin:  mode: 'preprocess'    # realtime/preprocess  theme: 'tomorrow'  line_number: false    # default false  custom_css:</code></pre><h3 id="站内搜索"><a href="#站内搜索" class="headerlink" title="站内搜索"></a>站内搜索</h3><p>安装 <a href="https://github.com/wzpan/hexo-generator-search" target="_blank" rel="noopener">hexo-generator-search</a> 在 <code>Hexo</code> 中实现搜索功能，在站点的根目录下执行以下命令：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-generator-search --save</code></pre><p>在 Hexo 站点根目录下的<code>_config.yml</code>文件中，新增以下的配置项：</p><pre class=" language-yml"><code class="language-yml">search:  path: search.xml  field: post  content: true</code></pre><h3 id="RSS-订阅"><a href="#RSS-订阅" class="headerlink" title="RSS 订阅"></a>RSS 订阅</h3><p>安装 <a href="https://github.com/hexojs/hexo-generator-feed" target="_blank" rel="noopener">hexo-generator-feed</a> 在 <code>Hexo</code> 中实现 <code>RSS 订阅</code>功能，安装命令如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-generator-feed --save</code></pre><p>在 Hexo 站点根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yml"><code class="language-yml">feed:  type: atom  path: atom.xml  limit: 20  hub:  content:  content_limit: 140  content_limit_delim: ' '  order_by: -date</code></pre><h3 id="中文链接转拼音"><a href="#中文链接转拼音" class="headerlink" title="中文链接转拼音"></a>中文链接转拼音</h3><p>如果博客文章的名称是中文的，那么 Hexo 默认生成的永久链接也会有中文，这样不利于 <code>SEO</code>，且 <code>gitment</code> 评论对中文链接也不支持。我们可以用<a href="https://github.com/viko16/hexo-permalink-pinyin" target="_blank" rel="noopener">hexo-permalink-pinyin</a> Hexo 插件使在生成文章时生成中文拼音的永久链接。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> i hexo-permalink-pinyin --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yml"><code class="language-yml">permalink_pinyin:  enable: true  separator: '-' # default: '-'</code></pre><blockquote><p><strong>注</strong>：除了此插件外，<a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> 插件也可以生成非中文的链接。</p></blockquote><h3 id="文章链接唯一化"><a href="#文章链接唯一化" class="headerlink" title="文章链接唯一化"></a>文章链接唯一化</h3><p>每次修改文章标题或者变更文章发布时间，Hexo 在默认设置下生成的文章链接都会改变，不利于搜索引擎收录，也不利于分享。唯一永久链接才是更好的选择。我们可以用<a href="https://github.com/Rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a> Hexo 插件来实现链接唯一化。</p><p>安装命令如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-abbrlink --save</code></pre><p>在 Hexo 根目录下的 <code>_config.yml</code> 文件中，修改以下的配置项：</p><pre class=" language-yml"><code class="language-yml">permalink: posts/:abbrlink/    # posts 部分可自行修改</code></pre><p>然后，在 Hexo 根目录下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yml"><code class="language-yml">abbrlink:  alg: crc32  # 算法：crc16(default) and crc32  rep: hex    # 进制：dec(default) and hex</code></pre><p>不同的算法和进制组合会得到不同的链接，下面提供了参考，如何选择就看需要了，需要注意的是使用 <code>crc16</code> 算法的文章数上限是 <code>65535</code>。</p><pre><code>crc16 &amp; hexhttps://post.zz173.com/posts/66c8.htmlcrc16 &amp; dechttps://post.zz173.com/posts/65535.htmlcrc32 &amp; hexhttps://post.zz173.com/posts/8ddf18fb.htmlcrc32 &amp; dechttps://post.zz173.com/posts/1690090958.html</code></pre><h3 id="添加萌宠或萌妹子"><a href="#添加萌宠或萌妹子" class="headerlink" title="添加萌宠或萌妹子"></a>添加萌宠或萌妹子</h3><p>安装 <a href="https://github.com/EYHN/hexo-helper-live2d" target="_blank" rel="noopener">hexo-helper-live2d</a> 在 <code>Hexo</code> 中实现 <code>为博客添加萌宠或萌妹子</code>功能，安装命令如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> --save hexo-helper-live2d</code></pre><p>可以到<a href="https://huaji8.top/post/live2d-plugin-2.0/" target="_blank" rel="noopener">作者动画展示网站</a>中查看，选择喜欢的萌宠或萌妹子造型：</p><pre><code>live2d-widget-model-chitoselive2d-widget-model-epsilon2_1live2d-widget-model-gflive2d-widget-model-haru/01 (use npm install --save live2d-widget-model-haru)live2d-widget-model-haru/02 (use npm install --save live2d-widget-model-haru)live2d-widget-model-harutolive2d-widget-model-hibikilive2d-widget-model-hijikilive2d-widget-model-izumilive2d-widget-model-koharulive2d-widget-model-mikulive2d-widget-model-ni-jlive2d-widget-model-nicolive2d-widget-model-nietzschelive2d-widget-model-nipsilonlive2d-widget-model-nitolive2d-widget-model-shizukulive2d-widget-model-tororolive2d-widget-model-tsumikilive2d-widget-model-unitychanlive2d-widget-model-wankolive2d-widget-model-z16</code></pre><p>选好对应的模型，使用 <code>npm install 模型的包名</code>来安装。比如选择的的是 <code>live2d-widget-model-wanko</code> 模型包，在 Hexo 博客根目录下执行以下代码：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> live2d-widget-model-wanko</code></pre><p>安装完成后，在 Hexo 站点根目录下的 <code>_config.yml</code> 文件或主题的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yml"><code class="language-yml">live2d:  enable: true  scriptFrom: local  pluginRootPath: live2dw/  pluginJsPath: lib/  pluginModelPath: assets/  tagMode: false  debug: false  model:    use: live2d-widget-model-wanko  display:    position: right    width: 150    height: 300  mobile:    show: true</code></pre><h3 id="文章字数阅读时长统计"><a href="#文章字数阅读时长统计" class="headerlink" title="文章字数阅读时长统计"></a>文章字数阅读时长统计</h3><p>安装 <a href="https://github.com/willin/hexo-wordcount" target="_blank" rel="noopener">hexo-wordcount</a> 在 <code>Hexo</code> 中实现 <code>文章字数、阅读时长统计</code>功能，安装命令如下：</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> i --save hexo-wordcount</code></pre><p>在当前主题下的 <code>_config.yml</code> 文件中，新增以下的配置项：</p><pre class=" language-yml"><code class="language-yml">wordCount:  enable: true  wordCount: true      # 单篇 字数统计  min2read: true       # 单篇 阅读时长  totalCount: true     # 全站 字数统计</code></pre><h2 id="添加-Hexo-个性化设置"><a href="#添加-Hexo-个性化设置" class="headerlink" title="添加 Hexo 个性化设置"></a>添加 Hexo 个性化设置</h2><h3 id="鼠标点击出现爱心特效"><a href="#鼠标点击出现爱心特效" class="headerlink" title="鼠标点击出现爱心特效"></a>鼠标点击出现爱心特效</h3><p>在当前主题的 <code>source/js</code> 下创建 <code>love.js</code> 文件，并将以下代码复制到创建的 <code>love.js</code> 文件中：</p><pre class=" language-javascript"><code class="language-javascript"> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span>window<span class="token punctuation">,</span> document<span class="token punctuation">,</span> undefined<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">var</span> hearts <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>     window<span class="token punctuation">.</span>requestAnimationFrame <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> window<span class="token punctuation">.</span>requestAnimationFrame <span class="token operator">||</span>             window<span class="token punctuation">.</span>webkitRequestAnimationFrame <span class="token operator">||</span>             window<span class="token punctuation">.</span>mozRequestAnimationFrame <span class="token operator">||</span>             window<span class="token punctuation">.</span>oRequestAnimationFrame <span class="token operator">||</span>             window<span class="token punctuation">.</span>msRequestAnimationFrame <span class="token operator">||</span>             <span class="token keyword">function</span> <span class="token punctuation">(</span>callback<span class="token punctuation">)</span> <span class="token punctuation">{</span>                 <span class="token function">setTimeout</span><span class="token punctuation">(</span>callback<span class="token punctuation">,</span> <span class="token number">1000</span> <span class="token operator">/</span> <span class="token number">60</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">function</span> <span class="token function">init</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token function">css</span><span class="token punctuation">(</span><span class="token string">".heart{width: 10px;height: 10px;position: fixed;background: #f00;transform: rotate(45deg);-webkit-transform: rotate(45deg);-moz-transform: rotate(45deg);}.heart:after,.heart:before{content: '';width: inherit;height: inherit;background: inherit;border-radius: 50%;-webkit-border-radius: 50%;-moz-border-radius: 50%;position: absolute;}.heart:after{top: -5px;}.heart:before{left: -5px;}"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token function">gameloop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">function</span> <span class="token function">gameloop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> hearts<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             <span class="token keyword">if</span> <span class="token punctuation">(</span>hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>alpha <span class="token operator">&lt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                 document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">)</span><span class="token punctuation">;</span>                 hearts<span class="token punctuation">.</span><span class="token function">splice</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                 <span class="token keyword">continue</span><span class="token punctuation">;</span>             <span class="token punctuation">}</span>             hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y<span class="token operator">--</span><span class="token punctuation">;</span>             hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>scale <span class="token operator">+</span><span class="token operator">=</span> <span class="token number">0.004</span><span class="token punctuation">;</span>             hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>alpha <span class="token operator">-</span><span class="token operator">=</span> <span class="token number">0.013</span><span class="token punctuation">;</span>             hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>el<span class="token punctuation">.</span>style<span class="token punctuation">.</span>cssText <span class="token operator">=</span> <span class="token string">"left:"</span> <span class="token operator">+</span> hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>x <span class="token operator">+</span> <span class="token string">"px;top:"</span> <span class="token operator">+</span> hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>y <span class="token operator">+</span> <span class="token string">"px;opacity:"</span> <span class="token operator">+</span> hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>alpha <span class="token operator">+</span> <span class="token string">";transform:scale("</span> <span class="token operator">+</span> hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>scale <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>scale <span class="token operator">+</span> <span class="token string">") rotate(45deg);background:"</span> <span class="token operator">+</span> hearts<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">.</span>color<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         <span class="token function">requestAnimationFrame</span><span class="token punctuation">(</span>gameloop<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">function</span> <span class="token function">attachEvent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">var</span> old <span class="token operator">=</span> <span class="token keyword">typeof</span> window<span class="token punctuation">.</span>onclick <span class="token operator">===</span> <span class="token string">"function"</span> <span class="token operator">&amp;&amp;</span> window<span class="token punctuation">.</span>onclick<span class="token punctuation">;</span>         window<span class="token punctuation">.</span>onclick <span class="token operator">=</span> <span class="token keyword">function</span> <span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>             old <span class="token operator">&amp;&amp;</span> <span class="token function">old</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>             <span class="token function">createHeart</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span>     <span class="token punctuation">}</span>     <span class="token keyword">function</span> <span class="token function">createHeart</span><span class="token punctuation">(</span>event<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">var</span> d <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"div"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         d<span class="token punctuation">.</span>className <span class="token operator">=</span> <span class="token string">"heart"</span><span class="token punctuation">;</span>         hearts<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">{</span>             el<span class="token punctuation">:</span> d<span class="token punctuation">,</span>             x<span class="token punctuation">:</span> event<span class="token punctuation">.</span>clientX <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">,</span>             y<span class="token punctuation">:</span> event<span class="token punctuation">.</span>clientY <span class="token operator">-</span> <span class="token number">5</span><span class="token punctuation">,</span>             scale<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>             alpha<span class="token punctuation">:</span> <span class="token number">1</span><span class="token punctuation">,</span>             color<span class="token punctuation">:</span> <span class="token function">randomColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span>         <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">function</span> <span class="token function">css</span><span class="token punctuation">(</span>css<span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">var</span> style <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement</span><span class="token punctuation">(</span><span class="token string">"style"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         style<span class="token punctuation">.</span>type <span class="token operator">=</span> <span class="token string">"text/css"</span><span class="token punctuation">;</span>         <span class="token keyword">try</span> <span class="token punctuation">{</span>             style<span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">createTextNode</span><span class="token punctuation">(</span>css<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>         <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">ex</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>             style<span class="token punctuation">.</span>styleSheet<span class="token punctuation">.</span>cssText <span class="token operator">=</span> css<span class="token punctuation">;</span>         <span class="token punctuation">}</span>         document<span class="token punctuation">.</span><span class="token function">getElementsByTagName</span><span class="token punctuation">(</span><span class="token string">'head'</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">appendChild</span><span class="token punctuation">(</span>style<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token keyword">function</span> <span class="token function">randomColor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token keyword">return</span> <span class="token string">"rgb("</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">","</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token operator">~</span><span class="token operator">~</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">255</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">")"</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span>window<span class="token punctuation">,</span> document<span class="token punctuation">)</span><span class="token punctuation">;</span></code></pre><p>然后在当前主题下的 <code>layout</code> 目录中找到 <code>layout.ejs</code> 文件，打开该文件并在 <code>&lt;body&gt;&lt;/body&gt;</code> 添加以下代码：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 页面点击小红心 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>/js/love.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><h3 id="添加动态背景"><a href="#添加动态背景" class="headerlink" title="添加动态背景"></a>添加动态背景</h3><p>在当前主题下的 <code>layout</code> 目录中找到 <code>layout.ejs</code> 文件，打开该文件并在 <code>&lt;body&gt;&lt;/body&gt;</code> 添加以下代码：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 页面动态背景 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>如果想要自定义线条样式，可以使用以下代码代替之前的配置：</p><pre class=" language-html"><code class="language-html"><span class="token comment" spellcheck="true">&lt;!-- 页面动态背景 --></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>text/javascript<span class="token punctuation">"</span></span> <span class="token attr-name">color</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>0,0,255<span class="token punctuation">"</span></span> <span class="token attr-name">opacity</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">'</span>0.7<span class="token punctuation">'</span></span> <span class="token attr-name">zIndex</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>-2<span class="token punctuation">"</span></span> <span class="token attr-name">count</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>99<span class="token punctuation">"</span></span> <span class="token attr-name">src</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token script language-javascript"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">></span></span></code></pre><p>配置项说明</p><ul><li><strong><code>color：</code></strong>线条颜色，默认：<code>&#39;0,0,0&#39;</code>，三个数字分别为<code>(R,G,B)</code></li><li><strong><code>opacity：</code></strong>线条透明度（0~1），默认：<code>0.5</code></li><li><strong><code>count：</code></strong>线条的总数量，默认：<code>150</code></li><li><strong><code>zIndex：</code></strong>背景的 z-index 属性，css 属性用于控制所在层的位置，默认：<code>-1</code></li></ul><h3 id="在文章末尾添加“本文结束”标记"><a href="#在文章末尾添加“本文结束”标记" class="headerlink" title="在文章末尾添加“本文结束”标记"></a>在文章末尾添加“本文结束”标记</h3><p>在当前主题的 <code>layout\_partial</code> 目录下创建 <code>post-end-tag.ejs</code> 文件，并将以下代码复制到创建的 <code>post-end-tag.ejs</code> 文件中：</p><pre class=" language-html"><code class="language-html"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token style-attr language-css"><span class="token attr-name"> <span class="token attr-name">style</span></span><span class="token punctuation">="</span><span class="token attr-value"><span class="token property">text-align</span><span class="token punctuation">:</span>center<span class="token punctuation">;</span><span class="token property">color</span><span class="token punctuation">:</span> <span class="token hexcode">#ccc</span><span class="token punctuation">;</span><span class="token property">font-size</span><span class="token punctuation">:</span><span class="token number">14</span>px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span><span class="token punctuation">></span></span>-------------本文结束<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>i</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation">=</span><span class="token punctuation">"</span>fa fa-paw<span class="token punctuation">"</span></span><span class="token punctuation">></span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>i</span><span class="token punctuation">></span></span>感谢阅读-------------<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">></span></span></code></pre><p>然后找到代表文章内容的 <code>post-detail.ejs</code> 文件，并在合适的位置(一般是在文章内容下面)添加以下代码：</p><pre class=" language-html"><code class="language-html">&lt;%- partial('_partial/post-end-tag') %></code></pre><h2 id="部署-Hexo-到-GitHub"><a href="#部署-Hexo-到-GitHub" class="headerlink" title="部署 Hexo 到 GitHub"></a>部署 Hexo 到 GitHub</h2><p>Hexo 提供了快速方便的一键部署功能，让您只需一条命令就能将网站部署到服务器上。</p><pre class=" language-bash"><code class="language-bash">$ hexo deployor$ hexo d</code></pre><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><p>安装 <a href="hexo-deployer-git">hexo-deployer-git</a>。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-deployer-git --save</code></pre><h3 id="修改配置"><a href="#修改配置" class="headerlink" title="修改配置"></a>修改配置</h3><p>在 Hexo 站点根目录下的 <code>_config.yml</code> 文件中，修改以下的配置项：</p><pre class=" language-yml"><code class="language-yml">deploy:  type: git  repo: <repository url>  branch: [branch]  message: [message]</code></pre><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>repo</code></td><td>仓库(Repository)地址</td></tr><tr><td><code>branch</code></td><td>分支名称。如果您使用的是 GitHub 或 GitCafe 的话，程序会尝试自动检测。</td></tr><tr><td><code>message</code></td><td>自定义提交信息(默认为 Site updated: &#123;&#123; now&#40;’YYYY-MM-DD HH:mm:ss’&#41; &#125;&#125;)</td></tr></tbody></table><h3 id="部署"><a href="#部署" class="headerlink" title="部署"></a>部署</h3><p>配置完成后，您可执行下列的其中一个命令，让 Hexo 在生成完毕后自动部署网站，两个命令的作用是相同的。</p><pre class=" language-bash"><code class="language-bash">$ hexo generate --deployor$ hexo deploy --generate</code></pre><p>上面的命令等同于：</p><pre class=" language-bash"><code class="language-bash">$ hexo generate$ hexo deploy</code></pre><blockquote><p><strong>注意：</strong> 在通过上面的命令部署之前，最好通过 <code>hexo clean</code> 命令先清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。</p></blockquote><blockquote><p>Hexo 除了可以部署到 <code>GitHub</code> 上之外，还可以部署到 <code>Heroku</code>、<code>Rsync</code>、<code>OpenShift</code>、<code>FTPSync</code> 等平台。<br>Hexo 生成的所有文件都放在 <code>public</code> 文件夹中，您可以将它们复制到您喜欢的地方。<br>不同平台的具体配置和部署信息可查看 <a href="https://hexo.io/docs/deployment" target="_blank" rel="noopener">Deployment</a></p></blockquote><h2 id="相关教程"><a href="#相关教程" class="headerlink" title="相关教程"></a>相关教程</h2><p><a href="https://git-scm.com/book/" target="_blank" rel="noopener">Git 教程</a><br><a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo 教程</a><br><a href="https://hexo.io/themes/" target="_blank" rel="noopener">Hexo 主题</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    <entry>
      <title>Hello Hexo</title>
      <link href="/posts/2018/a1751c09.html"/>
      <url>/posts/2018/a1751c09.html</url>
      
        <content type="html"><![CDATA[<p>欢迎使用 <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>！本文将帮助您快速上手，如果您在使用过程中遇到问题，请查看 <a href="https://hexo.io/docs/troubleshooting" target="_blank" rel="noopener">Troubleshooting</a> 中的解答，或者在 <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>、<a href="https://groups.google.com/group/hexo" target="_blank" rel="noopener">Google Group</a> 上提问。</p><h2 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo?"></a>什么是 Hexo?</h2><p>Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a>（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。<a href="https://www.youtube.com/watch?v=bCj0iVVqkSg" target="_blank" rel="noopener">视频教程</a></p><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>安装 Hexo 只需几分钟时间，若您在安装过程中遇到问题或无法找到解决方式，请 <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">提交问题</a>，我会尽力解决您的问题。</p><h3 id="安装前提"><a href="#安装前提" class="headerlink" title="安装前提"></a>安装前提</h3><p>安装 Hexo 相当简单。然而在安装前，您必须检查电脑中是否已安装下列应用程序：</p><ul><li><a href="https://nodejs.org/" target="_blank" rel="noopener">Node.js</a></li><li><a href="https://git-scm.com/" target="_blank" rel="noopener">Git</a></li></ul><p>如果您的电脑中已经安装上述必备程序，那么恭喜您！接下来只需要使用 npm 即可完成 Hexo 的安装。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> -g hexo-cli</code></pre><p>如果您的电脑中尚未安装所需要的程序，请根据以下安装指示完成安装。</p><blockquote><p>   <strong>Mac 用户</strong></p><p>   您在编译时可能会遇到问题，请先到 App Store 安装 Xcode，Xcode 完成后，启动并进入 <strong>Preferences -&gt; Download -&gt; Command Line Tools -&gt; Install</strong> 安装命令行工具。</p></blockquote><h3 id="安装-Git"><a href="#安装-Git" class="headerlink" title="安装 Git"></a>安装 Git</h3><ul><li>Windows：下载并安装 <a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git</a>。</li><li>Mac：使用 <a href="http://mxcl.github.com/homebrew/" target="_blank" rel="noopener">Homebrew</a>、<a href="http://www.macports.org/" target="_blank" rel="noopener">MacPorts</a>，或下载 <a href="http://sourceforge.net/projects/git-osx-installer/" target="_blank" rel="noopener">安装程序</a>。</li><li>Linux (Ubuntu, Debian)：<code>sudo apt-get install git-core</code>，参考 <a href="https://git-scm.com/download/linux" target="_blank" rel="noopener">Git for Linux and Unix</a></li><li>Linux (Fedora, Red Hat, CentOS)：<code>sudo yum install git-core</code>，参考 <a href="https://git-scm.com/download/linux" target="_blank" rel="noopener">Git for Linux and Unix</a></li></ul><blockquote><p>   <strong>Windows 用户</strong></p><p>   由于众所周知的原因，从上面的链接下载 Git 最好挂上一个代理，否则下载速度十分缓慢。也可以参考 <a href="https://github.com/waylau/git-for-win" target="_blank" rel="noopener">Git for Windows</a>，收录了存储于百度云的下载地址。</p></blockquote><h3 id="安装-Node-js"><a href="#安装-Node-js" class="headerlink" title="安装 Node.js"></a>安装 Node.js</h3><p>安装 Node.js 的最佳方式是使用 <a href="https://github.com/creationix/nvm" target="_blank" rel="noopener">nvm</a>。</p><p>cURL:</p><pre class=" language-bash"><code class="language-bash">$ curl https://raw.github.com/creationix/nvm/v0.33.11/install.sh <span class="token operator">|</span> sh</code></pre><p>Wget:</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">wget</span> -qO- https://raw.github.com/creationix/nvm/v0.33.11/install.sh <span class="token operator">|</span> sh</code></pre><p>安装完成后，重启终端并执行下列命令即可安装 Node.js。</p><pre class=" language-bash"><code class="language-bash">$ nvm <span class="token function">install</span> stable</code></pre><p>或者您也可以下载 <a href="http://nodejs.org/" target="_blank" rel="noopener">安装程序</a> 来安装。</p><blockquote><p>   <strong>Windows 用户</strong></p><p>   对于windows用户来说，建议使用安装程序进行安装。安装时，请勾选 <code>Add to PATH</code> 选项。<br>   另外，您也可以使用 <code>Git Bash</code>，这是 git for windows 自带的一组程序，提供了 Linux 风格的 shell，在该环境下，您可以直接用上面提到的命令来安装 Node.js。<br>   打开它的方法很简单，在任意位置单击右键，选择 “Git Bash Here” 即可。由于 Hexo 的很多操作都涉及到命令行，您可以考虑始终使用 <code>Git Bash</code> 来进行操作。</p></blockquote><h3 id="安装-Hexo"><a href="#安装-Hexo" class="headerlink" title="安装 Hexo"></a>安装 Hexo</h3><p>所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。</p><pre class=" language-bash"><code class="language-bash">$ <span class="token function">npm</span> <span class="token function">install</span> hexo-cli -g</code></pre><h2 id="建站"><a href="#建站" class="headerlink" title="建站"></a>建站</h2><p>安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。<a href="https://www.youtube.com/watch?v=iJv4N5EdKJ4" target="_blank" rel="noopener">视频教程</a></p><pre class=" language-bash"><code class="language-bash">$ hexo init <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token function">cd</span> <span class="token operator">&lt;</span>folder<span class="token operator">></span>$ <span class="token function">npm</span> <span class="token function">install</span></code></pre><p>新建完成后，指定文件夹的目录如下：</p><pre><code>    .    ├── _config.yml    ├── package.json    ├── scaffolds    ├── source    |   ├── _drafts    |   └── _posts    └── themes</code></pre><p>目录和文件的描述如下：</p><ul><li><strong>_config.yml：</strong> 网站的 <a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">配置</a> 信息，您可以在此配置大部分的参数。</li><li><strong>package.json：</strong> 应用程序的信息。<a href="http://embeddedjs.com/" target="_blank" rel="noopener">EJS</a>, <a href="http://learnboost.github.io/stylus/" target="_blank" rel="noopener">Stylus</a> 和 <a href="http://daringfireball.net/projects/markdown/" target="_blank" rel="noopener">Markdown</a> renderer 已默认安装，您可以自由移除。</li><li><strong>scaffolds：</strong> <a href="https://hexo.io/docs/writing#Scaffolds" target="_blank" rel="noopener">模版</a> 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。</li><li><strong>source：</strong> 资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。</li><li><strong>themes：</strong> <a href="https://hexo.io/docs/themes" target="_blank" rel="noopener">主题</a> 文件夹。Hexo 会根据主题来生成静态页面。</li></ul><h2 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h2><p>您可以在 <code>_config.yml</code> 中修改大部份的配置。</p><h3 id="网站"><a href="#网站" class="headerlink" title="网站"></a>网站</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>title</code></td><td>网站标题</td></tr><tr><td><code>subtitle</code></td><td>网站副标题</td></tr><tr><td><code>description</code></td><td>网站描述</td></tr><tr><td><code>author</code></td><td>您的名字</td></tr><tr><td><code>language</code></td><td>网站使用的语言</td></tr><tr><td><code>timezone</code></td><td>网站时区。Hexo 默认使用您电脑的时区。时区列表。比如说：<code>America/New_York</code>、 <code>Japan</code> 和 <code>UTC</code> 。</td></tr></tbody></table><p>其中，<code>description</code> 主要用于SEO，告诉搜索引擎一个关于您站点的简单描述，通常建议在其中包含您网站的关键词。<code>author</code> 参数用于主题显示文章的作者。</p><h3 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>url</code></td><td>网址</td><td></td></tr><tr><td><code>root</code></td><td>网站根目录</td><td></td></tr><tr><td><code>permalink</code></td><td>文章的 <a href="https://hexo.io/docs/permalinks" target="_blank" rel="noopener">永久链接</a> 格式</td><td><code>:year/:month/:day/:title/</code></td></tr><tr><td><code>permalink_defaults</code></td><td>永久链接中各部分的默认值</td></tr></tbody></table><blockquote><p>   网站存放在子目录：如果您的网站存放在子目录中，例如 <code>http://yoursite.com/blog</code>，则请将您的 <code>url</code> 设为 <code>http://yoursite.com/blog</code> 并把 <code>root</code> 设为 <code>/blog/</code>。</p></blockquote><h3 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>source_dir</code></td><td>资源文件夹，这个文件夹用来存放内容。</td><td><code>source</code></td></tr><tr><td><code>public_dir</code></td><td>公共文件夹，这个文件夹用于存放生成的站点文件。</td><td><code>public</code></td></tr><tr><td><code>tag_dir</code></td><td>标签文件夹</td><td><code>tags</code></td></tr><tr><td><code>archive_dir</code></td><td>归档文件夹</td><td><code>archives</code></td></tr><tr><td><code>category_dir</code></td><td>分类文件夹</td><td><code>categories</code></td></tr><tr><td><code>code_dir</code></td><td>Include code 文件夹</td><td><code>downloads/code</code></td></tr><tr><td><code>i18n_dir</code></td><td>国际化（i18n）文件夹</td><td><code>:lang</code></td></tr><tr><td><code>skip_render</code></td><td>跳过指定文件的渲染，您可使用 <a href="https://github.com/isaacs/node-glob" target="_blank" rel="noopener">glob 表达式</a>来匹配路径。</td></tr></tbody></table><blockquote><p>   提示：如果您刚刚开始接触 Hexo，通常没有必要修改这一部分的值。</p></blockquote><h3 id="文章"><a href="#文章" class="headerlink" title="文章"></a>文章</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>new_post_name</code></td><td>新文章的文件名称</td><td>:title.md</td></tr><tr><td><code>default_layout</code></td><td>预设布局</td><td>post</td></tr><tr><td><code>auto_spacing</code></td><td>在中文和英文之间加入空格</td><td>false</td></tr><tr><td><code>titlecase</code></td><td>把标题转换为 title case</td><td>false</td></tr><tr><td><code>external_link</code></td><td>在新标签中打开链接</td><td>true</td></tr><tr><td><code>filename_case</code></td><td>把文件名称转换为 (1) 小写或 (2) 大写</td><td>0</td></tr><tr><td><code>render_drafts</code></td><td>显示草稿</td><td>false</td></tr><tr><td><code>post_asset_folder</code></td><td>启动 Asset 文件夹</td><td>false</td></tr><tr><td><code>relative_link</code></td><td>把链接改为与根目录的相对位址</td><td>false</td></tr><tr><td><code>future</code></td><td>显示未来的文章</td><td>true</td></tr><tr><td><code>highlight</code></td><td>代码块的设置</td></tr></tbody></table><blockquote><p>   相对地址：默认情况下，Hexo 生成的超链接都是绝对地址。例如，如果您的网站域名为 <code>example.com</code>，您有一篇文章名为 <code>hello</code>，那么绝对链接可能像这样：<code>http://example.com/hello.html</code>，它是绝对于域名的。<br>   相对链接像这样：`/hello.html，也就是说，无论用什么域名访问该站点，都没有关系，这在进行反向代理时可能用到。通常情况下，建议使用绝对地址。</p></blockquote><h3 id="分类-amp-标签"><a href="#分类-amp-标签" class="headerlink" title="分类 &amp; 标签"></a>分类 &amp; 标签</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>default_category</code></td><td>默认分类</td><td>uncategorized</td></tr><tr><td><code>category_map</code></td><td>分类别名</td><td></td></tr><tr><td><code>tag_map</code></td><td>标签别名</td></tr></tbody></table><h3 id="日期-时间格式"><a href="#日期-时间格式" class="headerlink" title="日期 / 时间格式"></a>日期 / 时间格式</h3><p>Hexo 使用 <a href="http://momentjs.com/" target="_blank" rel="noopener">Moment.js</a> 来解析和显示时间。</p><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>date_format</code></td><td>日期格式</td><td>YYYY-MM-DD</td></tr><tr><td><code>time_format</code></td><td>时间格式</td><td>H:mm:ss</td></tr></tbody></table><h3 id="分页"><a href="#分页" class="headerlink" title="分页"></a>分页</h3><table><thead><tr><th>参数</th><th>描述</th><th>默认值</th></tr></thead><tbody><tr><td><code>per_page</code></td><td>每页显示的文章量 (0 = 关闭分页功能)</td><td>10</td></tr><tr><td><code>pagination_dir</code></td><td>分页目录</td><td>page</td></tr></tbody></table><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><table><thead><tr><th>参数</th><th>描述</th></tr></thead><tbody><tr><td><code>theme</code></td><td>当前主题名称。值为 <code>false</code> 时禁用主题</td></tr><tr><td><code>deploy</code></td><td>部署部分的设置</td></tr></tbody></table><h2 id="命令"><a href="#命令" class="headerlink" title="命令"></a>命令</h2><h3 id="init"><a href="#init" class="headerlink" title="init"></a>init</h3><pre class=" language-bash"><code class="language-bash">$ hexo init <span class="token punctuation">[</span>folder<span class="token punctuation">]</span></code></pre><p>新建一个网站。如果没有设置 <code>folder</code>，Hexo 默认在目前的文件夹建立网站。</p><h3 id="new"><a href="#new" class="headerlink" title="new"></a>new</h3><pre class=" language-bash"><code class="language-bash">$ hexo new <span class="token punctuation">[</span>layout<span class="token punctuation">]</span> <span class="token operator">&lt;</span>title<span class="token operator">></span></code></pre><p>新建一篇文章。如果没有设置 <code>layout</code> 的话，默认使用 <a href="https://hexo.io/docs/configuration" target="_blank" rel="noopener">_config.yml</a> 中的 <code>default_layout</code> 参数代替。如果标题包含空格的话，请使用引号括起来。查看<a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="server"><a href="#server" class="headerlink" title="server"></a>server</h3><pre class=" language-bash"><code class="language-bash">$ hexo serveror$ hexo s</code></pre><p>启动服务器。默认情况下，访问网址为： <a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a> 。查看<a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-p</code>, <code>--port</code></td><td>重设端口</td></tr><tr><td><code>-s</code>, <code>--static</code></td><td>只使用静态文件</td></tr><tr><td><code>-l</code>, <code>--log</code></td><td>启动日记记录，使用覆盖记录格式</td></tr></tbody></table><h3 id="generate"><a href="#generate" class="headerlink" title="generate"></a>generate</h3><pre class=" language-bash"><code class="language-bash">$ hexo generateor$ hexo g</code></pre><p>生成静态文件。</p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-d</code>, <code>--deploy</code></td><td>文件生成后立即部署网站</td></tr><tr><td><code>-w</code>, <code>--watch</code></td><td>监视文件变动</td></tr></tbody></table><p>查看<a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="deploy"><a href="#deploy" class="headerlink" title="deploy"></a>deploy</h3><pre class=" language-bash"><code class="language-bash">$ hexo deployor$ hexo d</code></pre><p>部署网站。查看<a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p><table><thead><tr><th>选项</th><th>描述</th></tr></thead><tbody><tr><td><code>-g</code>, <code>--generate</code></td><td>部署之前预先生成静态文件</td></tr></tbody></table><h3 id="migrate"><a href="#migrate" class="headerlink" title="migrate"></a>migrate</h3><pre class=" language-bash"><code class="language-bash">$ hexo migrate <span class="token operator">&lt;</span>type<span class="token operator">></span></code></pre><p>从其他博客系统 <a href="https://hexo.io/zh-cn/docs/migration" target="_blank" rel="noopener">迁移内容</a>。</p><h3 id="clean"><a href="#clean" class="headerlink" title="clean"></a>clean</h3><pre class=" language-bash"><code class="language-bash">$ hexo clean</code></pre><p>清除缓存文件 (<code>db.json</code>) 和已生成的静态文件 (<code>public</code>)。<br>在某些情况(尤其是更换主题后)，如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><pre class=" language-bash"><code class="language-bash">$ hexo list <span class="token operator">&lt;</span>type<span class="token operator">></span></code></pre><p>列出网站资料。</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><pre class=" language-bash"><code class="language-bash">$ hexo version</code></pre><p>显示 Hexo 版本。</p><h3 id="Options"><a href="#Options" class="headerlink" title="Options"></a>Options</h3><h4 id="Safe-mode"><a href="#Safe-mode" class="headerlink" title="Safe mode"></a>Safe mode</h4><pre class=" language-bash"><code class="language-bash">$ hexo --safe</code></pre><p>在安全模式下，不会载入插件和脚本。当您在安装新插件遭遇问题时，可以尝试以安全模式重新执行。</p><h4 id="Debug-mode"><a href="#Debug-mode" class="headerlink" title="Debug mode"></a>Debug mode</h4><pre class=" language-bash"><code class="language-bash">$ hexo --debug</code></pre><p>在终端中显示调试信息并记录到 <code>debug.log</code>。当您碰到问题时，可以尝试用调试模式重新执行一次，并 <a href="https://github.com/hexojs/hexo/issues/new" target="_blank" rel="noopener">提交调试信息到 GitHub</a>。</p><h4 id="Silent-mode"><a href="#Silent-mode" class="headerlink" title="Silent mode"></a>Silent mode</h4><pre class=" language-bash"><code class="language-bash">$ hexo --silent</code></pre><p>隐藏终端信息。</p><h2 id="相关教程"><a href="#相关教程" class="headerlink" title="相关教程"></a>相关教程</h2><p><a href="https://git-scm.com/book/" target="_blank" rel="noopener">Git 教程</a><br><a href="https://hexo.io/docs/" target="_blank" rel="noopener">Hexo 教程</a></p>]]></content>
      
      
      <categories>
          
          <category> 前端 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
  
  
</search>
